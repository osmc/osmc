diff -uwr ../libdvdnav-4.2.1/Makefile lib/libdvd/libdvdnav/Makefile
--- ../libdvdnav-4.2.1/Makefile	Tue Dec 30 14:48:46 2008
+++ lib/libdvd/libdvdnav/Makefile	Wed Jan 29 20:43:09 2014
@@ -112,7 +112,7 @@
 # Clean targets
 
 clean:
-	rm -rf  *~ $(.OBJDIR)/* version.h
+	rm -rf  *~ $(.OBJDIR)/* 
 
 pcedit = sed \
 	-e 's,@prefix@,$(PREFIX),' \
Only in lib/libdvd/libdvdnav/: config.h
Only in lib/libdvd/libdvdnav/: config.mak
diff -uwr ../libdvdnav-4.2.1/configure.ac lib/libdvd/libdvdnav/configure.ac
--- ../libdvdnav-4.2.1/configure.ac	Wed Dec  4 23:52:30 2013
+++ lib/libdvd/libdvdnav/configure.ac	Fri Feb  7 19:24:37 2014
@@ -89,7 +89,6 @@
 AC_PROG_MAKE_SET
 AC_PROG_INSTALL
 AC_PROG_LN_S
-PKG_PROG_PKG_CONFIG
 
 dnl --------------------------------------------------------------
 dnl Libtool
@@ -186,25 +185,15 @@
   [AS_HELP_STRING([--with-dvdread-config=PROG],
     [dvdread-config program to use @<:@default=from PATH@:>@])],
   [DVDREAD_CONFIG="$withval"],
-  [DVDREAD_CONFIG=""])
-
-dnl by default, search pkg-config, and then fall back to dvdread-config
-DVDREAD_PKG_CONFIG="no"
-if test "x$DVDREAD_CONFIG" = "x"; then
-  PKG_CHECK_MODULES([DVDREAD], [dvdread],
-    [DVDREAD_PKG_CONFIG="yes"],
     [dnl User didn't specify program, search PATH
       AC_PATH_PROG([DVDREAD_CONFIG], [dvdread-config], [no])
       test "x$DVDREAD_CONFIG" = xno && \
       AC_MSG_ERROR([dvdread-config required to link with libdvdread])
     ])
-fi
-if test "x$DVDREAD_PKG_CONFIG" != "xyes"; then
   DVDREAD_CFLAGS=`$DVDREAD_CONFIG --cflags` || \
     AC_MSG_ERROR([Could not get libdvdread CFLAGS from $DVDREAD_CONFIG])
   DVDREAD_LIBS=`$DVDREAD_CONFIG --libs` || \
     AC_MSG_ERROR([Could not get libdvdread LIBS from $DVDREAD_CONFIG])
-fi
 AC_SUBST([DVDREAD_CFLAGS])
 AC_SUBST([DVDREAD_LIBS])
 
diff -uwr ../libdvdnav-4.2.1/configure2 lib/libdvd/libdvdnav/configure2
--- ../libdvdnav-4.2.1/configure2	Thu Dec 19 21:43:16 2013
+++ lib/libdvd/libdvdnav/configure2	Fri Feb  7 19:24:37 2014
@@ -5,7 +5,6 @@
 
 cc=gcc
 make=make
-: ${PKG_CONFIG:=pkg-config}
 
 # find source path
 source_path="`dirname \"$0\"`"
@@ -44,15 +43,12 @@
   echo "Developer options:"
   echo "  --disable-strip          disable stripping of executables and shared libraries"
   echo "  --disable-opts           disable compiler optimizations"
-  echo "Environment variables:"
-  echo "  PKG_CONFIG               use specified pkg-config [$PKG_CONFIG]"
   exit 1
 }
 
 SHARED=yes
 STATIC=yes
-DVDREAD_CONFIG=""
-DVDREAD_PKG_CONFIG="${PKG_CONFIG} dvdread"
+DVDREAD_CONFIG=dvdread-config
 PREFIX=/usr/local/
 INSTALLSTRIP=-s
 USEDEBUG=-g
@@ -108,14 +104,8 @@
 test -z "$incdir" && incdir=$PREFIX/include/dvdnav
 
 dvdread=no
-if test -z "$DVDREAD_CONFIG" ; then
-  DVDREAD_CONFIG=${DVDREAD_PKG_CONFIG}
-  $DVDREAD_CONFIG --exists >> /dev/null 2>&1 && dvdread=yes
-fi
-if test "$dvdread" != "yes" ; then
-  DVDREAD_CONFIG=dvdread-config
   $DVDREAD_CONFIG --prefix >> /dev/null 2>&1 && dvdread=yes
-fi
+test "$dvdread" != "yes" && $DVDREAD_CONFIG --exists >> /dev/null 2>&1 && dvdread=yes
 if test "$dvdread" != "yes" ; then
   echo "$DVDREAD_CONFIG returned an error. Can't proceed"
   exit 1
Only in lib/libdvd/libdvdnav/: obj
diff -uwr ../libdvdnav-4.2.1/src/dvdnav/dvd_types.h lib/libdvd/libdvdnav/src/dvdnav/dvd_types.h
--- ../libdvdnav-4.2.1/src/dvdnav/dvd_types.h	Tue Dec 30 14:48:46 2008
+++ lib/libdvd/libdvdnav/src/dvdnav/dvd_types.h	Sun Jan 26 19:51:43 2014
@@ -161,14 +161,13 @@
 /* The audio format */
 typedef enum {
   DVD_AUDIO_FORMAT_AC3       = 0,
-  DVD_AUDIO_FORMAT_MPEG1     = 1,
-  DVD_AUDIO_FORMAT_MPEG1_DRC = 2,
-  DVD_AUDIO_FORMAT_MPEG2     = 3,
-  DVD_AUDIO_FORMAT_MPEG2_DRC = 4,
-  DVD_AUDIO_FORMAT_LPCM      = 5,
+  DVD_AUDIO_FORMAT_UNKNOWN_1 = 1,
+  DVD_AUDIO_FORMAT_MPEG      = 2,
+  DVD_AUDIO_FORMAT_MPEG2_EXT = 3,
+  DVD_AUDIO_FORMAT_LPCM      = 4,
+  DVD_AUDIO_FORMAT_UNKNOWN_5 = 5,
   DVD_AUDIO_FORMAT_DTS       = 6,
-  DVD_AUDIO_FORMAT_SDDS      = 7,
-  DVD_AUDIO_FORMAT_Other     = 8
+  DVD_AUDIO_FORMAT_SDDS      = 7
 } DVDAudioFormat_t;
 
 /* Audio language extension */
diff -uwr ../libdvdnav-4.2.1/src/dvdnav/dvdnav.h lib/libdvd/libdvdnav/src/dvdnav/dvdnav.h
--- ../libdvdnav-4.2.1/src/dvdnav/dvdnav.h	Sun Oct  6 21:47:20 2013
+++ lib/libdvd/libdvdnav/src/dvdnav/dvdnav.h	Fri Feb  7 19:24:42 2014
@@ -63,12 +63,6 @@
 #define DVDNAV_STATUS_ERR 0
 #define DVDNAV_STATUS_OK  1
 
-#define DVDNAV_FORMAT_AC3 0
-#define DVDNAV_FORMAT_MPEGAUDIO 3
-#define DVDNAV_FORMAT_LPCM 4
-#define DVDNAV_FORMAT_DTS 5
-#define DVDNAV_FORMAT_SDDS 6
-
 /*********************************************************************
  * initialisation & housekeeping functions                           *
  *********************************************************************/
@@ -377,6 +371,14 @@
  divide it by 90000 to get the current play time in seconds
  */
 int64_t dvdnav_get_current_time(dvdnav_t *self);
+
+/*
+ * Find the nearest vobu and jump to it
+ *
+ * Alternative to dvdnav_time_search
+ */
+dvdnav_status_t dvdnav_jump_to_sector_by_time(dvdnav_t *this,
+            uint64_t time_in_pts_ticks, int32_t mode);
 
 /*
  * Stop playing the current position and start playback of the title
  * from the specified timecode.
  *
@@ -695,6 +697,7 @@
  */
 int8_t dvdnav_is_domain_vts(dvdnav_t *self);
 
+void dvdnav_free(void* pdata);
 
 #ifdef __cplusplus
 }
diff -uwr ../libdvdnav-4.2.1/src/dvdnav.c lib/libdvd/libdvdnav/src/dvdnav.c
--- ../libdvdnav-4.2.1/src/dvdnav.c	Thu Oct  3 23:39:38 2013
+++ lib/libdvd/libdvdnav/src/dvdnav.c	Fri Feb  7 19:24:42 2014
@@ -467,6 +467,10 @@
 	/* Decode nav into pci and dsi. Then get next VOBU info. */
 	if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
 	  printerr("Expected NAV packet but none found.");
+#ifdef _XBMC
+    /* skip this cell as we won't recover from this*/
+    vm_get_next_cell(this->vm);
+#endif
 	  pthread_mutex_unlock(&this->vm_lock);
 	  return DVDNAV_STATUS_ERR;
 	}
@@ -619,9 +623,17 @@
     cell_event->pgc_length = dvdnav_convert_time(&state->pgc->playback_time);
 
     cell_event->cell_start = 0;
-    for (i = 1; i < state->cellN; i++)
+    for (i = 0; i < state->cellN; i++)
+    {
+      /* only count the first angle cell */
+      if(  state->pgc->cell_playback[i].block_type == BLOCK_TYPE_ANGLE_BLOCK 
+        && state->pgc->cell_playback[i].block_mode != BLOCK_MODE_FIRST_CELL )
+        continue;
+
       cell_event->cell_start +=
-        dvdnav_convert_time(&state->pgc->cell_playback[i - 1].playback_time);
+          dvdnav_convert_time(&state->pgc->cell_playback[i].playback_time);
+    }    
+    cell_event->cell_start-= dvdnav_convert_time(&state->pgc->cell_playback[state->cellN-1].playback_time);
 
     cell_event->pg_start = 0;
     for (i = 1; i < state->pgc->program_map[state->pgN-1]; i++)
@@ -770,6 +782,10 @@
     /* Decode nav into pci and dsi. Then get next VOBU info. */
     if(!dvdnav_decode_packet(this, *buf, &this->dsi, &this->pci)) {
       printerr("Expected NAV packet but none found.");
+#ifdef _XBMC
+      /* skip this cell as we won't recover from this */
+      vm_get_next_cell(this->vm);
+#endif
       pthread_mutex_unlock(&this->vm_lock);
       return DVDNAV_STATUS_ERR;
     }
@@ -908,27 +924,10 @@
   attr = vm_get_audio_attr(this->vm, stream);
   pthread_mutex_unlock(&this->vm_lock);
 
-  switch(attr.audio_format) {
-  case 0:
-    format = DVDNAV_FORMAT_AC3;
-    break;
-  case 2: /* MPEG-1 or MPEG-2 without extension bitstream. */
-  case 3: /* MPEG-2 with extension bitstream. */
-    format = DVDNAV_FORMAT_MPEGAUDIO;
-    break;
-  case 4:
-    format = DVDNAV_FORMAT_LPCM;
-    break;
-  case 6:
-    format = DVDNAV_FORMAT_DTS;
-    break;
-  case 7:
-    format = DVDNAV_FORMAT_SDDS;
-    break;
-  default:
+  if (attr.audio_format >=0 && attr.audio_format <= 7)
+    format = attr.audio_format;
+  else
     format = 0xffff;
-    break;
-  }
 
   return format;
 }
@@ -1167,6 +1166,11 @@
 
   ops.ops_int = 0;
 
+  if(!this) {
+    printerr("Passed a NULL pointer.");
+    return ops.ops_struct;
+  }
+
   if(!this->started) {
     printerr("Virtual DVD machine not started.");
     return ops.ops_struct;
@@ -1183,3 +1187,50 @@
 
   return ops.ops_struct;
 }
+
+#ifdef _XBMC
+
+vm_t* dvdnav_get_vm(dvdnav_t *this) {
+  if(!this) return 0;
+  return this->vm;
+}
+
+/* return the alpha and color for the current active button
+ * color, alpha [0][] = selection
+ * color, alpha = color
+ *
+ * argsize = [2][4]
+ */
+int dvdnav_get_button_info(dvdnav_t* this, int alpha[2][4], int color[2][4])
+{
+  int current_button, current_button_color, i;
+  pci_t* pci;
+  
+  if (!this) return -1;
+  
+  pci = dvdnav_get_current_nav_pci(this);
+  if (!pci) return -1;
+  
+  dvdnav_get_current_highlight(this, &current_button);
+  current_button_color = pci->hli.btnit[current_button - 1].btn_coln;
+  
+  for (i = 0; i < 2; i++)
+  {
+    alpha[i][0] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 0 & 0xf;
+    alpha[i][1] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 4 & 0xf;
+    alpha[i][2] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 8 & 0xf;
+    alpha[i][3] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 12 & 0xf;
+    
+    color[i][0] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 16 & 0xf;
+    color[i][1] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 20 & 0xf;
+    color[i][2] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 24 & 0xf;
+    color[i][3] = pci->hli.btn_colit.btn_coli[current_button_color - 1][i] >> 28 & 0xf;
+  }
+  
+  return 0;
+}
+
+void dvdnav_free(void* pdata)
+{
+  free(pdata);
+}
+
+#undef printerr
+#define printerr(str) strncpy(self->err_str, str, MAX_ERR_LEN);
+
+#endif // _XBMC
diff -uwr ../libdvdnav-4.2.1/src/dvdnav_internal.h lib/libdvd/libdvdnav/src/dvdnav_internal.h
--- ../libdvdnav-4.2.1/src/dvdnav_internal.h	Sun Dec  9 21:22:16 2012
+++ lib/libdvd/libdvdnav/src/dvdnav_internal.h	Fri Feb  7 19:24:37 2014
@@ -133,6 +133,45 @@
 } ATTRIBUTE_PACKED spu_status_t;
 #endif
 
+/*
+ * Describes a given time, and the closest sector, vobu and tmap index
+ */
+typedef struct {
+  uint64_t            time;
+  uint32_t            sector;
+  uint32_t            vobu_idx;
+  int32_t             tmap_idx;
+} dvdnav_pos_data_t;
+
+/*
+ * Encapsulates cell data
+ */
+typedef struct {
+  int32_t             idx;
+  dvdnav_pos_data_t   *bgn;
+  dvdnav_pos_data_t   *end;
+} dvdnav_cell_data_t;
+
+/*
+ * Encapsulates common variables used by internal functions of jump_to_time
+ */
+typedef struct {
+  vobu_admap_t        *admap;
+  int32_t             admap_len;
+  vts_tmap_t          *tmap;
+  int32_t             tmap_len;
+  int32_t             tmap_interval;
+} dvdnav_jump_args_t;
+
+/*
+ * Utility constants for jump_to_time
+ */
+#define TMAP_IDX_EDGE_BGN  -1
+#define TMAP_IDX_EDGE_END  -2
+#define JUMP_MODE_TIME_AFTER 1
+#define JUMP_MODE_TIME_DEFAULT 0
+#define JUMP_MODE_TIME_BEFORE -1
+
 typedef struct dvdnav_vobu_s {
   int32_t vobu_start;  /* Logical Absolute. MAX needed is 0x300000 */
   int32_t vobu_length;
@@ -182,6 +221,18 @@
 
 /* converts a dvd_time_t to PTS ticks */
 int64_t dvdnav_convert_time(dvd_time_t *time);
+
+/* XBMC added functions */
+/*
+ * Get current playback state
+ */
+dvdnav_status_t dvdnav_get_state(dvdnav_t *this, dvd_state_t *save_state);
+
+/*
+ * Resume playback state
+ */
+dvdnav_status_t dvdnav_set_state(dvdnav_t *this, dvd_state_t *save_state);
+/* end XBMC */
 
 /** USEFUL MACROS **/
 
diff -uwr ../libdvdnav-4.2.1/src/read_cache.c lib/libdvd/libdvdnav/src/read_cache.c
--- ../libdvdnav-4.2.1/src/read_cache.c	Tue Dec 30 14:48:46 2008
+++ lib/libdvd/libdvdnav/src/read_cache.c	Wed Jan 29 20:43:09 2014
@@ -338,7 +338,7 @@
   pthread_mutex_lock(&cache->lock);
   for (i = 0; i < READ_CACHE_CHUNKS; i++) {
     if (cache->chunk[i].cache_buffer && buf >= cache->chunk[i].cache_buffer &&
-        buf < cache->chunk[i].cache_buffer + cache->chunk[i].cache_malloc_size * DVD_VIDEO_LB_LEN) {
+        buf < cache->chunk[i].cache_buffer + cache->chunk[i].cache_malloc_size * DVD_VIDEO_LB_LEN && cache->chunk[i].usage_count > 0) {
       cache->chunk[i].usage_count--;
     }
   }
diff -uwr ../libdvdnav-4.2.1/src/searching.c lib/libdvd/libdvdnav/src/searching.c
--- ../libdvdnav-4.2.1/src/searching.c	Tue Nov 12 00:55:10 2013
+++ lib/libdvd/libdvdnav/src/searching.c	Fri Feb  7 19:24:37 2014
@@ -36,6 +36,7 @@
 #include "vm/decoder.h"
 #include "vm/vm.h"
 #include "dvdnav_internal.h"
+#include <dvdread/ifo_read.h>
 
 /*
 #define LOG_DEBUG
@@ -121,6 +122,12 @@
     return DVDNAV_STATUS_ERR;
   }
 
+  if((state->pgc->prohibited_ops.title_or_time_play == 1) ||
+      (this->pci.pci_gi.vobu_uop_ctl.title_or_time_play == 1 )){
+    printerr("operation forbidden.");
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
 
   this->cur_cell_time = 0;
   if (this->pgc_based) {
@@ -136,24 +143,109 @@
       last_cell_nr = state->pgc->nr_of_cells;
   }
 
+  /* FIXME: using time map is not going to work unless we are pgc_based */
+  /*        we'd need to recalculate the time to be relative to full pgc first*/
+  if(!this->pgc_based)
+  {
+#ifdef LOG_DEBUG
+    fprintf(MSG_OUT, "libdvdnav: time_search - not pgc based\n");
+#endif
+    goto timemapdone;
+  }
+
+  if(!this->vm->vtsi->vts_tmapt){
+    /* no time map for this program chain */
+#ifdef LOG_DEBUG
+    fprintf(MSG_OUT, "libdvdnav: time_search - no time map for this program chain\n");
+#endif
+    goto timemapdone;
+  }
+
+  if(this->vm->vtsi->vts_tmapt->nr_of_tmaps < state->pgcN){
+    /* to few time maps for this program chain */
+#ifdef LOG_DEBUG
+    fprintf(MSG_OUT, "libdvdnav: time_search - to few time maps for this program chain\n");
+#endif
+    goto timemapdone;
+  }
+
+  /* get the tmpat corresponding to the pgc */
+  vts_tmap_t *tmap = &(this->vm->vtsi->vts_tmapt->tmap[state->pgcN-1]);
+
+  if(tmap->tmu == 0){
+    /* no time unit for this time map */
+#ifdef LOG_DEBUG
+    fprintf(MSG_OUT, "libdvdnav: time_search - no time unit for this time map\n");
+#endif
+    goto timemapdone;
+  }
+
+  /* time is in pts (90khz clock), get the number of tmu's that represent */
+  /* first entry defines at time tmu not time zero */
+  int entry = time / tmap->tmu / 90000 - 1;
+  if(entry > tmap->nr_of_entries)
+    entry = tmap->nr_of_entries -1;
+
+  if(entry > 0)
+  {
+    /* get the table entry, disregarding marking of discontinuity */
+    target = tmap->map_ent[entry] & 0x7fffffff;
+  }
+  else
+  {
+    /* start from first vobunit */
+    target = state->pgc->cell_playback[first_cell_nr-1].first_sector;;
+  }
+
+  /* if we have an additional entry we can interpolate next position */
+  /* allowed only if next entry isn't discontinious */
+
+  if( entry < tmap->nr_of_entries - 1)
+  {
+    const uint32_t target2 = tmap->map_ent[entry+1];
+    const uint64_t timeunit = tmap->tmu*90000;
+    if( !( target2 & 0x80000000) )
+    {
+      length = target2 - target;
+      target += (uint32_t) (length * ( time - (entry+1)*timeunit ) / timeunit);
+    }
+  }
+  found = 1;
+
+timemapdone:
+
   found = 0;
-  for(cell_nr = first_cell_nr; (cell_nr <= last_cell_nr) && !found; cell_nr ++) {
+  for(cell_nr = first_cell_nr; cell_nr <= last_cell_nr; cell_nr ++) {
     cell =  &(state->pgc->cell_playback[cell_nr-1]);
     if(cell->block_type == BLOCK_TYPE_ANGLE_BLOCK && cell->block_mode != BLOCK_MODE_FIRST_CELL)
       continue;
+
+    if(found) {
+
+      if (target >= cell->first_sector
+      &&  target <= cell->last_sector)
+         break;
+
+    } else {
+
     length = dvdnav_convert_time(&cell->playback_time);
-    if (target >= length) {
-      target -= length;
+      if (time >= length) {
+        time -= length;
     } else {
       /* FIXME: there must be a better way than interpolation */
-      target = target * (cell->last_sector - cell->first_sector + 1) / length;
+        target = time * (cell->last_sector - cell->first_sector + 1) / length;
       target += cell->first_sector;
 
+  #ifdef LOG_DEBUG
+        if( cell->first_sector > target || target > cell->last_sector )
+          fprintf(MSG_OUT, "libdvdnav: time_search - sector is not within cell min:%u, max:%u, cur:%u\n", cell->first_sector, cell->last_sector, target);
+  #endif
+
       found = 1;
       break;
     }
   }
-
+  }
   if(found) {
     uint32_t vobu;
 #ifdef LOG_DEBUG
@@ -202,6 +294,7 @@
 
   result = dvdnav_get_position(this, &target, &length);
   if(!result) {
+    printerr("Cannot get current position");
     return DVDNAV_STATUS_ERR;
   }
 
@@ -213,7 +306,7 @@
     return DVDNAV_STATUS_ERR;
   }
 #ifdef LOG_DEBUG
-  fprintf(MSG_OUT, "libdvdnav: seeking to offset=%lu pos=%u length=%u\n", offset, target, length);
+  fprintf(MSG_OUT, "libdvdnav: seeking to offset=%llu pos=%u length=%u\n", offset, target, length);
   fprintf(MSG_OUT, "libdvdnav: Before cellN=%u blockN=%u\n", state->cellN, state->blockN);
 #endif
 
@@ -681,4 +774,653 @@
   if(!retval && tmp)
     free(tmp);
   return retval;
+}
+
+dvdnav_status_t dvdnav_get_state(dvdnav_t *this, dvd_state_t *save_state)
+{
+  if(!this || !this->vm) return DVDNAV_STATUS_ERR;
+
+  pthread_mutex_lock(&this->vm_lock);
+  
+  if( !vm_get_state(this->vm, save_state) )
+  {
+    printerr("Failed to get vm state.");
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  }
+  
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_set_state(dvdnav_t *this, dvd_state_t *save_state)
+{
+  if(!this || !this->vm)
+  {
+    printerr("Passed a NULL pointer.");
+    return DVDNAV_STATUS_ERR;
+  }
+
+  if(!this->started) {
+    printerr("Virtual DVD machine not started.");
+    return DVDNAV_STATUS_ERR;
+  }
+
+  pthread_mutex_lock(&this->vm_lock);
+
+  /* reset the dvdnav state */
+  memset(&this->pci,0,sizeof(this->pci));
+  memset(&this->dsi,0,sizeof(this->dsi));
+  this->last_cmd_nav_lbn = SRI_END_OF_CELL;
+
+  /* Set initial values of flags */  
+  this->position_current.still = 0;
+  this->skip_still = 0;
+  this->sync_wait = 0;
+  this->sync_wait_skip = 0;
+  this->spu_clut_changed = 0;
+
+
+  /* set the state. this will also start the vm on that state */
+  /* means the next read block should be comming from that new */
+  /* state */
+  if( !vm_set_state(this->vm, save_state) )
+  {
+    printerr("Failed to set vm state.");
+    pthread_mutex_unlock(&this->vm_lock);
+    return DVDNAV_STATUS_ERR;
+  } 
+
+  pthread_mutex_unlock(&this->vm_lock);
+  return DVDNAV_STATUS_OK;
+}
+
+
+
+/* Get an admap and admap_len */
+static vobu_admap_t* dvdnav_admap_get(dvdnav_t *this, dvd_state_t *state,
+            int32_t *admap_len) {
+  vobu_admap_t *admap = NULL;
+  switch(state->domain) {
+  case FP_DOMAIN:
+  case VMGM_DOMAIN:
+    admap = this->vm->vmgi->menu_vobu_admap;
+    break;
+  case VTSM_DOMAIN:
+    admap = this->vm->vtsi->menu_vobu_admap;
+    break;
+  case VTS_DOMAIN:
+    admap = this->vm->vtsi->vts_vobu_admap;
+    break;
+  default: {
+    fprintf(MSG_OUT, "Unknown domain");
+    return NULL;
+  }
+  }
+  if (admap == NULL) return NULL;
+
+  *admap_len = (admap->last_byte + 1 - VOBU_ADMAP_SIZE) / VOBU_ADMAP_SIZE;
+  if (*admap_len <= 0) {
+    fprintf(MSG_OUT, "admap_len <= 0");
+    return NULL;
+  }
+  return admap;
+}
+
+/* Get a tmap, tmap_len and tmap_interval */
+static vts_tmap_t* dvdnav_tmap_get(dvdnav_t *this, dvd_state_t *state,
+            int32_t *tmap_len, int32_t *tmap_interval) {
+  int32_t vts_idx = 0;
+  domain_t domain;
+  ifo_handle_t *ifo = NULL;
+  vts_tmapt_t *tmapt = NULL;
+  uint16_t tmap_count = 0;
+  int32_t pgcN = 0;
+  vts_tmap_t *tmap = NULL;
+  int32_t result = 0;
+
+  vts_idx = state->vtsN;
+  domain = state->domain;
+  switch(domain) {
+  case FP_DOMAIN:
+  case VTSM_DOMAIN:
+  case VMGM_DOMAIN: {
+    ifo = this->vm->vmgi;
+    break;
+  }
+  case VTS_DOMAIN: {
+    ifo = this->vm->vtsi;
+    break;
+  }
+  default: {
+    fprintf(MSG_OUT, "unknown domain for tmap");
+    return NULL;
+  }
+  }
+  if (ifo == NULL) return NULL;
+  tmapt = ifo->vts_tmapt;
+  /* HACK: ifo->vts_tmapt is NULL b/c ifo_read.c never loads it
+   * load ifo->vts_tmapt directly*/
+  if (tmapt == NULL) {
+    result = ifoRead_VTS_TMAPT(ifo);
+    if (!result) {
+      return NULL;
+    }
+    tmapt = ifo->vts_tmapt;
+    if (tmapt == NULL) return NULL;
+  }
+
+  tmap_count = tmapt->nr_of_tmaps;
+  pgcN = state->pgcN - 1; /* -1 b/c pgcN is base1 */
+  if (pgcN < 0) {
+    fprintf(MSG_OUT, "pgcN < 0");
+    return NULL;
+  }
+
+  /* get tmap */
+  switch(domain) {
+  case FP_DOMAIN:
+  case VMGM_DOMAIN:
+  case VTSM_DOMAIN: {
+    if (tmap_count == 0) {
+      fprintf(MSG_OUT, "tmap_count == 0");
+      return NULL;
+    }
+    tmap = &tmapt->tmap[0]; /* ASSUME: vmgi only has one time map */
+    break;
+  }
+  case VTS_DOMAIN: {
+    if (pgcN >= tmap_count) {
+      fprintf(MSG_OUT, "pgcN >= tmap_count; pgcN=%i tmap_count=%i",
+          pgcN, tmap_count);
+      return NULL;
+    }
+    tmap = &tmapt->tmap[pgcN];
+    break;
+  }
+  }
+  if (tmap == NULL) return NULL;
+
+  /* tmap->tmu is in seconds; convert to millisecs */
+  *tmap_interval = tmap->tmu * 1000;
+  if (*tmap_interval == 0) {
+    fprintf(MSG_OUT, "tmap_interval == 0");
+    return NULL;
+  }
+  *tmap_len = tmap->nr_of_entries;
+  if (*tmap_len == 0) {
+    fprintf(MSG_OUT, "tmap_len == 0");
+    return NULL;
+  }
+  return tmap;
+}
+
+/* Get a sector from a tmap */
+static int32_t dvdnav_tmap_get_entry(vts_tmap_t *tmap, uint16_t tmap_len,
+            int32_t idx, uint32_t *sector) {
+  /* tmaps start at idx 0 which represents a sector at time 1 * tmap_interval
+   * this creates a "fake" tmap index at idx -1 for sector 0 */
+  if (idx == TMAP_IDX_EDGE_BGN) {
+    *sector = 0;
+    return 1;
+  }
+  if (idx < TMAP_IDX_EDGE_BGN || idx >= tmap_len) {
+    fprintf(MSG_OUT, "idx out of bounds idx=%i %i", idx, tmap_len);
+    return 0;
+  }
+  /* 0x7fffffff unsets discontinuity bit if present */
+  *sector = tmap->map_ent[idx] & 0x7fffffff;
+  return 1;
+}
+
+/* Do a binary search for earlier admap index near find_sector */
+static int32_t dvdnav_admap_search(vobu_admap_t *admap, uint32_t admap_len,
+            uint32_t find_sector, uint32_t *vobu) {
+  int32_t adj = 1;
+  int32_t prv_pos = 0;
+  int32_t prv_len = admap_len;
+  int32_t cur_len = 0;
+  int32_t cur_idx = 0;
+  uint32_t cur_sector = 0;
+  while (1) {
+    cur_len = prv_len / 2;
+    /* need to add 1 when prv_len == 3 (cur_len shoud go to 2, not 1) */
+    if (prv_len % 2 == 1) ++cur_len;
+    cur_idx = prv_pos + (cur_len * adj);
+    if       (cur_idx < 0)           cur_idx = 0;
+    else if  (cur_idx >= admap_len)  cur_idx = admap_len - 1;
+
+    cur_sector = admap->vobu_start_sectors[cur_idx];
+    if      (find_sector <  cur_sector) adj = -1;
+    else if (find_sector >  cur_sector) adj =  1;
+    else if (find_sector == cur_sector) {
+      *vobu = cur_idx;
+      return 1;
+    }
+    if (cur_len == 1) {/* no smaller intervals left */
+      if (adj == -1) {/* last comparison was greater; take lesser */
+          cur_idx -= 1;
+          cur_sector = admap->vobu_start_sectors[cur_idx];
+      }
+      *vobu = cur_idx;
+      return 1;
+    }
+    prv_len = cur_len;
+    prv_pos = cur_idx;
+  }
+}
+
+/* Do a binary search for the earlier tmap entry near find_sector */
+static int32_t dvdnav_tmap_search(vts_tmap_t *tmap, uint32_t tmap_len,
+            uint32_t find_sector, int32_t *tmap_idx, uint32_t *sector) {
+  int32_t adj = 1;
+  int32_t prv_pos = 0;
+  int32_t prv_len = tmap_len;
+  int32_t result = 0;
+  int32_t cur_len = 0;
+  int32_t cur_idx = 0;
+  uint32_t cur_sector = 0;
+  while (1) {
+    cur_len = prv_len / 2;
+    /* need to add 1 when prv_len == 3 (cur_len shoud go to 2, not 1) */
+    if (prv_len % 2 == 1) ++cur_len;
+    cur_idx = prv_pos + (cur_len * adj);
+    if      (cur_idx < 0)         cur_idx = 0;
+    else if (cur_idx >= tmap_len) cur_idx = tmap_len - 1;
+    cur_sector = 0;
+    result = dvdnav_tmap_get_entry(tmap, tmap_len, cur_idx, &cur_sector);
+    if (!result) return 0;
+    if      (find_sector <  cur_sector) adj = -1;
+    else if (find_sector >  cur_sector) adj =  1;
+    else if (find_sector == cur_sector) {
+      *tmap_idx = cur_idx;
+      *sector = cur_sector;
+      return 1;
+    }
+    if (cur_len == 1) {/* no smaller intervals left */
+      if (adj == -1) {/* last comparison was greater; take lesser */
+        if (cur_idx == 0) { /* fake tmap index for sector 0 */
+          cur_idx = TMAP_IDX_EDGE_BGN;
+          cur_sector = 0;
+        }
+        else {
+          cur_idx -= 1;
+          result = dvdnav_tmap_get_entry(tmap, tmap_len, cur_idx, &cur_sector);
+          if (!result) return 0;
+        }
+      }
+      *tmap_idx = cur_idx;
+      *sector = cur_sector;
+      return 1;
+    }
+    prv_len = cur_len;
+    prv_pos = cur_idx;
+  }
+}
+
+/* Find the cell for a given time */
+static int32_t dvdnav_cell_find(dvdnav_t *this, dvd_state_t *state,
+            uint64_t find_val, dvdnav_cell_data_t *cell_data) {
+  uint32_t cells_len = 0;
+  uint32_t cells_bgn = 0;
+  uint32_t cells_end = 0;
+  uint32_t cell_idx = 0;
+  pgc_t *pgc = NULL;
+  int pgN = 0;
+  cell_playback_t *cell = NULL;
+  int found = 0;
+
+  pgc = state->pgc;
+  if (pgc == NULL) return 0;
+  cells_len = pgc->nr_of_cells;
+  if (cells_len == 0) {
+    fprintf(MSG_OUT, "cells_len == 0");
+    return 0;
+  }
+
+  /* get cells_bgn, cells_end */
+  if (this->pgc_based) {
+    cells_bgn = 1;
+    cells_end = cells_len;
+  }
+  else {
+    pgN = state->pgN;
+    cells_bgn = pgc->program_map[pgN - 1]; /* -1 b/c pgN is 1 based? */
+    if (pgN < pgc->nr_of_programs) {
+      cells_end = pgc->program_map[pgN] - 1;
+    }
+    else {
+      cells_end = cells_len;
+    }
+  }
+
+  /* search cells */
+  for (cell_idx = cells_bgn; cell_idx <= cells_end; cell_idx++) {
+    cell = &(pgc->cell_playback[cell_idx - 1]); /* -1 b/c cell is base1 */
+    /* if angle block, only consider first angleBlock
+     * (others are "redundant" for purpose of search) */
+    if ( cell->block_type == BLOCK_TYPE_ANGLE_BLOCK
+      && cell->block_mode != BLOCK_MODE_FIRST_CELL) {
+      continue;
+    }
+    cell_data->bgn->sector = cell->first_sector;
+    cell_data->end->sector = cell->last_sector;
+
+    /* 90 pts to ms */
+    cell_data->end->time += (dvdnav_convert_time(&cell->playback_time) / 90);
+    if (  find_val >= cell_data->bgn->time
+       && find_val <= cell_data->end->time) {
+      found = 1;
+      break;
+    }
+    cell_data->bgn->time = cell_data->end->time;
+  }
+
+  /* found cell: set var */
+  if (found) {
+    cell_data->idx = cell_idx;
+  }
+  else
+    fprintf(MSG_OUT, "cell not found; find=%"PRId64"", find_val);
+  return found;
+}
+
+/* Given two sectors and a fraction, calc the corresponding vobu */
+static int32_t dvdnav_admap_interpolate_vobu(dvdnav_jump_args_t *args,
+            dvdnav_pos_data_t *bgn, dvdnav_pos_data_t *end, uint32_t fraction,
+            uint32_t *jump_sector) {
+  int32_t result = 0;
+  uint32_t vobu_len = 0;
+  uint32_t vobu_adj = 0;
+  uint32_t vobu_idx = 0;
+
+  /* get bgn->vobu_idx */
+  result = dvdnav_admap_search(args->admap, args->admap_len,
+      bgn->sector, &bgn->vobu_idx);
+  if (!result) {
+    fprintf(MSG_OUT, "admap_interpolate: could not find sector_bgn");
+    return 0;
+  }
+
+  /* get end->vobu_idx */
+  result = dvdnav_admap_search(args->admap, args->admap_len,
+      end->sector, &end->vobu_idx);
+  if (!result) {
+    fprintf(MSG_OUT, "admap_interpolate: could not find sector_end");
+    return 0;
+  }
+
+  vobu_len = end->vobu_idx - bgn->vobu_idx;
+  /* +500 to round up else 74% of a 4 sec interval = 2 sec */
+  vobu_adj = ((fraction * vobu_len) + 500) / 1000;
+  /* HACK: need to add +1, or else will land too soon (not sure why) */
+  vobu_adj++;
+  vobu_idx = bgn->vobu_idx + vobu_adj;
+  if (vobu_idx >= args->admap_len) {
+    fprintf(MSG_OUT, "admap_interpolate: vobu_idx >= admap_len");
+    return 0;
+  }
+  *jump_sector = args->admap->vobu_start_sectors[vobu_idx];
+  return 1;
+}
+
+/* Given two tmap entries and a time, calc the time for the lo tmap entry */
+static int32_t dvdnav_tmap_calc_time_for_tmap_entry(dvdnav_jump_args_t *args,
+            dvdnav_pos_data_t *lo, dvdnav_pos_data_t *hi,
+            dvdnav_pos_data_t *pos, uint64_t *out_time) {
+  int32_t result = 0;
+  uint32_t vobu_pct = 0;
+  uint64_t time_adj = 0;
+
+  if (lo->sector == hi->sector) {
+    fprintf(MSG_OUT, "lo->sector == hi->sector: %i", lo->sector);
+    return 0;
+  }
+
+  /* get vobus corresponding to lo, hi, pos */
+  result = dvdnav_admap_search(args->admap, args->admap_len,
+      lo->sector, &lo->vobu_idx);
+  if (!result) {
+    fprintf(MSG_OUT, "lo->vobu: lo->sector=%i", lo->sector);
+    return 0;
+  }
+  result = dvdnav_admap_search(args->admap, args->admap_len,
+      hi->sector, &hi->vobu_idx);
+  if (!result) {
+    fprintf(MSG_OUT, "hi->vobu: hi->sector=%i", hi->sector);
+    return 0;
+  }
+  result = dvdnav_admap_search(args->admap, args->admap_len,
+      pos->sector, &pos->vobu_idx);
+  if (!result) {
+    fprintf(MSG_OUT, "pos->vobu: pos->sector=%i", pos->sector);
+    return 0;
+  }
+
+  /* calc position of cell relative to lo */
+  vobu_pct = ((pos->vobu_idx - lo->vobu_idx) * 1000)
+            / ( hi->vobu_idx - lo->vobu_idx);
+  if (vobu_pct < 0 || vobu_pct > 1000) {
+    fprintf(MSG_OUT, "vobu_pct must be between 0 and 1000");
+    return 0;
+  }
+
+  /* calc time of lo */
+  time_adj = (uint64_t)((args->tmap_interval * vobu_pct) / 1000);
+  *out_time = pos->time - time_adj;
+  return 1;
+}
+
+/* Find the tmap entries on either side of a given sector */
+static int32_t dvdnav_tmap_get_entries_for_sector(dvdnav_t *this,
+            dvd_state_t *state, dvdnav_jump_args_t *args,
+            dvdnav_cell_data_t *cell_data, uint32_t find_sector,
+            dvdnav_pos_data_t *lo, dvdnav_pos_data_t *hi) {
+  int32_t result = 0;
+
+  result = dvdnav_tmap_search(args->tmap, args->tmap_len, find_sector,
+      &lo->tmap_idx, &lo->sector);
+  if (!result) {
+    fprintf(MSG_OUT, "could not find lo idx: %i", find_sector);
+    return 0;
+  }
+
+  /* HACK: Most DVDs have a tmap that starts at sector 0
+   * However, some have initial dummy cells that are not seekable
+   * (restricted = y).
+   * These cells will throw off the tmap calcs when in the first playable cell.
+   * For now, assume that lo->sector is equal to the cell->bgn->sector
+   * Note that for most DVDs this will be 0
+   * (Since they will have no dummy cells and cell 1 will start at sector 0)
+   */
+  if (lo->tmap_idx == TMAP_IDX_EDGE_BGN) {
+    lo->sector = cell_data->bgn->sector;
+  }
+
+  if (lo->tmap_idx == args->tmap_len - 1) {
+    /* lo is last tmap entry; "fake" entry for one beyond
+     * and mark it with cell_end_sector */
+    hi->tmap_idx = TMAP_IDX_EDGE_END;
+    hi->sector = cell_data->end->sector;
+  }
+  else {
+    hi->tmap_idx = lo->tmap_idx + 1;
+    result = dvdnav_tmap_get_entry(args->tmap, args->tmap_len,
+        hi->tmap_idx, &hi->sector);
+    if (!result) {
+      fprintf(MSG_OUT, "could not find hi idx: %i", find_sector);
+      return 0;
+    }
+  }
+  return 1;
+}
+
+/* Find the nearest vobu by using the tmap */
+static int32_t dvdnav_find_vobu_by_tmap(dvdnav_t *this, dvd_state_t *state,
+            dvdnav_jump_args_t *args, dvdnav_cell_data_t *cell_data,
+            dvdnav_pos_data_t *jump) {
+  uint64_t seek_offset = 0;
+  uint32_t seek_idx = 0;
+  int32_t result = 0;
+  dvdnav_pos_data_t *cell_bgn_lo = NULL;
+  dvdnav_pos_data_t *cell_bgn_hi = NULL;
+  dvdnav_pos_data_t *jump_lo = NULL;
+  dvdnav_pos_data_t *jump_hi = NULL;
+
+  /* get tmap, tmap_len, tmap_interval */
+  args->tmap = dvdnav_tmap_get(this, state,
+      &args->tmap_len, &args->tmap_interval);
+  if (args->tmap == NULL) return 0;
+
+  /* get tmap entries on either side of cell_bgn */
+  cell_bgn_lo = &(dvdnav_pos_data_t){0};
+  cell_bgn_hi = &(dvdnav_pos_data_t){0};
+  result = dvdnav_tmap_get_entries_for_sector(this, state, args, cell_data,
+      cell_data->bgn->sector, cell_bgn_lo, cell_bgn_hi);
+  if (!result) return 0;
+
+  /* calc time of cell_bgn_lo */
+  result = dvdnav_tmap_calc_time_for_tmap_entry(args, cell_bgn_lo, cell_bgn_hi,
+      cell_data->bgn, &cell_bgn_lo->time);
+  if (!result) return 0;
+
+  /* calc time of jump_time relative to cell_bgn_lo */
+  seek_offset = jump->time - cell_bgn_lo->time;
+  seek_idx = (uint32_t)(seek_offset / args->tmap_interval);
+  uint32_t seek_remainder = seek_offset - (seek_idx * args->tmap_interval);
+  uint32_t seek_pct = (seek_remainder * 1000) / args->tmap_interval;
+
+  /* get tmap entries on either side of jump_time */
+  jump_lo = &(dvdnav_pos_data_t){0};
+  jump_hi = &(dvdnav_pos_data_t){0};
+
+  /* if seek_idx == 0, then tmap_indexes are the same, do not re-get
+   * also, note cell_bgn_lo will already have sector if TMAP_IDX_EDGE_BGN */
+  if (seek_idx == 0) {
+    jump_lo = cell_bgn_lo;
+    jump_hi = cell_bgn_hi;
+  }
+  else {
+    jump_lo->tmap_idx = (uint32_t)(cell_bgn_lo->tmap_idx + seek_idx);
+    result = dvdnav_tmap_get_entry(args->tmap, args->tmap_len,
+        jump_lo->tmap_idx, &jump_lo->sector);
+    if (!result) return 0;
+
+    /* +1 handled by dvdnav_tmap_get_entry */
+    jump_hi->tmap_idx = jump_lo->tmap_idx + 1;
+    result = dvdnav_tmap_get_entry(args->tmap, args->tmap_len,
+        jump_hi->tmap_idx, &jump_hi->sector);
+    if (!result) return 0;
+  }
+
+  /* interpolate sector */
+  result = dvdnav_admap_interpolate_vobu(args, jump_lo, jump_hi,
+      seek_pct, &jump->sector);
+
+  return result;
+}
+
+/* Find the nearest vobu by using the cell boundaries */
+static int32_t dvdnav_find_vobu_by_cell_boundaries(dvdnav_t *this,
+            dvdnav_jump_args_t *args, dvdnav_cell_data_t *cell_data,
+            dvdnav_pos_data_t *jump) {
+  uint64_t jump_offset = 0;
+  uint64_t cell_len = 0;
+  uint32_t jump_pct = 0;
+  int32_t result = 0;
+
+  /* get jump_offset */
+  jump_offset = jump->time - cell_data->bgn->time;
+  if (jump_offset < 0) {
+    fprintf(MSG_OUT, "jump_offset < 0");
+    return 0;
+  }
+  cell_len = cell_data->end->time - cell_data->bgn->time;
+  if (cell_len < 0) {
+    fprintf(MSG_OUT, "cell_len < 0");
+    return 0;
+  }
+  jump_pct = (jump_offset * 1000) / cell_len;
+
+  /* get sector */
+  /* NOTE: end cell sector in VTS_PGC is last sector of cell
+   * this last sector is not the start of a VOBU
+   * +1 to get sector that is the start of a VOBU
+   * start of a VOBU is needed in order to index into admap */
+  cell_data->end->sector += 1;
+  result = dvdnav_admap_interpolate_vobu(args,
+      cell_data->bgn, cell_data->end, jump_pct, &jump->sector);
+  if (!result) {
+    fprintf(MSG_OUT, "find_by_admap.interpolate");
+    return 0;
+  }
+  return 1;
+}
+
+/* Jump to sector by time */
+/* NOTE: Mode is currently unimplemented. Only 0 should be passed. */
+/* 1 and -1 are for future implementation */
+/*  0: Default. Jump to a time which may be either <> time_in_pts_ticks */
+/*  1: After. Always jump to a time that is > time_in_pts_ticks */
+/* -1: Before. Always jump to a time that is < time_in_pts_ticks */
+dvdnav_status_t dvdnav_jump_to_sector_by_time(dvdnav_t *this,
+            uint64_t time_in_pts_ticks, int32_t mode) {
+  if (mode != JUMP_MODE_TIME_DEFAULT) return DVDNAV_STATUS_ERR;
+  int32_t result = DVDNAV_STATUS_ERR;
+  dvd_state_t *state = NULL;
+  uint32_t sector_off = 0;
+  dvdnav_pos_data_t *jump = NULL;
+  dvdnav_cell_data_t *cell_data = NULL;
+  dvdnav_jump_args_t *args = NULL;
+
+  jump = &(dvdnav_pos_data_t){0};
+  /* convert time to milliseconds */
+  jump->time = time_in_pts_ticks / 90;
+
+  /* get variables that will be used across both functions */
+  state = &(this->vm->state);
+  if (state == NULL) goto exit;
+
+  /* get cell info */
+  cell_data = &(dvdnav_cell_data_t){0};
+  cell_data->bgn = &(dvdnav_pos_data_t){0};
+  cell_data->end = &(dvdnav_pos_data_t){0};
+  result = dvdnav_cell_find(this, state, jump->time, cell_data);
+  if (!result) goto exit;
+
+  /* get admap */
+  args = &(dvdnav_jump_args_t){0};
+  args->admap = dvdnav_admap_get(this, state, &args->admap_len);
+  if (args->admap == NULL) goto exit;
+
+  /* find sector */
+  result = dvdnav_find_vobu_by_tmap(this, state, args, cell_data, jump);
+  if (!result) {/* bad tmap; interpolate over cell */
+    result = dvdnav_find_vobu_by_cell_boundaries(this, args, cell_data, jump);
+    if (!result) {
+      goto exit;
+    }
+  }
+
+#ifdef LOG_DEBUG
+  fprintf(MSG_OUT, "libdvdnav: seeking to time=%lu\n", jump->time);
+  fprintf(MSG_OUT, "libdvdnav: Before cellN=%u blockN=%u\n", state->cellN, state->blockN);
+#endif
+
+  /* jump to sector */
+  sector_off = jump->sector - cell_data->bgn->sector;
+  this->cur_cell_time = 0;
+  if (vm_jump_cell_block(this->vm, cell_data->idx, sector_off)) {
+    pthread_mutex_lock(&this->vm_lock);
+    this->vm->hop_channel += HOP_SEEK;
+    pthread_mutex_unlock(&this->vm_lock);
+    result = DVDNAV_STATUS_OK;
+  }
+
+#ifdef LOG_DEBUG
+  fprintf(MSG_OUT, "libdvdnav: After cellN=%u blockN=%u\n", state->cellN, state->blockN);
+#endif
+
+exit:
+  return result;
 }
diff -uwr ../libdvdnav-4.2.1/src/vm/vm.c lib/libdvd/libdvdnav/src/vm/vm.c
--- ../libdvdnav-4.2.1/src/vm/vm.c	Wed Dec  4 23:02:02 2013
+++ lib/libdvd/libdvdnav/src/vm/vm.c	Fri Feb  7 19:31:48 2014
@@ -254,6 +254,15 @@
     fprintf(MSG_OUT, "libdvdnav: ifoRead_TITLE_VOBU_ADMAP vtsi failed\n");
     return 0;
   }
+  if(!ifoRead_VTS_TMAPT(vm->vtsi)) {
+    fprintf(MSG_OUT, "libdvdnav: ifoRead_VTS_TMAPT vtsi failed\n");
+    return 0;
+  }
+  if(!ifoRead_TITLE_C_ADT(vm->vtsi)) {
+    fprintf(MSG_OUT, "libdvdnav: ifoRead_TITLE_C_ADT vtsi failed\n");
+    return 0;
+  }
+
   (vm->state).vtsN = vtsN;
 
   return 1;
@@ -392,6 +401,13 @@
     }
     /* ifoRead_TXTDT_MGI(vmgi); Not implemented yet */
     dvd_read_name(vm->dvd_name, vm->dvd_serial, dvdroot);
+#ifdef _XBMC
+    if(DVDUDFVolumeInfo(vm->dvd, vm->dvd_name, sizeof(vm->dvd_name), NULL, 0))
+      if(DVDISOVolumeInfo(vm->dvd, vm->dvd_name, sizeof(vm->dvd_name), NULL, 0))
+        strcpy(vm->dvd_name, "");
+
+    fprintf(MSG_OUT, "libdvdnav: vm: DVD Title: %s\n", vm->dvd_name);
+#endif
     vm->map  = remap_loadmap(vm->dvd_name);
   }
   if (vm->vmgi) {
@@ -1983,6 +1999,50 @@
   ifoClose(ifo);
 }
 
+int vm_get_state(vm_t *vm, dvd_state_t *save_state) {
+  *save_state = vm->state;
+  
+  /* remove the pgc pointer as it might not be valid later*/
+  save_state->pgc = NULL;
+
+  return 1;
+}
+
+int vm_set_state(vm_t *vm, dvd_state_t *save_state) {
+
+  /* restore state from save_state as taken from ogle */
+
+  /* open the needed vts */
+  if( !ifoOpenNewVTSI(vm, vm->dvd, save_state->vtsN) ) return 0;
+  // sets state.vtsN
+    
+  vm->state = *save_state;
+  /* set state.domain before calling */
+  //calls get_pgcit()
+  //      needs state.domain and sprm[0] set
+  //      sets pgcit depending on state.domain
+  //writes: state.pgc
+  //        state.pgN
+  //        state.TT_PGCN_REG
+  
+  if( !set_PGCN(vm, save_state->pgcN) ) return 0;
+  save_state->pgc = vm->state.pgc;
+
+  /* set the rest of state after the call */
+  vm->state = *save_state;
+
+  /* if we are not in standard playback, we must get all data */
+  /* otherwise we risk loosing stillframes, and overlays */
+  if(vm->state.domain != VTS_DOMAIN)
+    vm->state.blockN = 0;
+
+  /* force a flush of data here */
+  /* we don't need a hop seek here as it's a complete state*/
+  vm->hop_channel++;
+
+  return 1;
+}
+
 /* Debug functions */
 
 #ifdef TRACE
diff -uwr ../libdvdnav-4.2.1/src/vm/vm.h lib/libdvd/libdvdnav/src/vm/vm.h
--- ../libdvdnav-4.2.1/src/vm/vm.h	Sat Jul 31 00:34:16 2010
+++ lib/libdvd/libdvdnav/src/vm/vm.h	Fri Feb  7 19:30:55 2014
@@ -170,6 +170,9 @@
 ifo_handle_t *vm_get_title_ifo(vm_t *vm, uint32_t title);
 void vm_ifo_close(ifo_handle_t *ifo);
 
+int vm_get_state(vm_t *vm, dvd_state_t *save_state);
+int vm_set_state(vm_t *vm, dvd_state_t *save_state);
+
 /* Uncomment for VM command tracing */
 /* #define TRACE */
 #ifdef TRACE
Only in lib/libdvd/libdvdnav/: version.h
