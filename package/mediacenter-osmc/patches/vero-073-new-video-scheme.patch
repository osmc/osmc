From feca90ccb4dfb6682ce1d1a4883c06640dda1559 Mon Sep 17 00:00:00 2001
From: Sam Nazarko <email@samnazarko.co.uk>
Date: Sun, 27 Aug 2017 19:09:38 +0100
Subject: [PATCH] A series of video improvements for iMX6

Signed-off-by: Sam Nazarko <email@samnazarko.co.uk>
---
 .../resource.language.en_gb/resources/strings.po   |   12 +
 xbmc/cores/IPlayer.h                               |    8 +-
 .../DVDCodecs/Video/DVDVideoCodecIMX.cpp           | 1042 ++++++++++----------
 .../VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h |  127 +--
 .../VideoRenderers/HwDecRender/RendererIMX.cpp     |   23 +-
 .../VideoRenderers/HwDecRender/RendererIMX.h       |    3 +-
 .../cores/VideoPlayer/VideoRenderers/RenderFlags.h |    5 +-
 .../VideoPlayer/VideoRenderers/RenderManager.cpp   |    4 +-
 xbmc/guilib/Resolution.cpp                         |  113 ++-
 xbmc/guilib/Resolution.h                           |    9 +-
 xbmc/linux/imx/IMX.cpp                             |   25 +-
 xbmc/linux/imx/IMX.h                               |  174 +++-
 xbmc/settings/Settings.cpp                         |   21 +-
 xbmc/settings/Settings.h                           |    8 +
 xbmc/video/dialogs/GUIDialogVideoSettings.cpp      |    4 +-
 xbmc/windowing/egl/EGLEdid.cpp                     |   94 ++
 xbmc/windowing/egl/EGLEdid.h                       |   71 ++
 xbmc/windowing/egl/EGLNativeTypeIMX.cpp            |  248 ++++-
 xbmc/windowing/egl/EGLNativeTypeIMX.h              |   20 +-
 xbmc/windowing/egl/Makefile.in                     |    1 +
 xbmc/windowing/egl/WinSystemEGL.cpp                |   67 +-
 xbmc/windowing/egl/vc_hdmi.h                       |  565 +++++++++++
 22 files changed, 1923 insertions(+), 721 deletions(-)
 create mode 100644 xbmc/windowing/egl/EGLEdid.cpp
 create mode 100644 xbmc/windowing/egl/EGLEdid.h
 create mode 100644 xbmc/windowing/egl/vc_hdmi.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 9009023..dcdb19b 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -8807,9 +8807,21 @@ msgstr ""
 #. Description of OSD video settings for deinterlace method with label #16336
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16336"
+msgid "IMX - Weave (half)"
+msgstr ""
+
+#. Description of OSD video settings for deinterlace method with label #16337
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16337"
 msgid "IMX - Advanced"
 msgstr ""
 
+#. Description of OSD video settings for deinterlace method with label #16338
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16338"
+msgid "IMX - Weave"
+msgstr ""
+
 #empty strings from id 16337 to 16399
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
diff --git a/xbmc/cores/IPlayer.h b/xbmc/cores/IPlayer.h
index a1ea99f..1240cbf 100644
--- a/xbmc/cores/IPlayer.h
+++ b/xbmc/cores/IPlayer.h
@@ -165,10 +165,12 @@ enum EINTERLACEMETHOD
   VS_INTERLACEMETHOD_MMAL_BOB_HALF = 28,
 
   VS_INTERLACEMETHOD_IMX_FASTMOTION = 29,
-  VS_INTERLACEMETHOD_IMX_ADVMOTION = 30,
-  VS_INTERLACEMETHOD_IMX_ADVMOTION_HALF = 31,
+  VS_INTERLACEMETHOD_IMX_ADVMOTION_HALF = 30,
+  VS_INTERLACEMETHOD_IMX_WEAVE_HALF = 31,
+  VS_INTERLACEMETHOD_IMX_ADVMOTION = 32,
+  VS_INTERLACEMETHOD_IMX_WEAVE = 33,
 
-  VS_INTERLACEMETHOD_DXVA_AUTO = 32,
+  VS_INTERLACEMETHOD_DXVA_AUTO = 34,
 
   VS_INTERLACEMETHOD_MAX // do not use and keep as last enum value.
 };
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index b1147d2..ea15717 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -18,10 +18,14 @@
  *
  */
 
+#include <linux/mxcfb.h>
+#include <vpu_lib.h>
+
 #include "DVDVideoCodecIMX.h"
 
 #include "settings/AdvancedSettings.h"
 #include "threads/SingleLock.h"
+#include "threads/SharedSection.h"
 #include "utils/log.h"
 #include "windowing/WindowingFactory.h"
 #include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
@@ -29,8 +33,11 @@
 #include "utils/StringUtils.h"
 #include "settings/MediaSettings.h"
 #include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+#include "utils/Environment.h"
 
 #include "linux/imx/IMX.h"
+#include <vpu_io.h>
+#include <linux/ipu.h>
 #include "libavcodec/avcodec.h"
 
 #include "guilib/LocalizeStrings.h"
@@ -42,23 +49,17 @@
 #include <unistd.h>
 #include <string.h>
 #include <fcntl.h>
-#include <algorithm>
 #include <linux/fb.h>
 #include <list>
+#include <algorithm>
 
 #define FRAME_ALIGN             16
 #define MEDIAINFO               1
-#define RENDER_QUEUE_SIZE       NUM_BUFFERS
-#define DECODE_OUTPUT_SIZE      15
+#define RENDER_QUEUE_SIZE       3
+#define DECODE_OUTPUT_SIZE      8
 #define IN_DECODER_SET          -1
 
-#define _4CC(c1,c2,c3,c4) (((uint32_t)(c4)<<24)|((uint32_t)(c3)<<16)|((uint32_t)(c2)<<8)|(uint32_t)(c1))
-#define Align(ptr,align)  (((unsigned int)ptr + (align) - 1)/(align)*(align))
-#define Align2(ptr,align)  (((unsigned int)ptr)/(align)*(align))
-#define ALIGN Align
-
 #define BIT(nr) (1UL << (nr))
-#define SZ_4K                   4*1024
 
 #if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS) || defined(TRACE_FRAMES)
 unsigned char CDVDVideoCodecIMXBuffer::i = 0;
@@ -73,7 +74,7 @@ std::list<VpuFrameBuffer*> m_recycleBuffers;
 const int CIMXContext::m_fbPages = 3;
 
 // Experiments show that we need at least one more (+1) VPU buffer than the min value returned by the VPU
-const unsigned int CIMXCodec::m_extraVpuBuffers = 1 + CIMXContext::m_fbPages + RENDER_QUEUE_SIZE;
+const unsigned int CIMXCodec::m_extraVpuBuffers = RENDER_QUEUE_SIZE + 1;
 
 CDVDVideoCodecIMX::~CDVDVideoCodecIMX()
 {
@@ -110,36 +111,26 @@ bool CDVDVideoCodecIMX::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 
 bool CIMXCodec::VpuAllocBuffers(VpuMemInfo *pMemBlock)
 {
-  int i, size;
-  void* ptr;
-  VpuMemDesc vpuMem;
-
-  for(i=0; i<pMemBlock->nSubBlockNum; i++)
+  for(int i=0; i<pMemBlock->nSubBlockNum; i++)
   {
-    size = pMemBlock->MemSubBlock[i].nAlignment + pMemBlock->MemSubBlock[i].nSize;
     if (pMemBlock->MemSubBlock[i].MemType == VPU_MEM_VIRT)
     { // Allocate standard virtual memory
-      ptr = malloc(size);
-      if(ptr == NULL)
+      if (posix_memalign((void**)&pMemBlock->MemSubBlock[i].pVirtAddr, PAGE_SIZE, pMemBlock->MemSubBlock[i].nSize))
       {
-        ExitError("%s - Unable to malloc %d bytes.\n", size);
+        ExitError("%s - Unable to malloc %d bytes.\n", pMemBlock->MemSubBlock[i].nSize);
         return false;
       }
-
-      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(ptr, pMemBlock->MemSubBlock[i].nAlignment);
-
-      m_decMemInfo.nVirtNum++;
-      m_decMemInfo.virtMem = (void**)realloc(m_decMemInfo.virtMem, m_decMemInfo.nVirtNum*sizeof(void*));
-      m_decMemInfo.virtMem[m_decMemInfo.nVirtNum-1] = ptr;
     }
     else
     { // Allocate contigous mem for DMA
-      vpuMem.nSize = size;
+      VpuMemDesc vpuMem = {};
+      vpuMem.nSize = pMemBlock->MemSubBlock[i].nSize + PAGE_SIZE;
       if(!VpuAlloc(&vpuMem))
         return false;
 
-      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(vpuMem.nVirtAddr, pMemBlock->MemSubBlock[i].nAlignment);
-      pMemBlock->MemSubBlock[i].pPhyAddr = (unsigned char*)Align(vpuMem.nPhyAddr, pMemBlock->MemSubBlock[i].nAlignment);
+      vpuMem.nSize = pMemBlock->MemSubBlock[i].nSize;
+      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(vpuMem.nVirtAddr, PAGE_SIZE);
+      pMemBlock->MemSubBlock[i].pPhyAddr = (unsigned char*)Align(vpuMem.nPhyAddr, PAGE_SIZE);
     }
   }
 
@@ -148,57 +139,31 @@ bool CIMXCodec::VpuAllocBuffers(VpuMemInfo *pMemBlock)
 
 bool CIMXCodec::VpuFreeBuffers(bool dispose)
 {
-  VpuMemDesc vpuMem;
-  VpuDecRetCode vpuRet;
-  int freePhyNum = dispose ? m_decMemInfo.nPhyNum : m_vpuFrameBuffers.size();
-  bool ret = true;
-
   m_decOutput.for_each(Release);
+  g2d_buf *preserveVpuRing = m_allocated.pop();
 
-  if (m_decMemInfo.virtMem && dispose)
-  {
-    //free virtual mem
-    for(int i=0; i<m_decMemInfo.nVirtNum; i++)
-    {
-      if (m_decMemInfo.virtMem[i])
-        free((void*)m_decMemInfo.virtMem[i]);
-    }
-    free(m_decMemInfo.virtMem);
-    m_decMemInfo.virtMem = NULL;
-    m_decMemInfo.nVirtNum = 0;
-  }
+  m_allocated.for_each(Release);
 
-  if (m_decMemInfo.nPhyNum)
+  if (dispose)
   {
-    int released = 0;
-    //free physical mem
-    for(int i=m_decMemInfo.nPhyNum - 1; i>=m_decMemInfo.nPhyNum - freePhyNum; i--)
+    for(int i=0; i<m_memInfo.nSubBlockNum; i++)
     {
-      vpuMem.nPhyAddr = m_decMemInfo.phyMem[i].nPhyAddr;
-      vpuMem.nVirtAddr = m_decMemInfo.phyMem[i].nVirtAddr;
-      vpuMem.nCpuAddr = m_decMemInfo.phyMem[i].nCpuAddr;
-      vpuMem.nSize = m_decMemInfo.phyMem[i].nSize;
-      vpuRet = VPU_DecFreeMem(&vpuMem);
-      if(vpuRet != VPU_DEC_RET_SUCCESS)
+      if (m_memInfo.MemSubBlock[i].MemType == VPU_MEM_VIRT && m_memInfo.MemSubBlock[i].pVirtAddr)
       {
-        CLog::Log(LOGERROR, "%s - Error while trying to free physical memory (%d).\n", __FUNCTION__, ret);
-        ret = false;
-        break;
+        free((void*)m_memInfo.MemSubBlock[i].pVirtAddr);
+        m_memInfo.MemSubBlock[i] = {};
       }
-      else
-        released++;
     }
 
-    m_decMemInfo.nPhyNum -= released;
-    if (!m_decMemInfo.nPhyNum)
-    {
-      free(m_decMemInfo.phyMem);
-      m_decMemInfo.phyMem = NULL;
-    }
+    g2d_free(preserveVpuRing);
+  }
+  else
+  {
+    m_allocated.push(preserveVpuRing);
   }
 
   m_vpuFrameBuffers.clear();
-  return ret;
+  return true;
 }
 
 
@@ -206,10 +171,9 @@ bool CIMXCodec::VpuOpen()
 {
   VpuDecRetCode  ret;
   VpuVersionInfo vpuVersion;
-  VpuMemInfo     memInfo;
   int            param;
 
-  memset(&memInfo, 0, sizeof(VpuMemInfo));
+  memset(&m_memInfo, 0, sizeof(VpuMemInfo));
   ret = VPU_DecLoad();
   if (ret != VPU_DEC_RET_SUCCESS)
   {
@@ -223,20 +187,17 @@ bool CIMXCodec::VpuOpen()
     CLog::Log(LOGERROR, "%s - VPU version cannot be read (%d).\n", __FUNCTION__, ret);
     goto VpuOpenError;
   }
-  else
-  {
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "VPU Lib version : major.minor.rel=%d.%d.%d.\n", vpuVersion.nLibMajor, vpuVersion.nLibMinor, vpuVersion.nLibRelease);
-  }
 
-  ret = VPU_DecQueryMem(&memInfo);
+  CLog::Log(LOGVIDEO, "VPU Lib version : major.minor.rel=%d.%d.%d.\n", vpuVersion.nLibMajor, vpuVersion.nLibMinor, vpuVersion.nLibRelease);
+
+  ret = VPU_DecQueryMem(&m_memInfo);
   if (ret != VPU_DEC_RET_SUCCESS)
   {
           CLog::Log(LOGERROR, "%s - iMX VPU query mem error (%d).\n", __FUNCTION__, ret);
           goto VpuOpenError;
   }
 
-  if (!VpuAllocBuffers(&memInfo))
+  if (!VpuAllocBuffers(&m_memInfo))
     goto VpuOpenError;
 
   m_decOpenParam.nReorderEnable = 1;
@@ -248,7 +209,7 @@ bool CIMXCodec::VpuOpen()
   m_decOpenParam.nTiled2LinearEnable = 0;
   m_decOpenParam.nEnableFileMode = 0;
 
-  ret = VPU_DecOpen(&m_vpuHandle, &m_decOpenParam, &memInfo);
+  ret = VPU_DecOpen(&m_vpuHandle, &m_decOpenParam, &m_memInfo);
   if (ret != VPU_DEC_RET_SUCCESS)
   {
     CLog::Log(LOGERROR, "%s - iMX VPU open failed (%d).\n", __FUNCTION__, ret);
@@ -265,23 +226,19 @@ VpuOpenError:
   return false;
 }
 
-bool CIMXCodec::VpuAlloc(VpuMemDesc *vpuMem)
+g2d_buf *CIMXCodec::VpuAlloc(VpuMemDesc *vpuMem)
 {
-  VpuDecRetCode ret = VPU_DecGetMem(vpuMem);
-  if (ret)
+  g2d_buf *g;
+  if ((g = g2d_alloc(vpuMem->nSize, 0)))
   {
-    CLog::Log(LOGERROR, "%s: vpu malloc frame buf of size %d failure: ret=%d \r\n",__FUNCTION__, vpuMem->nSize, ret);
-    return false;
+    vpuMem->nPhyAddr = g->buf_paddr;
+    vpuMem->nVirtAddr = (unsigned long)g->buf_vaddr;
+    m_allocated.push(g);
   }
+  else
+    CLog::Log(LOGERROR, "%s: vpu malloc frame buf of size %d\r\n",__FUNCTION__, vpuMem->nSize);
 
-  m_decMemInfo.nPhyNum++;
-  m_decMemInfo.phyMem = (VpuMemDesc*)realloc(m_decMemInfo.phyMem, m_decMemInfo.nPhyNum*sizeof(VpuMemDesc));
-  m_decMemInfo.phyMem[m_decMemInfo.nPhyNum-1].nPhyAddr = vpuMem->nPhyAddr;
-  m_decMemInfo.phyMem[m_decMemInfo.nPhyNum-1].nVirtAddr = vpuMem->nVirtAddr;
-  m_decMemInfo.phyMem[m_decMemInfo.nPhyNum-1].nCpuAddr = vpuMem->nCpuAddr;
-  m_decMemInfo.phyMem[m_decMemInfo.nPhyNum-1].nSize = vpuMem->nSize;
-
-  return true;
+  return g;
 }
 
 bool CIMXCodec::VpuAllocFrameBuffers()
@@ -294,7 +251,6 @@ bool CIMXCodec::VpuAllocFrameBuffers()
   int yStride   = 0;
   int uvStride  = 0;
 
-  VpuMemDesc vpuMem;
   unsigned char* ptr;
   unsigned char* ptrVirt;
   int nAlign;
@@ -350,6 +306,8 @@ bool CIMXCodec::VpuAllocFrameBuffers()
   totalSize = ySize + uSize + vSize + mvSize + nAlign;
   for (int i=0 ; i < nrBuf; i++)
   {
+    VpuMemDesc vpuMem = {};
+
     vpuMem.nSize = totalSize;
     if(!VpuAlloc(&vpuMem))
     {
@@ -371,7 +329,7 @@ bool CIMXCodec::VpuAllocFrameBuffers()
       ptrVirt = (unsigned char*)Align(ptrVirt,nAlign);
     }
 
-    VpuFrameBuffer vpuFrameBuffer;
+    VpuFrameBuffer vpuFrameBuffer = {};
     m_vpuFrameBuffers.push_back(vpuFrameBuffer);
 
     // fill stride info
@@ -383,8 +341,6 @@ bool CIMXCodec::VpuAllocFrameBuffers()
     m_vpuFrameBuffers[i].pbufCb             = ptr + ySize;
 #ifdef IMX_INPUT_FORMAT_I420
     m_vpuFrameBuffers[i].pbufCr             = ptr + ySize + uSize;
-#else
-    m_vpuFrameBuffers[i].pbufCr             = 0;
 #endif
     m_vpuFrameBuffers[i].pbufMvCol          = ptr + ySize + uSize + vSize;
 
@@ -393,15 +349,8 @@ bool CIMXCodec::VpuAllocFrameBuffers()
     m_vpuFrameBuffers[i].pbufVirtCb         = ptrVirt + ySize;
 #ifdef IMX_INPUT_FORMAT_I420
     m_vpuFrameBuffers[i].pbufVirtCr         = ptrVirt + ySize + uSize;
-#else
-    m_vpuFrameBuffers[i].pbufVirtCr         = 0;
 #endif
     m_vpuFrameBuffers[i].pbufVirtMvCol      = ptrVirt + ySize + uSize + vSize;
-
-    m_vpuFrameBuffers[i].pbufY_tilebot      = 0;
-    m_vpuFrameBuffers[i].pbufCb_tilebot     = 0;
-    m_vpuFrameBuffers[i].pbufVirtY_tilebot  = 0;
-    m_vpuFrameBuffers[i].pbufVirtCb_tilebot = 0;
   }
 
   if (VPU_DEC_RET_SUCCESS != VPU_DecRegisterFrameBuffer(m_vpuHandle, &m_vpuFrameBuffers[0], m_vpuFrameBuffers.size()))
@@ -415,6 +364,7 @@ bool CIMXCodec::VpuAllocFrameBuffers()
 
 CIMXCodec::CIMXCodec()
   : CThread("iMX VPU")
+  , m_vpuHandle(0)
   , m_dropped(0)
   , m_lastPTS(DVD_NOPTS_VALUE)
   , m_codecControlFlags(0)
@@ -424,19 +374,17 @@ CIMXCodec::CIMXCodec()
   , m_fps(-1)
   , m_burst(0)
 {
+  m_decOpenParam = {};
   m_nrOut.store(0);
 
-  m_vpuHandle = 0;
-  m_converter = NULL;
+  m_ring.reset(new CIMXCircular(5*1024*1024));
+
 #ifdef DUMP_STREAM
   m_dump = NULL;
 #endif
-  m_drainMode = VPU_DEC_IN_NORMAL;
-  m_skipMode = VPU_DEC_SKIPNONE;
-
   m_decOutput.setquotasize(1);
-  m_decInput.setquotasize(30);
-  m_loaded.Reset();
+  m_decInput.setquotasize(25);
+  Reinit();
 }
 
 CIMXCodec::~CIMXCodec()
@@ -450,6 +398,7 @@ CIMXCodec::~CIMXCodec()
 
 void CIMXCodec::DisposeDecQueues()
 {
+  m_ring->reset();
   m_decInput.signal();
   m_decInput.for_each(Release);
   m_decOutput.signal();
@@ -462,7 +411,21 @@ void CIMXCodec::Reset()
   m_queuesLock.lock();
   DisposeDecQueues();
   ProcessSignals(SIGNAL_FLUSH);
-  CLog::Log(LOGDEBUG, "iMX VPU : queues cleared ===== in/out %d/%d =====\n", m_decInput.size(), m_decOutput.size());
+  m_dtsDiff = 0.0;
+  CLog::Log(LOGVIDEO, "iMX VPU : queues cleared ===== in/out %d/%d =====\n", m_decInput.size(), m_decOutput.size());
+}
+
+void CIMXCodec::Reinit()
+{
+  m_drainMode = VPU_DEC_IN_NORMAL;
+  m_skipMode = VPU_DEC_SKIPNONE;
+
+  m_fps = -1;
+  m_ring->reset();
+  m_decInput.setquotasize(60);
+  m_loaded.Reset();
+  m_dtsDiff = 0.0;
+  CLog::Log(LOGVIDEO, "iMX VPU : Reinit()");
 }
 
 bool CIMXCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, std::string &m_pFormatName, CProcessInfo *m_pProcessInfo)
@@ -503,46 +466,43 @@ bool CIMXCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, std::stri
   {
     StopThread(false);
     ProcessSignals(SIGNAL_FLUSH);
+    m_decInput.for_each(Release);
+    Reinit();
   }
 
   m_hints = hints;
-  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "Let's decode with iMX VPU\n");
+  CLog::Log(LOGVIDEO, "Let's decode with iMX VPU\n");
 
   int param = 0;
   SetVPUParams(VPU_DEC_CONF_INPUTTYPE, &param);
   SetVPUParams(VPU_DEC_CONF_SKIPMODE, &param);
 
 #ifdef MEDIAINFO
-  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
   {
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: fpsrate %d / fpsscale %d\n", m_hints.fpsrate, m_hints.fpsscale);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: CodecID %d \n", m_hints.codec);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: StreamType %d \n", m_hints.type);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Level %d \n", m_hints.level);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Profile %d \n", m_hints.profile);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: PTS_invalid %d \n", m_hints.ptsinvalid);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag %d \n", m_hints.codec_tag);
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %dx%d \n", m_hints.width,  m_hints.height);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: fpsrate %d / fpsscale %d\n", m_hints.fpsrate, m_hints.fpsscale);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: CodecID %d \n", m_hints.codec);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: StreamType %d \n", m_hints.type);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: Level %d \n", m_hints.level);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: Profile %d \n", m_hints.profile);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: PTS_invalid %d \n", m_hints.ptsinvalid);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: Tag %d \n", m_hints.codec_tag);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: %dx%d \n", m_hints.width,  m_hints.height);
   }
   { char str_tag[128]; av_get_codec_tag_string(str_tag, sizeof(str_tag), m_hints.codec_tag);
-      CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag fourcc %s\n", str_tag);
+      CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: Tag fourcc %s\n", str_tag);
   }
   if (m_hints.extrasize)
   {
-    char buf[4096];
+    char *buf = new char[m_hints.extrasize * 2 + 1];
 
     for (unsigned int i=0; i < m_hints.extrasize; i++)
       sprintf(buf+i*2, "%02x", ((uint8_t*)m_hints.extradata)[i]);
 
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %s extradata %d %s\n", *(char*)m_hints.extradata == 1 ? "AnnexB" : "avcC", m_hints.extrasize, buf);
-  }
-  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-  {
-    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %d / %d \n", m_hints.width,  m_hints.height);
-    CLog::Log(LOGDEBUG, "Decode: aspect %f - forced aspect %d\n", m_hints.aspect, m_hints.forced_aspect);
+    CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: extradata %d %s\n", m_hints.extrasize, buf);
+    delete [] buf;
   }
+  CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: %d / %d \n", m_hints.width,  m_hints.height);
+  CLog::Log(LOGVIDEO, "Decode: aspect %f - forced aspect %d\n", m_hints.aspect, m_hints.forced_aspect);
 #endif
 
   m_warnOnce = true;
@@ -600,7 +560,7 @@ bool CIMXCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, std::stri
   case AV_CODEC_ID_MPEG4:
     switch(m_hints.codec_tag)
     {
-    case _4CC('D','I','V','X'):
+    case fourcc('D','I','V','X'):
       // Test for VPU unsupported profiles to revert to sw decoding
       if (m_hints.profile == -99 && m_hints.level == -99)
       {
@@ -610,15 +570,16 @@ bool CIMXCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, std::stri
       m_decOpenParam.CodecFormat = VPU_V_XVID; // VPU_V_DIVX4
       m_pFormatName = "iMX-divx4";
       break;
-    case _4CC('D','X','5','0'):
-    case _4CC('D','I','V','5'):
+    case fourcc('D','X','5','0'):
+    case fourcc('D','I','V','5'):
       m_decOpenParam.CodecFormat = VPU_V_XVID; // VPU_V_DIVX56
       m_pFormatName = "iMX-divx5";
       break;
-    case _4CC('X','V','I','D'):
-    case _4CC('M','P','4','V'):
-    case _4CC('P','M','P','4'):
-    case _4CC('F','M','P','4'):
+    case fourcc('X','V','I','D'):
+    case fourcc('x','v','i','d'):
+    case fourcc('M','P','4','V'):
+    case fourcc('P','M','P','4'):
+    case fourcc('F','M','P','4'):
       m_decOpenParam.CodecFormat = VPU_V_XVID;
       m_pFormatName = "iMX-xvid";
       break;
@@ -635,7 +596,7 @@ bool CIMXCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, std::stri
   std::list<EINTERLACEMETHOD> deintMethods({ EINTERLACEMETHOD::VS_INTERLACEMETHOD_AUTO,
                                              EINTERLACEMETHOD::VS_INTERLACEMETHOD_RENDER_BOB });
 
-  for(int i = EINTERLACEMETHOD::VS_INTERLACEMETHOD_IMX_FASTMOTION; i <= VS_INTERLACEMETHOD_IMX_ADVMOTION_HALF; ++i)
+  for(int i = EINTERLACEMETHOD::VS_INTERLACEMETHOD_IMX_FASTMOTION; i <= EINTERLACEMETHOD::VS_INTERLACEMETHOD_IMX_WEAVE; ++i)
     deintMethods.push_back(static_cast<EINTERLACEMETHOD>(i));
 
   m_processInfo = m_pProcessInfo;
@@ -670,7 +631,7 @@ void CIMXCodec::Dispose()
     if (ret != VPU_DEC_RET_SUCCESS)
       CLog::Log(LOGERROR, "%s - VPU close failed with error code %d.\n", __FUNCTION__, ret);
     else
-      CLog::Log(LOGDEBUG, "%s - VPU closed.", __FUNCTION__);
+      CLog::Log(LOGVIDEO, "%s - VPU closed.", __FUNCTION__);
 
     m_vpuHandle = 0;
   }
@@ -683,12 +644,6 @@ void CIMXCodec::Dispose()
     if (ret != VPU_DEC_RET_SUCCESS)
       CLog::Log(LOGERROR, "%s - VPU unload failed with error code %d.\n", __FUNCTION__, ret);
   }
-
-  if (m_converter)
-  {
-    m_converter->Close();
-    SAFE_DELETE(m_converter);
-  }
 }
 
 void CIMXCodec::SetVPUParams(VpuDecConfig InDecConf, void* pInParam)
@@ -736,9 +691,9 @@ void CIMXCodec::SetCodecControl(int flags)
 
   m_codecControlFlags = flags;
   if (m_codecControlFlags & DVD_CODEC_CTRL_HURRY && !m_burst)
-    m_burst = std::max(0, RENDER_QUEUE_SIZE - 2);
+    m_burst = RENDER_QUEUE_SIZE;
 
-  SetDrainMode(m_codecControlFlags & DVD_CODEC_CTRL_DRAIN && !m_decInput.size() ? VPU_DEC_IN_DRAIN : VPU_DEC_IN_NORMAL);
+  SetDrainMode(m_codecControlFlags & DVD_CODEC_CTRL_DRAIN && !m_ring->used() ? VPU_DEC_IN_DRAIN : VPU_DEC_IN_NORMAL);
 }
 
 bool CIMXCodec::getOutputFrame(VpuDecOutFrameInfo *frm)
@@ -752,6 +707,7 @@ bool CIMXCodec::getOutputFrame(VpuDecOutFrameInfo *frm)
 int CIMXCodec::Decode(BYTE *pData, int iSize, double dts, double pts)
 {
   static class CIMXFps ptrn;
+  static unsigned char mmm;
 
   if (EOS() && m_drainMode && !m_decOutput.size())
     return VC_BUFFER;
@@ -759,14 +715,15 @@ int CIMXCodec::Decode(BYTE *pData, int iSize, double dts, double pts)
   int ret = 0;
   if (!g_IMXCodec->IsRunning())
   {
-    if (!m_decInput.full())
+    if (!m_decInput.full() && (float)m_ring->used()/m_ring->size() < 0.9)
     {
       if (pts != DVD_NOPTS_VALUE)
         ptrn.Add(pts);
       else if (dts != DVD_NOPTS_VALUE)
         ptrn.Add(dts);
 
-      ret |= VC_BUFFER;
+      if (m_decInput.size() < m_decInput.getquotasize() - 1)
+        ret |= VC_BUFFER;
     }
     else
     {
@@ -775,10 +732,10 @@ int CIMXCodec::Decode(BYTE *pData, int iSize, double dts, double pts)
         m_fps = (double)m_hints.fpsrate / m_hints.fpsscale;
       else if (fd != 0)
         m_fps = (double)DVD_TIME_BASE / fd;
-      else
-        m_fps = 60;
 
-      m_decOpenParam.nMapType = 1;
+      m_decInput.setquotasize(std::max((unsigned int)m_fps, (unsigned int)25));
+
+      m_decOpenParam.nMapType = TILED_FRAME_MB_RASTER_MAP;
 
       ptrn.Flush();
       g_IMXCodec->Create();
@@ -787,37 +744,40 @@ int CIMXCodec::Decode(BYTE *pData, int iSize, double dts, double pts)
   }
 
   if (pData)
-    m_decInput.push(new VPUTask({ pData, iSize, 0, 0, 0, pts, dts, 0, 0 }, m_converter));
+  {
+    VPUTask *vpu = new VPUTask({ pData, iSize, 0, 0, 0, pts, dts, 0, 0 }, m_ring);
+    m_decInput.push(VPUTaskPtr(vpu));
+  }
 
-  if (!IsDraining() &&
-      (m_decInput.size() < m_decInput.getquotasize() -1))
+  if (!IsDraining() && (float)m_ring->used()/m_ring->size() < 0.7 && m_decInput.size() < m_decInput.getquotasize() - 1)
   {
     ret |= VC_BUFFER;
-    if (!m_burst && m_decInput.size() < m_decInput.getquotasize() /2)
-      return ret;
+    if (!m_burst && mmm++ % 3)
+      goto log;
   }
 
   if (m_rebuffer && m_decInput.size() > m_decInput.getquotasize() /2)
     m_rebuffer = false;
 
-  if ((m_decOutput.size() >= m_decOutput.getquotasize() /2 ||
-       m_drainMode || m_burst || !ret) && m_decOutput.size() && !m_rebuffer)
+  if ((m_decOutput.size() >= m_decOutput.getquotasize() /3 || m_drainMode || m_burst || !ret)
+    && m_decOutput.size() && !m_rebuffer)
     ret |= VC_PICTURE;
 
-  if (m_burst)
+  if (m_burst && ret & VC_PICTURE)
   {
-    if (m_decInput.size() >= RENDER_QUEUE_SIZE * 2)
+    if (m_decInput.size() > m_decInput.getquotasize() /2)
       ret &= ~VC_BUFFER;
     --m_burst;
   }
 
+log:
 #ifdef IMX_PROFILE
-  CLog::Log(LOGDEBUG, "%s - demux size: %d  dts : %f - pts : %f - addr : 0x%x, return %d ===== in/out %d/%d =====\n",
-                       __FUNCTION__, iSize, recalcPts(dts), recalcPts(pts), (uint)pData, ret, m_decInput.size(), m_decOutput.size());
+  CLog::Log(LOGVIDEO, "%s - demux size: %d  dts : %f - pts : %f - addr : 0x%x, return %d ===== in/out %d(%.0f)/%d ===== dr: %d, drm: %d\n",
+                       __FUNCTION__, iSize, recalcPts(dts), recalcPts(pts), (uint)pData, ret, m_decInput.size(), (float)m_ring->used()*100/m_ring->size(), m_decOutput.size(), IsDraining(), m_drainMode);
 #endif
 
-  if (!(ret & VC_PICTURE) || !ret || m_drainMode)
-    Sleep(10);
+  if (!ret || m_drainMode)
+    Sleep(5);
 
   return ret;
 }
@@ -829,7 +789,7 @@ void CIMXCodec::ReleaseFramebuffer(VpuFrameBuffer* fb)
 
 void CIMXCodec::RecycleFrameBuffers()
 {
-  while(!m_recycleBuffers.empty())
+  for(unsigned int i = 0; i < std::min(m_recycleBuffers.size(), (unsigned int)2); i++)
   {
     m_pts[m_recycleBuffers.front()] = DVD_NOPTS_VALUE;
     VPU_DecOutFrameDisplayed(m_vpuHandle, m_recycleBuffers.front());
@@ -854,14 +814,15 @@ void CIMXCodec::Process()
 {
   VpuDecFrameLengthInfo         frameLengthInfo;
   VpuBufferNode                 inData;
-  VpuBufferNode                 dummy;
+  VpuBufferNode                 dummy = {};
   VpuDecRetCode                 ret;
   int                           retStatus;
-  VPUTask                      *task = nullptr;
+  VpuDecOutFrameInfo            frameInfo;
 #ifdef IMX_PROFILE
-  static unsigned long long     previous, current;
   int                           freeInfo;
 #endif
+  double                        fps = 60.0;
+  VPUTaskPtr                    task;
 
   m_threadID = GetCurrentThreadId();
   SetPriority(GetPriority()+1);
@@ -870,48 +831,34 @@ void CIMXCodec::Process()
   m_pts.clear();
   m_loaded.Set();
 
+  m_burst = 0;
   m_dropped = 0;
   m_dropRequest = false;
   m_lastPTS = DVD_NOPTS_VALUE;
 
-  memset(&dummy, 0, sizeof(dummy));
-  AddExtraData(&dummy, (m_decOpenParam.CodecFormat == VPU_V_AVC && m_hints.extrasize));
+  AddExtraData(&dummy, m_decOpenParam.CodecFormat == VPU_V_AVC && m_hints.extradata);
   inData = dummy;
   if (dummy.sCodecData.pData)
     CLog::Log(LOGVIDEO, "Decode: MEDIAINFO: adding extra codec data\n");
 
-  VpuOpen();
+  if (!VpuOpen())
+    return;
 
   while (!m_bStop && m_vpuHandle)
   {
     RecycleFrameBuffers();
-    SAFE_DELETE(task);
-    if (!(task = m_decInput.pop()))
-      task = new VPUTask();
 
-#if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS)
-    unsigned long long before_dec;
-#ifdef IMX_PROFILE
-    current = XbmcThreads::SystemClockMillis();
-    CLog::Log(LOGDEBUG, "%s - delta time decode : %llu - demux size : %d  dts : %f - pts : %f - addr : 0x%x\n",
-                                      __FUNCTION__, current - previous, task->demux.iSize, recalcPts(task->demux.dts), recalcPts(task->demux.pts), (uint)task->demux.pData);
-    previous = current;
-#endif
-#endif
+    if (!(task = m_decInput.pop()))
+      task.reset(new VPUTask());
 
+    inData.pVirAddr = m_ring->pop(task->demux.iSize);
     inData.nSize = task->demux.iSize;
-    inData.pPhyAddr = NULL;
-    inData.pVirAddr = task->demux.pData;
 
     // some streams have problem with getting intial info after seek into (during playback start).
     // feeding VPU with extra data helps
     if (!m_vpuFrameBuffers.size() && !task->IsEmpty() && m_decRet & VPU_DEC_NO_ENOUGH_INBUF)
       AddExtraData(&inData, true);
 
-#ifdef IMX_PROFILE_BUFFERS
-    static unsigned long long dec_time = 0;
-#endif
-
     while (!m_bStop) // Decode as long as the VPU consumes data
     {
       RecycleFrameBuffers();
@@ -920,28 +867,25 @@ void CIMXCodec::Process()
       retStatus = m_decRet & VPU_DEC_SKIP ? VC_USERDATA : 0;
 
 #if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS)
-      before_dec = XbmcThreads::SystemClockMillis();
+      unsigned long long before_dec = XbmcThreads::SystemClockMillis();
 #endif
       ret = VPU_DecDecodeBuf(m_vpuHandle, &inData, &m_decRet);
-#ifdef IMX_PROFILE_BUFFERS
-      unsigned long long dec_single_call = XbmcThreads::SystemClockMillis()-before_dec;
-      dec_time += dec_single_call;
+
+#if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS)
+      unsigned long long dec_time = XbmcThreads::SystemClockMillis()-before_dec;
 #endif
 #ifdef IMX_PROFILE
       VPU_DecGetNumAvailableFrameBuffers(m_vpuHandle, &freeInfo);
-      CLog::Log(LOGDEBUG, "%s - VPU ret %d dec 0x%x decode takes : %lld free: %d\n\n", __FUNCTION__, ret, m_decRet,  XbmcThreads::SystemClockMillis() - before_dec, freeInfo);
+      CLog::Log(LOGVIDEO, "%s - VPU ret %d dec 0x%x decode takes : %lld (%db), free: %d\n\n", __FUNCTION__, ret, m_decRet,  dec_time, inData.nSize, freeInfo);
 #endif
 
       if (m_skipMode == IN_DECODER_SET)
         SetSkipMode(VPU_DEC_SKIPNONE);
 
-      if (m_drainMode == IN_DECODER_SET)
-      {
-        AddExtraData(&inData);
+      if (m_drainMode == VPU_DEC_IN_KICK)
         SetDrainMode(VPU_DEC_IN_NORMAL);
-      }
 
-      if (m_decRet & VPU_DEC_OUTPUT_EOS)
+      if (EOS())
         break;
 
       if (ret != VPU_DEC_RET_SUCCESS && ret != VPU_DEC_RET_FAILURE_TIMEOUT)
@@ -950,9 +894,9 @@ void CIMXCodec::Process()
       if (m_decRet & VPU_DEC_INIT_OK || m_decRet & VPU_DEC_RESOLUTION_CHANGED)
       // VPU decoding init OK : We can retrieve stream info
       {
-        if (m_decRet & VPU_DEC_RESOLUTION_CHANGED)
+        if (m_decRet & VPU_DEC_RESOLUTION_CHANGED && !(m_decSignal & SIGNAL_NOWAIT))
         {
-          while (m_nrOut > 2 && !m_bStop)
+          while (m_nrOut.load() && !m_bStop)
           {
             RecycleFrameBuffers();
             std::this_thread::yield();
@@ -962,19 +906,23 @@ void CIMXCodec::Process()
         if (VPU_DecGetInitialInfo(m_vpuHandle, &m_initInfo) != VPU_DEC_RET_SUCCESS)
           ExitError("VPU get initial info failed");
 
-        if (!VpuFreeBuffers(false) || !VpuAllocFrameBuffers())
+        if (!VpuFreeBuffers(false))
+          ExitError("VPU error while freeing frame buffers");
+        else if (!VpuAllocFrameBuffers())
           ExitError("VPU error while registering frame buffers");
 
-        if (m_initInfo.nInterlace && m_fps >= 49 && m_decOpenParam.nMapType == 1)
+        if (m_initInfo.nInterlace && m_fps >= 49 && m_decOpenParam.nMapType == TILED_FRAME_MB_RASTER_MAP)
         {
-          m_decOpenParam.nMapType = 0;
+          m_decOpenParam.nMapType = LINEAR_FRAME_MAP;
           Dispose();
           VpuOpen();
           continue;
         }
 
-        if (m_initInfo.nInterlace && m_fps <= 30)
-          m_fps *= 2;
+
+        fps = m_fps;
+        if (m_initInfo.nInterlace && fps <= 30)
+          fps *= 2;
 
         m_processInfo->SetVideoFps(m_fps);
 
@@ -984,52 +932,42 @@ void CIMXCodec::Process()
           m_initInfo.nAddressAlignment, m_initInfo.PicCropRect.nLeft, m_initInfo.PicCropRect.nTop,
           m_initInfo.PicCropRect.nRight, m_initInfo.PicCropRect.nBottom, m_initInfo.nQ16ShiftWidthDivHeightRatio, m_fps);
 
-        m_decInput.setquotasize(m_fps / 2);
-
-        bool getFrame = !(m_decOpenParam.CodecFormat == VPU_V_AVC && *(char*)m_hints.extradata == 1);
-        getFrame &= m_decOpenParam.CodecFormat != VPU_V_MPEG2 && m_decOpenParam.CodecFormat != VPU_V_XVID;
-        if (getFrame || m_decRet & VPU_DEC_RESOLUTION_CHANGED)
+        if (m_decOpenParam.CodecFormat == VPU_V_AVC || dummy.sCodecData.pData)
         {
-          SetDrainMode((VpuDecInputType)IN_DECODER_SET);
+          SetDrainMode((VpuDecInputType)VPU_DEC_IN_KICK);
           inData = dummy;
           continue;
         }
       }
 
+      if (m_hints.ptsinvalid && m_decRet & VPU_DEC_ONE_FRM_CONSUMED && m_decRet & CLASS_NOBUF)
+        m_dtsDiff += DVD_TIME_BASE / m_fps;
+
       if (m_decRet & VPU_DEC_ONE_FRM_CONSUMED)
         if (!VPU_DecGetConsumedFrameInfo(m_vpuHandle, &frameLengthInfo) && frameLengthInfo.pFrame)
           m_pts[frameLengthInfo.pFrame] = task->demux.pts;
 
-      if (m_decRet & CLASS_PICTURE && getOutputFrame(&m_frameInfo))
+      if (m_decRet & CLASS_PICTURE && getOutputFrame(&frameInfo))
       {
         ++m_nrOut;
-        CDVDVideoCodecIMXBuffer *buffer = new CDVDVideoCodecIMXBuffer(&m_frameInfo, m_fps, m_decOpenParam.nMapType);
+        CDVDVideoCodecIMXBuffer *buffer = new CDVDVideoCodecIMXBuffer(&frameInfo, fps, m_decOpenParam.nMapType);
 
         /* quick & dirty fix to get proper timestamping for VP8 codec */
         if (m_decOpenParam.CodecFormat == VPU_V_VP8)
           buffer->SetPts(task->demux.pts);
         else
-          buffer->SetPts(m_pts[m_frameInfo.pDisplayFrameBuf]);
-
-        buffer->SetDts(task->demux.dts);
+          buffer->SetPts(m_pts[frameInfo.pDisplayFrameBuf]);
 
+        buffer->SetDts(task->demux.dts - m_dtsDiff);
 #ifdef IMX_PROFILE_BUFFERS
-        CLog::Log(LOGNOTICE, "+D  %f  %lld\n", recalcPts(buffer->GetPts()), dec_time);
-        dec_time = 0;
+        CLog::Log(LOGVIDEO, "+D  %f/%f  %lld\n", recalcPts(buffer->GetDts()), recalcPts(buffer->GetPts()), dec_time);
 #endif
 #ifdef TRACE_FRAMES
-        CLog::Log(LOGDEBUG, "+  0x%x dts %f pts %f  (VPU)\n", buffer->GetIdx(), recalcPts(task->demux.dts), recalcPts(buffer->GetPts()));
+        CLog::Log(LOGVIDEO, "+  0x%x dts %f pts %f  (VPU)\n", buffer->GetIdx(), recalcPts(buffer->GetDts()), recalcPts(buffer->GetPts()));
 #endif
 
-#ifdef IMX_PROFILE_BUFFERS
-        static unsigned long long lastD = 0;
-        unsigned long long current = XbmcThreads::SystemClockMillis();
-        CLog::Log(LOGNOTICE, "+V  %f  %lld\n", recalcPts(buffer->GetPts()), current-lastD);
-        lastD = current;
-#endif
-
-        if (m_decRet & VPU_DEC_OUTPUT_DIS)
-          buffer->SetFlags(DVP_FLAG_ALLOCATED);
+        if (m_decRet & VPU_DEC_OUTPUT_MOSAIC_DIS)
+          buffer->SetFlags(DVP_FLAG_DROPPED);
 
         if (!m_decOutput.push(buffer))
           SAFE_RELEASE(buffer);
@@ -1043,15 +981,13 @@ void CIMXCodec::Process()
       if (m_decRet & VPU_DEC_SKIP)
         ++m_dropped;
 
-      if (m_decRet & VPU_DEC_NO_ENOUGH_BUF && m_decOutput.size())
+      if (m_decRet & VPU_DEC_NO_ENOUGH_BUF)
       {
-        m_decOutput.pop()->Release();
-        FlushVPU();
+        CLog::Log(LOGVIDEO, "iMX : VPU_DEC_NO_ENOUGH_BUF !");
+        inData = dummy;
         continue;
       }
 
-      ProcessSignals();
-
       if (retStatus & VC_USERDATA)
         continue;
 
@@ -1064,25 +1000,25 @@ void CIMXCodec::Process()
 
       inData = dummy;
     } // Decode loop
-
-    task->Release();
   } // Process() main loop
 
-  ProcessSignals(SIGNAL_RESET | SIGNAL_DISPOSE);
+  ProcessSignals(SIGNAL_FLUSH | SIGNAL_RESET | SIGNAL_DISPOSE);
 }
 
 void CIMXCodec::ProcessSignals(int signal)
 {
+  if (!(m_decSignal | signal))
+    return;
+
   if (signal & SIGNAL_SIGNAL)
   {
     m_decInput.signal();
     m_decOutput.signal();
+    m_ring->signal();
   }
-  if (!(m_decSignal | signal))
-    return;
 
   CSingleLock lk(m_signalLock);
-  m_decSignal |= signal & ~SIGNAL_SIGNAL;
+  m_decSignal |= signal & ~(SIGNAL_SIGNAL | SIGNAL_NOWAIT);
 
   if (!IsCurrentThread())
     return;
@@ -1094,6 +1030,7 @@ void CIMXCodec::ProcessSignals(int signal)
   {
     FlushVPU();
     m_queuesLock.unlock();
+    m_decSignal = SIGNAL_NOWAIT;
   }
   if (process & SIGNAL_RESET)
     DisposeDecQueues();
@@ -1103,9 +1040,14 @@ void CIMXCodec::ProcessSignals(int signal)
 
 void CIMXCodec::FlushVPU()
 {
+  CLog::Log(LOGVIDEO, "%s: VPU flush.\n", __FUNCTION__);
   int ret = VPU_DecFlushAll(m_vpuHandle);
+
+  if (ret == VPU_DEC_RET_FAILURE_TIMEOUT)
+    VPU_DecReset(m_vpuHandle);
+
   if (ret != VPU_DEC_RET_SUCCESS && ret != VPU_DEC_RET_INVALID_HANDLE)
-    CLog::Log(LOGERROR, "%s: VPU flush failed with error code %d.\n", __FUNCTION__, ret);
+    CLog::Log(LOGDEBUG, "%s: VPU flush failed with error code %d.\n", __FUNCTION__, ret);
 }
 
 inline
@@ -1121,60 +1063,58 @@ void CIMXCodec::ExitError(const char *msg, ...)
 
 bool CIMXCodec::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  pDvdVideoPicture->IMXBuffer = m_decOutput.pop();
-  assert(pDvdVideoPicture->IMXBuffer);
+  auto buffer = m_decOutput.pop();
+  assert(buffer);
 
 #ifdef IMX_PROFILE
   static unsigned int previous = 0;
   unsigned int current;
 
   current = XbmcThreads::SystemClockMillis();
-  CLog::Log(LOGDEBUG, "+G 0x%x %f/%f tm:%03d : Interlaced 0x%x\n", pDvdVideoPicture->IMXBuffer->GetIdx(),
-                            recalcPts(pDvdVideoPicture->IMXBuffer->GetDts()), recalcPts(pDvdVideoPicture->IMXBuffer->GetPts()), current - previous,
-                            m_initInfo.nInterlace ? pDvdVideoPicture->IMXBuffer->GetFieldType() : 0);
+  CLog::Log(LOGDEBUG | LOGVIDEO, "+G 0x%x %f/%f tm:%03d : Interlaced 0x%x\n", buffer->GetIdx(),
+                            recalcPts(buffer->GetDts()), recalcPts(buffer->GetPts()), current - previous,
+                            m_initInfo.nInterlace ? buffer->GetFieldType() : 0);
   previous = current;
 #endif
 
-  if (m_dropRequest && !m_burst)
-  {
-    pDvdVideoPicture->iFlags = DVP_FLAG_DROPPED;
-    ++m_dropped;
-  }
+  if (!m_dropRequest)
+    pDvdVideoPicture->iFlags = buffer->GetFlags();
   else
-    pDvdVideoPicture->iFlags = pDvdVideoPicture->IMXBuffer->GetFlags();
+    pDvdVideoPicture->iFlags = DVP_FLAG_DROPPED;
 
   if (m_initInfo.nInterlace)
   {
-    if (pDvdVideoPicture->IMXBuffer->GetFieldType() == VPU_FIELD_NONE && m_warnOnce)
+    if (buffer->GetFieldType() == VPU_FIELD_NONE && m_warnOnce)
     {
       m_warnOnce = false;
       CLog::Log(LOGWARNING, "Interlaced content reported by VPU, but full frames detected - Please turn off deinterlacing manually.");
     }
-    else if (pDvdVideoPicture->IMXBuffer->GetFieldType() == VPU_FIELD_TB || pDvdVideoPicture->IMXBuffer->GetFieldType() == VPU_FIELD_TOP)
+    else if (buffer->GetFieldType() == VPU_FIELD_TB || buffer->GetFieldType() == VPU_FIELD_TOP)
       pDvdVideoPicture->iFlags |= DVP_FLAG_TOP_FIELD_FIRST;
 
     pDvdVideoPicture->iFlags |= DVP_FLAG_INTERLACED;
   }
 
   pDvdVideoPicture->format = RENDER_FMT_IMXMAP;
-  pDvdVideoPicture->iWidth = pDvdVideoPicture->IMXBuffer->m_pctWidth;
-  pDvdVideoPicture->iHeight = pDvdVideoPicture->IMXBuffer->m_pctHeight;
+  pDvdVideoPicture->iWidth = buffer->m_pctWidth;
+  pDvdVideoPicture->iHeight = buffer->m_pctHeight;
 
-  pDvdVideoPicture->iDisplayWidth = ((pDvdVideoPicture->iWidth * m_frameInfo.pExtInfo->nQ16ShiftWidthDivHeightRatio) + 32767) >> 16;
+  pDvdVideoPicture->iDisplayWidth = ((pDvdVideoPicture->iWidth * buffer->nQ16ShiftWidthDivHeightRatio) + 32767) >> 16;
   pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
 
-  pDvdVideoPicture->pts = pDvdVideoPicture->IMXBuffer->GetPts();
-  pDvdVideoPicture->dts = pDvdVideoPicture->IMXBuffer->GetDts();
+  pDvdVideoPicture->pts = buffer->GetPts();
+  pDvdVideoPicture->dts = buffer->GetDts();
 
   if (pDvdVideoPicture->iFlags & DVP_FLAG_DROPPED)
-    SAFE_RELEASE(pDvdVideoPicture->IMXBuffer);
+    SAFE_RELEASE(buffer);
 
+  pDvdVideoPicture->IMXBuffer = buffer;
   return true;
 }
 
 void CIMXCodec::SetDropState(bool bDrop)
 {
-  m_dropRequest = bDrop;
+  m_dropRequest = false;
 }
 
 bool CIMXCodec::IsCurrentThread() const
@@ -1182,13 +1122,21 @@ bool CIMXCodec::IsCurrentThread() const
   return CThread::IsCurrentThread(m_threadID);
 }
 
+std::string CIMXCodec::GetPlayerInfo()
+{
+  std::ostringstream s;
+  if (g_IMXCodec && m_ring->size())
+    s << "buf In/Out: " << m_ring->used() * 100 / m_ring->size() << "%/" << m_decOutput.size();
+  return s.str();
+}
+
 /*******************************************/
 CDVDVideoCodecIMXBuffer::CDVDVideoCodecIMXBuffer(VpuDecOutFrameInfo *frameInfo, double fps, int map)
   : m_dts(DVD_NOPTS_VALUE)
   , m_fieldType(frameInfo->eFieldType)
   , m_frameBuffer(frameInfo->pDisplayFrameBuf)
-  , m_iFlags(DVP_FLAG_DROPPED)
-  , m_convBuffer(nullptr)
+  , m_iFlags(DVP_FLAG_ALLOCATED)
+  , m_convBuffer(0)
 {
   m_pctWidth  = frameInfo->pExtInfo->FrmCropRect.nRight - frameInfo->pExtInfo->FrmCropRect.nLeft;
   m_pctHeight = frameInfo->pExtInfo->FrmCropRect.nBottom - frameInfo->pExtInfo->FrmCropRect.nTop;
@@ -1200,12 +1148,13 @@ CDVDVideoCodecIMXBuffer::CDVDVideoCodecIMXBuffer(VpuDecOutFrameInfo *frameInfo,
   pVirtAddr   = m_frameBuffer->pbufVirtY;
   pPhysAddr   = (int)m_frameBuffer->pbufY;
 
+  nQ16ShiftWidthDivHeightRatio = frameInfo->pExtInfo->nQ16ShiftWidthDivHeightRatio;
+
 #ifdef IMX_INPUT_FORMAT_I420
-  iFormat     = _4CC('I', '4', '2', '0');
+  iFormat     = fourcc('I', '4', '2', '0');
 #else
-  iFormat     = map == 1 ? _4CC('T', 'N', 'V', 'P'):
-                map == 0 ? _4CC('N', 'V', '1', '2'):
-                           _4CC('T', 'N', 'V', 'F');
+  iFormat     = map == TILED_FRAME_MB_RASTER_MAP ? fourcc('T', 'N', 'V', 'P') :
+                map == TILED_FIELD_MB_RASTER_MAP ? fourcc('T', 'N', 'V', 'F') : fourcc('N', 'V', '1', '2');
 #endif
   m_fps       = fps;
 #if defined(IMX_PROFILE) || defined(IMX_PROFILE_BUFFERS) || defined(TRACE_FRAMES)
@@ -1214,27 +1163,29 @@ CDVDVideoCodecIMXBuffer::CDVDVideoCodecIMXBuffer(VpuDecOutFrameInfo *frameInfo,
   Lock();
 }
 
+void CDVDVideoCodecIMXBuffer::Recycle()
+{
+  if (!m_frameBuffer)
+    return;
+
+  CIMXCodec::ReleaseFramebuffer(m_frameBuffer);
+  m_frameBuffer = nullptr;
+}
+
 void CDVDVideoCodecIMXBuffer::Lock()
 {
-  long count = ++m_iRefs;
-#ifdef TRACE_FRAMES
-  CLog::Log(LOGDEBUG, "R+ 0x%x  -  ref : %ld  (VPU)\n", m_idx, count);
-#endif
+  ++m_iRefs;
 }
 
 long CDVDVideoCodecIMXBuffer::Release()
 {
   long count = --m_iRefs;
-#ifdef TRACE_FRAMES
-  CLog::Log(LOGDEBUG, "R- 0x%x  -  ref : %ld  (VPU)\n", m_idx, count);
-#endif
 
   if (count)
     return count;
 
-  CIMXCodec::ReleaseFramebuffer(m_frameBuffer);
-  if (m_convBuffer)
-    g2d_free(m_convBuffer);
+  Recycle();
+  g_IMXContext.ReturnDma(m_convBuffer);
 
   delete this;
   return 0;
@@ -1243,7 +1194,7 @@ long CDVDVideoCodecIMXBuffer::Release()
 CDVDVideoCodecIMXBuffer::~CDVDVideoCodecIMXBuffer()
 {
 #ifdef TRACE_FRAMES
-  CLog::Log(LOGDEBUG, "~  0x%x  (VPU)\n", m_idx);
+  CLog::Log(LOGVIDEO, "~  0x%x  (VPU)\n", m_idx);
 #endif
 }
 
@@ -1254,91 +1205,104 @@ CIMXContext::CIMXContext()
   , m_fbPhysAddr(0)
   , m_fbVirtAddr(NULL)
   , m_ipuHandle(0)
-  , m_vsync(true)
-  , m_pageCrops(NULL)
+  , m_pageCrops(nullptr)
   , m_bFbIsConfigured(false)
-  , m_g2dHandle(NULL)
-  , m_bufferCapture(NULL)
   , m_deviceName("/dev/fb1")
 {
-  m_pageCrops = new CRectInt[m_fbPages];
+  m_showBuffer.setquotasize(1);
+  m_dmaBuffer.setquotasize(0);
   OpenDevices();
 }
 
 CIMXContext::~CIMXContext()
 {
-  Stop(false);
+  Stop();
   Dispose();
+
   CloseDevices();
 }
 
 bool CIMXContext::AdaptScreen(bool allocate)
 {
-  MemMap();
+  {
+    CExclusiveLock lk(m_fbMapLock);
+    MemMap();
+  }
 
   struct fb_var_screeninfo fbVar;
   if (!GetFBInfo("/dev/fb0", &fbVar))
-    goto Err;
+    return false;
 
   m_fbWidth = allocate ? 1920 : fbVar.xres;
   m_fbHeight = allocate ? 1080 : fbVar.yres;
 
+  m_fbInterlaced = g_graphicsContext.GetResInfo().dwFlags & D3DPRESENTFLAG_INTERLACED;
+
   if (!GetFBInfo(m_deviceName, &m_fbVar))
-    goto Err;
+    return false;
 
   m_fbVar.xoffset = 0;
   m_fbVar.yoffset = 0;
 
-  if (!allocate && (fbVar.bits_per_pixel == 16 || m_fps >= 49 && m_fbHeight >= 1080))
+  if (!allocate && (fbVar.bits_per_pixel == 16 || (m_fps >= 49 && m_fbHeight == 1080)))
   {
-    m_fbVar.nonstd = _4CC('Y', 'U', 'Y', 'V');
+    m_fbVar.nonstd = fourcc('Y', 'U', 'Y', 'V');
     m_fbVar.bits_per_pixel = 16;
   }
   else
   {
-    m_fbVar.nonstd = _4CC('R', 'G', 'B', '4');
+    m_fbVar.nonstd = fourcc('R', 'G', 'B', '4');
     m_fbVar.bits_per_pixel = 32;
   }
 
-  m_fbVar.activate = FB_ACTIVATE_NOW;
   m_fbVar.xres = m_fbWidth;
   m_fbVar.yres = m_fbHeight;
 
+  if (m_fbInterlaced)
+    m_fbVar.vmode |= FB_VMODE_INTERLACED;
+  else
+    m_fbVar.vmode &= ~FB_VMODE_INTERLACED;
+
   m_fbVar.yres_virtual = (m_fbVar.yres + 1) * m_fbPages;
   m_fbVar.xres_virtual = m_fbVar.xres;
 
-  CloseIPU();
-  Blank();
-
   struct fb_fix_screeninfo fb_fix;
 
-  if (ioctl(m_fbHandle, FBIOPUT_VSCREENINFO, &m_fbVar) == -1)
+  bool err = false;
   {
-    CLog::Log(LOGWARNING, "iMX : Failed to setup %s (%s)\n", m_deviceName.c_str(), strerror(errno));
-    goto Err;
+    CExclusiveLock lk(m_fbMapLock);
+
+    Blank();
+
+    m_fbVar.activate = FB_ACTIVATE_NOW;
+    if (ioctl(m_fbHandle, FBIOPUT_VSCREENINFO, &m_fbVar) == -1)
+    {
+      CLog::Log(LOGWARNING, "iMX : Failed to setup %s (%s)\n", m_deviceName.c_str(), strerror(errno));
+      err = true;
+    }
+    else if (ioctl(m_fbHandle, FBIOGET_FSCREENINFO, &fb_fix) == -1)
+    {
+      CLog::Log(LOGWARNING, "iMX : Failed to query fixed screen info at %s (%s)\n", m_deviceName.c_str(), strerror(errno));
+      err = true;
+    }
+
+    MemMap(&fb_fix);
+    Unblank();
+    m_bFbIsConfigured = true;
   }
-  else if (ioctl(m_fbHandle, FBIOGET_FSCREENINFO, &fb_fix) == -1)
+
+  if (err)
   {
-    CLog::Log(LOGWARNING, "iMX : Failed to query fixed screen info at %s (%s)\n", m_deviceName.c_str(), strerror(errno));
-    goto Err;
+    TaskRestart();
+    return false;
   }
 
-  MemMap(&fb_fix);
-  Unblank();
-
-  OpenIPU();
-  m_bFbIsConfigured = true;
-
   return true;
-
-Err:
-  TaskRestart();
-  return false;
 }
 
 bool CIMXContext::GetFBInfo(const std::string &fbdev, struct fb_var_screeninfo *fbVar)
 {
-  int fb = open(fbdev.c_str(), O_RDONLY, 0);
+  int fb = open(fbdev.c_str(), O_RDWR | O_NONBLOCK);
   if (fb < 0)
   {
     CLog::Log(LOGWARNING, "iMX : Failed to open /dev/fb0\n");
@@ -1357,8 +1321,9 @@ void CIMXContext::MemMap(struct fb_fix_screeninfo *fb_fix)
 {
   if (m_fbVirtAddr && m_fbPhysSize)
   {
+    Clear();
     munmap(m_fbVirtAddr, m_fbPhysSize);
-    m_fbVirtAddr = NULL;
+    m_fbVirtAddr = nullptr;
     m_fbPhysAddr = 0;
   }
   else if (fb_fix)
@@ -1375,8 +1340,7 @@ void CIMXContext::MemMap(struct fb_fix_screeninfo *fb_fix)
 void CIMXContext::OnLostDisplay()
 {
   CSingleLock lk(m_pageSwapLock);
-  if (IsRunning())
-    m_bFbIsConfigured = false;
+  m_bFbIsConfigured = false;
 }
 
 void CIMXContext::OnResetDisplay()
@@ -1407,18 +1371,15 @@ void CIMXContext::Dispose()
     return;
 
   delete[] m_pageCrops;
-  m_pageCrops = NULL;
-}
-
-void CIMXContext::OpenIPU()
-{
-  m_ipuHandle = open("/dev/mxc_ipu", O_RDWR, 0);
+  m_pageCrops = nullptr;
 }
 
 bool CIMXContext::OpenDevices()
 {
-  m_fbHandle = open(m_deviceName.c_str(), O_RDWR, 0);
-  OpenIPU();
+  if ((m_fbHandle = open(m_deviceName.c_str(), O_RDWR | O_NONBLOCK)) < 0)
+    m_fbHandle = 0;
+  if ((m_ipuHandle = open("/dev/mxc_ipu", O_RDWR | O_SYNC | O_NONBLOCK, 0)) < 0)
+    m_ipuHandle = 0;
 
   bool opened = m_fbHandle > 0 && m_ipuHandle > 0;
   if (!opened)
@@ -1427,15 +1388,6 @@ bool CIMXContext::OpenDevices()
   return opened;
 }
 
-void CIMXContext::CloseIPU()
-{
-  if (m_ipuHandle)
-  {
-    close(m_ipuHandle);
-    m_ipuHandle = 0;
-  }
-}
-
 void CIMXContext::CloseDevices()
 {
   CLog::Log(LOGINFO, "iMX : Closing devices\n");
@@ -1446,30 +1398,25 @@ void CIMXContext::CloseDevices()
     m_fbHandle = 0;
   }
 
-  CloseIPU();
+  m_showBuffer.for_each(Release);
+
+  if (m_ipuHandle)
+  {
+    close(m_ipuHandle);
+    m_ipuHandle = 0;
+  }
 }
 
 bool CIMXContext::Blank()
 {
   if (!m_fbHandle) return false;
-
-  m_bFbIsConfigured = false;
-  return ioctl(m_fbHandle, FBIOBLANK, 1) == 0;
+  return ioctl(m_fbHandle, FBIOBLANK, FB_BLANK_NORMAL) == 0;
 }
 
 bool CIMXContext::Unblank()
 {
   if (!m_fbHandle) return false;
-
-  int ret = ioctl(m_fbHandle, FBIOBLANK, FB_BLANK_UNBLANK);
-  m_bFbIsConfigured = true;
-  return ret == 0;
-}
-
-bool CIMXContext::SetVSync(bool enable)
-{
-  m_vsync = enable;
-  return true;
+  return ioctl(m_fbHandle, FBIOBLANK, FB_BLANK_UNBLANK) == 0;
 }
 
 inline
@@ -1479,6 +1426,8 @@ void CIMXContext::SetFieldData(uint8_t fieldFmt, double fps)
     return;
 
   static EINTERLACEMETHOD imPrev;
+  fieldFmt &= -!m_fbInterlaced;
+
   bool dr = IsDoubleRate();
   bool deint = !!m_currentFieldFmt;
   m_currentFieldFmt = fieldFmt;
@@ -1492,6 +1441,11 @@ void CIMXContext::SetFieldData(uint8_t fieldFmt, double fps)
   if (m_bFbIsConfigured)
     return;
 
+  if (IsDoubleRate())
+    m_showBuffer.setquotasize(2);
+  else
+    m_showBuffer.setquotasize(1);
+
   m_fps = fps;
   imPrev = CMediaSettings::GetInstance().GetCurrentVideoSettings().m_InterlaceMethod;
   CLog::Log(LOGDEBUG, "iMX : Output parameters changed - deinterlace %s%s, fps: %.3f\n", !!fieldFmt ? "active" : "not active", IsDoubleRate() ? " DR" : "", m_fps);
@@ -1514,7 +1468,7 @@ bool checkIPUStrideOffset(struct ipu_deinterlace *d, bool DR)
   case HIGH_MOTION:
     return ((d->field_fmt & MASK1) == VAL1) || ((d->field_fmt & MASK2) == VAL2);
   case MED_MOTION:
-    return DR && !(((d->field_fmt & MASK1) == VAL1) || ((d->field_fmt & MASK2) == VAL2));
+    return DR && (((d->field_fmt & MASK1) == VAL1) || ((d->field_fmt & MASK2) != VAL2));
   default:
     return true;
   }
@@ -1533,6 +1487,16 @@ void CIMXContext::SetIPUMotion(EINTERLACEMETHOD imethod)
 
   switch (imethod)
   {
+  case VS_INTERLACEMETHOD_IMX_WEAVE_HALF:
+    strImethod = g_localizeStrings.Get(16336);
+    m_motion   = LOW_MOTION;
+    break;
+
+  case VS_INTERLACEMETHOD_IMX_WEAVE:
+    strImethod = g_localizeStrings.Get(16338);
+    m_motion   = LOW_MOTION;
+    break;
+
   case VS_INTERLACEMETHOD_IMX_ADVMOTION:
     strImethod = g_localizeStrings.Get(16337);
     m_motion   = MED_MOTION;
@@ -1559,34 +1523,49 @@ void CIMXContext::SetIPUMotion(EINTERLACEMETHOD imethod)
     m_processInfo->SetVideoDeintMethod(strImethod);
 }
 
-void CIMXContext::Blit(CIMXBuffer *source_p, CIMXBuffer *source, const CRect &srcRect,
+unsigned int CIMXContext::Blit(CIMXBuffer *source_p, CIMXBuffer *source, const CRect &srcRect,
                        const CRect &dstRect, uint8_t fieldFmt, int page)
 {
   static unsigned char pg;
 
   if (page == RENDER_TASK_AUTOPAGE)
     page = pg;
-  else if (page < 0 && page >= m_fbPages)
-    return;
 
-  IPUTaskPtr ipu(new IPUTask(source_p, source, page));
-  pg = ++pg % m_fbPages;
+  if (page < 0 && page >= m_fbPages)
+    return -1;
+
+  CIMXIPUTask *task = new CIMXIPUTask(source, source_p, page);
+  IPUTaskPtr ipu(task);
 
 #ifdef IMX_PROFILE_BUFFERS
   unsigned long long before = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGVIDEO, "+p 0x%x@%d  - (buf: %d/%d)", ipu->cb->GetIdx(), ipu->page, m_showBuffer.size(), m_dmaBuffer.size());
 #endif
   SetFieldData(fieldFmt, source->m_fps);
-  PrepareTask(ipu, srcRect, dstRect);
 
-  if (DoTask(ipu))
-    m_fbCurrentPage = ipu->page | checkIPUStrideOffset(&ipu->task.input.deinterlace, IsDoubleRate()) << 4;
+  if (!PrepareTask(ipu, srcRect, dstRect))
+    return -1;
+
+  if (!TileTask(ipu))
+  {
+    m_waitVSync.Set();
+    return -1;
+  }
+
+  DeintTask(ipu);
 
-  m_pingFlip.Set();
+  m_showBuffer.push(ipu);
+  pg = (1 + pg) % m_fbPages;
 
 #ifdef IMX_PROFILE_BUFFERS
   unsigned long long after = XbmcThreads::SystemClockMillis();
-  CLog::Log(LOGDEBUG, "+P 0x%x@%d  %d\n", ((CDVDVideoCodecIMXBuffer*)ipu->current)->GetIdx(), ipu->page, (int)(after-before));
+  CLog::Log(LOGVIDEO, "+P 0x%x@%d  %d (buf: %d/%d)", ipu->cb->GetIdx(), ipu->page, (int)(after-before), m_showBuffer.size(), m_dmaBuffer.size());
 #endif
+
+  if (g_IMXCodec)
+    return g_IMXCodec->GetLockedBuffers();
+
+  return -1;
 }
 
 void CIMXContext::WaitVSync()
@@ -1597,22 +1576,56 @@ void CIMXContext::WaitVSync()
 inline
 bool CIMXContext::ShowPage()
 {
-  m_pingFlip.Wait();
+  IPUTaskPtr ipu = m_showBuffer.pop();
+
+  if (!ipu)
+    return false;
 
+#if defined(TRACE_FRAMES) || defined(IMX_PROFILE_BUFFERS)
+  static unsigned long long pgprev;
+  unsigned long long pgstart = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGVIDEO, "np(@%d) - fbiopan: %d\n", m_fbCurrentPage, (int)(pgstart - pgprev));
+#endif
+
+  CSharedLock lock(m_fbMapLock);
   {
+
     CSingleLock lk(m_pageSwapLock);
-    if (!m_bFbIsConfigured)
-      return false;
-  }
+    {
+      if (!m_bFbIsConfigured)
+        return false;
+
+      if (DoTask(ipu))
+        m_fbVar.yoffset = (m_fbVar.yres + 1) * ipu->page + !checkIPUStrideOffset(&ipu->task.input.deinterlace, IsDoubleRate());
+      else
+        return false;
+    }
+
+    if (m_bStop)
+      return true;
+
+#if defined(TRACE_FRAMES) || defined(IMX_PROFILE_BUFFERS)
+    unsigned long long pgend = XbmcThreads::SystemClockMillis();
+    CLog::Log(LOGVIDEO, "NP(@%d) - pgswap: %d (%d)\n", ipu->page, (int)(pgend - pgstart), (int)(pgend - pgprev));
+    pgprev = pgend;
+#endif
 
-  m_fbVar.yoffset = (m_fbVar.yres + 1) * (m_fbCurrentPage & 0xf) + !(m_fbCurrentPage >> 4);
-  if (ioctl(m_fbHandle, FBIOPAN_DISPLAY, &m_fbVar) < 0)
-    CLog::Log(LOGWARNING, "Panning failed: %s\n", strerror(errno));
+    m_fbVar.activate = FB_ACTIVATE_VBL;
+    if (ioctl(m_fbHandle, FBIOPAN_DISPLAY, &m_fbVar) < 0)
+      CLog::Log(LOGWARNING, "Panning failed: %s\n", strerror(errno));
 
-  m_waitVSync.Set();
+    m_fbCurrentPage = ipu->page;
+    m_waitVSync.Set();
 
-  if (ioctl(m_fbHandle, MXCFB_WAIT_FOR_VSYNC, nullptr) < 0 && !CIMX::IsBlank())
-    CLog::Log(LOGWARNING, "Vsync failed: %s\n", strerror(errno));
+    if (ioctl(m_fbHandle, FBIO_WAITFORVSYNC, nullptr) < 0)
+      CLog::Log(LOGWARNING, "Vsync failed: %s\n", strerror(errno));
+
+  }
+
+  if (g_IMXCodec && !g_IMXCodec->GetBurst() && g_graphicsContext.GetResInfo().fRefreshRate <= 24.0)
+    CThread::Sleep(std::rand() % 7 + 7);
+
+  return true;
 }
 
 void CIMXContext::SetProcessInfo(CProcessInfo *m_pProcessInfo)
@@ -1629,6 +1642,7 @@ void CIMXContext::Clear(int page)
   if (!m_fbVirtAddr) return;
 
   uint16_t clr = 128 << 8 | 16;
+  uint32_t clr32 = (clr << 16) | clr;
   uint8_t *tmp_buf;
   int bytes;
 
@@ -1646,19 +1660,24 @@ void CIMXContext::Clear(int page)
     // out of range
     return;
 
-  if (m_fbVar.nonstd == _4CC('R', 'G', 'B', '4'))
+  if (m_fbVar.nonstd == fourcc('R', 'G', 'B', '4'))
     memset(tmp_buf, 0, bytes);
-  else if (m_fbVar.nonstd == _4CC('Y', 'U', 'Y', 'V'))
-    for (int i = 0; i < bytes / 2; ++i, tmp_buf += 2)
-      memcpy(tmp_buf, &clr, 2);
+  else if (m_fbVar.nonstd == fourcc('Y', 'U', 'Y', 'V'))
+    for (int i = 0; i < bytes / 4; ++i, tmp_buf += 4)
+      memcpy(tmp_buf, &clr32, 4);
   else
     CLog::Log(LOGERROR, "iMX Clear fb error : Unexpected format");
 
   SetProcessInfo(m_processInfo);
 }
 
-void CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
+bool CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
 {
+  CSharedLock lock(m_fbMapLock);
+
+  if (srcRect.IsEmpty() || dstRect.IsEmpty())
+    return false;
+
   CRectInt iSrcRect, iDstRect;
 
   float srcWidth = srcRect.Width();
@@ -1700,7 +1719,10 @@ void CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
   iDstRect.x1 = Align((int)dstRect.x1,8);
   iDstRect.y1 = Align((int)dstRect.y1,8);
   iDstRect.x2 = Align2((int)dstRect.x2,8);
-  iDstRect.y2 = Align2((int)dstRect.y2,8);
+  iDstRect.y2 = std::min(Align2((int)dstRect.y2,16)+8, m_fbHeight);
+
+  if (srcRect.IsEmpty() || dstRect.IsEmpty())
+    return false;
 
   ipu->task.input.crop.pos.x  = iSrcRect.x1;
   ipu->task.input.crop.pos.y  = iSrcRect.y1;
@@ -1712,142 +1734,122 @@ void CIMXContext::PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect)
   ipu->task.output.crop.w     = iDstRect.Width();
   ipu->task.output.crop.h     = iDstRect.Height();
 
-  // Setup deinterlacing if enabled
-  if (m_currentFieldFmt)
-  {
-    ipu->task.input.deinterlace.enable = 1;
-    ipu->task.input.deinterlace.motion = ipu->previous ? m_motion : HIGH_MOTION;
-    ipu->task.input.deinterlace.field_fmt = m_currentFieldFmt;
-  }
+  ipu->task.input.width   = ipu->cb->iWidth;
+  ipu->task.input.height  = ipu->cb->iHeight;
+  ipu->task.input.format  = ipu->cb->iFormat;
+  ipu->task.input.paddr   = ipu->cb->pPhysAddr;
+
+  return true;
 }
 
 bool CIMXContext::TileTask(IPUTaskPtr &ipu)
 {
   m_zoomAllowed = true;
 
-  // on double rate deinterlacing this is reusing previous already rasterised frame
-  if (ipu->current->iFormat != _4CC('T', 'N', 'V', 'F') && ipu->current->iFormat != _4CC('T', 'N', 'V', 'P'))
-  {
-    if (ipu->task.input.deinterlace.enable && ipu->task.input.deinterlace.motion != HIGH_MOTION)
-    {
-      ipu->task.input.paddr_n = ipu->task.input.paddr;
-      ipu->task.input.paddr   = ipu->previous->pPhysAddr;
-    }
+  // on double rate deinterlacing this is reusing pb already rasterised frame
+  if (ipu->cb->iFormat != fourcc('T', 'N', 'V', 'F') && ipu->cb->iFormat != fourcc('T', 'N', 'V', 'P'))
     return true;
-  }
 
   // Use band mode directly to FB, as no transformations needed (eg cropping)
-  if (m_fps >= 49 && m_fbWidth == 1920 && ipu->task.input.width == 1920 && !ipu->task.input.deinterlace.enable)
+  if (m_fps >= 49 && m_fbWidth == 1920 && ipu->task.input.width == 1920 && !ipu->task.input.deinterlace.enable && CEnvironment::getenv("IPU_RESIZE").empty())
   {
     m_zoomAllowed = false;
     ipu->task.output.crop.pos.x = ipu->task.input.crop.pos.x = 0;
     ipu->task.output.crop.pos.y = ipu->task.input.crop.pos.y = 0;
-    ipu->task.output.crop.h     = ipu->task.input.height     = ipu->task.input.crop.h = ipu->current->iHeight;
-    ipu->task.output.crop.w     = ipu->task.input.width      = ipu->task.input.crop.w = ipu->current->iWidth;
+    ipu->task.output.crop.h     = ipu->task.input.height     = ipu->task.input.crop.h = ipu->cb->iHeight;
+    ipu->task.output.crop.w     = ipu->task.input.width      = ipu->task.input.crop.w = ipu->cb->iWidth;
     if (ipu->task.input.crop.h < m_fbHeight)
       ipu->task.output.paddr     += m_fbLineLength * (m_fbHeight - ipu->task.input.crop.h)/2;
     return true;
   }
-
+/*
   // check for 3-field deinterlace (no HIGH_MOTION allowed) from tile field format
-  if (ipu->previous && ipu->current->iFormat == _4CC('T', 'N', 'V', 'F'))
+  if (ipu->cb->iFormat == fourcc('T', 'N', 'V', 'F') && ipu->pb)
   {
-    ipu->task.input.paddr     = ipu->previous->pPhysAddr;
-    ipu->task.input.paddr_n   = ipu->current->pPhysAddr;
+    ipu->task.input.paddr     = ipu->pb->pPhysAddr;
+    ipu->task.input.paddr_n   = ipu->cb->pPhysAddr;
     ipu->task.input.deinterlace.field_fmt = IPU_DEINTERLACE_FIELD_TOP;
     ipu->task.input.deinterlace.enable = true;
 
     ipu->task.output.crop.pos.x = ipu->task.input.crop.pos.x = 0;
     ipu->task.output.crop.pos.y = ipu->task.input.crop.pos.y = 0;
-    ipu->task.output.crop.h     = ipu->task.input.height     = ipu->task.input.crop.h = ipu->current->iHeight;
-    ipu->task.output.crop.w     = ipu->task.input.width      = ipu->task.input.crop.w = ipu->current->iWidth;
+    ipu->task.output.crop.h     = ipu->task.input.height     = ipu->task.input.crop.h = ipu->cb->iHeight;
+    ipu->task.output.crop.w     = ipu->task.input.width      = ipu->task.input.crop.w = ipu->cb->iWidth;
 
     return CheckTask(ipu) == 0;
   }
-
+*/
   // rasterize from tile (frame)
-  struct ipu_task    vdoa;
+  struct ipu_task vdoa = {};
 
-  memset(&vdoa, 0, sizeof(ipu->task));
-  vdoa.input.width   = vdoa.output.width  = ipu->current->iWidth;
-  vdoa.input.height  = vdoa.output.height = ipu->current->iHeight;
-  vdoa.input.format  = ipu->current->iFormat;
+  vdoa.input.width   = vdoa.output.width  = vdoa.output.crop.w = vdoa.input.crop.w = ipu->cb->iWidth;
+  vdoa.input.height  = vdoa.output.height = vdoa.output.crop.h = vdoa.input.crop.h = ipu->cb->iHeight;
+  vdoa.input.format  = ipu->cb->iFormat;
+  vdoa.input.paddr   = ipu->cb->pPhysAddr;
+  vdoa.output.format = ipu->task.input.format = m_fbVar.bits_per_pixel == 16 ? fourcc('Y', 'U', 'Y', 'V') : fourcc('N', 'V', '1', '2');
 
-  vdoa.input.paddr   = vdoa.input.paddr_n ? ipu->previous->pPhysAddr : ipu->current->pPhysAddr;
-  vdoa.output.format = ipu->task.input.format = m_fbVar.bits_per_pixel == 16 ? _4CC('Y', 'U', 'Y', 'V') : _4CC('N', 'V', '1', '2');
-
-  int check = CheckTask(ipu);
-  if (check == IPU_CHECK_ERR_PROC_NO_NEED)
-  {
-    vdoa.output.paddr = ipu->task.output.paddr;
-  }
-  else
-  {
-    struct g2d_buf *conv = g2d_alloc(ipu->current->iWidth *ipu->current->iHeight * 3, 0);
-    if (!conv)
-    {
-      CLog::Log(LOGERROR, "iMX: can't allocate crop buffer");
-      return false;
-    }
+  dma_addr_t buffer = AllocateBuffer(vdoa.input.width, vdoa.input.height);
+  if (buffer < 0)
+    return false;
 
-    ((CDVDVideoCodecIMXBuffer*)ipu->current)->m_convBuffer = conv;
-    vdoa.output.paddr = conv->buf_paddr;
-  }
+  vdoa.output.paddr = ipu->cb->SetConvBuffer(buffer);
 
-  if (ioctl(m_ipuHandle, IPU_QUEUE_TASK, &vdoa) < 0)
-  {
-    int ret = ioctl(m_ipuHandle, IPU_CHECK_TASK, &vdoa);
-    CLog::Log(LOGERROR, "IPU conversion from tiled failed %d at #%d", ret, __LINE__);
+  if (!RunIoctl(m_ipuHandle, IPU_QUEUE_TASK, &vdoa))
     return false;
-  }
 
-  ipu->task.input.paddr   = vdoa.output.paddr;
+  ipu->cb->Recycle();
 
-  if (ipu->current->iFormat == _4CC('T', 'N', 'V', 'F'))
-    return true;
+  ipu->task.input.format = vdoa.output.format;
+  ipu->task.input.paddr  = vdoa.output.paddr;
 
-  // output of VDOA task was sent directly to FB. no more processing needed.
-  if (check == IPU_CHECK_ERR_PROC_NO_NEED)
-    return true;
+  ipu->cb->iFormat   = vdoa.output.format;
+  ipu->cb->pPhysAddr = vdoa.output.paddr;
 
-  if (ipu->task.input.deinterlace.enable && ipu->task.input.deinterlace.motion != HIGH_MOTION)
-  {
-    ipu->task.input.paddr_n = ipu->task.input.paddr;
-    ipu->task.input.paddr   = ipu->previous->pPhysAddr;
-  }
-  ipu->current->iFormat   = vdoa.output.format;
-  ipu->current->pPhysAddr = vdoa.output.paddr;
+  return true;
+}
+
+bool CIMXContext::DeintTask(IPUTaskPtr &ipu)
+{
+  if (!m_currentFieldFmt || !ipu->pb)
+    return false;
+
+  ipu->task.input.deinterlace.enable = 1;
+  ipu->task.input.deinterlace.motion = m_motion;
+  ipu->task.input.deinterlace.field_fmt = m_currentFieldFmt;
+
+  if (ipu->task.input.deinterlace.motion != HIGH_MOTION)
+    ipu->task.input.paddr_n = ipu->cb->pPhysAddr;
+
+  ipu->task.input.format  = ipu->cb->iFormat;
+  ipu->task.input.paddr   = ipu->task.input.paddr_n ? ipu->pb->pPhysAddr : ipu->cb->pPhysAddr;
 
   return true;
 }
 
-int CIMXContext::CheckTask(IPUTaskPtr &ipu)
+int CIMXContext::CheckTask(struct ipu_task *task)
 {
-  //We really use IPU only if we have to deinterlace (using VDIC)
   int ret = IPU_CHECK_ERR_INPUT_CROP;
-  while (ret > IPU_CHECK_ERR_MIN)
+  while (ret != IPU_CHECK_OK && ret > IPU_CHECK_ERR_MIN)
   {
-    ret = ioctl(m_ipuHandle, IPU_CHECK_TASK, &ipu->task);
+    ret = ioctl(m_ipuHandle, IPU_CHECK_TASK, task);
     switch (ret)
     {
       case IPU_CHECK_OK:
         break;
       case IPU_CHECK_ERR_SPLIT_INPUTW_OVER:
-        ipu->task.input.crop.w -= 8;
+        task->input.crop.w -= 8;
         break;
       case IPU_CHECK_ERR_SPLIT_INPUTH_OVER:
-        ipu->task.input.crop.h -= 8;
+        task->input.crop.h -= 8;
         break;
       case IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER:
-        ipu->task.output.width -= 8;
-        ipu->task.output.crop.w = ipu->task.output.width;
+        task->output.width -= 8;
+        task->output.crop.w = task->output.width;
         break;
       case IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER:
-        ipu->task.output.height -= 8;
-        ipu->task.output.crop.h = ipu->task.output.height;
+        task->output.height -= 8;
+        task->output.crop.h = task->output.height;
         break;
-      // deinterlacing setup changing, m_ipuHandle is closed
-      case -1:
       // no IPU processing needed
       case IPU_CHECK_ERR_PROC_NO_NEED:
         return ret;
@@ -1860,73 +1862,70 @@ int CIMXContext::CheckTask(IPUTaskPtr &ipu)
   return 0;
 }
 
-bool CIMXContext::DoTask(IPUTaskPtr &ipu, CRect *dest)
+bool CIMXContext::DoTask(IPUTaskPtr &ipu)
 {
-  // Clear page if cropping changes
-  CRectInt dstRect(ipu->task.output.crop.pos.x, ipu->task.output.crop.pos.y,
-                   ipu->task.output.crop.pos.x + ipu->task.output.crop.w,
-                   ipu->task.output.crop.pos.y + ipu->task.output.crop.h);
-
-  // Populate input block
-  ipu->task.input.width   = ipu->current->iWidth;
-  ipu->task.input.height  = ipu->current->iHeight;
-  ipu->task.input.format  = ipu->current->iFormat;
-  ipu->task.input.paddr   = ipu->current->pPhysAddr;
+  CSharedLock lock(m_fbMapLock);
 
   ipu->task.output.width  = m_fbWidth;
   ipu->task.output.height = m_fbHeight;
   ipu->task.output.format = m_fbVar.nonstd;
   ipu->task.output.paddr  = m_fbPhysAddr + ipu->page*m_fbPageSize;
 
+  if (CheckTask(ipu))
+    return false;
+
+  // Clear page if cropping changes
+  CRectInt dstRect(ipu->task.output.crop.pos.x, ipu->task.output.crop.pos.y,
+                   ipu->task.output.crop.pos.x + ipu->task.output.crop.w,
+                   ipu->task.output.crop.pos.y + ipu->task.output.crop.h);
+
   if (m_pageCrops[ipu->page] != dstRect)
   {
     m_pageCrops[ipu->page] = dstRect;
     Clear(ipu->page);
   }
 
-  if ((ipu->task.input.crop.w <= 0) || (ipu->task.input.crop.h <= 0)
-  ||  (ipu->task.output.crop.w <= 0) || (ipu->task.output.crop.h <= 0))
-    return false;
+  return RunIoctl(m_ipuHandle, IPU_QUEUE_TASK, &ipu->task);
+}
 
-  if (!TileTask(ipu))
+inline
+bool CIMXContext::RunIoctl(int handle, int cmd, struct ipu_task *task)
+{
+  if (ioctl(handle, cmd, task) < 0)
+  {
+    CLog::Log(LOGERROR, "IPU task failed: %s at #%d\n", strerror(errno), __LINE__);
     return false;
+  }
 
-  if (CheckTask(ipu) == IPU_CHECK_ERR_PROC_NO_NEED)
-    return true;
-
-  int ret = ioctl(m_ipuHandle, IPU_QUEUE_TASK, &ipu->task);
-  if (ret < 0)
-    CLog::Log(LOGERROR, "IPU task failed: %s at #%d (ret %d)\n", strerror(errno), __LINE__, ret);
-
-  return ret == 0;
+  return true;
 }
 
 bool CIMXContext::CaptureDisplay(unsigned char *&buffer, int iWidth, int iHeight, bool blend)
 {
+  void *g2dHandle;
   int size = iWidth * iHeight * 4;
-  m_bufferCapture = g2d_alloc(size, 0);
+  struct g2d_buf *bufferCapture = g2d_alloc(size, 0);
 
-  if (!buffer)
-    buffer = new uint8_t[size];
-  else if (blend)
-    std::memcpy(m_bufferCapture->buf_vaddr, buffer, m_bufferCapture->buf_size);
-
-  if (g2d_open(&m_g2dHandle))
+  if (!bufferCapture || g2d_open(&g2dHandle))
   {
-    CLog::Log(LOGERROR, "%s : Error while trying open G2D\n", __FUNCTION__);
+    CLog::Log(LOGERROR, "%s : Error while trying open/allocate G2D\n", __FUNCTION__);
     return false;
   }
 
+  if (!buffer)
+    buffer = new uint8_t[size];
+  else if (blend)
+    std::memcpy(bufferCapture->buf_vaddr, buffer, bufferCapture->buf_size);
+
   CSingleLock lk(m_pageSwapLock);
-  if (m_bufferCapture && buffer)
+  if (buffer)
   {
-    struct g2d_surface src, dst;
-    memset(&src, 0, sizeof(src));
-    memset(&dst, 0, sizeof(dst));
+    struct g2d_surface src = {};
+    struct g2d_surface dst = {};
 
     {
-      src.planes[0] = m_fbPhysAddr + (m_fbCurrentPage & 0xf) * m_fbPageSize;
-      dst.planes[0] = m_bufferCapture->buf_paddr;
+      src.planes[0] = m_fbPhysAddr + m_fbCurrentPage * m_fbPageSize;
+      dst.planes[0] = bufferCapture->buf_paddr;
       if (m_fbVar.bits_per_pixel == 16)
       {
         src.format = G2D_YUYV;
@@ -1952,29 +1951,68 @@ bool CIMXContext::CaptureDisplay(unsigned char *&buffer, int iWidth, int iHeight
       {
         src.blendfunc = G2D_ONE_MINUS_DST_ALPHA;
         dst.blendfunc = G2D_ONE;
-        g2d_enable(m_g2dHandle, G2D_BLEND);
+        g2d_enable(g2dHandle, G2D_BLEND);
       }
 
-      g2d_blit(m_g2dHandle, &src, &dst);
-      g2d_finish(m_g2dHandle);
-      g2d_disable(m_g2dHandle, G2D_BLEND);
+      g2d_blit(g2dHandle, &src, &dst);
+      g2d_finish(g2dHandle);
+      g2d_disable(g2dHandle, G2D_BLEND);
     }
 
-    std::memcpy(buffer, m_bufferCapture->buf_vaddr, m_bufferCapture->buf_size);
+    std::memcpy(buffer, bufferCapture->buf_vaddr, bufferCapture->buf_size);
   }
   else
     CLog::Log(LOGERROR, "iMX : Error allocating capture buffer\n");
 
-  if (m_bufferCapture && g2d_free(m_bufferCapture))
+  if (g2d_free(bufferCapture))
     CLog::Log(LOGERROR, "iMX : Error while freeing capture buuffer\n");
 
-  if (m_g2dHandle && !g2d_close(m_g2dHandle))
-    m_g2dHandle = NULL;
+  g2d_close(g2dHandle);
   return true;
 }
 
+dma_addr_t CIMXContext::AllocateBuffer(unsigned int x, unsigned int y)
+{
+  int dmaPhy;
+
+  if (!m_dmaBuffer.size())
+  {
+    dmaPhy = x * y * 4;
+
+    if (ioctl(m_ipuHandle, IPU_ALLOC, &dmaPhy) < 0)
+      dmaPhy = -1;
+
+    m_dmaBuffer.setquotasize(m_dmaBuffer.getquotasize() + 1);
+  }
+  else
+  {
+    dmaPhy = m_dmaBuffer.pop();
+  }
+
+  if (dmaPhy < 0)
+    CLog::Log(LOGERROR, "iMX : Error allocating crop buffer (%d)", dmaPhy);
+
+  return dmaPhy;
+}
+
+void CIMXContext::DeallocateBuffer()
+{
+  CLog::Log(LOGVIDEO, "iMX : Deallocating crop buffers (%d)", m_dmaBuffer.getquotasize());
+  
+  while (m_dmaBuffer.size() < m_dmaBuffer.getquotasize())
+    Sleep(10);
+
+  while (m_dmaBuffer.size() && m_ipuHandle)
+    ioctl(m_ipuHandle, IPU_FREE, m_dmaBuffer.pop());
+
+  m_dmaBuffer.setquotasize(0);
+  CLog::Log(LOGVIDEO, "iMX : Deallocating crop buffers done");
+}
+
 void CIMXContext::Allocate()
 {
+  m_pageCrops = new CRectInt[m_fbPages];
+
   CSingleLock lk(m_pageSwapLock);
   AdaptScreen(true);
   AdaptScreen();
@@ -2001,7 +2039,8 @@ void CIMXContext::Stop(bool bWait /*= true*/)
     return;
 
   CThread::StopThread(false);
-  m_pingFlip.Set();
+  m_showBuffer.signal();
+  m_dmaBuffer.signal();
   if (bWait && IsRunning())
     CThread::StopThread(true);
 }
@@ -2009,5 +2048,10 @@ void CIMXContext::Stop(bool bWait /*= true*/)
 void CIMXContext::Process()
 {
   while (!m_bStop)
-    ShowPage();
+  {
+    if (!ShowPage())
+      m_waitVSync.Set();
+  }
+
+  m_showBuffer.for_each(Release);
 }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index 32e3a6c..8cacabe 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -22,9 +22,9 @@
 #include "linux/imx/IMX.h"
 
 #include "threads/CriticalSection.h"
+#include "threads/SharedSection.h"
 #include "threads/Condition.h"
 #include "threads/Thread.h"
-#include "utils/BitstreamConverter.h"
 #include "guilib/Geometry.h"
 #include "DVDVideoCodec.h"
 #include "DVDStreamInfo.h"
@@ -40,6 +40,7 @@
 #include <unordered_map>
 #include <cstring>
 #include <stdlib.h>
+#include <memory>
 
 // The decoding format of the VPU buffer. Comment this to decode
 // as NV12. The VPU works faster with NV12 in combination with
@@ -76,6 +77,7 @@ enum SIGNALS
   SIGNAL_DISPOSE       = (1 << 1),
   SIGNAL_SIGNAL        = (1 << 2),
   SIGNAL_FLUSH         = (1 << 3),
+  SIGNAL_NOWAIT        = (1 << 4),
 };
 
 enum RENDER_TASK
@@ -99,18 +101,17 @@ public:
 
   bool AdaptScreen(bool allocate = false);
   bool TaskRestart();
-  void OpenIPU();
-  void CloseIPU();
   void CloseDevices();
   bool OpenDevices();
 
   bool Blank();
   bool Unblank();
-  bool SetVSync(bool enable);
 
   void WaitVSync();
   void Stop(bool bWait = true);
 
+  void ReturnDma(dma_addr_t &addr) { if (addr) m_dmaBuffer.push(addr); addr = 0; }
+
   // Blitter configuration
   bool IsDoubleRate() const { return m_currentFieldFmt & IPU_DEINTERLACE_RATE_EN; }
 
@@ -121,7 +122,7 @@ public:
   // Blits a buffer to a particular page (-1 for auto page)
   // source_p (previous buffer) is required for de-interlacing
   // modes LOW_MOTION and MED_MOTION.
-  void Blit(CIMXBuffer *source_p, CIMXBuffer *source, const CRect &srcRect, const CRect &dstRect,
+  unsigned int Blit(CIMXBuffer *source_p, CIMXBuffer *source, const CRect &srcRect, const CRect &dstRect,
             uint8_t fieldFmt = 0, int targetPage = RENDER_TASK_AUTOPAGE);
 
   // Shows a page vsynced
@@ -138,52 +139,47 @@ public:
   void OnLostDisplay();
 
   void Allocate();
+  void DeallocateBuffer();
 
   static const int  m_fbPages;
 
 private:
-  struct IPUTask
-  {
-    IPUTask(CIMXBuffer *buffer_p, CIMXBuffer *buffer, int p = 0)
-      : previous(buffer_p), current(buffer), page(p)
-    {
-      memset(&task, 0, sizeof(task));
-    }
-
-    // Kept for reference
-    CIMXBuffer *previous;
-    CIMXBuffer *current;
-
-    // The actual task
-    struct ipu_task task;
-
-    unsigned int page;
-    int shift = true;
-  };
-
-  typedef std::shared_ptr<struct IPUTask> IPUTaskPtr;
+  typedef std::shared_ptr<CIMXIPUTask> IPUTaskPtr;
 
   bool GetFBInfo(const std::string &fbdev, struct fb_var_screeninfo *fbVar);
 
-  void PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect);
-  bool DoTask(IPUTaskPtr &ipu, CRect *dest = nullptr);
+  bool PrepareTask(IPUTaskPtr &ipu, CRect srcRect, CRect dstRect);
+  bool DoTask(IPUTaskPtr &ipu);
   bool TileTask(IPUTaskPtr &ipu);
-  int  CheckTask(IPUTaskPtr &ipu);
+  bool DeintTask(IPUTaskPtr &ipu);
+
+  int  CheckTask(struct ipu_task *task);
+  int  CheckTask(IPUTaskPtr &ipu) { return CheckTask(&ipu->task); }
 
   void SetFieldData(uint8_t fieldFmt, double fps);
 
   void Dispose();
-  void MemMap(struct fb_fix_screeninfo *fb_fix = NULL);
+  void MemMap(struct fb_fix_screeninfo *fb_fix = nullptr);
 
   virtual void OnStartup() override;
   virtual void OnExit() override;
   virtual void Process() override;
 
+  dma_addr_t AllocateBuffer(unsigned int x, unsigned int y);
+
+  static void Release(IPUTaskPtr &t) { t.reset(); }
+
+  bool RunIoctl(int handle, int cmd, struct ipu_task *task);
+
 private:
+  lkFIFO<IPUTaskPtr>             m_showBuffer;
+  lkFIFO<dma_addr_t>             m_dmaBuffer;
+
   int                            m_fbHandle;
   int                            m_fbCurrentPage;
-  int                            m_fbWidth;
-  int                            m_fbHeight;
+  unsigned int                   m_fbWidth;
+  unsigned int                   m_fbHeight;
+  bool                           m_fbInterlaced;
   int                            m_fbLineLength;
   int                            m_fbPageSize;
   int                            m_fbPhysSize;
@@ -192,22 +188,17 @@ private:
   struct fb_var_screeninfo       m_fbVar;
   int                            m_ipuHandle;
   uint8_t                        m_currentFieldFmt;
-  bool                           m_vsync;
   CRectInt                      *m_pageCrops;
   bool                           m_bFbIsConfigured;
   CEvent                         m_waitVSync;
-  CEvent                         m_pingFlip;
   CProcessInfo                  *m_processInfo;
   ipu_motion_sel                 m_motion;
 
   bool                           m_zoomAllowed;
   CCriticalSection               m_pageSwapLock;
-public:
-  void                          *m_g2dHandle;
-  struct g2d_buf                *m_bufferCapture;
+  CSharedSection                 m_fbMapLock;
 
   std::string                    m_deviceName;
-
   double                         m_fps;
 };
 
@@ -219,6 +210,8 @@ extern CIMXContext g_IMXContext;
 class CDVDVideoCodecIMX;
 class CIMXCodec;
 
+extern std::shared_ptr<CIMXCodec> g_IMXCodec;
+
 class CDecMemInfo
 {
 public:
@@ -251,6 +244,8 @@ public:
   virtual void Lock();
   virtual long Release();
 
+  void Recycle();
+
   void                  SetPts(double pts)      { m_pts = pts; }
   double                GetPts() const          { return m_pts; }
 
@@ -264,6 +259,7 @@ public:
   int                   GetIdx()                { return m_idx; }
 #endif
   VpuFieldType          GetFieldType() const    { return m_fieldType; }
+  dma_addr_t            SetConvBuffer(dma_addr_t buf) { return m_convBuffer = buf; }
 
 protected:
   unsigned int             m_pctWidth;
@@ -281,7 +277,7 @@ private:
 #endif
 
 public:
-  struct g2d_buf          *m_convBuffer;
+  dma_addr_t               m_convBuffer;
 };
 
 class CIMXCodec : public CThread
@@ -296,6 +292,7 @@ public:
   void                  SetDropState(bool bDrop);
 
   void                  Reset();
+  void                  Reinit();
 
   void                  WaitStartup()                           { m_loaded.Wait(); }
 
@@ -304,40 +301,41 @@ public:
   bool                  GetCodecStats(double &pts, int &droppedFrames, int &skippedPics);
   void                  SetCodecControl(int flags);
 
+  unsigned int          GetLockedBuffers() { if (m_decRet & VPU_DEC_RESOLUTION_CHANGED && !m_decOutput.size()) return m_nrOut.load(); return -1; }
+
   virtual void Process() override;
 
   static void           ReleaseFramebuffer(VpuFrameBuffer* fb);
 
+  virtual bool          GetInterlaced()                         { return m_initInfo.nInterlace; }
+  std::string           GetPlayerInfo();
+
+  bool                  GetBurst()                              { return m_burst; }
+
 protected:
-  class VPUTask
+  struct VPUTask
   {
-  public:
-    VPUTask(DemuxPacket pkg = { nullptr, 0, 0, 0, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE, 0, 0 },
-            CBitstreamConverter *cnv = nullptr) : demux(pkg)
+    VPUTask(DemuxPacket pkg = { nullptr, 0, 0, 0, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE, 0, 0 }, CIMXCircularPtr r = {})
+      : demux(pkg)
+      , ring(r)
     {
-      if (IsEmpty())
+      if (!pkg.pData || !ring)
         return;
 
-      bool cok = false;
-      if (cnv && (cok = cnv->Convert(pkg.pData, pkg.iSize)))
-        demux.iSize = cnv->GetConvertSize();
-
-      posix_memalign((void**)&demux.pData, 1024, demux.iSize);
-      std::memcpy(demux.pData, cok ? cnv->GetConvertBuffer() : pkg.pData, demux.iSize);
+      ring->push(pkg.pData, demux.iSize);
     }
 
-    void Release()
+    bool IsEmpty()
     {
-      if (!IsEmpty())
-        free(demux.pData);
-      demux.pData = nullptr;
+      return !demux.iSize;
     }
 
-    bool IsEmpty() { return !demux.pData; }
-
     DemuxPacket demux;
+    CIMXCircularPtr ring;
   };
 
+  typedef std::shared_ptr<VPUTask> VPUTaskPtr;
+
   bool VpuOpen();
   bool VpuAllocBuffers(VpuMemInfo *);
   bool VpuFreeBuffers(bool dispose = true);
@@ -349,10 +347,11 @@ protected:
 
   void RecycleFrameBuffers();
 
-  static void Release(VPUTask *&t)                     { SAFE_RELEASE(t); }
+  static void Release(VPUTaskPtr &t)                   { t.reset(); }
   static void Release(CDVDVideoCodecIMXBuffer *&t)     { SAFE_RELEASE(t); }
+  static void Release(g2d_buf *&t)                     { if (t) g2d_free(t); }
 
-  lkFIFO<VPUTask*>             m_decInput;
+  lkFIFO<VPUTaskPtr>           m_decInput;
   lkFIFO<CDVDVideoCodecIMXBuffer*>
                                m_decOutput;
 
@@ -361,7 +360,7 @@ protected:
   CDVDStreamInfo               m_hints;             // Hints from demuxer at stream opening
 
   VpuDecOpenParam              m_decOpenParam;      // Parameters required to call VPU_DecOpen
-  CDecMemInfo                  m_decMemInfo;        // VPU dedicated memory description
+  VpuMemInfo                   m_memInfo;
   VpuDecHandle                 m_vpuHandle;         // Handle for VPU library calls
   VpuDecInitInfo               m_initInfo;          // Initial info returned from VPU at decoding start
   VpuDecSkipMode               m_skipMode;          // Current drop state
@@ -373,9 +372,8 @@ protected:
   std::vector<VpuFrameBuffer>  m_vpuFrameBuffers;   // Table of VPU frame buffers description
   std::unordered_map<VpuFrameBuffer*,double>
                                m_pts;
+  lkFIFO<g2d_buf*>             m_allocated;
   double                       m_lastPTS;
-  VpuDecOutFrameInfo           m_frameInfo;         // Store last VPU output frame info
-  CBitstreamConverter         *m_converter;         // H264 annex B converter
   bool                         m_warnOnce;          // Track warning messages to only warn once
   int                          m_codecControlFlags;
   CCriticalSection             m_signalLock;
@@ -393,7 +391,7 @@ private:
   void                         ProcessSignals(int signal = 0);
   void                         AddExtraData(VpuBufferNode *bn, bool force = false);
 
-  bool                         VpuAlloc(VpuMemDesc *vpuMem);
+  g2d_buf                     *VpuAlloc(VpuMemDesc *vpuMem);
 
   void                         DisposeDecQueues();
   void                         FlushVPU();
@@ -408,6 +406,9 @@ private:
   unsigned int                 m_burst;
   bool                         m_requestDrop;
   CProcessInfo                *m_processInfo;
+  double                       m_dtsDiff;
+
+  CIMXCircularPtr              m_ring;
 
 private:
   void                         ExitError(const char *msg, ...);
@@ -417,7 +418,6 @@ private:
   std::atomic<unsigned char>   m_nrOut;
 };
 
-
 /*
  *
  *  CDVDVideoCodec only wraps IMXCodec class
@@ -446,6 +446,9 @@ public:
                                                                                 { return m_IMXCodec->GetCodecStats(pts, droppedFrames, skippedPics); }
   virtual void          SetCodecControl(int flags) override                     { m_IMXCodec->SetCodecControl(flags); }
 
+  virtual bool          GetInterlaced()                                         { return m_IMXCodec->GetInterlaced(); }
+  std::string           GetPlayerInfo()                                         { return g_IMXCodec ? g_IMXCodec->GetPlayerInfo() : ""; }
+
 private:
   std::shared_ptr<CIMXCodec> m_IMXCodec;
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
index b5c7095..bd15091 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
@@ -34,13 +34,14 @@
 
 CRendererIMX::CRendererIMX()
 {
-  m_bufHistory.clear();
+  m_bufHistory[0] = m_bufHistory[1] = nullptr;
 }
 
 CRendererIMX::~CRendererIMX()
 {
   UnInit();
-  std::for_each(m_bufHistory.begin(), m_bufHistory.end(), Release);
+  SAFE_RELEASE(m_bufHistory[1]);
+  SAFE_RELEASE(m_bufHistory[0]);
   g_IMX.Deinitialize();
 }
 
@@ -139,12 +140,14 @@ bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
   CDVDVideoCodecIMXBuffer *buffer = static_cast<CDVDVideoCodecIMXBuffer*>(m_buffers[m_iYV12RenderBuffer].hwDec);
   if (buffer)
   {
-    if (!m_bufHistory.empty() && m_bufHistory.back() != buffer || m_bufHistory.empty())
+    if (m_bufHistory[0] != buffer)
     {
       buffer->Lock();
-      m_bufHistory.push_back(buffer);
+      SAFE_RELEASE(m_bufHistory[1]);
+      m_bufHistory[1] = m_bufHistory[0];
+      m_bufHistory[0] = buffer;
     }
-    else if (!m_bufHistory.empty() && m_bufHistory.back() == buffer && flagsPrev == flags)
+    else if (flagsPrev == flags)
     {
       g_IMX.WaitVsync();
       return true;
@@ -152,13 +155,6 @@ bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
 
     flagsPrev = flags;
 
-    int size = flags & RENDER_FLAG_FIELDMASK ? 2 : 1;
-    while (m_bufHistory.size() > size)
-    {
-      m_bufHistory.front()->Release();
-      m_bufHistory.pop_front();
-    }
-
     // this hack is needed to get the 2D mode of a 3D movie going
     RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
     if (stereo_mode)
@@ -206,8 +202,7 @@ bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
       }
     }
 
-    CDVDVideoCodecIMXBuffer *buffer_p = m_bufHistory.front();
-    g_IMXContext.Blit(buffer_p == buffer ? nullptr : buffer_p, buffer, srcRect, dstRect, fieldFmt);
+    g_IMXContext.Blit(m_bufHistory[1], buffer, srcRect, dstRect, fieldFmt);
   }
 
 #if 0
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
index fc71e89..7fdb666 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.h
@@ -62,8 +62,7 @@ protected:
   virtual int  GetImageHook(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
   virtual bool RenderUpdateVideoHook(bool clear, DWORD flags = 0, DWORD alpha = 255);
 
-  std::deque<CDVDVideoCodecIMXBuffer*> m_bufHistory;
-  static void Release(CDVDVideoCodecIMXBuffer *&t) { if (t) t->Release(); }
+  CDVDVideoCodecIMXBuffer *m_bufHistory[2];
 };
 
 #endif
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
index ac0dfe1..eecc725 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
@@ -79,7 +79,9 @@
 #define CONF_FLAGS_STEREO_CADANCE_LEFT_RIGHT 0x000000
 #define CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT 0x008000
 
-
+/* defines interlaced modes */
+#define CONF_FLAGS_INTERLACED                   0x010000
+#define CONF_FLAGS_INTERLACED_MODE_MASK(a)      ((a) & CONF_FLAGS_INTERLACED)
 
 namespace RenderManager {
 
@@ -88,6 +90,7 @@ namespace RenderManager {
   unsigned int GetFlagsColorPrimaries(unsigned int color_primaries);
   unsigned int GetFlagsColorTransfer(unsigned int color_transfer);
   unsigned int GetStereoModeFlags(const std::string& mode);
+  unsigned int GetInterlacedModeFlag(bool interlaced);
   std::string  GetStereoModeInvert(const std::string& mode);
 
 }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index 420b5b5..7e41214 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -883,7 +883,7 @@ RESOLUTION CRenderManager::GetResolution()
     return res;
 
   if (CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF)
-    res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, CONF_FLAGS_STEREO_MODE_MASK(m_flags));
+    res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, CONF_FLAGS_STEREO_MODE_MASK(m_flags), CONF_FLAGS_INTERLACED_MODE_MASK(m_flags));
 
   return res;
 }
@@ -1079,7 +1079,7 @@ void CRenderManager::UpdateResolution()
     {
       if (CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF && m_fps > 0.0f)
       {
-        RESOLUTION res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, CONF_FLAGS_STEREO_MODE_MASK(m_flags));
+        RESOLUTION res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, CONF_FLAGS_STEREO_MODE_MASK(m_flags), CONF_FLAGS_INTERLACED_MODE_MASK(m_flags));
         g_graphicsContext.SetVideoResolution(res);
         UpdateDisplayLatency();
       }
diff --git a/xbmc/guilib/Resolution.cpp b/xbmc/guilib/Resolution.cpp
index 8c19be8..052472c 100644
--- a/xbmc/guilib/Resolution.cpp
+++ b/xbmc/guilib/Resolution.cpp
@@ -24,7 +24,13 @@
 #include "utils/MathUtils.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
 #include <cstdlib>
+#include <float.h>
+
+#include "Application.h"
+
+#include "windowing/egl/vc_hdmi.h"
 
 RESOLUTION_INFO::RESOLUTION_INFO(int width, int height, float aspect, const std::string &mode) :
   strMode(mode)
@@ -51,7 +57,7 @@ RESOLUTION_INFO::RESOLUTION_INFO(const RESOLUTION_INFO& res) :
   iScreenWidth = res.iScreenWidth; iScreenHeight = res.iScreenHeight;
   iSubtitles = res.iSubtitles; dwFlags = res.dwFlags;
   fPixelRatio = res.fPixelRatio; fRefreshRate = res.fRefreshRate;
-  iBlanking = res.iBlanking;
+  refresh_rate = res.refresh_rate; iBlanking = res.iBlanking;
 }
 
 float RESOLUTION_INFO::DisplayRatio() const
@@ -59,21 +65,21 @@ float RESOLUTION_INFO::DisplayRatio() const
   return iWidth * fPixelRatio / iHeight;
 }
 
-RESOLUTION CResolutionUtils::ChooseBestResolution(float fps, int width, bool is3D)
+RESOLUTION CResolutionUtils::ChooseBestResolution(float fps, int width, int height, bool is3D, bool isI)
 {
   RESOLUTION res = g_graphicsContext.GetVideoResolution();
   float weight;
-  if (!FindResolutionFromOverride(fps, width, is3D, res, weight, false)) //find a refreshrate from overrides
+  if (!FindResolutionFromOverride(fps, width, height, is3D, isI, res, weight, false)) //find a refreshrate from overrides
   {
-    if (!FindResolutionFromOverride(fps, width, is3D, res, weight, true))//if that fails find it from a fallback
-      FindResolutionFromFpsMatch(fps, width, is3D, res, weight);//if that fails use automatic refreshrate selection
+    if (!FindResolutionFromOverride(fps, width, height, is3D, isI, res, weight, true))//if that fails find it from a fallback
+      FindResolutionFromFpsMatch(fps, width, height, is3D, isI, res, weight);//if that fails use automatic refreshrate selection
   }
   CLog::Log(LOGNOTICE, "Display resolution ADJUST : %s (%d) (weight: %.3f)",
             g_graphicsContext.GetResInfo(res).strMode.c_str(), res, weight);
   return res;
 }
 
-bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight, bool fallback)
+bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, int height, bool is3D, bool isI, RESOLUTION &resolution, float& weight, bool fallback)
 {
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(resolution);
 
@@ -127,12 +133,12 @@ bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, bool is3
   return false; //no override found
 }
 
-void CResolutionUtils::FindResolutionFromFpsMatch(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight)
+void CResolutionUtils::FindResolutionFromFpsMatch(float fps, int width, int height, bool is3D, bool isI, RESOLUTION &resolution, float& weight)
 {
   const float maxWeight = 0.0021f;
   RESOLUTION_INFO curr;
 
-  resolution = FindClosestResolution(fps, width, is3D, 1.0, resolution, weight);
+  resolution = FindClosestResolution(fps, width, height, is3D, isI, 1.0, resolution, weight);
   curr = g_graphicsContext.GetResInfo(resolution);
 
   if (weight >= maxWeight) //not a very good match, try a 2:3 cadence instead
@@ -140,7 +146,7 @@ void CResolutionUtils::FindResolutionFromFpsMatch(float fps, int width, bool is3
     CLog::Log(LOGDEBUG, "Resolution %s (%d) not a very good match for fps %.3f (weight: %.3f), trying 2:3 cadence",
         curr.strMode.c_str(), resolution, fps, weight);
 
-    resolution = FindClosestResolution(fps, width, is3D, 2.5, resolution, weight);
+    resolution = FindClosestResolution(fps, width, height, is3D, isI, 2.5, resolution, weight);
     curr = g_graphicsContext.GetResInfo(resolution);
 
     if (weight >= maxWeight) //2:3 cadence not a good match
@@ -191,8 +197,11 @@ void CResolutionUtils::FindResolutionFromFpsMatch(float fps, int width, bool is3
   }
 }
 
-RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is3D, float multiplier, RESOLUTION current, float& weight)
+RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, int height, bool is3D, bool isI, float multiplier, RESOLUTION current, float& weight)
 {
+  if (CDisplaySettings::GetInstance().ResolutionInfoSize() < 2)
+    return current;
+
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(current);
   RESOLUTION orig_res  = CDisplaySettings::GetInstance().GetCurrentResolution();
 
@@ -203,11 +212,80 @@ RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is
 
   float fRefreshRate = fps;
 
-  float last_diff = fRefreshRate;
+  float last_diff = FLT_MAX;
 
   int curr_diff = std::abs(width - curr.iScreenWidth);
   int loop_diff = 0;
 
+  // CHANGERESOLUTION
+  if (CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTION) && !is3D)
+  {
+    bool i_found = false;
+
+    // if interlaced mode
+    if (isI && CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTIONINTERLACED))
+      for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::GetInstance().ResolutionInfoSize(); i++)
+      {
+        const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        if (!(info.dwFlags & D3DPRESENTFLAG_INTERLACED)
+        ||  CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_MINIMUMVERTICAL) > info.iScreenHeight
+        || ((int)CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA) < GETFLAGS_GROUP(info.dwFlags)-1)
+        ||    info.iScreenHeight != height
+        ||    IS_3D(info.dwFlags))
+          continue;
+
+        current = (RESOLUTION)i;
+        curr    = info;
+        i_found = true;
+      }
+
+    if (!i_found)
+      for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::GetInstance().ResolutionInfoSize(); i++)
+      {
+        const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        if ((fabs(info.fRefreshRate - fRefreshRate) > 0.001 && fabs(info.fRefreshRate - 2*fRefreshRate) > 0.001)
+        ||  IS_3D(info.dwFlags)
+        ||  CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_MINIMUMVERTICAL) > info.iScreenHeight
+        ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED && !isI)
+        || (!CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTIONINTERLACED) && (info.dwFlags & D3DPRESENTFLAG_INTERLACED))
+        || ((int)CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA) < GETFLAGS_GROUP(info.dwFlags)-1)
+        ||   width > info.iScreenWidth || height > info.iScreenHeight
+        ||   pow(info.iScreenWidth*info.iScreenHeight - width*height, 2) > last_diff)
+          continue;
+
+        current = (RESOLUTION)i;
+        curr    = info;
+        i_found = true;
+        last_diff = pow(curr.iScreenWidth*curr.iScreenHeight - width*height, 2);
+
+        if (info.iScreenWidth == width && info.iScreenHeight == height)
+          break;
+      }
+
+    last_diff = FLT_MAX;
+    for (size_t i = (int)RES_DESKTOP; !i_found && i < CDisplaySettings::GetInstance().ResolutionInfoSize(); i++)
+    {
+      const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+
+      if (width > info.iScreenWidth || height > info.iScreenHeight
+      ||  CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_MINIMUMVERTICAL) > info.iScreenHeight
+      ||  pow(info.iScreenWidth*info.iScreenHeight - width*height, 2) > last_diff
+      ||  info.iScreen != curr.iScreen
+      || ((int)CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA) < GETFLAGS_GROUP(info.dwFlags)-1)
+      ||  (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK))
+        {
+        /*  CLog::Log(LOGDEBUG, "curr %.2f, trying %.2f, mode nr. %d, %dx%d msk %d, m_msk %d", info.fPixelRatio, curr.fPixelRatio, i,
+               info.iScreenWidth, info.iScreenHeight, info.dwFlags & D3DPRESENTFLAG_MODEMASK,
+                    m_iFlags & D3DPRESENTFLAG_MODEMASK); */
+          continue;
+        }
+
+      current = (RESOLUTION)i;
+      curr    = info;
+      last_diff = pow(curr.iScreenWidth*curr.iScreenHeight - width*height, 2);
+    }
+  }
+
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::GetInstance().ResolutionInfoSize(); i++)
   {
@@ -215,9 +293,15 @@ RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is
 
     //discard resolutions that are not the same width and height (and interlaced/3D flags)
     //or have a too low refreshrate
-    if (info.iScreenWidth != curr.iScreenWidth ||
-        info.iScreenHeight != curr.iScreenHeight ||
-        info.iScreen != curr.iScreen ||
+    if ((!CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTION) &&
+        (info.iScreenWidth != curr.iScreenWidth ||
+         info.iScreenHeight != curr.iScreenHeight)) ||
+        (CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTION) &&
+         CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_MINIMUMVERTICAL) > info.iScreenHeight))
+      continue;
+
+    if (info.iScreen != curr.iScreen ||
+        ((int)CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA) < GETFLAGS_GROUP(info.dwFlags)-1) ||
         (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) ||
         info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
     {
@@ -228,6 +312,7 @@ RESOLUTION CResolutionUtils::FindClosestResolution(float fps, int width, bool is
       if ((width < orig.iScreenWidth) || // orig res large enough
          (info.iScreenWidth < orig.iScreenWidth) || // new res is smaller
          (info.iScreenHeight < orig.iScreenHeight) || // new height would be smaller
+         ((int)CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA) < GETFLAGS_GROUP(info.dwFlags)-1) ||
          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) || // don't switch to interlaced modes
          (info.iScreen != curr.iScreen) || // skip not current displays
          is3D) // skip res changing when doing 3D
diff --git a/xbmc/guilib/Resolution.h b/xbmc/guilib/Resolution.h
index f571528..9c69aee 100644
--- a/xbmc/guilib/Resolution.h
+++ b/xbmc/guilib/Resolution.h
@@ -88,6 +88,7 @@ struct RESOLUTION_INFO
   uint32_t dwFlags;
   float fPixelRatio;
   float fRefreshRate;
+  float refresh_rate;
   std::string strMode;
   std::string strOutput;
   std::string strId;
@@ -100,10 +101,10 @@ public:
 class CResolutionUtils
 {
 public:
-  static RESOLUTION ChooseBestResolution(float fps, int width, bool is3D);
+  static RESOLUTION ChooseBestResolution(float fps, int width, int height, bool is3D, bool isI);
+  static RESOLUTION FindClosestResolution(float fps, int width, int height, bool is3D, bool isI, float multiplier, RESOLUTION current, float& weight);
 protected:
-  static bool FindResolutionFromOverride(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight, bool fallback);
-  static void FindResolutionFromFpsMatch(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight);
-  static RESOLUTION FindClosestResolution(float fps, int width, bool is3D, float multiplier, RESOLUTION current, float& weight);
+  static bool FindResolutionFromOverride(float fps, int width, int height, bool is3D, bool isI, RESOLUTION &resolution, float& weight, bool fallback);
+  static void FindResolutionFromFpsMatch(float fps, int width, int height, bool is3D, bool isI, RESOLUTION &resolution, float& weight);
   static float RefreshWeight(float refresh, float fps);
 };
diff --git a/xbmc/linux/imx/IMX.cpp b/xbmc/linux/imx/IMX.cpp
index 84ab531..6d1d790 100644
--- a/xbmc/linux/imx/IMX.cpp
+++ b/xbmc/linux/imx/IMX.cpp
@@ -37,6 +37,8 @@
 #include "guilib/GraphicContext.h"
 #include "cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h"
 
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h"
+
 #define  DCIC_DEVICE    "/dev/mxc_dcic0"
 
 CIMX::CIMX(void) : CThread("CIMX")
@@ -93,7 +95,7 @@ bool CIMX::UpdateDCIC()
   CSingleLock lock(m_critSection);
   m_change = false;
 
-  int fb0 = open(FB_DEVICE, O_RDONLY | O_NONBLOCK);
+  int fb0 = open(FB_DEVICE, O_RDWR | O_NONBLOCK);
   if (fb0 < 0)
     return false;
 
@@ -154,13 +156,22 @@ void CIMX::OnResetDisplay()
   UpdateDCIC();
 }
 
-bool CIMX::IsBlank()
+CIMXIPUTask::CIMXIPUTask(CIMXBuffer *buffer, CIMXBuffer *buffer_p, int p)
+  : pb(static_cast<CDVDVideoCodecIMXBuffer*>(buffer_p))
+  , cb(static_cast<CDVDVideoCodecIMXBuffer*>(buffer))
+  , task({})
+  , page(p)
+{
+  cb->Lock();
+  if (pb)
+    pb->Lock();
+}
+
+CIMXIPUTask::~CIMXIPUTask()
 {
-  unsigned long curBlank;
-  int fd = open(FB_DEVICE, O_RDONLY | O_NONBLOCK);
-  bool ret = ioctl(fd, MXCFB_GET_FB_BLANK, &curBlank) || curBlank != FB_BLANK_UNBLANK;
-  close(fd);
-  return ret;
+  cb->Release();
+  if (pb)
+    pb->Release();
 }
 
 bool CIMXFps::Recalc()
diff --git a/xbmc/linux/imx/IMX.h b/xbmc/linux/imx/IMX.h
index a269af0..f600b3f 100644
--- a/xbmc/linux/imx/IMX.h
+++ b/xbmc/linux/imx/IMX.h
@@ -26,6 +26,9 @@
 #include "utils/log.h"
 #include "cores/VideoPlayer/DVDClock.h"
 
+#include <linux/ipu.h>
+#include <sys/mman.h>
+
 #include <mutex>
 #include <queue>
 #include <condition_variable>
@@ -33,12 +36,23 @@
 #include <atomic>
 #include <thread>
 #include <map>
+#include <cstring>
+#include <stdlib.h>
 
-#define DIFFRINGSIZE 60
+#define DIFFRINGSIZE 120
 
 #define FB_DEVICE "/dev/fb0"
 
+#define Align(ptr,align)  (((unsigned int)ptr + (align) - 1)/(align)*(align))
+#define Align2(ptr,align)  (((unsigned int)ptr)/(align)*(align))
+
+#define PAGE_SIZE sysconf(_SC_PAGESIZE)
+
+typedef uint8_t BYTE;
+
 class CIMX;
+class CDVDVideoCodecIMXBuffer;
+
 extern CIMX g_IMX;
 
 class CIMX : public CThread, IDispResource
@@ -53,8 +67,6 @@ public:
   int           WaitVsync();
   virtual void  OnResetDisplay();
 
-  static bool   IsBlank();
-
 private:
   virtual void  Process();
   bool          UpdateDCIC();
@@ -92,6 +104,10 @@ public:
       val = queue.front();
       queue.pop_front();
     }
+    else
+    {
+      val = {};
+    }
 
     m_lock.unlock();
     write.notify_one();
@@ -167,9 +183,144 @@ private:
   volatile bool           m_abort;
 };
 
+class CIMXCircular
+{
+public:
+  CIMXCircular(int size)
+    : m_size(Align(size, PAGE_SIZE))
+    , m_used(0)
+    , m_stillDecoding(0)
+    , m_buffer(nullptr)
+  {
+    m_fd = fileno(tmpfile());
+
+    ftruncate(m_fd, m_size * 2);
+
+    m_buffer = (BYTE*) mmap(nullptr, m_size * 2, PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+
+    mmap(m_buffer, m_size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, m_fd, 0);
+    mmap(m_buffer + m_size, m_size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, m_fd, 0);
+  }
+
+  ~CIMXCircular()
+  {
+    munmap(m_buffer, m_size * 2);
+    close(m_fd);
+  }
+
+  BYTE *pop(unsigned long count)
+  {
+    std::unique_lock<std::mutex> m_lock(lkqueue);
+    m_abort = false;
+    while (count && empty() && !m_abort)
+      read.wait(m_lock);
+
+    BYTE *ret = nullptr;
+    if (m_abort || !count)
+      return ret;
+
+    ret = readfrom();
+    p_read = (p_read + count) % m_size;
+    m_used -= count;
+    m_stillDecoding = count;
+
+    m_lock.unlock();
+    write.notify_one();
+    return ret;
+  }
+
+  bool push(BYTE *data, unsigned long count)
+  {
+    std::unique_lock<std::mutex> m_lock(lkqueue);
+    m_abort = false;
+    while (free() < count && !m_abort)
+      write.wait(m_lock);
+
+    if (m_abort)
+      return false;
+
+    std::memcpy(writeto(), data, count);
+    p_write = (p_write + count) % m_size;
+    m_used += count;
+
+    m_lock.unlock();
+    read.notify_one();
+    return true;
+  }
+
+  void reset()
+  {
+    std::unique_lock<std::mutex> m_lock(lkqueue);
+    m_used = p_write = p_read = m_stillDecoding = 0;
+  }
+
+  void signal()
+  {
+    m_abort = true;
+    notify();
+  }
+
+  unsigned long used()
+  {
+    std::unique_lock<std::mutex> m_lock(lkqueue);
+    return m_used;
+  }
+
+  unsigned long free()
+  {
+    return m_size - m_used - m_stillDecoding;
+  }
+
+  unsigned long size()
+  {
+    std::unique_lock<std::mutex> m_lock(lkqueue);
+    return m_size;
+  }
+
+private:
+  void notify()
+  {
+    read.notify_one();
+    write.notify_one();
+  }
+
+  BYTE *writeto()
+  {
+    return m_buffer + p_write;
+  }
+
+  BYTE *readfrom()
+  {
+    return m_buffer + p_read;
+  }
+
+  bool empty()
+  {
+    return p_write == p_read;
+  }
+
+  unsigned long m_size;
+  unsigned long p_read;
+  unsigned long p_write;
+  unsigned long m_used;
+  unsigned long m_stillDecoding;
+
+  int m_fd;
+  BYTE *m_buffer;
+
+  std::mutex lkqueue;
+  std::condition_variable write;
+  std::condition_variable read;
+
+  volatile bool m_abort;
+};
+
+typedef std::shared_ptr<CIMXCircular> CIMXCircularPtr;
+
 // Generell description of a buffer used by
 // the IMX context, e.g. for blitting
-class CIMXBuffer {
+class CIMXBuffer
+{
 public:
   CIMXBuffer() : m_iRefs(0) {}
 
@@ -186,11 +337,26 @@ public:
   uint8_t     *pVirtAddr;
   int          iFormat;
   double       m_fps;
+  unsigned int nQ16ShiftWidthDivHeightRatio;
 
 protected:
   std::atomic<long> m_iRefs;
 };
 
+struct CIMXIPUTask
+{
+  CIMXIPUTask(CIMXBuffer *buffer, CIMXBuffer *buffer_p = nullptr, int p = 0);
+  ~CIMXIPUTask();
+
+  // Kept for reference
+  CDVDVideoCodecIMXBuffer *pb;
+  CDVDVideoCodecIMXBuffer *cb;
+
+  // The actual task
+  struct ipu_task task;
+  unsigned int page;
+};
+
 class CIMXFps
 {
   public:
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 3758375..12e3925 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -75,7 +75,6 @@
 #include "threads/SingleLock.h"
 #include "utils/CharsetConverter.h"
 #include "utils/log.h"
-#include "utils/md5.h"
 #include "utils/RssManager.h"
 #include "utils/StringUtils.h"
 #include "utils/SystemInfo.h"
@@ -182,6 +181,11 @@ const std::string CSettings::SETTING_VIDEOPLAYER_USEMMAL = "videoplayer.usemmal"
 const std::string CSettings::SETTING_VIDEOPLAYER_USESTAGEFRIGHT = "videoplayer.usestagefright";
 const std::string CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE = "videoplayer.limitguiupdate";
 const std::string CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC = "videoplayer.supportmvc";
+const std::string CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTION = "videoplayer.adjustresolution";
+const std::string CSettings::SETTING_VIDEOPLAYER_ADJUSTRESOLUTIONINTERLACED = "videoplayer.adjustresolutioninterlaced";
+const std::string CSettings::SETTING_VIDEOPLAYER_MINIMUMVERTICAL = "videoplayer.minimumvertical";
+const std::string CSettings::SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA = "videoplayer.adjustallownoncea";
+const std::string CSettings::SETTING_VIDEOPLAYER_ACCELERATEDJPEGS = "videoplayer.acceleratedjpegs";
 const std::string CSettings::SETTING_MYVIDEOS_SELECTACTION = "myvideos.selectaction";
 const std::string CSettings::SETTING_MYVIDEOS_EXTRACTFLAGS = "myvideos.extractflags";
 const std::string CSettings::SETTING_MYVIDEOS_EXTRACTCHAPTERTHUMBS = "myvideos.extractchapterthumbs";
@@ -216,6 +220,7 @@ const std::string CSettings::SETTING_ACCESSIBILITY_SUBHEARING = "accessibility.s
 const std::string CSettings::SETTING_SCRAPERS_MOVIESDEFAULT = "scrapers.moviesdefault";
 const std::string CSettings::SETTING_SCRAPERS_TVSHOWSDEFAULT = "scrapers.tvshowsdefault";
 const std::string CSettings::SETTING_SCRAPERS_MUSICVIDEOSDEFAULT = "scrapers.musicvideosdefault";
+const std::string CSettings::SETTING_PVRMANAGER_ENABLED = "pvrmanager.enabled";
 const std::string CSettings::SETTING_PVRMANAGER_HIDECONNECTIONLOSTWARNING = "pvrmanager.hideconnectionlostwarning";
 const std::string CSettings::SETTING_PVRMANAGER_SYNCCHANNELGROUPS = "pvrmanager.syncchannelgroups";
 const std::string CSettings::SETTING_PVRMANAGER_BACKENDCHANNELORDER = "pvrmanager.backendchannelorder";
@@ -350,6 +355,7 @@ const std::string CSettings::SETTING_VIDEOSCREEN_GUICALIBRATION = "videoscreen.g
 const std::string CSettings::SETTING_VIDEOSCREEN_TESTPATTERN = "videoscreen.testpattern";
 const std::string CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGE = "videoscreen.limitedrange";
 const std::string CSettings::SETTING_VIDEOSCREEN_FRAMEPACKING = "videoscreen.framepacking";
+const std::string CSettings::SETTING_VIDEOSCREEN_BLANKCURRENT = "videoscreen.blankcurrent";
 const std::string CSettings::SETTING_AUDIOOUTPUT_AUDIODEVICE = "audiooutput.audiodevice";
 const std::string CSettings::SETTING_AUDIOOUTPUT_CHANNELS = "audiooutput.channels";
 const std::string CSettings::SETTING_AUDIOOUTPUT_CONFIG = "audiooutput.config";
@@ -390,6 +396,7 @@ const std::string CSettings::SETTING_NETWORK_HTTPPROXYPORT = "network.httpproxyp
 const std::string CSettings::SETTING_NETWORK_HTTPPROXYUSERNAME = "network.httpproxyusername";
 const std::string CSettings::SETTING_NETWORK_HTTPPROXYPASSWORD = "network.httpproxypassword";
 const std::string CSettings::SETTING_NETWORK_BANDWIDTH = "network.bandwidth";
+const std::string CSettings::SETTING_NETWORK_RESTARTSERVICES = "network.restartservices";
 const std::string CSettings::SETTING_POWERMANAGEMENT_DISPLAYSOFF = "powermanagement.displaysoff";
 const std::string CSettings::SETTING_POWERMANAGEMENT_SHUTDOWNTIME = "powermanagement.shutdowntime";
 const std::string CSettings::SETTING_POWERMANAGEMENT_SHUTDOWNSTATE = "powermanagement.shutdownstate";
@@ -546,17 +553,6 @@ bool CSettings::Save(const std::string &file)
   if (!m_settingsManager->Save(root))
     return false;
 
-  // Avoid saving if the settings saved earlier are indetical to the current ones
-  if (CFile::Exists(file))
-  {
-    std::string fileMD5 = CUtil::GetFileMD5(file);
-    TiXmlPrinter xmlPrinter;
-    xmlDoc.Accept(&xmlPrinter);
-    std::string settingsMD5 = XBMC::XBMC_MD5::GetMD5(xmlPrinter.CStr());
-    if (fileMD5 == settingsMD5)
-      return true;
-  }
-
   return xmlDoc.SaveFile(file);
 }
 
@@ -1063,6 +1059,7 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_3DLUT);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_DISPLAYPROFILE);
   m_settingsManager->RegisterCallback(&CDisplaySettings::GetInstance(), settingSet);
+  m_settingsManager->RegisterCallback(&g_application, settingSet);
   
   settingSet.clear();
   settingSet.insert(CSettings::SETTING_VIDEOPLAYER_SEEKDELAY);
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index ab67709..5d4f292 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -138,6 +138,11 @@ public:
   static const std::string SETTING_VIDEOPLAYER_USESTAGEFRIGHT;
   static const std::string SETTING_VIDEOPLAYER_LIMITGUIUPDATE;
   static const std::string SETTING_VIDEOPLAYER_SUPPORTMVC;
+  static const std::string SETTING_VIDEOPLAYER_ADJUSTRESOLUTION;
+  static const std::string SETTING_VIDEOPLAYER_ADJUSTRESOLUTIONINTERLACED;
+  static const std::string SETTING_VIDEOPLAYER_MINIMUMVERTICAL;
+  static const std::string SETTING_VIDEOPLAYER_ADJUSTALLOWNONCEA;
+  static const std::string SETTING_VIDEOPLAYER_ACCELERATEDJPEGS;
   static const std::string SETTING_MYVIDEOS_SELECTACTION;
   static const std::string SETTING_MYVIDEOS_EXTRACTFLAGS;
   static const std::string SETTING_MYVIDEOS_EXTRACTCHAPTERTHUMBS;
@@ -172,6 +177,7 @@ public:
   static const std::string SETTING_SCRAPERS_MOVIESDEFAULT;
   static const std::string SETTING_SCRAPERS_TVSHOWSDEFAULT;
   static const std::string SETTING_SCRAPERS_MUSICVIDEOSDEFAULT;
+  static const std::string SETTING_PVRMANAGER_ENABLED;
   static const std::string SETTING_PVRMANAGER_HIDECONNECTIONLOSTWARNING;
   static const std::string SETTING_PVRMANAGER_SYNCCHANNELGROUPS;
   static const std::string SETTING_PVRMANAGER_BACKENDCHANNELORDER;
@@ -306,6 +312,7 @@ public:
   static const std::string SETTING_VIDEOSCREEN_TESTPATTERN;
   static const std::string SETTING_VIDEOSCREEN_LIMITEDRANGE;
   static const std::string SETTING_VIDEOSCREEN_FRAMEPACKING;
+  static const std::string SETTING_VIDEOSCREEN_BLANKCURRENT;
   static const std::string SETTING_AUDIOOUTPUT_AUDIODEVICE;
   static const std::string SETTING_AUDIOOUTPUT_CHANNELS;
   static const std::string SETTING_AUDIOOUTPUT_CONFIG;
@@ -346,6 +353,7 @@ public:
   static const std::string SETTING_NETWORK_HTTPPROXYUSERNAME;
   static const std::string SETTING_NETWORK_HTTPPROXYPASSWORD;
   static const std::string SETTING_NETWORK_BANDWIDTH;
+  static const std::string SETTING_NETWORK_RESTARTSERVICES;
   static const std::string SETTING_POWERMANAGEMENT_DISPLAYSOFF;
   static const std::string SETTING_POWERMANAGEMENT_SHUTDOWNTIME;
   static const std::string SETTING_POWERMANAGEMENT_SHUTDOWNSTATE;
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index 0534828..b300e13 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -276,7 +276,9 @@ void CGUIDialogVideoSettings::InitializeSettings()
   entries.push_back(std::make_pair(16333, VS_INTERLACEMETHOD_MMAL_BOB_HALF));
   entries.push_back(std::make_pair(16334, VS_INTERLACEMETHOD_IMX_FASTMOTION));
   entries.push_back(std::make_pair(16335, VS_INTERLACEMETHOD_IMX_ADVMOTION_HALF));
-  entries.push_back(std::make_pair(16336, VS_INTERLACEMETHOD_IMX_ADVMOTION));
+  entries.push_back(std::make_pair(16336, VS_INTERLACEMETHOD_IMX_WEAVE_HALF));
+  entries.push_back(std::make_pair(16337, VS_INTERLACEMETHOD_IMX_ADVMOTION));
+  entries.push_back(std::make_pair(16338, VS_INTERLACEMETHOD_IMX_WEAVE));
   entries.push_back(std::make_pair(16320, VS_INTERLACEMETHOD_DXVA_AUTO));
 
   /* remove unsupported methods */
diff --git a/xbmc/windowing/egl/EGLEdid.cpp b/xbmc/windowing/egl/EGLEdid.cpp
new file mode 100644
index 0000000..1e24c1d
--- /dev/null
+++ b/xbmc/windowing/egl/EGLEdid.cpp
@@ -0,0 +1,94 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "EGLEdid.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+#include "settings/DisplaySettings.h"
+
+CEGLEdid g_EGLEdid;
+
+CEGLEdid::CEGLEdid()
+  : m_fSar(0.0f)
+  , m_edidEmpty(true)
+{
+  memset(&m_edid, 0, EDID_MAXSIZE);
+}
+
+CEGLEdid::~CEGLEdid()
+{
+}
+
+float CEGLEdid::ValidateSAR(struct dt_dim *dtm, bool mb)
+{
+  int Height = dtm->Height | (mb ? (dtm->msbits & 0x0f) << 8 : 0);
+  if (Height < 1)
+    return .0f;
+
+  int Width = dtm->Width | (mb ? (dtm->msbits & 0xf0) << 4 : 0);
+  float t_sar = (float) Width / Height;
+
+  if (t_sar < 0.33 || t_sar > 3.00)
+    t_sar = .0f;
+  else
+    CLog::Log(LOGINFO, "%s: Screen SAR: %.3f (from detailed: %s, %dx%d)",__FUNCTION__, t_sar, mb ? "yes" : "no", Width, Height);
+
+  return t_sar;
+}
+
+void CEGLEdid::CalcSAR()
+{
+  CSingleLock lk(m_lock);
+
+  m_fSar = .0f;
+  m_edidEmpty = true;
+  ReadEdidData();
+
+  // enumerate through (max four) detailed timing info blocks
+  // specs and lookup WxH [mm / in]. W and H are in 3 bytes,
+  // where 1st = W, 2nd = H, 3rd byte is 4bit/4bit.
+  //
+  // if DTM block starts with 0 - it is not DTM, skip
+  for (int i = EDID_DTM_START; i < 126 && m_fSar == 0 && *(m_edid +i); i += 18)
+    m_fSar = ValidateSAR((struct dt_dim *)(m_edid +i +EDID_DTM_OFFSET_DIMENSION), true);
+
+  // fallback - info related to 'Basic display parameters.' is at offset 0x14-0x18.
+  // where W is 2nd byte, H 3rd.
+  if (m_fSar == 0)
+    m_fSar = ValidateSAR((struct dt_dim *)(m_edid +EDID_STRUCT_DISPLAY +1));
+
+  // if m_sar != 0, final SAR is usefull
+  // if it is 0, EDID info was missing or calculated
+  // SAR value wasn't sane
+  if (m_fSar == 0)
+  {
+    RESOLUTION_INFO res = CDisplaySettings::GetInstance().GetCurrentResolutionInfo();
+
+    CLog::Log(LOGWARNING, "%s: Screen SAR - not usable info",__FUNCTION__);
+
+    if (res.iScreenWidth != 0)
+      m_fSar = res.iScreenHeight / res.iScreenWidth;
+    else
+      m_fSar = .0f;
+  }
+
+  m_edidEmpty = false;
+}
diff --git a/xbmc/windowing/egl/EGLEdid.h b/xbmc/windowing/egl/EGLEdid.h
new file mode 100644
index 0000000..e4b3287
--- /dev/null
+++ b/xbmc/windowing/egl/EGLEdid.h
@@ -0,0 +1,71 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/CriticalSection.h"
+#include "threads/SingleLock.h"
+#include <string>
+#include "guilib/GraphicContext.h"
+
+#define EDID_STRUCT_DISPLAY             0x14
+#define EDID_DTM_START                  0x36
+#define EDID_DTM_OFFSET_DIMENSION       0x0c
+#define EDID_EXTENSION_BLOCK_START      0x7e
+
+#define EDID_STRUCT_DISPLAY             0x14
+#define EDID_MAXSIZE                    512
+#define EDID_HEADERSIZE                 8
+
+static const char EDID_HEADER[8]    = { 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0 };
+
+class CEGLEdid
+{
+  struct dt_dim {
+    uint8_t Width;
+    uint8_t Height;
+    uint8_t msbits;
+  };
+
+public:
+  CEGLEdid();
+  virtual ~CEGLEdid();
+
+  bool    ReadEdidData();
+  const uint8_t *GetRawEdid() { Lock(); if (m_edidEmpty) CalcSAR(); return m_edidEmpty ? NULL : &m_edid[0]; }
+
+  float   GetSAR() const { CSingleLock lk(m_lock); return m_fSar; }
+  void    CalcSAR();
+
+  void Lock() { m_lock.lock(); }
+  void Unlock() { m_lock.unlock(); }
+
+  uint8_t      m_edid[EDID_MAXSIZE];
+
+protected:
+  float   ValidateSAR(struct dt_dim *dtm, bool mb = false);
+
+  float        m_fSar;
+  bool         m_edidEmpty;
+
+  CCriticalSection m_lock;
+};
+
+extern CEGLEdid g_EGLEdid;
diff --git a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
index f958bdc..2dba66a 100644
--- a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
@@ -23,6 +23,7 @@
 #include "system.h"
 #include <EGL/egl.h>
 
+#include "Application.h"
 #include "EGLNativeTypeIMX.h"
 #include <math.h>
 #include <sys/mman.h>
@@ -40,13 +41,26 @@
 #include "windowing/WindowingFactory.h"
 #include "cores/AudioEngine/AEFactory.h"
 #include <fstream>
+#include <float.h>
+#include "peripherals/Peripherals.h"
+
+#include "EGLEdid.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.h"
+
+using namespace PERIPHERALS;
 
 CEGLNativeTypeIMX::CEGLNativeTypeIMX()
-  : m_sar(0.0f)
-  , m_show(true)
+#ifdef HAS_IMXVPU
+  : m_show(true)
   , m_display(NULL)
   , m_window(NULL)
+  , m_ntsc(0)
+  , m_ignorenext(false)
+#endif
 {
+#ifdef HAS_IMXVPU
+  m_readonly = true;
+#endif
 }
 
 CEGLNativeTypeIMX::~CEGLNativeTypeIMX()
@@ -55,12 +69,17 @@ CEGLNativeTypeIMX::~CEGLNativeTypeIMX()
 
 bool CEGLNativeTypeIMX::CheckCompatibility()
 {
+#ifdef HAS_IMXVPU
   std::ifstream file("/sys/class/graphics/fb0/fsl_disp_dev_property");
   return file.is_open();
+#else
+  return false;
+#endif
 }
 
 void CEGLNativeTypeIMX::Initialize()
 {
+#ifdef HAS_IMXVPU
   int fd;
 
   // Check if we can change the framebuffer resolution
@@ -97,15 +116,13 @@ void CEGLNativeTypeIMX::Initialize()
     }
   }
 
-  ShowWindow(false);
-
-  fd = open("/dev/fb0",O_RDWR);
+  fd = open("/dev/fb0", O_RDWR | O_NONBLOCK);
   if (fd < 0)
   {
     CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
     return;
   }
-#ifdef HAS_IMXVPU
+
   struct mxcfb_color_key colorKey;
   struct mxcfb_gbl_alpha gbl_alpha;
   struct mxcfb_loc_alpha lalpha;
@@ -128,21 +145,27 @@ void CEGLNativeTypeIMX::Initialize()
     CLog::Log(LOGERROR, "%s - Failed to setup color keying\n", __FUNCTION__);
 
   close(fd);
-  ShowWindow(true);
 
+  ShowWindow(false);
   g_IMXContext.Allocate();
-  m_sar = GetMonitorSAR();
+  ShowWindow();
+
+  // Check if we can change the framebuffer resolution
+  if (!m_readonly)
+    GetNativeResolution(&m_init);
 #endif
   return;
 }
 
 void CEGLNativeTypeIMX::Destroy()
 {
+#ifdef HAS_IMXVPU
+  CLog::Log(LOGDEBUG, "%s\n", __FUNCTION__);
   struct fb_fix_screeninfo fixed_info;
   void *fb_buffer;
   int fd;
 
-  fd = open("/dev/fb0",O_RDWR);
+  fd = open("/dev/fb0",O_RDWR | O_NONBLOCK);
   if (fd < 0)
   {
     CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
@@ -161,20 +184,29 @@ void CEGLNativeTypeIMX::Destroy()
     memset(fb_buffer, 0x0, fixed_info.smem_len);
     munmap(fb_buffer, fixed_info.smem_len);
   }
-
   close(fd);
 
+  if (!m_readonly)
+    SysfsUtils::SetString("/sys/class/graphics/fb0/mode", m_init.strId + "\n");
+  SysfsUtils::SetInt("/sys/class/graphics/fb1/blank", 1);
+
+  system("/usr/bin/splash --force -i -m 'stopping kodi...'");
+#endif
   return;
 }
 
 bool CEGLNativeTypeIMX::CreateNativeDisplay()
 {
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
+#ifdef HAS_IMXVPU
+  if (m_display)
+    return true;
+
   // Force double-buffering
   CEnvironment::setenv("FB_MULTI_BUFFER", "2", 0);
-
-#ifdef HAS_IMXVPU
   // EGL will be rendered on fb0
-  m_display = fbGetDisplayByIndex(0);
+  if (!(m_display = fbGetDisplayByIndex(0)))
+    return false;
   m_nativeDisplay = &m_display;
   return true;
 #else
@@ -184,8 +216,14 @@ bool CEGLNativeTypeIMX::CreateNativeDisplay()
 
 bool CEGLNativeTypeIMX::CreateNativeWindow()
 {
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
 #ifdef HAS_IMXVPU
-  m_window = fbCreateWindow(m_display, 0, 0, 0, 0);
+  if (m_window)
+    return true;
+
+  if (!(m_window = fbCreateWindow(m_display, 0, 0, 0, 0)))
+    return false;
+
   m_nativeWindow = &m_window;
   return true;
 #else
@@ -195,30 +233,39 @@ bool CEGLNativeTypeIMX::CreateNativeWindow()
 
 bool CEGLNativeTypeIMX::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
 {
-  if (!nativeDisplay)
-    return false;
+#ifdef HAS_IMXVPU
   if (!m_nativeDisplay)
     return false;
+
   *nativeDisplay = (XBNativeDisplayType*)m_nativeDisplay;
   return true;
+#else
+  return false;
+#endif
 }
 
 bool CEGLNativeTypeIMX::GetNativeWindow(XBNativeWindowType **nativeWindow) const
 {
-  if (!nativeWindow)
-    return false;
-  if (!m_nativeWindow || !m_window)
+#ifdef HAS_IMXVPU
+  if (!m_nativeWindow)
     return false;
+
   *nativeWindow = (XBNativeWindowType*)m_nativeWindow;
   return true;
+#else
+  return false;
+#endif
 }
 
 bool CEGLNativeTypeIMX::DestroyNativeDisplay()
 {
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
 #ifdef HAS_IMXVPU
   if (m_display)
     fbDestroyDisplay(m_display);
-  m_display =  NULL;
+
+  m_display = NULL;
+  m_nativeDisplay = NULL;
   return true;
 #else
   return false;
@@ -227,37 +274,87 @@ bool CEGLNativeTypeIMX::DestroyNativeDisplay()
 
 bool CEGLNativeTypeIMX::DestroyNativeWindow()
 {
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
 #ifdef HAS_IMXVPU
   if (m_window)
     fbDestroyWindow(m_window);
-  m_window =  NULL;
+
+  m_window = NULL;
+  m_nativeWindow = NULL;
   return true;
 #else
   return false;
 #endif
 }
 
+#ifdef HAS_IMXVPU
+bool ntsc_mode()
+{
+  std::ifstream file("/sys/class/graphics/fb0/ntsc_mode");
+  return file.is_open();
+}
+
+bool get_ntsc()
+{
+  std::string mode;
+  SysfsUtils::GetString("/sys/class/graphics/fb0/ntsc_mode", mode);
+  return mode.find("active") != std::string::npos;
+}
+#endif
+
 bool CEGLNativeTypeIMX::GetNativeResolution(RESOLUTION_INFO *res) const
 {
+#ifdef HAS_IMXVPU
   std::string mode;
   SysfsUtils::GetString("/sys/class/graphics/fb0/mode", mode);
-  return ModeToResolution(mode, res);
+  CLog::Log(LOGDEBUG,": %s, %s", __FUNCTION__, mode.c_str());
+
+  bool ret = ModeToResolution(mode, res);
+  if (ntsc_mode() && get_ntsc())
+    res->fRefreshRate  = (float)res->refresh_rate * (1000.0f/1001.0f);
+  else if (!ntsc_mode())
+    return ret;
+
+  SetStrMode(res);
+  return ret;
+#else
+  return false;
+#endif
 }
 
 bool CEGLNativeTypeIMX::SetNativeResolution(const RESOLUTION_INFO &res)
 {
+#ifdef HAS_IMXVPU
   if (m_readonly)
     return false;
 
   std::string mode;
+  int new_ntsc;
+
+  if (ntsc_mode())
+    new_ntsc = fabs(res.refresh_rate - res.fRefreshRate) < FLT_EPSILON ? 0 : 1;
+  else
+    new_ntsc = 0;
+
   SysfsUtils::GetString("/sys/class/graphics/fb0/mode", mode);
-  if (res.strId == mode)
-    return false;
+
+  if (res.strId == mode && m_ntsc == new_ntsc)
+  {
+    CLog::Log(LOGDEBUG,": %s - not changing res (%s vs %s)%s", __FUNCTION__, res.strId.c_str(), mode.c_str(), new_ntsc ? " mode NTSC" : "");
+    return true;
+  }
 
   DestroyNativeWindow();
   DestroyNativeDisplay();
 
+  if (ntsc_mode())
+  {
+    SysfsUtils::SetInt("/sys/class/graphics/fb0/ntsc_mode", new_ntsc);
+    m_ntsc = new_ntsc;
+  }
+
   ShowWindow(false);
+  CLog::Log(LOGDEBUG,": %s - changing resolution to %s%s", __FUNCTION__, res.strId.c_str(), new_ntsc ? " mode NTSC" : "");
   SysfsUtils::SetString("/sys/class/graphics/fb0/mode", res.strId + "\n");
 
   CreateNativeDisplay();
@@ -265,11 +362,13 @@ bool CEGLNativeTypeIMX::SetNativeResolution(const RESOLUTION_INFO &res)
 
   g_IMXContext.OnResetDisplay();
   ShowWindow(true);
-  CLog::Log(LOGDEBUG, "%s: %s",__FUNCTION__, res.strId.c_str());
-
   return true;
+#else
+  return false;
+#endif
 }
 
+#ifdef HAS_IMXVPU
 bool CEGLNativeTypeIMX::FindMatchingResolution(const RESOLUTION_INFO &res, const std::vector<RESOLUTION_INFO> &resolutions)
 {
   for (int i = 0; i < (int)resolutions.size(); i++)
@@ -284,9 +383,13 @@ bool CEGLNativeTypeIMX::FindMatchingResolution(const RESOLUTION_INFO &res, const
   }
   return false;
 }
+#endif
 
 bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
 {
+#ifdef HAS_IMXVPU
+  g_EGLEdid.CalcSAR();
+
   if (m_readonly)
     return false;
 
@@ -304,26 +407,53 @@ bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutio
   RESOLUTION_INFO res;
   for (size_t i = 0; i < probe_str.size(); i++)
   {
-    if(!StringUtils::StartsWith(probe_str[i], "S:") && !StringUtils::StartsWith(probe_str[i], "U:") &&
-       !StringUtils::StartsWith(probe_str[i], "V:") && !StringUtils::StartsWith(probe_str[i], "D:"))
+    if(!StringUtils::StartsWithNoCase(probe_str[i], "S:") && !StringUtils::StartsWithNoCase(probe_str[i], "U:") &&
+       !StringUtils::StartsWithNoCase(probe_str[i], "V:") && !StringUtils::StartsWithNoCase(probe_str[i], "D:") &&
+       !StringUtils::StartsWithNoCase(probe_str[i], "H:") && !StringUtils::StartsWithNoCase(probe_str[i], "T:"))
       continue;
 
     if(ModeToResolution(probe_str[i], &res))
       if(!FindMatchingResolution(res, resolutions))
+      {
         resolutions.push_back(res);
+        if (!ntsc_mode())
+          continue;
+
+        if (res.refresh_rate == 24 || res.refresh_rate == 30 || res.refresh_rate == 60)
+        {
+          RESOLUTION_INFO res2 = res;
+          res2.fRefreshRate  = (float)res.refresh_rate * (1000.0f/1001.0f);
+          SetStrMode(&res2);
+          resolutions.push_back(res2);
+        }
+      }
   }
   return resolutions.size() > 0;
+#else
+  return false;
+#endif
 }
 
 bool CEGLNativeTypeIMX::GetPreferredResolution(RESOLUTION_INFO *res) const
 {
+#ifdef HAS_IMXVPU
   return GetNativeResolution(res);
+#else
+  return false;
+#endif
 }
 
 bool CEGLNativeTypeIMX::ShowWindow(bool show)
 {
-  if (m_show == show)
+#ifdef HAS_IMXVPU
+
+  if (m_ignorenext || (m_show == show))
+  {
+    if (!show)
+      m_ignorenext ^= 1;
+
     return true;
+  }
 
   CLog::Log(LOGDEBUG, ": %s %s", __FUNCTION__, show?"show":"hide");
   SysfsUtils::SetInt("/sys/class/graphics/fb0/blank", show ? 0 : 1 );
@@ -331,9 +461,13 @@ bool CEGLNativeTypeIMX::ShowWindow(bool show)
   m_show = show;
 
   return true;
+#else
+  return false;
+#endif
 }
 
-float CEGLNativeTypeIMX::GetMonitorSAR()
+#ifdef HAS_IMXVPU
+bool CEGLEdid::ReadEdidData()
 {
   FILE *f_edid;
   char *str = NULL;
@@ -348,7 +482,7 @@ float CEGLNativeTypeIMX::GetMonitorSAR()
     f_edid = fopen("/sys/devices/soc0/soc.1/20e0000.hdmi_video/edid", "r");
 
   if(!f_edid)
-    return 0;
+    return false;
 
   // first check if EDID is in binary format by reading 512bytes, compare 1st 8bytes
   // against EDID 1.4 identificator [0x0,0xff,0xff,0xff,0xff,0xff,0xff,0x0]
@@ -392,20 +526,15 @@ float CEGLNativeTypeIMX::GetMonitorSAR()
   }
   fclose(f_edid);
 
-  // info related to 'Basic display parameters.' is at offset 0x14-0x18.
-  // where W is 2nd byte, H 3rd.
-  int cmWidth  = (int)*(m_edid +EDID_STRUCT_DISPLAY +1);
-  int cmHeight = (int)*(m_edid +EDID_STRUCT_DISPLAY +2);
-  if (cmHeight > 0)
-  {
-    float t_sar = (float) cmWidth / cmHeight;
-    if (t_sar >= 0.33 && t_sar <= 3.0)
-      return t_sar;
-  }
+  return true;
+}
 
-  // if we end up here, H/W values or final SAR are useless
-  // return 0 and use 1.0f as PR for all resolutions
-  return 0;
+void CEGLNativeTypeIMX::SetStrMode(RESOLUTION_INFO *res) const
+{
+  res->strMode       = StringUtils::Format("%4sx%4s @ %.3f%s - Full Screen %s (%.3f) %s", StringUtils::Format("%d", res->iScreenWidth).c_str(),
+                                           StringUtils::Format("%d", res->iScreenHeight).c_str(), res->fRefreshRate,
+                                           res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : " ", HDMI_RES_GROUP_NAME(GETFLAGS_GROUP(res->dwFlags)), res->fPixelRatio,
+                                           res->dwFlags & D3DPRESENTFLAG_MODE3DSBS ? "- 3DSBS" : res->dwFlags & D3DPRESENTFLAG_MODE3DTB ? "- 3DTB" : "");
 }
 
 bool CEGLNativeTypeIMX::ModeToResolution(std::string mode, RESOLUTION_INFO *res) const
@@ -422,6 +551,13 @@ bool CEGLNativeTypeIMX::ModeToResolution(std::string mode, RESOLUTION_INFO *res)
   std::string fromMode = StringUtils::Mid(mode, 2);
   StringUtils::Trim(fromMode);
 
+  if (StringUtils::StartsWithNoCase(mode, "U:") || StringUtils::StartsWithNoCase(mode, "V:"))
+    res->dwFlags = HDMI_RES_GROUP_DMT;
+  else
+    res->dwFlags = HDMI_RES_GROUP_CEA;
+
+  res->fPixelRatio = 1.0f;
+
   CRegExp split(true);
   split.RegComp("([0-9]+)x([0-9]+)([pi])-([0-9]+)");
   if (split.RegFind(fromMode) < 0)
@@ -436,18 +572,30 @@ bool CEGLNativeTypeIMX::ModeToResolution(std::string mode, RESOLUTION_INFO *res)
   res->iHeight= h;
   res->iScreenWidth = w;
   res->iScreenHeight= h;
-  res->fRefreshRate = r;
-  res->dwFlags = p[0] == 'p' ? D3DPRESENTFLAG_PROGRESSIVE : D3DPRESENTFLAG_INTERLACED;
+  if (!ntsc_mode() && StringUtils::isasciilowercaseletter(mode[0]))
+    res->fRefreshRate = (float)r * 1000 / 1001;
+  else
+    res->fRefreshRate = (float)r;
+  res->refresh_rate = (float)r;
+
+  res->dwFlags = MAKEFLAGS(res->dwFlags, 0, p[0] != 'p' && p[0] != 'd');
+
+  if (StringUtils::StartsWithNoCase(mode, "H:")) {
+    res->dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
+    res->fPixelRatio = 2.0f;
+  } else if (StringUtils::StartsWithNoCase(mode, "T:")) {
+    res->dwFlags |= D3DPRESENTFLAG_MODE3DTB;
+    res->fPixelRatio = 0.5f;
+  }
 
   res->iScreen       = 0;
   res->bFullScreen   = true;
   res->iSubtitles    = (int)(0.965 * res->iHeight);
 
-  res->fPixelRatio   = !m_sar ? 1.0f : (float)m_sar / res->iScreenWidth * res->iScreenHeight;
-  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
-                                           res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  res->fPixelRatio  *= (g_EGLEdid.GetSAR() ? (float)g_EGLEdid.GetSAR() / res->iScreenWidth * res->iScreenHeight : (float)1.0f);
   res->strId         = mode;
+  SetStrMode(res);
 
   return res->iWidth > 0 && res->iHeight> 0;
 }
-
+#endif
diff --git a/xbmc/windowing/egl/EGLNativeTypeIMX.h b/xbmc/windowing/egl/EGLNativeTypeIMX.h
index 53cbc2e..948a102 100644
--- a/xbmc/windowing/egl/EGLNativeTypeIMX.h
+++ b/xbmc/windowing/egl/EGLNativeTypeIMX.h
@@ -27,12 +27,7 @@
 
 #include <EGL/egl.h>
 #include "EGLNativeType.h"
-
-#define EDID_STRUCT_DISPLAY     0x14
-#define EDID_MAXSIZE            512
-#define EDID_HEADERSIZE         8
-
-static const char EDID_HEADER[EDID_HEADERSIZE] = { 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0 };
+#include "windowing/egl/vc_hdmi.h"
 
 class CEGLNativeTypeIMX : public CEGLNativeType
 {
@@ -58,17 +53,22 @@ public:
   virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
   virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
 
-  virtual bool  ShowWindow(bool show);
+  virtual bool  ShowWindow(bool show = true);
 
+#ifdef HAS_IMXVPU
 protected:
   bool m_readonly;
-  float m_sar;
   bool m_show;
+  RESOLUTION_INFO m_init;
   bool ModeToResolution(std::string mode, RESOLUTION_INFO *res) const;
   bool FindMatchingResolution(const RESOLUTION_INFO &res, const std::vector<RESOLUTION_INFO> &resolutions);
-  float GetMonitorSAR();
 
   EGLNativeDisplayType m_display;
   EGLNativeWindowType  m_window;
-  uint8_t              m_edid[EDID_MAXSIZE];
+
+private:
+  void SetStrMode(RESOLUTION_INFO *res) const;
+  int  m_ntsc;
+  bool m_ignorenext;
+#endif
 };
diff --git a/xbmc/windowing/egl/Makefile.in b/xbmc/windowing/egl/Makefile.in
index 68f7862..b86d6f3 100644
--- a/xbmc/windowing/egl/Makefile.in
+++ b/xbmc/windowing/egl/Makefile.in
@@ -13,6 +13,7 @@ ifeq (@USE_IMXVPU@,1)
 SRCS+= EGLNativeTypeIMX.cpp
 endif
 SRCS+= EGLWrapper.cpp
+SRCS+= EGLEdid.cpp
 
 LIB = windowing_egl.a
 
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 852f337..7e066f8 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -18,6 +18,7 @@
  *
  */
 #include "system.h"
+#include "Application.h"
 
 #ifdef HAS_EGL
 
@@ -29,6 +30,7 @@
 #include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/DisplaySettings.h"
+#include "guilib/Resolution.h"
 #include "guilib/DispResource.h"
 #include "threads/SingleLock.h"
 #ifdef HAS_IMXVPU
@@ -284,7 +286,9 @@ bool CWinSystemEGL::CreateNewWindow(const std::string& name, bool fullScreen, RE
     m_stereo_mode == stereo_mode)
   {
     CLog::Log(LOGDEBUG, "CWinSystemEGL::CreateNewWindow: No need to create a new window");
+#if !defined(TARGET_RASPBERRY_PI)
     return true;
+#endif
   }
 
   int delay = CSettings::GetInstance().GetInt("videoscreen.delayrefreshchange");
@@ -362,7 +366,7 @@ void CWinSystemEGL::UpdateResolutions()
 {
   CWinSystemBase::UpdateResolutions();
 
-  RESOLUTION_INFO resDesktop, curDisplay;
+  RESOLUTION_INFO curDisplay, resDesktop = CDisplaySettings::GetInstance().GetResolutionInfo(CDisplaySettings::GetInstance().GetCurrentResolution());
   std::vector<RESOLUTION_INFO> resolutions;
 
   if (!m_egl->ProbeResolutions(resolutions) || resolutions.empty())
@@ -381,14 +385,6 @@ void CWinSystemEGL::UpdateResolutions()
     }
   }
 
-  /* ProbeResolutions includes already all resolutions.
-   * Only get desktop resolution so we can replace xbmc's desktop res
-   */
-  if (m_egl->GetNativeResolution(&curDisplay))
-    resDesktop = curDisplay;
-
-
-  RESOLUTION ResDesktop = RES_INVALID;
   RESOLUTION res_index  = RES_DESKTOP;
 
   for (size_t i = 0; i < resolutions.size(); i++)
@@ -404,41 +400,43 @@ void CWinSystemEGL::UpdateResolutions()
     g_graphicsContext.ResetOverscan(resolutions[i]);
     CDisplaySettings::GetInstance().GetResolutionInfo(res_index) = resolutions[i];
 
-    CLog::Log(LOGNOTICE, "Found resolution %d x %d for display %d with %d x %d%s @ %f Hz\n",
-      resolutions[i].iWidth,
-      resolutions[i].iHeight,
-      resolutions[i].iScreen,
-      resolutions[i].iScreenWidth,
-      resolutions[i].iScreenHeight,
-      resolutions[i].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
-      resolutions[i].fRefreshRate);
+    CLog::Log(LOGNOTICE, "Found resolution %s\n", resolutions[i].strMode.c_str());
+
+    res_index = (RESOLUTION)((int)res_index + 1);
+  }
 
+  /* ProbeResolutions includes already all resolutions.
+   * Only get desktop resolution so we can replace xbmc's desktop res
+   */
+  if (resDesktop.strMode.empty() || CDisplaySettings::GetInstance().GetCurrentResolution() != CDisplaySettings::GetInstance().GetDisplayResolution())
+    resDesktop = CDisplaySettings::GetInstance().GetResolutionInfo(CDisplaySettings::GetInstance().GetDisplayResolution());
+  if (CDisplaySettings::GetInstance().GetCurrentResolution() == RES_DESKTOP)
+    if (m_egl->GetNativeResolution(&curDisplay))
+      resDesktop = curDisplay;
+
+  CLog::Log(LOGDEBUG, "Looking for resolution %s", resDesktop.strMode.c_str());
+  RESOLUTION ResDesktop = RES_INVALID;
+
+  for (size_t i = 0; i < resolutions.size(); i++)
     if(resDesktop.iWidth == resolutions[i].iWidth &&
        resDesktop.iHeight == resolutions[i].iHeight &&
        resDesktop.iScreenWidth == resolutions[i].iScreenWidth &&
        resDesktop.iScreenHeight == resolutions[i].iScreenHeight &&
        (resDesktop.dwFlags & D3DPRESENTFLAG_MODEMASK) == (resolutions[i].dwFlags & D3DPRESENTFLAG_MODEMASK) &&
-       fabs(resDesktop.fRefreshRate - resolutions[i].fRefreshRate) < FLT_EPSILON)
+       fabs(resDesktop.fRefreshRate - resolutions[i].fRefreshRate) < FLT_EPSILON &&
+       fabs(resDesktop.fPixelRatio - resolutions[i].fPixelRatio) < FLT_EPSILON)
     {
-      ResDesktop = res_index;
+      ResDesktop = (RESOLUTION)(i + (int)RES_DESKTOP);
     }
 
-    res_index = (RESOLUTION)((int)res_index + 1);
-  }
-
-  // swap desktop index for desktop res if available
-  if (ResDesktop != RES_INVALID)
+  if (ResDesktop == RES_INVALID)
   {
-    CLog::Log(LOGNOTICE, "Found (%dx%d%s@%f) at %d, setting to RES_DESKTOP at %d",
-      resDesktop.iWidth, resDesktop.iHeight,
-      resDesktop.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
-      resDesktop.fRefreshRate,
-      (int)ResDesktop, (int)RES_DESKTOP);
-
-    RESOLUTION_INFO desktop = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP);
-    CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop);
-    CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop) = desktop;
+    ResDesktop = CDisplaySettings::GetInstance().GetDisplayResolution();
+    CLog::Log(LOGNOTICE, "New screen doesn't provide previous resolution. Will change to %d (%s)", ResDesktop,
+                                   CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop).strMode.c_str());
   }
+
+  CDisplaySettings::GetInstance().SetCurrentResolution(ResDesktop);
 }
 
 bool CWinSystemEGL::IsExtSupported(const char* extension)
@@ -475,9 +473,6 @@ void CWinSystemEGL::SetVSyncImpl(bool enable)
     m_iVSyncMode = 0;
     CLog::Log(LOGERROR, "%s,Could not set egl vsync", __FUNCTION__);
   }
-#ifdef HAS_IMXVPU
-  g_IMXContext.SetVSync(enable);
-#endif
 }
 
 void CWinSystemEGL::ShowOSMouse(bool show)
diff --git a/xbmc/windowing/egl/vc_hdmi.h b/xbmc/windowing/egl/vc_hdmi.h
new file mode 100644
index 0000000..c8e21ce
--- /dev/null
+++ b/xbmc/windowing/egl/vc_hdmi.h
@@ -0,0 +1,565 @@
+/*
+Copyright (c) 2012, Broadcom Europe Ltd
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/*
+ * HDMI common host header for TV service, defines resolution code which host applications should
+ * use for power up command for HDMI
+ */
+
+#ifndef _VC_HDMI_H_
+#define _VC_HDMI_H_
+
+#include "guilib/gui3d.h"
+
+typedef int VC_HDMI_BOOL_T;
+
+/**
+ * HDMI resolution groups. There are two main groups: 
+ * CEA - the conventional HDMI ones like 720p
+ * DMT - computer monitor resolutions like XGA
+ */
+typedef enum {
+   HDMI_RES_GROUP_INVALID = 0, /**< Initialised value */
+   HDMI_RES_GROUP_CEA     = 1, /**< CEA - HDMI device */
+   HDMI_RES_GROUP_DMT     = 2, /**< DMT - computer monitors */
+   HDMI_RES_GROUP_CEA_3D  = 3, /* deprecated */
+
+} HDMI_RES_GROUP_T;
+
+
+/**
+ *  CEA 861 defined video code and aspect ratios for various HDMI modes
+ *  Not all values are valid for AVI infoframe
+ */
+typedef enum {
+   HDMI_ASPECT_UNKNOWN  = 0, /**< Unknown aspect ratio, or not one of the values below */
+   HDMI_ASPECT_4_3      = 1, /**< 4:3  */
+   HDMI_ASPECT_14_9     = 2, /**< 14:9 */
+   HDMI_ASPECT_16_9     = 3, /**< 16:9 */
+   HDMI_ASPECT_5_4      = 4, /**< 5:4  */
+   HDMI_ASPECT_16_10    = 5, /**< 16:10*/
+   HDMI_ASPECT_15_9     = 6, /**< 15:9 */
+   HDMI_ASPECT_64_27    = 7, /**< 64:27 */
+   HDMI_ASPECT_21_9     = HDMI_ASPECT_64_27 /**< 21:9 is jargon, 64:27 is the actual aspect ratio */
+   /* More aspect ratio values may be added here if defined by CEA in future */
+} HDMI_ASPECT_T;
+
+/**
+ * Display options set the bounding box (only used in CEA mode)
+ */
+typedef struct {
+   uint16_t aspect; /**<HDMI_ASPECT_T */
+   /** Active area information - meanings as in CEA-861. */
+   uint16_t vertical_bar_present; /**<VC_HDMI_BOOL_T */
+   uint16_t left_bar_width;
+   uint16_t right_bar_width;
+   uint16_t horizontal_bar_present; /**<VC_HDMI_BOOL_T */
+   uint16_t top_bar_height;
+   uint16_t bottom_bar_height;
+   /** S0/S1 flags as defined in CEA-861. */
+   uint8_t         overscan_flags;
+} HDMI_DISPLAY_OPTIONS_T;
+
+/**
+ * HDMI internal state (with some of the properties related to current display signal)
+ * Also see SDTV_DISPLAY_STATE_T in vc_sdtv.h, members up to scan_mode will be in the
+ * same position as the equivalent state in SDTV_DISPLAY_STATE_T;
+ */
+typedef struct {
+   uint32_t state;
+   uint32_t width;
+   uint32_t height;
+   uint16_t frame_rate;
+   uint16_t scan_mode;
+   uint32_t group; /**<HDMI_RES_GROUP_T */
+   uint32_t mode; /* This is the mode number of the format */
+   uint16_t pixel_rep;   /* Pixel repetition factor, only relevant for CEA formats */
+   uint16_t aspect_ratio; /* This is the format's native aspect ratio */
+   HDMI_DISPLAY_OPTIONS_T display_options; /* This has the aspect ratio sent in AVI infoframe */
+   uint16_t pixel_encoding;
+   uint16_t format_3d; /* 3D format, only relevant for CEA formats */
+} HDMI_DISPLAY_STATE_T;
+
+/**
+ * Copy protection for HDMI, only HDCP is available
+ * This enum is to make it consistent with the enums
+ * SDTV_CP_MODE_T in vc_sdtv.h
+ */
+typedef enum {
+   HDMI_CP_NONE         = 0, /**< No copyprotection */
+   HDMI_CP_HDCP         = 1  /**< HDCP 1.x */
+} HDMI_CP_MODE_T;
+
+/**
+ *  HDMI operation modes
+ */
+typedef enum {
+   HDMI_MODE_OFF,  /**< Off! */
+   HDMI_MODE_DVI,  /**< DVI */
+   HDMI_MODE_HDMI, /**< HDMI */
+   HDMI_MODE_3D    /**< HDMI 1.4a 3D */
+} HDMI_MODE_T;
+
+/**
+ * Possible values for the Source Product Description type code (in SPD infoframe).
+ * Taken from the CEA-861 spec.
+ */
+typedef enum {
+   HDMI_SPD_TYPE_UNKNOWN,
+   HDMI_SPD_TYPE_STB,           /**<Digital STB */
+   HDMI_SPD_TYPE_DVD,           /**<DVD player */
+   HDMI_SPD_TYPE_DVHS,          /**<D-VHS */
+   HDMI_SPD_TYPE_HDD_RECORDER,  /**<HDD video recoder */
+   HDMI_SPD_TYPE_DVC,           /**<DVC */
+   HDMI_SPD_TYPE_DSC,           /**<DSC */
+   HDMI_SPD_TYPE_VCD,           /**<Video CD */
+   HDMI_SPD_TYPE_GAME,          /**<Game */
+   HDMI_SPD_TYPE_PC,            /**<PC general */
+   HDMI_SPD_TYPE_BD,            /**<Blu-Ray Disc */
+   HDMI_SPD_TYPE_SACD,          /**<Super Audio CD */
+   HDMI_SPD_TYPE_HDDVD,         /**<HD DVD */
+   HDMI_SPD_TYPE_PMP            /**<Personal media player */
+} HDMI_SPD_TYPE_CODE_T;
+
+/**
+ * Structure for SPD infoframe
+ */
+typedef struct {
+   char  *manufacturer;        /**< Manufacture name (up to 8 characters) */
+   char  *description;         /**< Product name (up to 16 characters) */
+   HDMI_SPD_TYPE_CODE_T type;  /**< Product type */
+} HDMI_SPD_DATA_T;
+
+/**
+ * These are CEA mode numbers (sent in AVI infoframe) for different resolutions as define in CEA-861
+ * 1080i at 100/120Hz (40,46) are supported by HDMI H/W but note we cannot
+ * display the debug overlay under these modes.
+ * Some modes have two codes, the first one has aspect ratio 4:3 and
+ * the second one (with "H" suffix") 16:9.
+ * The modes with "4x", etc. are the same the corresponding "non-multiplied" modes
+ * but clocked at a higher pixel clock.
+ */
+typedef enum {
+   HDMI_CEA_VGA             =  1,
+   HDMI_CEA_480p60          =  2,
+   HDMI_CEA_480p60H         =  3,
+   HDMI_CEA_720p60          =  4,
+   HDMI_CEA_1080i60         =  5,
+   HDMI_CEA_480i60          =  6,
+   HDMI_CEA_480i60H         =  7,
+   HDMI_CEA_240p60          =  8,
+   HDMI_CEA_240p60H         =  9,
+   HDMI_CEA_480i60_4x       = 10,
+   HDMI_CEA_480i60_4xH      = 11,
+   HDMI_CEA_240p60_4x       = 12,
+   HDMI_CEA_240p60_4xH      = 13,
+   HDMI_CEA_480p60_2x       = 14,
+   HDMI_CEA_480p60_2xH      = 15,
+   HDMI_CEA_1080p60         = 16,
+   HDMI_CEA_576p50          = 17,
+   HDMI_CEA_576p50H         = 18,
+   HDMI_CEA_720p50          = 19,
+   HDMI_CEA_1080i50         = 20,
+   HDMI_CEA_576i50          = 21,
+   HDMI_CEA_576i50H         = 22,
+   HDMI_CEA_288p50          = 23,
+   HDMI_CEA_288p50H         = 24,
+   HDMI_CEA_576i50_4x       = 25,
+   HDMI_CEA_576i50_4xH      = 26,
+   HDMI_CEA_288p50_4x       = 27,
+   HDMI_CEA_288p50_4xH      = 28,
+   HDMI_CEA_576p50_2x       = 29,
+   HDMI_CEA_576p50_2xH      = 30,
+   HDMI_CEA_1080p50         = 31,
+   HDMI_CEA_1080p24         = 32,
+   HDMI_CEA_1080p25         = 33,
+   HDMI_CEA_1080p30         = 34,
+   HDMI_CEA_480p60_4x       = 35,
+   HDMI_CEA_480p60_4xH      = 36,
+   HDMI_CEA_576p50_4x       = 37,
+   HDMI_CEA_576p50_4xH      = 38,
+   HDMI_CEA_1080i50_rb      = 39,
+   HDMI_CEA_1080i100        = 40,
+   HDMI_CEA_720p100         = 41,
+   HDMI_CEA_576p100         = 42,
+   HDMI_CEA_576p100H        = 43,
+   HDMI_CEA_576i100         = 44,
+   HDMI_CEA_576i100H        = 45,
+   HDMI_CEA_1080i120        = 46,
+   HDMI_CEA_720p120         = 47,
+   HDMI_CEA_480p120         = 48,
+   HDMI_CEA_480p120H        = 49,
+   HDMI_CEA_480i120         = 50,
+   HDMI_CEA_480i120H        = 51,
+   HDMI_CEA_576p200         = 52,
+   HDMI_CEA_576p200H        = 53,
+   HDMI_CEA_576i200         = 54,
+   HDMI_CEA_576i200H        = 55,
+   HDMI_CEA_480p240         = 56,
+   HDMI_CEA_480p240H        = 57,
+   HDMI_CEA_480i240         = 58,
+   HDMI_CEA_480i240H        = 59,
+   HDMI_CEA_720p24          = 60,
+   HDMI_CEA_720p25          = 61,
+   HDMI_CEA_720p30          = 62,
+   HDMI_CEA_1080p120        = 63,
+   HDMI_CEA_1080p100        = 64,
+
+   /* Up-to-date as of CEA 861-E */
+
+   HDMI_CEA_OFF = 0xff /**<Special code to shutdown HDMI */
+
+} HDMI_CEA_RES_CODE_T;
+
+/**
+ * These are the DMT modes from VESA. They are used for powering up
+ * HDMI in DMT resolutions and are not sent in AVI infoframes.
+ * Enum is ordered as ascending order of DMT id.
+ * All reduced blanking formats are 60Hz unless stated otherwise.
+ */
+typedef enum {
+   HDMI_DMT_640x350_85      = 0x1,  /**<640x350 */
+   HDMI_DMT_640x400_85      = 0x2,  /**<640x400 */
+   HDMI_DMT_IBM_VGA_85      = 0x3,  /**<720x400 */
+   HDMI_DMT_VGA_60          = 0x4,  /**<640x480 (60Hz is same as VGA above) */
+   HDMI_DMT_VGA_72          = 0x5,
+   HDMI_DMT_VGA_75          = 0x6,
+   HDMI_DMT_VGA_85          = 0x7,
+   HDMI_DMT_SVGA_56         = 0x8,  /**<800x600 */
+   HDMI_DMT_SVGA_60         = 0x9,
+   HDMI_DMT_SVGA_72         = 0xA,
+   HDMI_DMT_SVGA_75         = 0xB,
+   HDMI_DMT_SVGA_85         = 0xC,
+   HDMI_DMT_SVGA_120        = 0xD,
+   HDMI_DMT_848x480_60      = 0xE,  /**<848x480 */
+   HDMI_DMT_XGA_43          = 0xF,  /**<1024x768 - interlaced, DO NOT USE */
+   HDMI_DMT_XGA_60          = 0x10, /**<1024x768 */
+   HDMI_DMT_XGA_70          = 0x11,
+   HDMI_DMT_XGA_75          = 0x12,
+   HDMI_DMT_XGA_85          = 0x13,
+   HDMI_DMT_XGA_120         = 0x14,
+   HDMI_DMT_XGAP_75         = 0x15, /**<1152x864 */
+   HDMI_DMT_WXGA_RB         = 0x16, /**<1280x768 reduced blanking */
+   HDMI_DMT_WXGA_60         = 0x17,
+   HDMI_DMT_WXGA_75         = 0x18,
+   HDMI_DMT_WXGA_85         = 0x19,
+   HDMI_DMT_WXGA_120        = 0x1A, /**<120Hz with reduced blanking */
+   HDMI_DMT_1280x800_RB     = 0x1B, /**<1280x800 reduced blanking */
+   HDMI_DMT_1280x800_60     = 0x1C,
+   HDMI_DMT_1280x800_75     = 0x1D,
+   HDMI_DMT_1280x800_85     = 0x1E,
+   HDMI_DMT_1280x800_120    = 0x1F, /** reduced blanking */
+   HDMI_DMT_1280x960_60     = 0x20, /**<1280x960 */
+   HDMI_DMT_1280x960_85     = 0x21,
+   HDMI_DMT_1280x960_120    = 0x22, /** reduced blanking */
+   HDMI_DMT_SXGA_60         = 0x23, /**<1280x1024 */
+   HDMI_DMT_SXGA_75         = 0x24,
+   HDMI_DMT_SXGA_85         = 0x25,
+   HDMI_DMT_SXGA_120        = 0x26, /** reduced blanking */
+   HDMI_DMT_1360x768_60     = 0x27, /**<1360x768 */
+   HDMI_DMT_1360x768_120    = 0x28, /**<120 Hz with reduced blanking */
+   HDMI_DMT_SXGAP_RB        = 0x29, /**<1400x1050 reduced blanking */
+   HDMI_DMT_SXGAP_60        = 0x2A,
+   HDMI_DMT_SXGAP_75        = 0x2B,
+   HDMI_DMT_SXGAP_85        = 0x2C,
+   HDMI_DMT_SXGAP_120       = 0x2D, /** reduced blanking */
+   HDMI_DMT_1440x900_RB     = 0x2E, /**<1440x900 reduced blanking */
+   HDMI_DMT_1440x900_60     = 0x2F,
+   HDMI_DMT_1440x900_75     = 0x30,
+   HDMI_DMT_1440x900_85     = 0x31,
+   HDMI_DMT_1440x900_120    = 0x32, /** reduced blanking */
+   HDMI_DMT_UXGA_60         = 0x33, /**<1600x1200 60Hz */
+   HDMI_DMT_UXGA_65         = 0x34, 
+   HDMI_DMT_UXGA_70         = 0x35, 
+   HDMI_DMT_UXGA_75         = 0x36, 
+   HDMI_DMT_UXGA_85         = 0x37, 
+   HDMI_DMT_UXGA_120        = 0x38, /** reduced blanking */
+   HDMI_DMT_SWXGAP_RB       = 0x39, /**<1680x1050 reduced blanking */
+   HDMI_DMT_SWXGAP_60       = 0x3A, /**<1680x1050 60Hz */
+   HDMI_DMT_SWXGAP_75       = 0x3B, 
+   HDMI_DMT_SWXGAP_85       = 0x3C, 
+   HDMI_DMT_SWXGAP_120      = 0x3D, /** reduced blanking */ 
+   HDMI_DMT_1792x1344_60    = 0x3E, /**<1792x1344 60Hz */
+   HDMI_DMT_1792x1344_75    = 0x3F, /**<1792x1344 75Hz */
+   HDMI_DMT_1792x1344_120   = 0x40, /** reduced blanking */
+   HDMI_DMT_1856x1392_60    = 0x41, /**<1856x1392 60Hz */
+   HDMI_DMT_1856x1392_75    = 0x42, /**<1856x1392 75Hz */
+   HDMI_DMT_1856x1392_120   = 0x43, /** reduced blanking */
+   HDMI_DMT_WUXGA_RB        = 0x44, /**<1920x1200 reduced blanking */
+   HDMI_DMT_WUXGA_60        = 0x45, /**<1920x1200 60Hz */
+   HDMI_DMT_WUXGA_75        = 0x46, /**<1920x1200 75Hz */
+   HDMI_DMT_WUXGA_85        = 0x47, /**<1920x1200 85Hz */
+   HDMI_DMT_WUXGA_120       = 0x48, /** reduced blanking */
+   HDMI_DMT_1920x1440_60    = 0x49, /**<1920x1440 60Hz */
+   HDMI_DMT_1920x1440_75    = 0x4A, /**<1920x1440 75Hz */
+   HDMI_DMT_1920x1440_120   = 0x4B, /** reduced blanking */
+   HDMI_DMT_2560x1600_RB    = 0x4C, /**<2560x1600 reduced blanking */
+   HDMI_DMT_2560x1600_60    = 0x4D, /**<2560x1600 60 Hz */
+   HDMI_DMT_2560x1600_75    = 0x4E, /**<2560x1600 75 Hz */
+   HDMI_DMT_2560x1600_85    = 0x4E, /**<2560x1600 85 Hz */
+   HDMI_DMT_2560x1600_120   = 0x50, /** reduced blanking */
+   HDMI_DMT_1366x768_60     = 0x51, /**<1366x768 60Hz */
+   HDMI_DMT_1080p_60        = 0x52, /**<Same as 1080p60 above */
+   HDMI_DMT_1600x900_RB     = 0x53, /**<1600x900 reduced blanking */
+   HDMI_DMT_2048x1152_RB    = 0x54, /**<2048x1152 reduced blanking */
+   HDMI_DMT_720p_60         = 0x55, /**<Same as 720p60 above */
+   HDMI_DMT_1366x768_RB     = 0x56, /**<1366x768 reduced blanking */
+   /* Up-to-date as of VESA DMT v1 r12 */
+
+   HDMI_DMT_OFF = 0xff
+} HDMI_DMT_RES_CODE_T;
+
+/**
+ * HDMI scanmode
+ */
+typedef enum {
+   HDMI_NONINTERLACED,
+   HDMI_INTERLACED
+} HDMI_INTERLACED_T;
+
+/**
+ * Preference for powering up HDMI using best mode
+ * Note we will only use CEA modes for matching
+ */
+typedef enum {
+   HDMI_MODE_MATCH_NONE          = 0x0, /**<No mode*/
+   HDMI_MODE_MATCH_FRAMERATE     = 0x1, /**<Match based on frame rate */
+   HDMI_MODE_MATCH_RESOLUTION    = 0x2, /**<Match based on resolution */
+   HDMI_MODE_MATCH_SCANMODE      = 0x4  /**<Match based on scan mode */
+} EDID_MODE_MATCH_FLAG_T;
+
+/**
+ * Audio support flags
+ */
+typedef enum {
+   EDID_AUDIO_NO_SUPPORT         = (1 << 0), /**<No support for that format */
+   EDID_AUDIO_CHAN_UNSUPPORTED   = (1 << 1), /**<max. no. of channels exceeded */
+   EDID_AUDIO_FS_UNSUPPORTED     = (1 << 2), /**<no support for that sampling frequency */
+   EDID_AUDIO_BR_UNSUPPORTED     = (1 << 3), /**<max. bitrate exceeded */
+   EDID_AUDIO_SAMP_UNSUPPORTED   = (1 << 4), /**sample size unsupported (pcm only) */
+} EDID_AUDIO_SUPPORT_FLAG_T;
+
+/**
+ * Enums for audio support in audio descriptor block (CEA only)
+ * audio formats as specified in CEA Short Audio Descriptors
+ */
+typedef enum {
+   EDID_AudioFormat_eReserved,      /**<Refer to header when set in audio info frame */
+   EDID_AudioFormat_ePCM,           /**<Plain old PCM, mandatory for any audio support */
+   EDID_AudioFormat_eAC3,           /**<AC3 */
+   EDID_AudioFormat_eMPEG1,         /**<Mpeg layer 1 and 2 */
+   EDID_AudioFormat_eMP3,           /**<Mpeg layer 3 */
+   EDID_AudioFormat_eMPEG2,         /**<Mpeg 2 audio */
+   EDID_AudioFormat_eAAC,           /**<AAC */
+   EDID_AudioFormat_eDTS,           /**<DTS */
+   EDID_AudioFormat_eATRAC,         /**<Sony proprietary */
+   EDID_AudioFormat_eDSD,           /**<Super Audio CD 1-bit audio */
+   EDID_AudioFormat_eEAC3,          /**<Dolby Digital + */
+   EDID_AudioFormat_eDTS_HD,        /**<DTS-HD */
+   EDID_AudioFormat_eMLP,           /**<Meridian Lossless Packing - for DVD audio */
+   EDID_AudioFormat_eDST,           /**<Direct stream transfer - compressed super audio CD */
+   EDID_AudioFormat_eWMAPRO,        /**<WMA Pro */
+   EDID_AudioFormat_eExtended,      /**<Refer to byte 3 of audio db for coding extension type */
+
+   EDID_AudioFormat_eMaxCount
+} EDID_AudioFormat;
+
+/**
+ * If audio format is set to EDID_AudioFormat_eExtended,
+ * this gives the extended audio type (see CEA-861E section 6.6.1)
+ */
+typedef enum {
+   EDID_AudioCodingExtension_NONE    = 0x0, /** no extension, for audio format != Extended */
+   EDID_AudioCodingExtension_HEAAC   = 0x1, /**<HE-AAC */
+   EDID_AudioCodingExtension_HEAAC2  = 0x2, /**<HE-AAC v2 */
+   EDID_AudioCodingExtension_MPEGSUR = 0x3, /**<MPEG Surround */
+
+   EDID_AudioCodingExtension_max
+} EDID_AudioCodingExtension;
+
+/**
+ * Audio sample rates as specified in CEA Short Audio Descriptors
+ */
+typedef enum {
+   EDID_AudioSampleRate_eReferToHeader = 0x0,      /**<Only used in audio infoframe */
+   EDID_AudioSampleRate_e32KHz         = (1 << 0), /**<32 kHz (mandatory) */
+   EDID_AudioSampleRate_e44KHz         = (1 << 1), /**<44.1 kHz (mandatory) */
+   EDID_AudioSampleRate_e48KHz         = (1 << 2), /**<48kHz (mandatory) */
+   EDID_AudioSampleRate_e88KHz         = (1 << 3), /**<88.2 kHz */
+   EDID_AudioSampleRate_e96KHz         = (1 << 4), /**<96kHz */
+   EDID_AudioSampleRate_e176KHz        = (1 << 5), /**<176.4 kHz */
+   EDID_AudioSampleRate_e192KHz        = (1 << 6)  /**<192 kHz */
+} EDID_AudioSampleRate;
+
+/**
+ * Audio sample sizes (L-PCM) as specified in CEA Short Audio Descriptors
+ */
+typedef enum {
+   EDID_AudioSampleSize_refertoheader = 0x0, /**<Only used in audio infoframe */
+   EDID_AudioSampleSize_16bit         = 0x1, /**<16-bit samples (mandatory) */
+   EDID_AudioSampleSize_20bit         = 0x2, /**<20-bit samples */
+   EDID_AudioSampleSize_24bit         = 0x4  /**<24-bit samples */
+} EDID_AudioSampleSize;
+
+/**
+ *  LFE feedback level as described in audio db
+ */
+typedef enum {
+   EDID_AudioLFEFB_UNKNOWN = 0x0, /**<Refer to other information */
+   EDID_AudioLFEFB_0dB     = 0x1, /**<0dB - same level as other channels */
+   EDID_AudioLFEFB_10dB    = 0x2  /**<+10dB relative to other channels */
+} EDID_AudioLFEFB;
+
+/**
+ * All possible 3D structures
+ * to be used in decoded 3D modes (e.g. HDMI_3D_SUPPORTED_MODE)
+ */
+typedef enum {
+   HDMI_3D_STRUCT_NONE                                   = 0,
+   HDMI_3D_STRUCT_FRAME_PACKING                          = (1<<0),
+   HDMI_3D_STRUCT_FIELD_ALTERNATIVE                      = (1<<1),
+   HDMI_3D_STRUCT_LINE_ALTERNATIVE                       = (1<<2),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_FULL                      = (1<<3),
+   HDMI_3D_STRUCT_L_DEPTH                                = (1<<4),
+   HDMI_3D_STRUCT_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH        = (1<<5),
+   HDMI_3D_STRUCT_TOP_AND_BOTTOM                         = (1<<6),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_HORIZONTAL           = (1<<7),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_ODD_RIGHT   = (1<<8),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_ODD_LEFT_EVEN_RIGHT  = (1<<9),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_ODD_RIGHT  = (1<<10),
+   HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_EVEN_LEFT_EVEN_RIGHT = (1<<11),
+   HDMI_3D_STRUCT_FRAME_SEQUENTIAL                       = (1<<12),
+} HDMI_3D_STRUCT_T;
+
+/**
+ * HDMI notifications (defined as a bit mask to be conveniently returned as a state),
+ * make sure this does not clash with the values in vc_sdtv.h
+ * SDTV notifications start at bit 16.
+ * These values are returned by the TV service in a callback.
+ */
+typedef enum {
+   VC_HDMI_UNPLUGGED          = (1 << 0),  /**<HDMI cable is detached */
+   VC_HDMI_ATTACHED           = (1 << 1),  /**<HDMI cable is attached but not powered on */
+   VC_HDMI_DVI                = (1 << 2),  /**<HDMI is on but in DVI mode (no audio) */
+   VC_HDMI_HDMI               = (1 << 3),  /**<HDMI is on and HDMI mode is active */
+   VC_HDMI_HDCP_UNAUTH        = (1 << 4),  /**<HDCP authentication is broken (e.g. Ri mismatched) or not active */
+   VC_HDMI_HDCP_AUTH          = (1 << 5),  /**<HDCP is active */
+   VC_HDMI_HDCP_KEY_DOWNLOAD  = (1 << 6),  /**<HDCP key download successful/fail */
+   VC_HDMI_HDCP_SRM_DOWNLOAD  = (1 << 7),  /**<HDCP revocation list download successful/fail */
+   VC_HDMI_CHANGING_MODE      = (1 << 8),  /**<HDMI is starting to change mode, clock has not yet been set */
+
+} VC_HDMI_NOTIFY_T;
+#define VC_HDMI_STANDBY (VC_HDMI_ATTACHED) /* For backward code compatibility */
+
+/**
+ * Callback reason and arguments from HDMI middleware
+ * Each callback comes with two optional uint32_t parameters.
+ * Reason                     param1       param2      remark
+ * VC_HDMI_UNPLUGGED            -            -         cable is unplugged
+ * VC_HDMI_STANDBY            CEA/DMT      mode code   cable is plugged in and peripheral powered off (preferred mode sent back if available)
+ * VC_HDMI_DVI                CEA/DMT      mode code   DVI mode is active at said resolution
+ * VC_HDMI_HDMI               CEA(3D)/DMT  mode code   HDMI mode is active at said resolution (in 3D mode if CEA3D)
+ * VC_HDMI_HDCP_UNAUTH        HDCP_ERROR_T  retry?     HDCP is inactive, the error can be none if we actively disable HDCP, if retry is non-zero, HDCP will attempt to reauthenticate
+ * VC_HDMI_HDCP_AUTH            -            -         HDCP is active
+ * VC_HDMI_HDCP_KEY_DOWNLOAD  success?       -         HDCP key download success (zero) or not (non zero)
+ * VC_HDMI_HDCP_SRM_DOWNLOAD  no. of keys    -         HDCP revocation list download set no. of keys (zero means failure)
+ * VC_HDMI_CHANGING_MODE        0            0         No information is supplied in this callback
+ */
+
+/* Some constants which are required on host side */
+#define HDCP_KEY_BLOCK_SIZE 328 /* KSV, padding, device keys and hash. */
+#define HDCP_KSV_LENGTH   5
+#define HDCP_MAX_DEVICE 127 /* Max. number of HDCP downstream device supported */
+#define HDCP_MAX_DEPTH 7 /* Max. number of levels HDCP 1.x can have */
+#define EDID_BLOCKSIZE 128
+#define HDMI_NUM_PACKET_BYTES 28 /* Size of HDMI infoframes minus the header */
+#define HDMI_MAX_EXPLICIT_3D_MODES 31 /* The number of explicit 3D modes is stored in 5 bits */
+#define EDID_MONITOR_DESC_SIZE  18 /* Size of detailed timing descriptor in EDID */
+#define EDID_DESC_HEADER_LEN     5 /* Size of detailed timing descriptor header in EDID */
+#define EDID_DESC_ASCII_STRING_LEN (EDID_MONITOR_DESC_SIZE - EDID_DESC_HEADER_LEN)
+#define EDID_DEVICE_VENDOR_ID_LENGTH 3 /* Expanded Device Vendor ID length in EDID */
+
+/* All CEC related constants now reside in vc_cec.h */
+
+/**
+ * General callback function for both HDMI and HDCP middleware
+ * reason is the notification nature
+ * param1 and param2 have different meanings depending on the notification (see above)
+ *
+ * @param client_p is the callback context
+ *
+ * @param reason is the callback reason
+ *
+ * @param param1 is the first callback argument (meaning as above)
+ *
+ * @param param2 is the second callback argument (meaning as above)
+ *
+ * @return void
+ */
+typedef void (*HDMI_CALLBACK_T)(void *client_p, VC_HDMI_NOTIFY_T reason, uint32_t param1, uint32_t param2);
+
+/* TV service error return code */
+typedef enum {
+   VC_HDMI_SUCCESS                  = 0, /** OK */
+   VC_HDMI_ERROR_FORMAT_UNSUPPORTED = 1, /** format not supported */
+   VC_HDMI_ERROR_INVALID_FORMAT     = 2, /** invalid format */
+   VC_HDMI_ERROR_INVALID_PROPERTY   = 3, /** invalid property */
+   VC_HDMI_ERROR_OUT_OF_RANGE       = 4, /** invalid values passed to set property */
+   VC_HDMI_ERROR_INVALID_INFOFRAME  = 5, /** invalid infoframe */
+} VC_HDMI_ERROR_T;
+
+/* Defines for backward code compatibilty (these were originally in hdmi.h) */
+typedef VC_HDMI_ERROR_T HDMI_RESULT_T;
+#define HDMI_RESULT_SUCCESS (VC_HDMI_SUCCESS)
+#define HDMI_RESULT_FAILED  (VC_HDMI_ERROR_FORMAT_UNSUPPORTED)
+
+#endif /*_VC_HDMI_H_*/
+
+#ifndef HDMI_RES_GROUP_NAME
+#define HDMI_RES_GROUP_NAME(g) \
+   (((g) == HDMI_RES_GROUP_INVALID) ? "Invalid" : \
+   (((g) == HDMI_RES_GROUP_CEA) ? "CEA" : \
+   (((g) == HDMI_RES_GROUP_DMT) ? "DMT" : \
+    "Unknown")))
+
+#define IS_WIDESCREEN(m) ( m == 3 || m == 7 || m == 9 || \
+    m == 11 || m == 13 || m == 15 || m == 18 || m == 22 || \
+    m == 24 || m == 26 || m == 28 || m == 30 || m == 36 || \
+    m == 38 || m == 43 || m == 45 || m == 49 || m == 51 || \
+    m == 53 || m == 55 || m == 57 || m == 59)
+
+#define MAKEFLAGS(group, mode, interlace) \
+  ( ( (mode)<<24 ) | ( (group)<<16 ) | \
+   ( (interlace) != 0 ? D3DPRESENTFLAG_INTERLACED : D3DPRESENTFLAG_PROGRESSIVE) | \
+   ( ((group) == HDMI_RES_GROUP_CEA && IS_WIDESCREEN(mode) ) ? D3DPRESENTFLAG_WIDESCREEN : 0) )
+
+#define GETFLAGS_GROUP(f)       ( (HDMI_RES_GROUP_T)( ((f) >> 16) & 0xff ))
+#define GETFLAGS_MODE(f)        ( ( (f) >>24 ) & 0xff )
+
+#define IS_3D(f)                ( f & (D3DPRESENTFLAG_MODE3DSBS | D3DPRESENTFLAG_MODE3DTB) )
+
+#endif /*HDMI_RES_GROUP_NAME*/
-- 
2.7.4

