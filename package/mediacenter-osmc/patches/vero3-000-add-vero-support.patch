diff --git a/cmake/modules/FindAML.cmake b/cmake/modules/FindAML.cmake
new file mode 100644
index 0000000000..89d1fd985d
--- /dev/null
+++ b/cmake/modules/FindAML.cmake
@@ -0,0 +1,49 @@
+#.rst:
+# FindAML
+# -------
+# Finds the AML codec
+#
+# This will define the following variables::
+#
+# AML_FOUND - system has AML
+# AML_INCLUDE_DIRS - the AML include directory
+# AML_DEFINITIONS - the AML definitions
+#
+# and the following imported targets::
+#
+#   AML::AML   - The AML codec
+
+find_path(AML_INCLUDE_DIR codec_error.h
+                          PATH_SUFFIXES amcodec)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(AML
+                                  REQUIRED_VARS AML_INCLUDE_DIR)
+
+include(CheckCSourceCompiles)
+set(CMAKE_REQUIRED_INCLUDES ${AML_INCLUDE_DIR})
+check_c_source_compiles("#include <amcodec/codec.h>
+
+                         int main()
+                         {
+                           int i = VIDEO_DEC_FORMAT_VP9;
+                           return 0;
+                         }
+                         " AML_HAS_VP9)
+
+if(AML_FOUND)
+  set(AML_INCLUDE_DIRS ${AML_INCLUDE_DIR})
+  set(AML_DEFINITIONS -DHAS_LIBAMCODEC=1)
+  if(AML_HAS_VP9)
+    list(APPEND AML_DEFINITIONS -DHAS_LIBAMCODEC_VP9=1)
+  endif()
+
+  if(NOT TARGET AML::AML)
+    add_library(AML::AML UNKNOWN IMPORTED)
+    set_target_properties(AML::AML PROPERTIES
+                                   INTERFACE_INCLUDE_DIRECTORIES "${AML_INCLUDE_DIR}"
+                                   INTERFACE_COMPILE_DEFINITIONS HAS_LIBAMCODEC=1)
+  endif()
+endif()
+
+mark_as_advanced(AMLCODEC_INCLUDE_DIR)
diff --git a/cmake/modules/FindFFMPEG.cmake b/cmake/modules/FindFFMPEG.cmake
index fedbf0adde..6da66c8b27 100644
--- a/cmake/modules/FindFFMPEG.cmake
+++ b/cmake/modules/FindFFMPEG.cmake
@@ -96,7 +96,11 @@ macro(buildFFMPEG)
                  -DPKG_CONFIG_PATH=${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/lib/pkgconfig)
   set(PATCH_COMMAND ${CMAKE_COMMAND} -E copy
                     ${CMAKE_SOURCE_DIR}/tools/depends/target/ffmpeg/CMakeLists.txt
-                    <SOURCE_DIR>)
+                    <SOURCE_DIR> &&
+                    /bin/bash -c "patch -p1 < ${CMAKE_SOURCE_DIR}/tools/depends/target/ffmpeg/0001-added_upstream_mvc_patches.patch"
+                    /bin/bash -c "patch -p1 < ${CMAKE_SOURCE_DIR}/tools/depends/target/ffmpeg/0002-increase-max-pes-payload-limit.patch"
+                    /bin/bash -c "patch -p1 < ${CMAKE_SOURCE_DIR}/tools/depends/target/ffmpeg/0003-MKV-added-basic-block-addition-mapping-support-and-i.patch"
+)
 
   if(CMAKE_GENERATOR STREQUAL Xcode)
     set(FFMPEG_GENERATOR CMAKE_GENERATOR "Unix Makefiles")
diff --git a/cmake/platform/linux/aml.cmake b/cmake/platform/linux/aml.cmake
new file mode 100644
index 0000000000..4206c283e2
--- /dev/null
+++ b/cmake/platform/linux/aml.cmake
@@ -0,0 +1,2 @@
+list(APPEND PLATFORM_REQUIRED_DEPS OpenGLES AML EGL LibInput Xkbcommon)
+set(APP_RENDER_SYSTEM gles)
diff --git a/cmake/scripts/android/ArchSetup.cmake b/cmake/scripts/android/ArchSetup.cmake
index 2fe85fe2f7..cd3f4a8526 100644
--- a/cmake/scripts/android/ArchSetup.cmake
+++ b/cmake/scripts/android/ArchSetup.cmake
@@ -39,6 +39,7 @@ endif()
 list(APPEND SYSTEM_DEFINES -DHAS_ZEROCONF)
 
 set(ENABLE_X11 OFF CACHE BOOL "" FORCE)
+set(ENABLE_AML OFF CACHE BOOL "" FORCE)
 set(ENABLE_OPTICAL OFF CACHE BOOL "" FORCE)
 set(ENABLE_MDNS OFF CACHE BOOL "" FORCE)
 
diff --git a/cmake/scripts/common/ArchSetup.cmake b/cmake/scripts/common/ArchSetup.cmake
index a59fcb52f7..c9b5a1ce34 100644
--- a/cmake/scripts/common/ArchSetup.cmake
+++ b/cmake/scripts/common/ArchSetup.cmake
@@ -160,11 +160,6 @@ if(NOT MSVC)
   # these options affect all code built by cmake including external projects.
   add_options(ALL_LANGUAGES ALL_BUILDS
     -Wall
-    -Wdouble-promotion
-    -Wmissing-field-initializers
-    -Wsign-compare
-    -Wextra
-    -Wno-unused-parameter # from -Wextra
   )
 
   if(CMAKE_COMPILER_IS_GNUCXX)
@@ -188,13 +183,6 @@ if(NOT MSVC)
   )
 
   # these options affect only core code
-  if(NOT CORE_COMPILE_OPTIONS)
-    set(CORE_COMPILE_OPTIONS
-      -Werror=double-promotion
-      -Werror=missing-field-initializers
-      -Werror=sign-compare
-    )
-  endif()
 endif()
 
 # set for compile info to help detect binary addons
diff --git a/cmake/scripts/common/Platform.cmake b/cmake/scripts/common/Platform.cmake
index 397d8d46e8..7a4a35a31b 100644
--- a/cmake/scripts/common/Platform.cmake
+++ b/cmake/scripts/common/Platform.cmake
@@ -3,9 +3,9 @@ if(NOT CORE_SYSTEM_NAME)
 endif()
 
 if(CORE_SYSTEM_NAME STREQUAL linux OR CORE_SYSTEM_NAME STREQUAL freebsd)
-  # Set default CORE_PLATFORM_NAME to X11 WAYLAND GBM
+  # Set default CORE_PLATFORM_NAME to X11 WAYLAND AML GBM
   # This is overridden by user setting -DCORE_PLATFORM_NAME=<platform>
-  set(_DEFAULT_PLATFORM X11 WAYLAND GBM)
+  set(_DEFAULT_PLATFORM X11 WAYLAND AML GBM)
 
   if(NOT APP_RENDER_SYSTEM)
     message(SEND_ERROR "You need to decide whether you want to use GL- or GLES-based rendering. Please set APP_RENDER_SYSTEM to either \"gl\" or \"gles\". For normal desktop systems, you will usually want to use \"gl\".")
diff --git a/cmake/treedata/common/aml/aml.txt b/cmake/treedata/common/aml/aml.txt
new file mode 100644
index 0000000000..1e4856fcd4
--- /dev/null
+++ b/cmake/treedata/common/aml/aml.txt
@@ -0,0 +1,2 @@
+xbmc/cores/RetroPlayer/process/amlogic cores/RetroPlayer/process/amlogic
+xbmc/windowing/amlogic windowing/amlogic
diff --git a/system/keymaps/remote.xml b/system/keymaps/remote.xml
index c122b99188..5a6ad165af 100644
--- a/system/keymaps/remote.xml
+++ b/system/keymaps/remote.xml
@@ -50,7 +50,7 @@
       <volumeplus>VolumeUp</volumeplus>
       <volumeminus>VolumeDown</volumeminus>
       <mute>Mute</mute>
-      <power>ShutDown()</power>
+      <power>noop</power>
       <myvideo>ActivateWindow(Videos)</myvideo>
       <mymusic>ActivateWindow(Music)</mymusic>
       <mypictures>ActivateWindow(Pictures)</mypictures>
diff --git a/system/settings/linux.xml b/system/settings/linux.xml
index 531974f3f4..9b85a3bf92 100644
--- a/system/settings/linux.xml
+++ b/system/settings/linux.xml
@@ -223,11 +223,6 @@
           </constraints>
           <control type="list" format="string" />
         </setting>
-        <setting id="videoscreen.limitedrange" type="boolean" label="36042" help="36359">
-          <level>3</level>
-          <default>false</default>
-          <control type="toggle" />
-        </setting>
       </group>
     </category>
     <category id="input">
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index ff555db738..6289c2747c 100755
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -87,6 +87,7 @@
               <option label="634">4</option> <!-- ViewModeStretch16x9 -->
               <option label="644">7</option> <!-- ViewModeStretch16x9 - nonlinear -->
               <option label="631">1</option> <!-- ViewModeZoom -->
+              <option label="10636">10</option> <!-- ViewModeHDMIAVI -->
             </options>
           </constraints>
           <control type="list" format="string" />
@@ -113,6 +114,125 @@
             <formatlabel>14047</formatlabel>
           </control>
         </setting>
+        <setting id="videoplayer.useamcodec" type="boolean" label="13438" help="36439">
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>true</default>
+          <updates>
+            <update type="change" />
+          </updates>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoplayer.useamcodecmpeg2" type="integer" label="39001" >
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <options>
+              <option label="20420">9999</option>   <!-- Never -->
+              <option label="39000">800</option>  <!-- HD -->
+              <option label="20422">0</option>  <!-- Always -->
+            </options>
+          </constraints>
+          <updates>
+            <update type="change" />
+          </updates>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useamcodec" operator="is">true</condition> <!-- USE AMCODEC -->
+            </dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
+        <setting id="videoplayer.useamcodecmpeg4" type="integer" label="39002">
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>800</default>
+          <constraints>
+            <options>
+              <option label="20420">9999</option>   <!-- Never -->
+              <option label="39000">800</option>  <!-- HD -->
+              <option label="20422">0</option>  <!-- Always -->
+            </options>
+          </constraints>
+          <updates>
+            <update type="change" />
+          </updates>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useamcodec" operator="is">true</condition> <!-- USE AMCODEC -->
+            </dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
+        <setting id="videoplayer.useamcodech264" type="integer" label="39003">
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <options>
+              <option label="20420">9999</option>   <!-- Never -->
+              <option label="39000">800</option>  <!-- HD -->
+              <option label="20422">0</option>  <!-- Always -->
+            </options>
+          </constraints>
+          <updates>
+            <update type="change" />
+          </updates>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useamcodec" operator="is">true</condition> <!-- USE AMCODEC -->
+            </dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
+        <setting id="videoplayer.useamcodecav1" type="integer" label="38999">
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <options>
+              <option label="20420">9999</option>   <!-- Never -->
+              <option label="20422">0</option>  <!-- Always -->
+            </options>
+          </constraints>
+          <updates>
+            <update type="change" />
+          </updates>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useamcodec" operator="is">true</condition> <!-- USE AMCODEC -->
+            </dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
+        <setting id="videoplayer.amlhdrmodes" type="integer" label="34210" help="34211">
+          <requirement>HAVE_AMCODEC</requirement>
+          <level>2</level>
+          <default>2</default>
+          <constraints>
+            <options>
+              <option label="34212">2</option>   <!-- Auto -->
+              <option label="34213">0</option>  <!-- passthrough -->
+              <option label="34214">1</option>  <!-- HDR-SDR -->
+              <option label="34215">3</option>  <!-- HDR-BT2020SDR -->
+            </options>
+          </constraints>
+          <updates>
+            <update type="change" />
+          </updates>
+          <dependencies>
+            <dependency type="enable">
+              <condition setting="videoplayer.useamcodec" operator="is">true</condition> <!-- USE AMCODEC -->
+            </dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
         <setting id="videoplayer.usemediacodecsurface" type="boolean" label="13440" help="36544">
           <requirement>HAS_MEDIACODEC</requirement>
           <level>2</level>
@@ -2584,6 +2704,36 @@
           </dependencies>
           <control type="toggle" />
         </setting>
+        <setting id="videoscreen.forcergb" type="boolean" parent="videoscreen.screen" label="13133" help="40065">
+          <level>1</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoscreen.lockhpd" type="boolean" parent="videoscreen.screen" label="13134" help="40066">
+          <level>1</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoscreen.mutehdmi" type="boolean" parent="videoscreen.screen" label="13135" help="40067">
+          <level>1</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoscreen.force422" type="boolean" parent="videoscreen.screen" label="13136" help="40068">
+          <level>1</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoscreen.maxlum" type="integer" parent="videoscreen.screen" label="13137" help="40069">
+          <level>1</level>
+          <default>100</default>
+          <constraints>
+            <minimum>50</minimum>
+            <step>25</step>
+            <maximum>350</maximum>
+          </constraints>
+          <control type="spinner" format="integer" />
+        </setting>
         <setting id="videoscreen.delayrefreshchange" type="integer" parent="videoscreen.screen" label="13550" help="36165">
           <level>2</level>
           <default>0</default>
@@ -2616,6 +2766,21 @@
           </constraints>
           <control type="spinner" format="string" />
         </setting>
+        <setting id="videoscreen.limitedrangeaml" type="boolean" label="36042" help="36359">
+          <requirement>
+            <or>
+              <condition>HAS_GL</condition>
+              <condition>HAS_DX</condition>
+              <condition>true</condition>
+            </or>
+          </requirement>
+          <level>3</level>
+          <default>true</default>
+          <updates>
+            <update type="rename">videoplayer.vdpaustudiolevel</update>
+          </updates>
+          <control type="toggle" />
+        </setting>
         <setting id="videoscreen.dither" type="boolean" label="36099" help="36598">
           <requirement>
             <or>
@@ -2836,7 +3001,7 @@
         </setting>
         <setting id="videoscreen.whitelistpulldown" type="boolean" parent="videoscreen.whitelist" label="14127" help="36444">
           <level>3</level>
-          <default>false</default>
+          <default>true</default>
           <dependencies>
             <dependency type="enable" setting="videoscreen.whitelist" operator="!is"></dependency>
           </dependencies>
@@ -2844,7 +3009,7 @@
         </setting>
         <setting id="videoscreen.whitelistdoublerefreshrate" type="boolean" parent="videoscreen.whitelist" label="14128" help="36445">
           <level>3</level>
-          <default>false</default>
+          <default>true</default>
           <dependencies>
             <dependency type="enable" setting="videoscreen.whitelist" operator="!is"></dependency>
           </dependencies>
@@ -2926,7 +3091,7 @@
         </setting>
         <setting id="audiooutput.config" type="integer" label="337" help="36361">
           <level>2</level>
-          <default>2</default>
+          <default>3</default>
           <constraints>
             <options>
               <option label="338">1</option>
@@ -2971,6 +3136,18 @@
             <formatlabel>36459</formatlabel>
           </control>
         </setting>
+        <setting id="audiooutput.boostcenter" type="integer" label="38007" help="38008">
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <minimum>0</minimum>
+            <step>1</step>
+            <maximum>30</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38009</formatlabel>
+          </control>
+        </setting>
         <setting id="audiooutput.processquality" type="integer" label="13505" help="36169">
           <requirement>HAS_AE_QUALITY_LEVELS</requirement>
           <level>2</level>
@@ -3016,7 +3193,7 @@
         </setting>
         <setting id="audiooutput.streamsilence" type="integer" label="421" help="34111">
           <level>2</level>
-          <default>1</default>
+          <default>0</default>
           <constraints>
             <options>audiostreamsilence</options>
           </constraints>
@@ -3024,7 +3201,7 @@
         </setting>
         <setting id="audiooutput.streamnoise" type="boolean" label="34112" help="34113">
           <level>2</level>
-          <default>true</default>
+          <default>false</default>
           <control type="toggle" />
         </setting>
       </group>
diff --git a/tools/depends/target/ffmpeg/0001-added_upstream_mvc_patches.patch b/tools/depends/target/ffmpeg/0001-added_upstream_mvc_patches.patch
new file mode 100644
index 0000000000..f6b60e48b9
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-added_upstream_mvc_patches.patch
@@ -0,0 +1,279 @@
+From 82f0ffcf18eeb87719213596655de540b7ff9e77 Mon Sep 17 00:00:00 2001
+From: tanio99 <tanio99@wolke7.net>
+Date: Sat, 9 Jan 2021 10:28:48 +0100
+Subject: [PATCH 1/4] avcodec: add h264_mvc codec id and profiles (original
+ patch from h.leppkes@gmail.com)
+
+---
+ libavcodec/avcodec.h    | 1 +
+ libavcodec/codec_desc.c | 7 +++++++
+ libavcodec/codec_id.h   | 2 ++
+ libavcodec/profiles.c   | 1 +
+ libavformat/mpegts.c    | 2 +-
+ 5 files changed, 12 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
+index c91b2fd..1fcc269 100644
+--- a/libavcodec/avcodec.h
++++ b/libavcodec/avcodec.h
+@@ -1910,6 +1910,7 @@ typedef struct AVCodecContext {
+ #define FF_PROFILE_H264_HIGH_444_PREDICTIVE  244
+ #define FF_PROFILE_H264_HIGH_444_INTRA       (244|FF_PROFILE_H264_INTRA)
+ #define FF_PROFILE_H264_CAVLC_444            44
++#define FF_PROFILE_H264_MULTIVIEW_HIGH_DEPTH 138
+ 
+ #define FF_PROFILE_VC1_SIMPLE   0
+ #define FF_PROFILE_VC1_MAIN     1
+diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
+index 9f88475..dcd509a 100644
+--- a/libavcodec/codec_desc.c
++++ b/libavcodec/codec_desc.c
+@@ -1777,6 +1777,13 @@ static const AVCodecDescriptor codec_descriptors[] = {
+         .long_name = NULL_IF_CONFIG_SMALL("PFM (Portable FloatMap) image"),
+         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+     },
++    {
++        .id        = AV_CODEC_ID_H264_MVC,
++        .type      = AVMEDIA_TYPE_VIDEO,
++        .name      = "h264_mvc",
++        .long_name = NULL_IF_CONFIG_SMALL("H264 MVC"),
++        .props     = AV_CODEC_PROP_LOSSY,
++    },
+ 
+     /* various PCM "codecs" */
+     {
+diff --git a/libavcodec/codec_id.h b/libavcodec/codec_id.h
+index d885962..55da519 100644
+--- a/libavcodec/codec_id.h
++++ b/libavcodec/codec_id.h
+@@ -296,6 +296,8 @@ enum AVCodecID {
+     AV_CODEC_ID_NOTCHLC,
+     AV_CODEC_ID_PFM,
+ 
++    AV_CODEC_ID_H264_MVC,
++
+     /* various PCM "codecs" */
+     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
+     AV_CODEC_ID_PCM_S16LE = 0x10000,
+diff --git a/libavcodec/profiles.c b/libavcodec/profiles.c
+index e59a3a5..860743c 100644
+--- a/libavcodec/profiles.c
++++ b/libavcodec/profiles.c
+@@ -71,6 +71,7 @@ const AVProfile ff_h264_profiles[] = {
+     { FF_PROFILE_H264_CAVLC_444,            "CAVLC 4:4:4"           },
+     { FF_PROFILE_H264_MULTIVIEW_HIGH,       "Multiview High"        },
+     { FF_PROFILE_H264_STEREO_HIGH,          "Stereo High"           },
++    { FF_PROFILE_H264_MULTIVIEW_HIGH_DEPTH, "Multiview High Depth"  },
+     { FF_PROFILE_UNKNOWN },
+ };
+ 
+diff --git a/libavformat/mpegts.c b/libavformat/mpegts.c
+index 1da81a0..d321861 100644
+--- a/libavformat/mpegts.c
++++ b/libavformat/mpegts.c
+@@ -798,7 +798,7 @@ static const StreamType ISO_types[] = {
+ #endif
+     { 0x1b, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264       },
+     { 0x1c, AVMEDIA_TYPE_AUDIO, AV_CODEC_ID_AAC        },
+-    { 0x20, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264       },
++    { 0x20, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_H264_MVC   },
+     { 0x21, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_JPEG2000   },
+     { 0x24, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_HEVC       },
+     { 0x42, AVMEDIA_TYPE_VIDEO, AV_CODEC_ID_CAVS       },
+-- 
+2.25.1
+
+
+From b5092af43c5801875872860e02c809339732b9f2 Mon Sep 17 00:00:00 2001
+From: tanio99 <tanio99@wolke7.net>
+Date: Sat, 9 Jan 2021 10:48:08 +0100
+Subject: [PATCH 2/4] h264_parser: add support for parsing h264 mvc NALUs
+ (original patch from h.leppkes@gmail.com)
+
+---
+ libavcodec/h264_parser.c | 36 ++++++++++++++++++++++++++++++++----
+ libavcodec/parsers.c     |  1 +
+ 2 files changed, 33 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
+index aacd44c..a658a88 100644
+--- a/libavcodec/h264_parser.c
++++ b/libavcodec/h264_parser.c
+@@ -62,6 +62,7 @@ typedef struct H264ParseContext {
+     int parse_last_mb;
+     int64_t reference_dts;
+     int last_frame_num, last_picture_structure;
++    int is_mvc;
+ } H264ParseContext;
+ 
+ 
+@@ -109,14 +110,19 @@ static int h264_find_frame_end(H264ParseContext *p, const uint8_t *buf,
+         } else if (state <= 5) {
+             int nalu_type = buf[i] & 0x1F;
+             if (nalu_type == H264_NAL_SEI || nalu_type == H264_NAL_SPS ||
+-                nalu_type == H264_NAL_PPS || nalu_type == H264_NAL_AUD) {
++                nalu_type == H264_NAL_PPS || nalu_type == H264_NAL_AUD ||
++                nalu_type == H264_NAL_SUB_SPS) {
+                 if (pc->frame_start_found) {
+                     i++;
+                     goto found;
+                 }
+             } else if (nalu_type == H264_NAL_SLICE || nalu_type == H264_NAL_DPA ||
+-                       nalu_type == H264_NAL_IDR_SLICE) {
++                       nalu_type == H264_NAL_IDR_SLICE || (p->is_mvc && nalu_type == H264_NAL_EXTEN_SLICE)) {
+                 state += 8;
++
++                if (nalu_type == H264_NAL_EXTEN_SLICE) {
++                    i += 3; // skip mvc extension
++                }
+                 continue;
+             }
+             state = 7;
+@@ -601,7 +607,9 @@ static int h264_parse(AVCodecParserContext *s,
+         }
+     }
+ 
+-    parse_nal_units(s, avctx, buf, buf_size);
++    if (!p->is_mvc) {
++        parse_nal_units(s, avctx, buf, buf_size);
++    }
+ 
+     if (avctx->framerate.num)
+         avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational){avctx->ticks_per_frame, 1}));
+@@ -658,7 +666,7 @@ static int h264_split(AVCodecContext *avctx,
+         if ((state & 0xFFFFFF00) != 0x100)
+             break;
+         nalu_type = state & 0x1F;
+-        if (nalu_type == H264_NAL_SPS) {
++        if (nalu_type == H264_NAL_SPS || nalu_type == H264_NAL_SUB_SPS) {
+             has_sps = 1;
+         } else if (nalu_type == H264_NAL_PPS)
+             has_pps = 1;
+@@ -710,3 +718,23 @@ AVCodecParser ff_h264_parser = {
+     .parser_close   = h264_close,
+     .split          = h264_split,
+ };
++
++static av_cold int init_mvc(AVCodecParserContext *s)
++{
++    H264ParseContext *p = s->priv_data;
++    int ret = init(s);
++    if (ret < 0)
++        return ret;
++
++    p->is_mvc = 1;
++    return 0;
++}
++
++AVCodecParser ff_h264_mvc_parser = {
++    .codec_ids      = { AV_CODEC_ID_H264_MVC },
++    .priv_data_size = sizeof(H264ParseContext),
++    .parser_init    = init_mvc,
++    .parser_parse   = h264_parse,
++    .parser_close   = h264_close,
++    .split          = h264_split,
++};
+diff --git a/libavcodec/parsers.c b/libavcodec/parsers.c
+index 7d75cea..2d4118d 100644
+--- a/libavcodec/parsers.c
++++ b/libavcodec/parsers.c
+@@ -47,6 +47,7 @@ extern AVCodecParser ff_gsm_parser;
+ extern AVCodecParser ff_h261_parser;
+ extern AVCodecParser ff_h263_parser;
+ extern AVCodecParser ff_h264_parser;
++extern AVCodecParser ff_h264_mvc_parser;
+ extern AVCodecParser ff_hevc_parser;
+ extern AVCodecParser ff_jpeg2000_parser;
+ extern AVCodecParser ff_mjpeg_parser;
+-- 
+2.25.1
+
+
+From f90a2611e19d4f5b818580896023a8c6dacd2ace Mon Sep 17 00:00:00 2001
+From: tanio99 <tanio99@wolke7.net>
+Date: Sat, 9 Jan 2021 10:53:04 +0100
+Subject: [PATCH 3/4] h264_parser: force grabbing a new timestamp until a frame
+ start was found (original patch from h.leppkes@gmail.com)
+
+---
+ libavcodec/h264_parser.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/libavcodec/h264_parser.c b/libavcodec/h264_parser.c
+index a658a88..fa06a71 100644
+--- a/libavcodec/h264_parser.c
++++ b/libavcodec/h264_parser.c
+@@ -595,6 +595,10 @@ static int h264_parse(AVCodecParserContext *s,
+     } else {
+         next = h264_find_frame_end(p, buf, buf_size, avctx);
+ 
++        if (next == END_NOT_FOUND && pc->frame_start_found == 0) {
++            s->fetch_timestamp = 1;
++        }
++
+         if (ff_combine_frame(pc, next, &buf, &buf_size) < 0) {
+             *poutbuf      = NULL;
+             *poutbuf_size = 0;
+-- 
+2.25.1
+
+
+From 34ae43a66cdd99f91ff22ef0651ed109cdb703d4 Mon Sep 17 00:00:00 2001
+From: tanio99 <tanio99@wolke7.net>
+Date: Sat, 9 Jan 2021 11:00:47 +0100
+Subject: [PATCH 4/4] fixup (original patch from popcornmix@gmail.com)
+
+---
+ libavcodec/extract_extradata_bsf.c | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+diff --git a/libavcodec/extract_extradata_bsf.c b/libavcodec/extract_extradata_bsf.c
+index 1fead74..e20e45a 100644
+--- a/libavcodec/extract_extradata_bsf.c
++++ b/libavcodec/extract_extradata_bsf.c
+@@ -140,7 +140,7 @@ static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,
+         HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,
+     };
+     static const int extradata_nal_types_h264[] = {
+-        H264_NAL_SPS, H264_NAL_PPS,
++        H264_NAL_SPS, H264_NAL_SUB_SPS, H264_NAL_PPS,
+     };
+ 
+     ExtractExtradataContext *s = ctx->priv_data;
+@@ -171,7 +171,7 @@ static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,
+                 if (nal->type == HEVC_NAL_SPS) has_sps = 1;
+                 if (nal->type == HEVC_NAL_VPS) has_vps = 1;
+             } else {
+-                if (nal->type == H264_NAL_SPS) has_sps = 1;
++                if (nal->type == H264_NAL_SPS || nal->type == H264_NAL_SUB_SPS) has_sps = 1;
+             }
+         } else if (s->remove) {
+             filtered_size += nal->raw_size + 3;
+@@ -180,7 +180,7 @@ static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,
+ 
+     if (extradata_size &&
+         ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||
+-         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {
++         ((ctx->par_in->codec_id == AV_CODEC_ID_H264 || ctx->par_in->codec_id == AV_CODEC_ID_H264_MVC) && has_sps))) {
+         AVBufferRef *filtered_buf = NULL;
+         PutByteContext pb_filtered_data, pb_extradata;
+         uint8_t *extradata;
+@@ -337,6 +337,7 @@ static const struct {
+     { AV_CODEC_ID_AVS2,       extract_extradata_mpeg4   },
+     { AV_CODEC_ID_CAVS,       extract_extradata_mpeg4   },
+     { AV_CODEC_ID_H264,       extract_extradata_h2645   },
++    { AV_CODEC_ID_H264_MVC,   extract_extradata_h2645   },
+     { AV_CODEC_ID_HEVC,       extract_extradata_h2645   },
+     { AV_CODEC_ID_MPEG1VIDEO, extract_extradata_mpeg12  },
+     { AV_CODEC_ID_MPEG2VIDEO, extract_extradata_mpeg12  },
+@@ -404,6 +405,7 @@ static const enum AVCodecID codec_ids[] = {
+     AV_CODEC_ID_AVS2,
+     AV_CODEC_ID_CAVS,
+     AV_CODEC_ID_H264,
++    AV_CODEC_ID_H264_MVC,
+     AV_CODEC_ID_HEVC,
+     AV_CODEC_ID_MPEG1VIDEO,
+     AV_CODEC_ID_MPEG2VIDEO,
+-- 
+2.25.1
+
diff --git a/tools/depends/target/ffmpeg/0002-increase-max-pes-payload-limit.patch b/tools/depends/target/ffmpeg/0002-increase-max-pes-payload-limit.patch
new file mode 100644
index 0000000000..5141648965
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0002-increase-max-pes-payload-limit.patch
@@ -0,0 +1,12 @@
+diff --git a/libavformat/mpegts.c b/libavformat/mpegts.c
+index 27eac75..a9cb73e 100644
+--- a/libavformat/mpegts.c
++++ b/libavformat/mpegts.c
+@@ -42,7 +42,7 @@
+  * synchronization is lost */
+ #define MAX_RESYNC_SIZE 65536
+
+-#define MAX_PES_PAYLOAD 200 * 1024
++#define MAX_PES_PAYLOAD 1024 * 1024
+
+ #define MAX_MP4_DESCR_COUNT 16
diff --git a/tools/depends/target/ffmpeg/0003-MKV-added-basic-block-addition-mapping-support-and-i.patch b/tools/depends/target/ffmpeg/0003-MKV-added-basic-block-addition-mapping-support-and-i.patch
new file mode 100644
index 0000000000..d92dc8dd95
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0003-MKV-added-basic-block-addition-mapping-support-and-i.patch
@@ -0,0 +1,119 @@
+From 622773156b98bc0c28818a8030ff1453028c0e41 Mon Sep 17 00:00:00 2001
+From: tanio99 <tanio99@wolke7.net>
+Date: Sun, 10 Jan 2021 16:52:01 +0100
+Subject: [PATCH] MKV: added basic 'block addition mapping' support and
+ integrate 'mvcC' extradata
+
+---
+ libavformat/matroska.h    |  6 +++++
+ libavformat/matroskadec.c | 49 +++++++++++++++++++++++++++++++++++----
+ 2 files changed, 50 insertions(+), 5 deletions(-)
+
+diff --git a/libavformat/matroska.h b/libavformat/matroska.h
+index 6f198f0..7ad28ce 100644
+--- a/libavformat/matroska.h
++++ b/libavformat/matroska.h
+@@ -107,6 +107,12 @@
+ #define MATROSKA_ID_TRACKTIMECODESCALE 0x23314F
+ #define MATROSKA_ID_TRACKMAXBLKADDID 0x55EE
+ 
++#define MATROSKA_ID_BLOCKADDITIONMAPPING 0x41E4
++#define MATROSKA_ID_BLOCKADDIDVALUE 0x41F0
++#define MATROSKA_ID_BLOCKADDIDNAME 0x41A4
++#define MATROSKA_ID_BLOCKADDIDTYPE 0x41E7
++#define MATROSKA_ID_BLOCKADDIDEXTRADATA 0x41ED
++
+ /* IDs in the trackvideo master */
+ #define MATROSKA_ID_VIDEOFRAMERATE 0x2383E3
+ #define MATROSKA_ID_VIDEODISPLAYWIDTH 0x54B0
+diff --git a/libavformat/matroskadec.c b/libavformat/matroskadec.c
+index cff7f0c..bde0c82 100644
+--- a/libavformat/matroskadec.c
++++ b/libavformat/matroskadec.c
+@@ -226,6 +226,13 @@ typedef struct MatroskaTrackOperation {
+     EbmlList combine_planes;
+ } MatroskaTrackOperation;
+ 
++typedef struct MatroskaBlockAdditionMapping {
++	uint64_t  type;
++	uint64_t  value;
++	char     *name;
++	EbmlBin   extra_data;
++} MatroskaBlockAdditionMapping;
++
+ typedef struct MatroskaTrack {
+     uint64_t num;
+     uint64_t uid;
+@@ -233,6 +240,7 @@ typedef struct MatroskaTrack {
+     char    *name;
+     char    *codec_id;
+     EbmlBin  codec_priv;
++    MatroskaBlockAdditionMapping block_addition_mapping;
+     char    *language;
+     double time_scale;
+     uint64_t default_duration;
+@@ -548,6 +556,14 @@ static EbmlSyntax matroska_track_operation[] = {
+     CHILD_OF(matroska_track)
+ };
+ 
++static const EbmlSyntax matroska_block_addition_mapping[] = {
++    { MATROSKA_ID_BLOCKADDIDTYPE,       EBML_UINT, 0, offsetof(MatroskaBlockAdditionMapping, type) },
++    { MATROSKA_ID_BLOCKADDIDNAME,       EBML_STR,  0, offsetof(MatroskaBlockAdditionMapping, name) },
++    { MATROSKA_ID_BLOCKADDIDVALUE,      EBML_UINT, 0, offsetof(MatroskaBlockAdditionMapping, value) },
++    { MATROSKA_ID_BLOCKADDIDEXTRADATA,  EBML_BIN,  0, offsetof(MatroskaBlockAdditionMapping, extra_data) },
++    { 0 }
++};
++
+ static EbmlSyntax matroska_track[] = {
+     { MATROSKA_ID_TRACKNUMBER,           EBML_UINT,  0, offsetof(MatroskaTrack, num) },
+     { MATROSKA_ID_TRACKNAME,             EBML_UTF8,  0, offsetof(MatroskaTrack, name) },
+@@ -555,6 +571,7 @@ static EbmlSyntax matroska_track[] = {
+     { MATROSKA_ID_TRACKTYPE,             EBML_UINT,  0, offsetof(MatroskaTrack, type) },
+     { MATROSKA_ID_CODECID,               EBML_STR,   0, offsetof(MatroskaTrack, codec_id) },
+     { MATROSKA_ID_CODECPRIVATE,          EBML_BIN,   0, offsetof(MatroskaTrack, codec_priv) },
++    { MATROSKA_ID_BLOCKADDITIONMAPPING,  EBML_NEST,  0, offsetof(MatroskaTrack, block_addition_mapping), { .n = matroska_block_addition_mapping } },
+     { MATROSKA_ID_CODECDELAY,            EBML_UINT,  0, offsetof(MatroskaTrack, codec_delay) },
+     { MATROSKA_ID_TRACKLANGUAGE,         EBML_STR,   0, offsetof(MatroskaTrack, language),     { .s = "eng" } },
+     { MATROSKA_ID_TRACKDEFAULTDURATION,  EBML_UINT,  0, offsetof(MatroskaTrack, default_duration) },
+@@ -2701,11 +2718,33 @@ static int matroska_parse_tracks(AVFormatContext *s)
+                 st->codecpar->extradata      = extradata;
+                 st->codecpar->extradata_size = extradata_size;
+             } else if (track->codec_priv.data && track->codec_priv.size > 0) {
+-                if (ff_alloc_extradata(st->codecpar, track->codec_priv.size))
+-                    return AVERROR(ENOMEM);
+-                memcpy(st->codecpar->extradata,
+-                       track->codec_priv.data + extradata_offset,
+-                       track->codec_priv.size);
++                if (st->codecpar->codec_id == AV_CODEC_ID_H264 &&
++                    track->block_addition_mapping.type == MKBETAG('m', 'v', 'c', 'C') &&
++                    track->block_addition_mapping.extra_data.size > 0) {
++                    /* merge the extradata with MVC extradata */
++                    const uint32_t fill = 0xfdf8f800;
++                    const uint32_t mvc_ext_len = 4 + track->block_addition_mapping.extra_data.size;
++                    const int ex_size = track->codec_priv.size + 4 + 4 + mvc_ext_len;
++                    int offs = track->codec_priv.size;
++
++                    if (ff_alloc_extradata(st->codecpar, ex_size)) {
++                        return AVERROR(ENOMEM);
++                    }
++                    memcpy(st->codecpar->extradata, track->codec_priv.data + extradata_offset, track->codec_priv.size);
++
++                    AV_WB32(st->codecpar->extradata + offs, fill);
++                    AV_WB32(st->codecpar->extradata + offs + 4, mvc_ext_len);
++                    AV_WB32(st->codecpar->extradata + offs + 8, MKBETAG('m', 'v', 'c', 'C'));
++
++                    memcpy(st->codecpar->extradata + offs + 12, track->block_addition_mapping.extra_data.data, track->block_addition_mapping.extra_data.size);
++                    st->codecpar->extradata_size = ex_size;
++                } else {
++                    if (ff_alloc_extradata(st->codecpar, track->codec_priv.size))
++                        return AVERROR(ENOMEM);
++                    memcpy(st->codecpar->extradata,
++                           track->codec_priv.data + extradata_offset,
++                           track->codec_priv.size);
++                }
+             }
+         }
+ 
+-- 
+2.25.1
+
diff --git a/xbmc/CMakeLists.txt b/xbmc/CMakeLists.txt
index 4c69707dd5..34f1a98c91 100644
--- a/xbmc/CMakeLists.txt
+++ b/xbmc/CMakeLists.txt
@@ -16,6 +16,8 @@ set(SOURCES AutoSwitch.cpp
             LangInfo.cpp
             MediaSource.cpp
             NfoFile.cpp
+            OSMCSecureOS.cpp
+            OSMCHelper.cpp
             PasswordManager.cpp
             PlayListPlayer.cpp
             PartyModeManager.cpp
@@ -58,6 +60,8 @@ set(HEADERS AutoSwitch.h
             LockType.h
             MediaSource.h
             NfoFile.h
+            OSMCSecureOS.h
+	    OSMCHelper.h
             PartyModeManager.h
             PasswordManager.h
             PlayListPlayer.h
diff --git a/xbmc/OSMCHelper.cpp b/xbmc/OSMCHelper.cpp
new file mode 100644
index 0000000000..2b605881b1
--- /dev/null
+++ b/xbmc/OSMCHelper.cpp
@@ -0,0 +1,36 @@
+/*                                                   
+ *      Copyright (C) 2005-2013 Team XBMC            
+ *      http://xbmc.org                              
+ *                                                   
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option) 
+ *  any later version.                                                  
+ *                                                                      
+ *  This Program is distributed in the hope that it will be useful,     
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of      
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the        
+ *  GNU General Public License for more details.                        
+ *                                                                      
+ *  You should have received a copy of the GNU General Public License   
+ *  along with XBMC; see the file COPYING.  If not, see                 
+ *  <http://www.gnu.org/licenses/>.                                     
+ *                                                                      
+ */                                                                     
+// OSMCHelper.cpp: implementation of OSMC helper routines
+//                                                                       
+//////////////////////////////////////////////////////////////////////   
+                                                                         
+extern "C" {                                                            
+#include "OSMCHelper.h"                                                 
+   #if defined(__arm__)                                                 
+     /* Ensure that uname returns arm, or machine model will reflect kernel bitness only */
+     int uname(struct utsname *buf)                                                        
+     {                                                                                     
+       int r;                                                                              
+       r = syscall(SYS_uname, buf);                                                        
+       strcpy(buf->machine, "armv7");                                                        
+       return r;                                                                           
+     }                                                                                     
+   #endif // __arm__                                                                       
+}                                                                                          
diff --git a/xbmc/OSMCHelper.h b/xbmc/OSMCHelper.h
new file mode 100644
index 0000000000..709d21afbe
--- /dev/null
+++ b/xbmc/OSMCHelper.h
@@ -0,0 +1,38 @@
+/*                                                                                         
+ *      Copyright (C) 2005-2013 Team XBMC                                                  
+ *      http://xbmc.org                                                                    
+ *                                                                                         
+ *  This Program is free software; you can redistribute it and/or modify                   
+ *  it under the terms of the GNU General Public License as published by                   
+ *  the Free Software Foundation; either version 2, or (at your option)                    
+ *  any later version.                                                                     
+ *                                                                                         
+ *  This Program is distributed in the hope that it will be useful,                        
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of                         
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.                                           
+ *                                                                                         
+ *  You should have received a copy of the GNU General Public License                      
+ *  along with XBMC; see the file COPYING.  If not, see                                    
+ *  <http://www.gnu.org/licenses/>.                                                        
+ *                                                                                         
+ */                                                                                        
+// OSMCHelper.h: routines to improve behaviour of Kodi on OSMC                             
+//                                                                                         
+//////////////////////////////////////////////////////////////////////                     
+                                                                                           
+#pragma once                                                                               
+                                                                                           
+#include <sys/syscall.h>                                                                   
+#include <sys/types.h>                                                                     
+#include <sys/utsname.h>                                                                   
+#include <unistd.h>                                                                        
+#include <stdio.h>                                                                         
+#include <string.h>                                                                        
+                                                                                           
+extern "C" {                                                                               
+    #if defined(__arm__)                                                                   
+      /* Fix up uname for 64-bit kernels with 32-bit userland */                           
+      int uname(struct utsname *buf);                                                      
+    #endif // __arm__                                                                      
+}                                                                                          
diff --git a/xbmc/OSMCSecureOS.cpp b/xbmc/OSMCSecureOS.cpp
new file mode 100644
index 0000000000..3045b8be01
--- /dev/null
+++ b/xbmc/OSMCSecureOS.cpp
@@ -0,0 +1,168 @@
+/*
+ *  Copyright (C) 2005-2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include <string>
+
+#include "utils/log.h"
+#include "DynamicDll.h"
+
+#include "OSMCSecureOS.h"
+
+#define LIBSECUREOSMC  "/opt/securevero/lib/libsecureOSMC.so"
+
+OSMCSecureOS *OSMCSecureOS::m_instance = nullptr;
+CCriticalSection OSMCSecureOS::m_mutex;
+
+// ----------------------------------------------------------------------------
+
+class LibsecureOSMCInterface
+{
+public:
+	virtual ~LibsecureOSMCInterface() {};
+
+	virtual void *osmc_init(void (*logf)(const char *, ...))=0;
+	virtual void osmc_close(void *ctxt)=0;
+
+	virtual int auth_get_key_id(void *ctx, char *id, uint32_t *id_length)=0;
+	virtual int auth_get_totp(void *ctx, char *totp, uint32_t *totp_length)=0;
+
+	virtual int mvcsub_get_depth(void *ctx, double pts)=0;
+	virtual int parse_frame(void *ctx, uint32_t codecTag, uint8_t subtitlePlane, int64_t pts, const uint8_t *data, size_t size)=0;
+};
+
+class LibsecureOSMC : public DllDynamic, LibsecureOSMCInterface
+{
+	DECLARE_DLL_WRAPPER(LibsecureOSMC, LIBSECUREOSMC)
+
+	DEFINE_METHOD_FP(void *, osmc_init,  (void (*)(const char *, ...)))
+	DEFINE_METHOD1(void,     osmc_close, (void *p1))
+
+	DEFINE_METHOD3(int, auth_get_key_id, (void *p1, char *p2, uint32_t *p3))
+	DEFINE_METHOD3(int, auth_get_totp,   (void *p1, char *p2, uint32_t *p3))
+
+	DEFINE_METHOD2(int, mvcsub_get_depth, (void *p1, double p2));
+	DEFINE_METHOD6(int, parse_frame,      (void *p1, uint32_t p2, uint8_t p3, int64_t p4, const uint8_t *p5, size_t p6))
+
+	BEGIN_METHOD_RESOLVE()
+		RESOLVE_METHOD_FP(osmc_init)
+		RESOLVE_METHOD(osmc_close)
+		RESOLVE_METHOD(auth_get_key_id)
+		RESOLVE_METHOD(auth_get_totp)
+		RESOLVE_METHOD(mvcsub_get_depth)
+		RESOLVE_METHOD(parse_frame)
+	END_METHOD_RESOLVE()
+
+public:
+	virtual void *osmc_init(void (*logf)(const char *, ...))
+	{
+		if (m_osmc_init) {
+			return m_osmc_init(logf);
+		}
+
+		return nullptr;
+	}
+
+};
+
+// ----------------------------------------------------------------------------
+
+extern "C" void osmcsecureos_logf(const char *format, ...)
+{
+  va_list arglist;
+  char buf[512];
+
+  va_start(arglist, format);
+  vsnprintf(buf, sizeof(buf), format, arglist);
+  va_end(arglist);
+
+  CLog::Log(LOGINFO, buf);
+}
+
+OSMCSecureOS::OSMCSecureOS()
+	: m_osmcCtxt(nullptr)
+{
+	m_dll = new LibsecureOSMC();
+	if (!m_dll->Load()) {
+		CLog::Log(LOGWARNING, "OSMCSecureOS::OSMCSecureOS: unable to load libsecureOSMC");
+		delete m_dll, m_dll = nullptr;
+		return;
+	}
+
+	m_osmcCtxt = m_dll->osmc_init(osmcsecureos_logf);
+	if (!m_osmcCtxt) {
+		CLog::Log(LOGERROR, "OSMCSecureOS: unable to initialize libsecureOSMC");
+		delete m_dll, m_dll = nullptr;
+		return;
+	}
+
+	CLog::Log(LOGWARNING, "OSMCSecureOS: key-id = {}", getKeyId());
+}
+
+OSMCSecureOS::~OSMCSecureOS()
+{
+        std::unique_lock<CCriticalSection> lock(m_mutex);
+
+	if (m_osmcCtxt) {
+		m_dll->osmc_close(m_osmcCtxt);
+	}
+
+	if (m_dll) {
+		delete m_dll, m_dll = nullptr;
+	}
+
+	m_instance = nullptr;
+}
+
+OSMCSecureOS &OSMCSecureOS::getInstance()
+{
+	std::unique_lock<CCriticalSection> lock(m_mutex);
+
+	if (m_instance == nullptr) {
+		m_instance = new OSMCSecureOS();
+	}
+
+	return *m_instance;
+}
+
+std::string OSMCSecureOS::getKeyId() const
+{
+	char id[65];
+	uint32_t idLength = sizeof(id);
+
+	if (!m_dll || m_dll->auth_get_key_id(m_osmcCtxt, id, &idLength)) {
+		CLog::Log(LOGWARNING, "OSMCSecureOS::getKeyId: unable to get key id");
+		return "<unknown>";
+	}
+
+	return std::string(id, idLength);
+}
+
+std::string OSMCSecureOS::getTOTP() const
+{
+	char totp[9];
+	uint32_t totpLength = sizeof(totp);
+
+	if (!m_dll || m_dll->auth_get_totp(m_osmcCtxt, totp, &totpLength)) {
+		CLog::Log(LOGWARNING, "OSMCSecureOS::getTOTP: unable to get totp");
+		return "<unknown>";
+	}
+
+	return std::string(totp, totpLength);
+}
+
+int OSMCSecureOS::getMvcSubtitleDepth(double pts) const
+{
+	return !m_dll ? 0 : m_dll->mvcsub_get_depth(m_osmcCtxt, pts);
+}
+
+void OSMCSecureOS::parseFrame(uint32_t codecTag, uint8_t subtitlePlane, int64_t pts, const uint8_t *data, size_t size) const
+{
+	if (m_dll) {
+		(void) m_dll->parse_frame(m_osmcCtxt, codecTag, subtitlePlane, pts, data, size);
+	}
+}
diff --git a/xbmc/OSMCSecureOS.h b/xbmc/OSMCSecureOS.h
new file mode 100644
index 0000000000..2c800133e5
--- /dev/null
+++ b/xbmc/OSMCSecureOS.h
@@ -0,0 +1,39 @@
+/*
+ *  Copyright (C) 2005-2020 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <stddef.h>
+#include "threads/CriticalSection.h"
+#include <stdarg.h>
+
+class LibsecureOSMC;
+
+class OSMCSecureOS
+{
+private:
+	static OSMCSecureOS		*m_instance;
+	static CCriticalSection m_mutex;
+
+	LibsecureOSMC	*m_dll;
+	void			*m_osmcCtxt;
+
+	OSMCSecureOS();
+	~OSMCSecureOS();
+
+public:
+	static OSMCSecureOS &getInstance();
+
+	std::string getKeyId() const;
+	std::string getTOTP() const;
+
+	int getMvcSubtitleDepth(double pts) const;
+
+	void parseFrame(uint32_t codecTag, uint8_t subtitlePlane, int64_t pts, const uint8_t *data, size_t size) const;
+};
diff --git a/xbmc/addons/kodi-dev-kit/include/kodi/c-api/addon-instance/inputstream/demux_packet.h b/xbmc/addons/kodi-dev-kit/include/kodi/c-api/addon-instance/inputstream/demux_packet.h
index 79686abc9b..84aa11512c 100644
--- a/xbmc/addons/kodi-dev-kit/include/kodi/c-api/addon-instance/inputstream/demux_packet.h
+++ b/xbmc/addons/kodi-dev-kit/include/kodi/c-api/addon-instance/inputstream/demux_packet.h
@@ -98,6 +98,11 @@ extern "C"
 
     //------------------------------------------
 
+    /// @brief The 3D MVC subtitle plane
+    int subtitlePlane;
+
+    //------------------------------------------
+
     /// @brief Optional data to allow decryption at processing site if
     /// necessary.
     ///
diff --git a/xbmc/application/Application.cpp b/xbmc/application/Application.cpp
index 6eba27eb50..dbc9f9e7ad 100644
--- a/xbmc/application/Application.cpp
+++ b/xbmc/application/Application.cpp
@@ -60,6 +60,7 @@
 #include "utils/LangCodeExpander.h"
 #include "utils/Screenshot.h"
 #include "utils/Variant.h"
+#include "utils/SysfsUtils.h"
 #include "video/Bookmark.h"
 #include "video/VideoLibraryQueue.h"
 
@@ -1248,8 +1249,15 @@ bool CApplication::OnAction(const CAction &action)
   }
 
   // forward action to graphic context and see if it can handle it
-  if (CServiceBroker::GetGUI()->GetStereoscopicsManager().OnAction(action))
-    return true;
+  RENDER_STEREO_MODE oldRsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+  if (CServiceBroker::GetGUI()->GetStereoscopicsManager().OnAction(action)) {
+    RENDER_STEREO_MODE newRsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+    if (oldRsm != newRsm) {
+      // stereo mode changed
+      appPlayer->TriggerUpdateResolution();
+    }
+  return true;
+  }
 
   if (appPlayer->IsPlaying())
   {
@@ -1596,6 +1604,18 @@ void CApplication::OnApplicationMessage(ThreadMessage* pMsg)
       break;
   }
 
+  case TMSG_AML_RESIZE:
+  {
+    if (! appPlayer->IsPlayingVideo()) {
+      CDisplaySettings::GetInstance().ClearCustomResolutions();
+      CServiceBroker::GetWinSystem()->UpdateResolutions();
+      CDisplaySettings::GetInstance().SetCurrentResolution(RES_DESKTOP);
+      CServiceBroker::GetWinSystem()->GetGfxContext().SetVideoResolution(RES_DESKTOP, true);
+      CLog::Log(LOGINFO, "Updated resolutions and set desktop");
+    }
+    break;
+  }
+
   case TMSG_NETWORKMESSAGE:
     m_ServiceManager->GetNetwork().NetworkMessage(static_cast<CNetworkBase::EMESSAGE>(pMsg->param1),
                                                   pMsg->param2);
@@ -2604,6 +2624,7 @@ void CApplication::PlaybackCleanup()
     else
     {
       //  resets to res_desktop or look&feel resolution (including refreshrate)
+      SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/aspect", 2);
       CServiceBroker::GetWinSystem()->GetGfxContext().SetFullScreenVideo(false);
     }
 #ifdef TARGET_DARWIN_EMBEDDED
@@ -3603,7 +3624,7 @@ void CApplication::SetLoggingIn(bool switchingProfiles)
 void CApplication::PrintStartupLog()
 {
   CLog::Log(LOGINFO, "-----------------------------------------------------------------------");
-  CLog::Log(LOGINFO, "Starting {} ({}). Platform: {} {} {}-bit", CSysInfo::GetAppName(),
+  CLog::Log(LOGINFO, "Starting {} ({}). Platform: {} {} {}-bit (version for Vero)", CSysInfo::GetAppName(),
             CSysInfo::GetVersion(), g_sysinfo.GetBuildTargetPlatformName(),
             g_sysinfo.GetBuildTargetCpuFamily(), g_sysinfo.GetXbmcBitness());
 
diff --git a/xbmc/application/ApplicationPlayerCallback.cpp b/xbmc/application/ApplicationPlayerCallback.cpp
index 0dbb4b9fe5..a2902fa36c 100644
--- a/xbmc/application/ApplicationPlayerCallback.cpp
+++ b/xbmc/application/ApplicationPlayerCallback.cpp
@@ -281,8 +281,19 @@ void CApplicationPlayerCallback::OnAVChange()
 {
   CLog::LogF(LOGDEBUG, "CApplication::OnAVChange");
 
+  RENDER_STEREO_MODE oldRsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+
   CServiceBroker::GetGUI()->GetStereoscopicsManager().OnStreamChange();
 
+  RENDER_STEREO_MODE newRsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+
+  if (oldRsm != newRsm) {
+    // stereo mode changed
+    auto& components = CServiceBroker::GetAppComponents();
+    const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+    appPlayer->TriggerUpdateResolution();
+  }
+
   CGUIMessage msg(GUI_MSG_PLAYBACK_AVCHANGE, 0, 0);
   CServiceBroker::GetGUI()->GetWindowManager().SendThreadMessage(msg);
 
diff --git a/xbmc/application/ApplicationPowerHandling.cpp b/xbmc/application/ApplicationPowerHandling.cpp
index ea182d554e..d9ac5021fc 100644
--- a/xbmc/application/ApplicationPowerHandling.cpp
+++ b/xbmc/application/ApplicationPowerHandling.cpp
@@ -16,6 +16,7 @@
 #include "addons/gui/GUIDialogAddonSettings.h"
 #include "application/ApplicationComponents.h"
 #include "application/ApplicationPlayer.h"
+#include "application/Application.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIMessage.h"
 #include "guilib/GUIWindowManager.h"
@@ -35,8 +36,14 @@
 #include "settings/SettingsComponent.h"
 #include "utils/AlarmClock.h"
 #include "utils/log.h"
+#include "utils/SysfsUtils.h"
 #include "video/VideoLibraryQueue.h"
 #include "windowing/WinSystem.h"
+#include "filesystem/SpecialProtocol.h"
+#include "filesystem/File.h"
+#include <sstream>
+
+using namespace XFILE;
 
 void CApplicationPowerHandling::ResetScreenSaver()
 {
@@ -150,6 +157,8 @@ bool CApplicationPowerHandling::WakeUpScreenSaverAndDPMS(bool bPowerOffKeyPresse
 
 bool CApplicationPowerHandling::WakeUpScreenSaver(bool bPowerOffKeyPressed /* = false */)
 {
+  if (m_bVeroStandby)
+    ToggleStandby();
   if (m_iScreenSaveLock == 2)
     return false;
 
@@ -228,6 +237,66 @@ bool CApplicationPowerHandling::WakeUpScreenSaver(bool bPowerOffKeyPressed /* =
     return false;
 }
 
+void CApplicationPowerHandling::ActivateScreenSaverStandby()
+{
+  if (m_bVeroStandby) {
+    CLog::Log(LOGINFO, "Ignoring standby request: we are already in standby");
+    return;
+  }
+
+  CLog::Log(LOGINFO, "Activating Vero standby mode");
+  const auto& components = CServiceBroker::GetAppComponents();
+  const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+  if (appPlayer && appPlayer->IsPlayingVideo())
+    g_application.StopPlaying();
+  ToggleStandby();
+  CServiceBroker::GetAnnouncementManager()->Announce(ANNOUNCEMENT::GUI, "OnScreenSaverActivated");
+  CServiceBroker::GetGUI()->GetWindowManager().CloseDialogs(true);
+}
+
+void CApplicationPowerHandling::ToggleStandby() {
+  CLog::Log(LOGINFO, "Toggle standby state is {}", m_bVeroStandby ? "waking" : "sleeping");
+  int sysfs_toggle = m_bVeroStandby;
+  CLog::Log(LOGINFO, "CApplication::ToggleStandby -- Toggle TMDS clock to {}", sysfs_toggle);
+  SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/phy", sysfs_toggle);
+  CLog::Log(LOGINFO, "CApplication::ToggleStandby -- Toggle LED brightness to {}", sysfs_toggle);
+  SysfsUtils::SetInt("/sys/class/leds/standby/brightness", ! sysfs_toggle);
+  std::string cpu_governor = "powersave";
+  if (m_bVeroStandby)
+        cpu_governor = "ondemand";
+  CLog::Log(LOGINFO, "CApplication::ToggleStandby -- governor will now be {}", cpu_governor);
+  for (int i = 0; i < 4; i++) {
+	std::stringstream ss_govpath;
+	ss_govpath << "/sys/devices/system/cpu/cpu" << i << "/cpufreq/scaling_governor";
+	SysfsUtils::SetString(ss_govpath.str(), cpu_governor);
+  }
+  std::string hpdlock = "hpd_lock1";
+  if (m_bVeroStandby && ! CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_LOCKHPD))
+	hpdlock = "hpd_lock0";
+  CLog::Log(LOGINFO, "CApplication::ToggleStandby -- HPD locking will now be {}", hpdlock);
+  SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/debug", hpdlock);
+  if (m_bVeroStandby) {
+	CServiceBroker::GetAppMessenger()->PostMsg(TMSG_CECACTIVATESOURCEOSMCWAKEUP); // wake cec
+  }
+
+  std::string strStandbyScript;
+  if (m_bVeroStandby)
+	strStandbyScript = CSpecialProtocol::TranslatePath("special://profile/wake.py");
+  else
+	strStandbyScript = CSpecialProtocol::TranslatePath("special://profile/standby.py");
+  CLog::Log(LOGINFO, "CApplication::ToggleStandby -- checking for existence of {}", strStandbyScript);
+
+  if (XFILE::CFile::Exists(strStandbyScript)) {
+    CLog::Log(LOGINFO, "CApplication::ToggleStandby -- script {} found", strStandbyScript);
+    CScriptInvocationManager::GetInstance().ExecuteAsync(strStandbyScript);
+  }
+
+  m_bVeroStandby = ! m_bVeroStandby; //invert state
+  m_screensaverActive = m_bVeroStandby;
+  return;
+
+}
+
 void CApplicationPowerHandling::CheckOSScreenSaverInhibitionSetting()
 {
   // Kodi screen saver overrides OS one: always inhibit OS screen saver then
diff --git a/xbmc/application/ApplicationPowerHandling.h b/xbmc/application/ApplicationPowerHandling.h
index 9d78c6e36d..12310a029e 100644
--- a/xbmc/application/ApplicationPowerHandling.h
+++ b/xbmc/application/ApplicationPowerHandling.h
@@ -47,6 +47,8 @@ public:
   bool GetRenderGUI() const { return m_renderGUI; }
   void SetRenderGUI(bool renderGUI);
 
+  bool isVeroStandby() const {return m_bVeroStandby; }
+
   int GlobalIdleTime();
   void ResetSystemIdleTimer();
   bool IsIdleShutdownInhibited() const;
@@ -65,8 +67,11 @@ public:
   bool OnSettingChanged(const CSetting& setting);
   bool OnSettingAction(const CSetting& setting);
 
+  void ActivateScreenSaverStandby();
+
 protected:
   void ActivateScreenSaver(bool forceType = false);
+  void ToggleStandby();
   void CheckOSScreenSaverInhibitionSetting();
   // Checks whether the screensaver and / or DPMS should become active.
   void CheckScreenSaverAndDPMS();
@@ -93,6 +98,7 @@ protected:
   // -1 = failed, 0 = locked, 1 = unlocked, 2 = check in progress
   int m_iScreenSaveLock = 0;
   std::string m_screensaverIdInUse;
+  bool m_bVeroStandby;
 
   bool m_dpmsIsActive = false;
   bool m_dpmsIsManual = false;
diff --git a/xbmc/application/ApplicationSettingsHandling.cpp b/xbmc/application/ApplicationSettingsHandling.cpp
index 0a2c1b1c2f..953674933c 100644
--- a/xbmc/application/ApplicationSettingsHandling.cpp
+++ b/xbmc/application/ApplicationSettingsHandling.cpp
@@ -64,6 +64,8 @@ void CApplicationSettingsHandling::RegisterSettings()
                                        CSettings::SETTING_AUDIOCDS_SETTINGS,
                                        CSettings::SETTING_VIDEOSCREEN_GUICALIBRATION,
                                        CSettings::SETTING_VIDEOSCREEN_TESTPATTERN,
+                                       CSettings::SETTING_VIDEOPLAYER_USEAMCODEC,
+                                       CSettings::SETTING_VIDEOPLAYER_HDR_PROCESS,
                                        CSettings::SETTING_VIDEOPLAYER_USEMEDIACODEC,
                                        CSettings::SETTING_VIDEOPLAYER_USEMEDIACODECSURFACE,
                                        CSettings::SETTING_AUDIOOUTPUT_VOLUMESTEPS,
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
index 0badf8b065..70300a00c0 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
@@ -8,6 +8,8 @@
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "ActiveAEResampleFFMPEG.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
 #include "utils/log.h"
 #include "settings/SettingsComponent.h"
 #include "settings/Settings.h"
@@ -93,6 +95,12 @@ bool CActiveAEResampleFFMPEG::Init(SampleConfig dstConfig, SampleConfig srcConfi
   {
     av_opt_set_int(m_pContext, "output_sample_bits", m_dst_bits, 0);
   }
+  int boost_center = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   // tell resampler to clamp float values
   // not required for sink stage (remapLayout == true)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 105839c0b9..e5eea36275 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -20,6 +20,14 @@
 #include "utils/XTimeUtils.h"
 #include "utils/log.h"
 
+#if defined(HAS_LIBAMCODEC)
+#include "utils/AMLUtils.h"
+#include "utils/SysfsUtils.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
+#include "settings/SettingsComponent.h"
+#endif
+
 #include <algorithm>
 #include <limits.h>
 #include <set>
@@ -86,6 +94,8 @@ inline std::unique_ptr<snd_config_t, SndConfigDeleter> SndConfigCopy(snd_config_
 }
 } // namespace
 
+int speaker_layout = 0;
+
 CAESinkALSA::CAESinkALSA() :
   m_pcm(NULL)
 {
@@ -199,7 +209,7 @@ inline CAEChannelInfo CAESinkALSA::GetChannelLayout(const AEAudioFormat& format,
   {
     /* ask for the actual map */
     snd_pcm_chmap_t* actualMap = snd_pcm_get_chmap(m_pcm);
-    if (actualMap)
+    if (actualMap && m_device == "default")
     {
       alsaMapStr = ALSAchmapToString(actualMap);
 
@@ -236,8 +246,8 @@ inline CAEChannelInfo CAESinkALSA::GetChannelLayout(const AEAudioFormat& format,
             format.m_channelLayout.Count(), info.Count());
   CLog::Log(LOGDEBUG, "CAESinkALSA::GetChannelLayout - Requested Layout: {}",
             std::string(format.m_channelLayout));
-  CLog::Log(LOGDEBUG, "CAESinkALSA::GetChannelLayout - Got Layout: {} (ALSA: {})",
-            std::string(info), alsaMapStr);
+  CLog::Log(LOGDEBUG, "CAESinkALSA::GetChannelLayout - Got Layout: {} (ALSA: {} CEA: {} )",
+            std::string(info), alsaMapStr, speaker_layout);
 
   return info;
 }
@@ -418,8 +428,12 @@ snd_pcm_chmap_t* CAESinkALSA::SelectALSAChannelMap(const CAEChannelInfo& info)
   for (snd_pcm_chmap_query_t* supportedMap = supportedMaps[i++];
        supportedMap; supportedMap = supportedMaps[i++])
   {
-    if (supportedMap->map.channels == info.Count())
-    {
+    if (info.Count() < 3)
+      break;
+
+    CLog::Log(LOGDEBUG, "CAESinkALSA::SelectALSAChannelMap checking available maps i: {} channels {} requested channels {}", i, supportedMap->map.channels, info.Count());
+
+    if (supportedMap->map.channels == info.Count()) {
       CAEChannelInfo candidate = ALSAchmapToAEChannelMap(&supportedMap->map);
       const CAEChannelInfo* selectedInfo = &info;
 
@@ -509,6 +523,8 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   inconfig.format = format.m_dataFormat;
   inconfig.sampleRate = format.m_sampleRate;
 
+  CLog::Log(LOGINFO, "CAESinkALSA::Initialize - Requested layout {}", std::string(format.m_channelLayout));
+
   /*
    * We can't use the better GetChannelLayout() at this point as the device
    * is not opened yet, and we need inconfig.channels to select the correct
@@ -528,12 +544,61 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
     m_passthrough   = false;
   }
 
+    int aml_digital_codec = 0;
+
+   if (m_passthrough)
+    {
+      switch(format.m_streamInfo.m_type)
+      {
+        case CAEStreamInfo::STREAM_TYPE_AC3:
+          aml_digital_codec = 2;
+          break;
+        case CAEStreamInfo::STREAM_TYPE_DTS_512:
+        case CAEStreamInfo::STREAM_TYPE_DTS_1024:
+        case CAEStreamInfo::STREAM_TYPE_DTS_2048:
+        case CAEStreamInfo::STREAM_TYPE_DTSHD_CORE:
+          aml_digital_codec = 3;
+          break;
+        case CAEStreamInfo::STREAM_TYPE_DTSHD:
+          aml_digital_codec = 5;
+          break;
+        case CAEStreamInfo::STREAM_TYPE_DTSHD_MA:
+          aml_digital_codec = 8;
+          break;
+        case CAEStreamInfo::STREAM_TYPE_EAC3:
+          aml_digital_codec = 4;
+          break;
+        case CAEStreamInfo::STREAM_TYPE_TRUEHD:
+        case CAEStreamInfo::STREAM_TYPE_MLP:
+          aml_digital_codec = 7;
+          break;
+        default:
+          break;
+      }
+    }
+    else if (device.find("AML") != std::string::npos)
+        device = "default";
+
+    aml_set_audio_passthrough(m_passthrough);
+    SysfsUtils::SetInt("/sys/class/audiodsp/digital_codec", aml_digital_codec);
+
+    CLog::Log(LOGINFO, "CAESinkALSA::Initialize - set digital codec {}", aml_digital_codec);
+
   if (inconfig.channels == 0)
   {
     CLog::Log(LOGERROR, "CAESinkALSA::Initialize - Unable to open the requested channel layout");
     return false;
   }
 
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_MUTEHDMI)) {
+      CLog::Log(LOGDEBUG, "CAESinkALSA::Initialize -- muting HDMI");
+      SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/config", "audio_off");
+  }
+  else {
+      CLog::Log(LOGDEBUG, "CAESinkALSA::Initialize -- unmuting HDMI");
+      SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/config", "audio_on");
+  }
+
   AEDeviceType devType = AEDeviceTypeFromName(device);
 
   std::string AESParams;
@@ -549,15 +614,10 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
 
   if (!OpenPCMDevice(device, AESParams, inconfig.channels, &m_pcm, config.get()))
   {
-    CLog::Log(LOGERROR, "CAESinkALSA::Initialize - failed to initialize device \"{}\"", device);
+    CLog::Log(LOGERROR, "CAESinkALSA::Initialize - failed to initialize device \"{}\" with params {} even for stereo", device, AESParams);
     return false;
   }
 
-  /* get the actual device name that was used */
-  device = snd_pcm_name(m_pcm);
-  m_device = device;
-
-  CLog::Log(LOGINFO, "CAESinkALSA::Initialize - Opened device \"{}\"", device);
 
   snd_pcm_chmap_t* selectedChmap = NULL;
   if (!m_passthrough)
@@ -565,24 +625,65 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
     selectedChmap = SelectALSAChannelMap(format.m_channelLayout);
     if (selectedChmap)
     {
+      CLog::Log(LOGDEBUG, "CAESinkALSA::Initialize - found a channel map, channels {}", selectedChmap->channels);
       /* update wanted channel count according to the selected map */
       inconfig.channels = selectedChmap->channels;
     }
   }
 
+  if (!OpenPCMDevice(device, AESParams, inconfig.channels, &m_pcm, config.get()))
+  {
+    CLog::Log(LOGERROR, "CAESinkALSA::Initialize - failed to initialize device \"{}\"", device);
+    return false;
+  }
+
+  /* get the actual device name that was used */
+  device = snd_pcm_name(m_pcm);
+  m_device = device;
+
+  CLog::Log(LOGINFO, "CAESinkALSA::Initialize - Opened device \"{}\"", device);
+
   if (!InitializeHW(inconfig, outconfig) || !InitializeSW(outconfig))
   {
     free(selectedChmap);
     return false;
   }
+  /* set up channel layout defaults */
+  if (outconfig.channels == 2 || m_passthrough)
+    speaker_layout = 0;
+  else if (format.m_channelLayout.Count() <= 4)
+    speaker_layout = 8;
+  else if (format.m_channelLayout.Count() <= 6)
+    speaker_layout = 11;
+  else
+    speaker_layout = 19;
 
   if (selectedChmap)
   {
-    /* failure is OK, that likely just means the selected chmap is fixed already */
-    snd_pcm_set_chmap(m_pcm, selectedChmap);
+    /* refine the speaker channel layout for HDMI LPCM */
+    if (device == "default")
+    {
+      snd_pcm_chmap_query_t** supportedMaps;
+      supportedMaps = snd_pcm_query_chmaps(m_pcm);
+      int i = 0;
+      for (snd_pcm_chmap_query_t* supportedMap = supportedMaps[i++];
+          supportedMap; supportedMap = supportedMaps[i++])
+      {
+        if (ALSAchmapToString(&supportedMap->map) == ALSAchmapToString(selectedChmap))
+        {
+          speaker_layout = --i;
+          break;
+        }
+      }
+      /* failure is OK, that likely just means the selected chmap is fixed already */
+      snd_pcm_set_chmap(m_pcm, selectedChmap);
+    }
     free(selectedChmap);
   }
 
+  SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/aud_ch", speaker_layout);
+  CLog::Log(LOGINFO, "CAESinkALSA::Initialize - speaker layout {}", speaker_layout);
+
   // we want it blocking
   snd_pcm_nonblock(m_pcm, 0);
   snd_pcm_prepare (m_pcm);
@@ -881,7 +982,7 @@ void CAESinkALSA::Stop()
 {
   if (!m_pcm)
     return;
-  snd_pcm_drop(m_pcm);
+  snd_pcm_drain(m_pcm);
 }
 
 void CAESinkALSA::GetDelay(AEDelayStatus& status)
@@ -1197,11 +1298,8 @@ void CAESinkALSA::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
        * "plughw", "dsnoop"). */
 
       else if (baseName != "default"
-            && baseName != "surround40"
-            && baseName != "surround41"
-            && baseName != "surround50"
-            && baseName != "surround51"
-            && baseName != "surround71"
+            && baseName != "sysdefault"
+            && baseName.find("surround") == std::string::npos
             && baseName != "hw"
             && baseName != "dmix"
             && baseName != "plughw"
@@ -1481,6 +1579,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
       info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_DTS_512);
       info.m_dataFormats.push_back(AE_FMT_RAW);
     }
+    else if (info.m_displayName.find("AML") != std::string::npos)
+    {
+      info.m_displayNameExtra = "HDMI, S/PDIF & analogue";
+    }
     else if (info.m_displayNameExtra.empty())
     {
       /* for USB audio, it gets a bit confusing as there is
@@ -1495,7 +1597,7 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (device == "@" || device == "default")
     {
       /* Make it "Default (whatever)" */
-      info.m_displayName = "Default (" + info.m_displayName + (info.m_displayNameExtra.empty() ? "" : " " + info.m_displayNameExtra + ")");
+      info.m_displayName = "Default (" + info.m_displayName + (info.m_displayNameExtra.empty() ? "" : ": " + info.m_displayNameExtra + ")");
       info.m_displayNameExtra = "";
     }
 
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index d7863c254b..357e85a3c5 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -24,6 +24,8 @@
 #include <androidjni/Build.h>
 #include <unistd.h>
 
+#include "utils/AMLUtils.h"
+
 // This is an alternative to the linear weighted delay smoothing
 // advantages: only one history value needs to be stored
 // in tests the linear weighted average smoother yield better results
@@ -45,6 +47,24 @@ static const AEChannel KnownChannels[] = {AE_CH_FL, AE_CH_FR,   AE_CH_FC,   AE_C
                                           AE_CH_SL, AE_CH_SR,   AE_CH_BL,   AE_CH_BR,
                                           AE_CH_BC, AE_CH_BLOC, AE_CH_BROC, AE_CH_NULL};
 
+// AMLogic helper for HD Audio
+bool CAESinkAUDIOTRACK::HasAmlHD()
+{
+  // AML in great wisdom have these values renamed - with the workaround in libjniandroid gone
+  // we also workaround that here. Remember: a hack introduces a second hack
+  if (CJNIAudioFormat::ENCODING_TRUEHD != -1)
+    CJNIAudioFormat::ENCODING_DOLBY_TRUEHD = CJNIAudioFormat::ENCODING_TRUEHD;
+
+  // For DTS_HD AML might know two formats: ENCODING_DTSHD or ENCODING_DTSHD_MA
+  // ENCODING_DTSHD_MA has priority
+  if (CJNIAudioFormat::ENCODING_DTSHD != -1)
+    CJNIAudioFormat::ENCODING_DTS_HD = CJNIAudioFormat::ENCODING_DTSHD;
+  if (CJNIAudioFormat::ENCODING_DTSHD_MA != -1)
+    CJNIAudioFormat::ENCODING_DTS_HD = CJNIAudioFormat::ENCODING_DTSHD_MA;
+
+  return ((CJNIAudioFormat::ENCODING_TRUEHD != -1) && (CJNIAudioFormat::ENCODING_DTSHD != -1));
+}
+
 static int AEStreamFormatToATFormat(const CAEStreamInfo::DataType& dt)
 {
   switch (dt)
@@ -425,6 +445,10 @@ bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
       atChannelMask = CJNIAudioFormat::CHANNEL_OUT_STEREO;
   }
 
+  // old aml without IEC61937 passes everything via 2 channels
+  if (aml_present() && m_passthrough && m_info.m_wantsIECPassthrough && (CJNIAudioFormat::ENCODING_IEC61937 == -1))
+    atChannelMask = CJNIAudioFormat::CHANNEL_OUT_STEREO;
+
   bool retried = false;
   while (!m_at_jni)
   {
@@ -507,8 +531,14 @@ bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
     else
     {
       m_format.m_frameSize = m_format.m_channelLayout.Count() * (CAEUtil::DataFormatToBits(m_format.m_dataFormat) / 8);
-      m_sink_frameSize = m_format.m_frameSize;
-      // aim at max 200 ms buffer and 50 ms periods but at least two periods of min_buffer
+
+      // again a workaround for AML old code
+      if (m_passthrough && aml_present() && m_info.m_wantsIECPassthrough && (CJNIAudioFormat::ENCODING_IEC61937 == -1))
+        m_sink_frameSize = 2 * CAEUtil::DataFormatToBits(AE_FMT_S16LE) / 8; // sending via 2 channels 2 * 16 / 8 = 4
+      else
+        m_sink_frameSize = m_format.m_frameSize;
+
+      // aim at 200 ms buffer and 50 ms periods but at least two periods of min_buffer
       // make sure periods are actually not smaller than 32 ms (32, cause 32 * 2 = 64)
       // but also lower than 64 ms
       // which is large enough to not cause CPU hogging in case 32 ms periods are used
@@ -526,6 +556,19 @@ bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
         m_min_buffer_size = buffer_frames * m_sink_frameSize;
         c = 5; // 50 ms
       }
+
+      if (m_passthrough)
+      {
+        // AML in old mode needs more buffer or it stutters when faking PT
+        if (aml_present() && m_passthrough && m_info.m_wantsIECPassthrough && (CJNIAudioFormat::ENCODING_IEC61937 == -1))
+        {
+          if (m_sink_sampleRate > 48000)
+            m_min_buffer_size *= (m_sink_sampleRate / 48000); // same amount of buffer in seconds as for 48 khz
+          else if (m_sink_sampleRate < m_format.m_sampleRate) // eac3
+            m_min_buffer_size *= (m_format.m_sampleRate / m_sink_sampleRate);
+        }
+      }
+
       // update potential new buffertime
       m_audiotrackbuffer_sec =
           static_cast<double>(m_min_buffer_size) / (m_sink_frameSize * m_sink_sampleRate);
@@ -678,7 +721,16 @@ void CAESinkAUDIOTRACK::GetDelay(AEDelayStatus& status)
   // and add head_pos which wrapped around, e.g. 0x0001 0000 0000 -> 0x0001 0000 0004
   m_headPos = (m_headPos & UINT64_UPPER_BYTES) | (uint64_t)head_pos;
 
-  double gone = static_cast<double>(m_headPos) / m_sink_sampleRate;
+  uint64_t normHead_pos = m_headPos;
+
+  // this makes EAC3 working even when AML is not enabled
+  if (aml_present() && m_info.m_wantsIECPassthrough &&
+      (m_encoding == CJNIAudioFormat::ENCODING_DTS_HD ||
+       m_encoding == CJNIAudioFormat::ENCODING_E_AC3 ||
+       m_encoding == CJNIAudioFormat::ENCODING_DOLBY_TRUEHD))
+    normHead_pos /= m_sink_frameSize;  // AML wants sink in 48k but returns pos in 192k
+
+  double gone = static_cast<double>(normHead_pos) / m_sink_sampleRate;
 
   // if sink is run dry without buffer time written anymore
   if (gone > m_duration_written)
@@ -1097,6 +1149,25 @@ void CAESinkAUDIOTRACK::UpdateAvailablePassthroughCapabilities(bool isRaw)
       }
     }
 
+    if (aml_present() && CJNIAudioManager::GetSDKVersion() < 23)
+    {
+      // passthrough
+      m_info.m_wantsIECPassthrough = true;
+      m_sink_sampleRates.insert(44100);
+      m_sink_sampleRates.insert(48000);
+      if (HasAmlHD())
+      {
+        m_sink_sampleRates.insert(96000);
+        m_sink_sampleRates.insert(192000);
+        m_info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_EAC3);
+        m_info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_DTSHD);
+        m_info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_DTSHD_MA);
+        m_info.m_streamTypes.push_back(CAEStreamInfo::STREAM_TYPE_TRUEHD);
+      }
+      std::copy(m_sink_sampleRates.begin(), m_sink_sampleRates.end(), std::back_inserter(m_info.m_sampleRates));
+      return;  // all done here
+    }
+
     if (CJNIAudioManager::GetSDKVersion() >= 23)
     {
       if (CJNIAudioFormat::ENCODING_DTS_HD != -1)
@@ -1194,15 +1265,21 @@ void CAESinkAUDIOTRACK::UpdateAvailablePCMCapabilities()
     CLog::Log(LOGINFO, "Multi channel Float is supported");
   }
 
-  int test_sample[] = { 32000, 44100, 48000, 88200, 96000, 176400, 192000 };
-  int test_sample_sz = sizeof(test_sample) / sizeof(int);
-
-  for (int i = 0; i < test_sample_sz; ++i)
+  // Still AML API 21 and 22 get hardcoded samplerates - we can drop that
+  // when we stop supporting API < 23 - let's only add the default
+  // music samplerate
+  if (!aml_present() || CJNIAudioManager::GetSDKVersion() >= 23)
   {
-    if (IsSupported(test_sample[i], CJNIAudioFormat::CHANNEL_OUT_STEREO, encoding))
+    int test_sample[] = { 32000, 44100, 48000, 88200, 96000, 176400, 192000 };
+    int test_sample_sz = sizeof(test_sample) / sizeof(int);
+
+    for (int i = 0; i < test_sample_sz; ++i)
     {
-      m_sink_sampleRates.insert(test_sample[i]);
-      CLog::Log(LOGDEBUG, "AESinkAUDIOTRACK - {} supported", test_sample[i]);
+      if (IsSupported(test_sample[i], CJNIAudioFormat::CHANNEL_OUT_STEREO, encoding))
+      {
+        m_sink_sampleRates.insert(test_sample[i]);
+        CLog::Log(LOGDEBUG, "AESinkAUDIOTRACK - {:d} supported", test_sample[i]);
+      }
     }
   }
   std::copy(m_sink_sampleRates.begin(), m_sink_sampleRates.end(), std::back_inserter(m_info.m_sampleRates));
@@ -1246,4 +1323,3 @@ double CAESinkAUDIOTRACK::GetMovingAverageDelay(double newestdelay)
 
   return sum * denom;
 }
-
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
index d40b9a7c8e..0cab6ff2de 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
@@ -49,6 +49,7 @@ protected:
                                       int channelMask,
                                       int encoding,
                                       bool isRaw = false);
+  static bool HasAmlHD();
   static void UpdateAvailablePCMCapabilities();
   static void UpdateAvailablePassthroughCapabilities(bool isRaw = false);
 
diff --git a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
index e3d74ca3a1..d724ab4bd5 100644
--- a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
@@ -313,7 +313,8 @@ bool CAEChannelInfo::ContainsChannels(const CAEChannelInfo& rhs) const
 {
   for (unsigned int i = 0; i < rhs.m_channelCount; ++i)
   {
-    if (!HasChannel(rhs.m_channels[i]))
+   if (rhs.m_channels[i] > AE_CH_NULL && rhs.m_channels[i] < AE_CH_UNKNOWN1 &&
+        !HasChannel(rhs.m_channels[i]))
       return false;
   }
   return true;
diff --git a/xbmc/cores/RetroPlayer/process/RPProcessInfo.h b/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
index bc5a5db986..61d97b9558 100644
--- a/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
+++ b/xbmc/cores/RetroPlayer/process/RPProcessInfo.h
@@ -142,6 +142,14 @@ public:
    */
   SCALINGMETHOD GetDefaultScalingMethod() const { return m_defaultScalingMethod; }
 
+  /*!
+   * \brief Configure the render system
+   *
+   * \param format The pixel format of the video stream, or AV_PIX_FMT_NONE
+   *        if the stream has ended
+   */
+  virtual void ConfigureRenderSystem(AVPixelFormat format) { }
+
   ///}
 
   /// @name Player video info
diff --git a/xbmc/cores/RetroPlayer/process/amlogic/CMakeLists.txt b/xbmc/cores/RetroPlayer/process/amlogic/CMakeLists.txt
new file mode 100644
index 0000000000..be5fcbdabe
--- /dev/null
+++ b/xbmc/cores/RetroPlayer/process/amlogic/CMakeLists.txt
@@ -0,0 +1,6 @@
+if("aml" IN_LIST CORE_PLATFORM_NAME_LC)
+  set(SOURCES RPProcessInfoAmlogic.cpp)
+  set(HEADERS RPProcessInfoAmlogic.h)
+
+  core_add_library(rp-process-amlogic)
+endif()
diff --git a/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.cpp b/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.cpp
new file mode 100644
index 0000000000..f4ad256d67
--- /dev/null
+++ b/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.cpp
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RPProcessInfoAmlogic.h"
+#include "utils/AMLUtils.h"
+#include "utils/log.h"
+
+using namespace KODI;
+using namespace RETRO;
+
+CRPProcessInfoAmlogic::CRPProcessInfoAmlogic() :
+  CRPProcessInfo("Amlogic")
+{
+}
+
+CRPProcessInfo* CRPProcessInfoAmlogic::Create()
+{
+  return new CRPProcessInfoAmlogic();
+}
+
+void CRPProcessInfoAmlogic::Register()
+{
+  CRPProcessInfo::RegisterProcessControl(CRPProcessInfoAmlogic::Create);
+}
+
+void CRPProcessInfoAmlogic::ConfigureRenderSystem(AVPixelFormat format)
+{
+  if (format == AV_PIX_FMT_0RGB32 || format == AV_PIX_FMT_0BGR32)
+  {
+    /*  Set the Amlogic chip to ignore the alpha channel.
+     *  The proprietary OpenGL lib does not (currently)
+     *  handle this, potentially resulting in a black screen.
+     *  This capability is only present in S905 chips and higher.
+     */
+    if (aml_set_reg_ignore_alpha())
+      CLog::Log(LOGDEBUG, "RetroPlayer[RENDER]: Amlogic set to ignore alpha");
+  }
+  else
+  {
+    if (aml_unset_reg_ignore_alpha())
+      CLog::Log(LOGDEBUG, "RetroPlayer[RENDER]: Amlogic unset to ignore alpha");
+  }
+}
diff --git a/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.h b/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.h
new file mode 100644
index 0000000000..13804026b9
--- /dev/null
+++ b/xbmc/cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/RetroPlayer/process/RPProcessInfo.h"
+
+namespace KODI
+{
+namespace RETRO
+{
+  class CRPProcessInfoAmlogic : public CRPProcessInfo
+  {
+  public:
+    CRPProcessInfoAmlogic();
+
+    static CRPProcessInfo* Create();
+    static void Register();
+
+    // Implementation of CRPProcessInfo
+    void ConfigureRenderSystem(AVPixelFormat format) override;
+
+  };
+}
+}
diff --git a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
index 7d76d7ec8f..fca2908c09 100644
--- a/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
+++ b/xbmc/cores/RetroPlayer/rendering/RPRenderManager.cpp
@@ -67,6 +67,9 @@ void CRPRenderManager::Deinitialize()
     task.wait();
   m_savestateThreads.clear();
 
+  // Required to reset Amlogic chip to default state
+  m_processInfo.ConfigureRenderSystem(AV_PIX_FMT_NONE);
+
   for (auto& pixelScalerMap : m_scalers)
   {
     for (auto& pixelScaler : pixelScalerMap.second)
@@ -280,6 +283,8 @@ void CRPRenderManager::FrameMove()
 
     if (m_state == RENDER_STATE::CONFIGURING)
     {
+      m_processInfo.ConfigureRenderSystem(m_format);
+
       m_state = RENDER_STATE::CONFIGURED;
 
       CLog::Log(LOGINFO, "RetroPlayer[RENDER]: Renderer configured on first frame");
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
index 5b7f34d6e5..b758fab06a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.cpp
@@ -10,11 +10,14 @@
 
 #include "cores/FFmpeg.h"
 #include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "utils/log.h"
 
 #include <array>
+#include <assert.h>
 
 extern "C" {
 #include <libswscale/swscale.h>
+#include <libavutil/intreadwrite.h>
 }
 
 bool CDVDCodecUtils::IsVP3CompatibleWidth(int width)
@@ -75,3 +78,84 @@ double CDVDCodecUtils::NormalizeFrameduration(double frameduration, bool *match)
   }
 }
 
+bool CDVDCodecUtils::IsH264AnnexB(std::string format, AVStream *avstream)
+{
+  assert(avstream->codecpar->codec_id == AV_CODEC_ID_H264 || avstream->codecpar->codec_id == AV_CODEC_ID_H264_MVC);
+  if (avstream->codecpar->extradata_size < 4)
+    return true;
+  if (avstream->codecpar->extradata[0] == 1)
+    return false;
+  if (format == "avi")
+  {
+    uint8_t *src = avstream->codecpar->extradata;
+    unsigned startcode = AV_RB32(src);
+    if (startcode == 0x00000001 || (startcode & 0xffffff00) == 0x00000100)
+      return true;
+    if (avstream->codecpar->codec_tag == MKTAG('A', 'V', 'C', '1') || avstream->codecpar->codec_tag == MKTAG('a', 'v', 'c', '1'))
+      return false;
+  }
+  return true;
+}
+
+bool CDVDCodecUtils::ProcessH264MVCExtradata(uint8_t *data, uint32_t data_size, uint8_t **mvc_data, uint32_t *mvc_data_size)
+{
+  uint8_t* extradata = data;
+  uint32_t extradata_size = data_size;
+
+  if (extradata_size > 4 && *(char *)extradata == 1)
+  {
+    // Find "mvcC" atom
+    uint32_t state = -1;
+    uint32_t i = 0;
+    for (; i < extradata_size; i++)
+    {
+      state = (state << 8) | extradata[i];
+      if (state == MKBETAG('m', 'v', 'c', 'C'))
+        break;
+    }
+    if (i >= 8 && i < extradata_size)
+    {
+      // Update pointers to the start of the mvcC atom
+      extradata = extradata + i - 7;
+      extradata_size = extradata_size - i + 7;
+      // verify size atom and actual size
+      if (extradata_size >= 14 && (AV_RB32(extradata) + 4) <= extradata_size)
+      {
+        extradata += 8;
+        extradata_size -= 8;
+        if (*(char *)extradata == 1)
+        {
+          if (mvc_data)
+            *mvc_data = extradata;
+          if (mvc_data_size)
+            *mvc_data_size = extradata_size;
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+
+bool CDVDCodecUtils::GetH264MvcStreamIndex(AVFormatContext *fmt, int *mvcIndex)
+{
+  *mvcIndex = -1;
+
+  for (size_t i = 0; i < fmt->nb_streams; i++)
+  {
+    AVStream *st = fmt->streams[i];
+
+    if (st->codecpar->codec_id == AV_CODEC_ID_H264_MVC)
+    {
+      if (*mvcIndex != -1)
+      {
+        CLog::Log(LOGDEBUG, "multiple h264 mvc extension streams aren't supported");
+        return false;
+      }
+
+      *mvcIndex = i;
+    }
+  }
+
+  return *mvcIndex >= 0;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
index 37872d1624..9936faacae 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h
@@ -8,11 +8,18 @@
 
 #pragma once
 
+#include "Video/DVDVideoCodec.h"
+
+class AVStream;
+struct AVFormatContext;
 
 class CDVDCodecUtils
 {
 public:
   static bool IsVP3CompatibleWidth(int width);
   static double NormalizeFrameduration(double frameduration, bool *match = nullptr);
+  static bool IsH264AnnexB(std::string format, AVStream *avstream);
+  static bool ProcessH264MVCExtradata(uint8_t *extradata, uint32_t extradata_size, uint8_t **mvc_extradata = nullptr, uint32_t *mvc_extradata_size = nullptr);
+  static bool GetH264MvcStreamIndex(AVFormatContext *fmt, int *mvcIndex);
 };
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlay.h b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlay.h
index bf8ff7a03d..0af5db4a02 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlay.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlay.h
@@ -36,6 +36,7 @@ public:
     replace = false;
     m_references = 1;
     m_textureid = 0;
+    m_3dSubtitleDepth = 0;
     m_enableTextAlign = false;
     m_overlayContainerFlushable = true;
     m_setForcedMargins = false;
@@ -50,6 +51,7 @@ public:
     replace       = src.replace;
     m_references  = 1;
     m_textureid = 0;
+    m_3dSubtitleDepth = 0;
     m_enableTextAlign = src.m_enableTextAlign;
     m_overlayContainerFlushable = src.m_overlayContainerFlushable;
     m_setForcedMargins = src.m_setForcedMargins;
@@ -136,6 +138,8 @@ public:
   bool replace; // replace by next nomatter what stoptime it has
   unsigned long m_textureid;
 
+  int m_3dSubtitleDepth;
+
 protected:
   DVDOverlayType m_type;
   bool m_enableTextAlign;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
index 8c26cad306..c4ecbd8b1d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
@@ -246,22 +246,6 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
       }
     }
 
-    RENDER_STEREO_MODE render_stereo_mode = CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
-    if (render_stereo_mode != RENDER_STEREO_MODE_OFF &&
-        render_stereo_mode != RENDER_STEREO_MODE_HARDWAREBASED)
-    {
-      if (rect.h > m_height / 2)
-      {
-        m_height /= 2;
-        rect.h /= 2;
-      }
-      else if (rect.w > m_width / 2)
-      {
-        m_width /= 2;
-        rect.w /= 2;
-      }
-    }
-
     CDVDOverlayImage* overlay = new CDVDOverlayImage();
 
     overlay->iPTSStartTime = m_StartTime;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
index 517acc3cd4..dee28926a0 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
@@ -11,6 +11,40 @@ if(NOT ENABLE_EXTERNAL_LIBAV)
   list(APPEND HEADERS DVDVideoPPFFmpeg.h)
 endif()
 
+if(AML_FOUND)
+  list(APPEND SOURCES amlogic/AMLCodecList.cpp
+                      amlogic/AMLInsecureVideoCodec.cpp
+                      amlogic/AMLVideoCodec.cpp
+                      amlogic/AV1Codec.cpp
+                      amlogic/H264Codec.cpp
+                      amlogic/HEVCCodec.cpp
+                      amlogic/LibAmcodec.cpp
+                      amlogic/MJPEGCodec.cpp
+                      amlogic/MPEG12Codec.cpp
+                      amlogic/MPEG4Codec.cpp
+                      amlogic/VC1Codec.cpp
+                      amlogic/VP9Codec.cpp
+                      DVDVideoCodecAmlogic.cpp)
+  list(APPEND HEADERS amlogic/AMLCodecList.h
+                      amlogic/AMLInsecureVideoCodec.h
+                      amlogic/AMLVideoCodec.h
+                      amlogic/AMLVideoCodecConstants.h
+                      amlogic/AMLVideoCodecDataTypes.h
+                      amlogic/AMLVideoCodecInfo.h
+                      amlogic/AV1Codec.h
+                      amlogic/H264Codec.h
+                      amlogic/HEVCCodec.h
+                      amlogic/LibAmcodec.h
+                      amlogic/MJPEGCodec.h
+                      amlogic/MPEG12Codec.h
+                      amlogic/MPEG4Codec.h
+                      amlogic/namespace.h
+                      amlogic/PosixFile.h
+                      amlogic/VC1Codec.h
+                      amlogic/VP9Codec.h
+                      DVDVideoCodecAmlogic.h)
+endif()
+
 if(CORE_SYSTEM_NAME STREQUAL windows OR CORE_SYSTEM_NAME STREQUAL windowsstore)
   list(APPEND SOURCES DXVA.cpp)
   list(APPEND HEADERS DXVA.h)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
index 5e025945f5..d5cb42b5a3 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
@@ -46,6 +46,8 @@ void VideoPicture::Reset()
   colorBits = 8;
   stereoMode.clear();
 
+  m_3dSubtitleDepth = 0;
+
   qp_table = nullptr;
   qstride = 0;
   qscale_type = 0;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
index b23fd48383..dd1c7b8fdb 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -58,6 +58,8 @@ public:
   unsigned int colorBits = 8;
   std::string stereoMode;
 
+  int m_3dSubtitleDepth;
+
   int8_t* qp_table;                //< Quantization parameters, primarily used by filters
   int qstride;
   int qscale_type;
@@ -237,6 +239,11 @@ public:
    */
   virtual void Reopen() {}
 
+  /**
+  * Indicates that the decoder supports extention streams.
+  */
+  virtual bool SupportsExtention() { return false; }
+
 protected:
   CProcessInfo &m_processInfo;
 };
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp
new file mode 100644
index 0000000000..be986d1c7a
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp
@@ -0,0 +1,305 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include <math.h>
+
+#include "DVDCodecs/DVDFactoryCodec.h"
+#include "DVDVideoCodecAmlogic.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "DVDStreamInfo.h"
+#include "ServiceBroker.h"
+#include "utils/AMLUtils.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "threads/Thread.h"
+
+#include "amlogic/AMLCodecList.h"
+#include "amlogic/AMLVideoCodecInfo.h"
+
+#define __MODULE_NAME__ "DVDVideoCodecAmlogic"
+
+CAMLVideoBufferPool::~CAMLVideoBufferPool()
+{
+  CLog::Log(LOGDEBUG, "CAMLVideoBufferPool::~CAMLVideoBufferPool: Deleting {:d} buffers", static_cast<unsigned int>(m_videoBuffers.size()) );
+  for (auto buffer : m_videoBuffers)
+    delete buffer;
+}
+
+CVideoBuffer* CAMLVideoBufferPool::Get()
+{
+  std::unique_lock<CCriticalSection> lock(m_criticalSection);
+
+  if (m_freeBuffers.empty())
+  {
+    m_freeBuffers.push_back(m_videoBuffers.size());
+    m_videoBuffers.push_back(new CAMLVideoBuffer(static_cast<int>(m_videoBuffers.size())));
+  }
+  int bufferIdx(m_freeBuffers.back());
+  m_freeBuffers.pop_back();
+
+  m_videoBuffers[bufferIdx]->Acquire(shared_from_this());
+
+  return m_videoBuffers[bufferIdx];
+}
+
+void CAMLVideoBufferPool::Return(int id)
+{
+  std::unique_lock<CCriticalSection> lock(m_criticalSection);
+  if (m_videoBuffers[id]->m_amlCodec)
+  {
+    m_videoBuffers[id]->m_amlCodec->releaseFrame(m_videoBuffers[id]->m_bufferIndex, true);
+    m_videoBuffers[id]->m_amlCodec = nullptr;
+  }
+  m_freeBuffers.push_back(id);
+}
+
+/***************************************************************************/
+
+CDVDVideoCodecAmlogic::CDVDVideoCodecAmlogic(CProcessInfo &processInfo)
+  : CDVDVideoCodec(processInfo)
+  , m_pFormatName("amcodec")
+  , m_opened(false)
+  , m_codecControlFlags(0)
+{
+}
+
+CDVDVideoCodecAmlogic::~CDVDVideoCodecAmlogic()
+{
+  Dispose();
+}
+
+std::unique_ptr<CDVDVideoCodec> CDVDVideoCodecAmlogic::Create(CProcessInfo& processInfo)
+{
+  return std::make_unique<CDVDVideoCodecAmlogic>(processInfo);
+}
+
+bool CDVDVideoCodecAmlogic::Register()
+{
+  CDVDFactoryCodec::RegisterHWVideoCodec("amlogic_dec", CDVDVideoCodecAmlogic::Create);
+  return true;
+}
+
+std::atomic<bool> CDVDVideoCodecAmlogic::m_InstanceGuard(false);
+
+bool CDVDVideoCodecAmlogic::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEAMCODEC))
+    return false;
+  if (hints.stills || hints.width == 0)
+    return false;
+
+  if (!aml_permissions())
+  {
+    CLog::Log(LOGERROR, "AML: no proper permission, please contact the device vendor. Skipping codec...");
+    return false;
+  }
+
+  // allow only 1 instance here
+  if (m_InstanceGuard.exchange(true))
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecAmlogic::Open - InstanceGuard locked\n");
+    return false;
+  }
+
+  m_opened = false;
+
+  m_hints = hints;
+
+  CLog::Log(LOGDEBUG, "CDVDVideoCodecAmlogic::Opening: codec {:d} profile:{:d} extra_size:{:d}", m_hints.codec, hints.profile, hints.extrasize);
+
+  bool needSecureDecoder = false;
+#if notyet
+  if (m_hints.cryptoSession) {
+	  // TODO implement DRM playback
+	  needSecureDecoder = true;
+  }
+#endif
+
+  amlogic::AMLCodecList &codecList = amlogic::AMLCodecList::getInstance();
+
+  for (unsigned cc = 0; cc < codecList.getCodecCount(); cc++) {
+	  amlogic::AMLVideoCodecInfo &codecInfo = codecList.getCodecInfoAt(cc);
+
+	  if (codecInfo.isSecure() != needSecureDecoder) {
+		  CLog::Log(LOGDEBUG, "CDVDVideoCodecAmlogic: skipping decoder {} because security precondition not met (decoder is marked as {}secure)",
+				  codecInfo.getCodecName(), codecInfo.isSecure() ? "" : "not ");
+		  continue;
+	  }
+
+	  if (!codecInfo.canPlay(m_hints)) {
+		  CLog::Log(LOGDEBUG, "CDVDVideoCodecAmlogic: skipping decoder {}", codecInfo.getCodecName());
+		  continue;
+	  }
+
+	  CLog::Log(LOGINFO, "CDVDVideoCodecAmlogic: using Amlogic decoder {}", codecInfo.getCodecName());
+	  m_codec = std::shared_ptr<amlogic::AMLVideoCodec>(codecInfo.createCodec(m_processInfo, m_hints));
+	  break;
+  }
+
+  if (m_codec == nullptr) {
+    // no suitable codec found
+    CLog::Log(LOGERROR, "{}: Failed to create Amlogic Codec for codec id = {}", __MODULE_NAME__, m_hints.codec);
+    goto FAIL;
+  }
+
+  m_pFormatName = m_codec->getFormatName().c_str();
+
+  m_aspect_ratio = m_hints.aspect;
+
+  // allocate a dummy VideoPicture buffer.
+  m_videobuffer.Reset();
+
+  m_videobuffer.iWidth  = m_hints.width;
+  m_videobuffer.iHeight = m_hints.height;
+
+  m_videobuffer.iDisplayWidth  = m_videobuffer.iWidth;
+  m_videobuffer.iDisplayHeight = m_videobuffer.iHeight;
+  if (m_hints.aspect > 0.0 && !m_hints.forced_aspect)
+  {
+    m_videobuffer.iDisplayWidth  = ((int)lrint(m_videobuffer.iHeight * m_hints.aspect)) & ~3;
+    if (m_videobuffer.iDisplayWidth > m_videobuffer.iWidth)
+    {
+      m_videobuffer.iDisplayWidth  = m_videobuffer.iWidth;
+      m_videobuffer.iDisplayHeight = ((int)lrint(m_videobuffer.iWidth / m_hints.aspect)) & ~3;
+    }
+  }
+
+  m_processInfo.SetVideoDecoderName(m_pFormatName, true);
+  m_processInfo.SetVideoDimensions(m_hints.width, m_hints.height);
+  m_processInfo.SetVideoDeintMethod("hardware");
+  m_processInfo.SetVideoDAR(m_hints.aspect);
+  m_processInfo.SetVideoStereoMode(m_hints.stereo_mode);
+
+  CLog::Log(LOGINFO, "{}: Opened Amlogic Codec", __MODULE_NAME__);
+  return true;
+FAIL:
+  Dispose();
+  return false;
+}
+
+void CDVDVideoCodecAmlogic::Dispose(void)
+{
+  m_videoBufferPool = nullptr;
+
+  if (m_codec) {
+    m_codec->closeDecoder(), m_codec = nullptr;
+  }
+
+  m_videobuffer.iFlags = 0;
+
+  m_opened = false;
+  m_InstanceGuard.exchange(false);
+}
+
+bool CDVDVideoCodecAmlogic::AddData(const DemuxPacket &packet)
+{
+  // Handle Input, add demuxer packet to input queue, we must accept it or
+  // it will be discarded as VideoPlayerVideo has no concept of "try again".
+
+  if (packet.iSize == 0 || packet.pData == nullptr) {
+	  // we ignore empty packets
+	  return true;
+  }
+
+  uint8_t *pData(packet.pData);
+  size_t iSize(packet.iSize);
+
+  if (!m_codec->prepareFrame(m_hints, pData, iSize, packet.dts, packet.pts)) {
+	  // something went wrong or we haven't got enough data yet
+      return true;
+  }
+
+  if (!m_opened) {
+    if (packet.pts == DVD_NOPTS_VALUE) {
+      m_hints.ptsinvalid = true;
+    }
+
+    if (m_codec && !m_codec->openDecoder(m_hints)) {
+      CLog::Log(LOGERROR, "{}: Failed to open Amlogic Codec", __MODULE_NAME__);
+    }
+
+    m_videoBufferPool = std::shared_ptr<CAMLVideoBufferPool>(new CAMLVideoBufferPool());
+
+    m_opened = true;
+  }
+
+  return m_codec->addData(pData, iSize, packet.dts, m_hints.ptsinvalid ? DVD_NOPTS_VALUE : packet.pts, packet.subtitlePlane);
+}
+
+void CDVDVideoCodecAmlogic::Reset(void)
+{
+  m_codec->reset();
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecAmlogic::GetPicture(VideoPicture* pVideoPicture)
+{
+  if (!m_codec) {
+    return VC_ERROR;
+  }
+
+  VCReturn retVal = m_codec->getPicture(&m_videobuffer);
+
+  if (retVal == VC_PICTURE)
+  {
+    pVideoPicture->SetParams(m_videobuffer);
+
+    pVideoPicture->videoBuffer = m_videoBufferPool->Get();
+    static_cast<CAMLVideoBuffer*>(pVideoPicture->videoBuffer)->Set(this, m_codec,
+     m_codec->getOMXPts(), m_codec->getAmlDuration(), m_codec->getBufferIndex());;
+  }
+
+  m_aspect_ratio = m_codec->getAspectRatio();
+
+  pVideoPicture->iDisplayWidth  = pVideoPicture->iWidth;
+  pVideoPicture->iDisplayHeight = pVideoPicture->iHeight;
+
+  //set default if there is no other information for TV/DVD modes
+  if (pVideoPicture->iWidth > 0 && pVideoPicture->iWidth != 640 &&
+      (pVideoPicture->iHeight == 480 || pVideoPicture->iHeight == 576) &&
+      m_aspect_ratio < 0.1f)
+      m_aspect_ratio = 16.0f / 9.0f;
+
+  if (m_aspect_ratio > 1.0 && !m_hints.forced_aspect)
+  {
+    pVideoPicture->iDisplayWidth  = ((int)lrint(pVideoPicture->iHeight * m_aspect_ratio)) & ~3;
+    if (pVideoPicture->iDisplayWidth > pVideoPicture->iWidth)
+    {
+      pVideoPicture->iDisplayWidth  = pVideoPicture->iWidth;
+      pVideoPicture->iDisplayHeight = ((int)lrint(pVideoPicture->iWidth / m_aspect_ratio)) & ~3;
+    }
+  }
+
+  return retVal;
+}
+
+void CDVDVideoCodecAmlogic::SetCodecControl(int flags)
+{
+  if (m_codecControlFlags != flags)
+  {
+    CLog::Log(LOGDEBUG, LOGVIDEO, "{} {:x}->{:x}",  __func__, m_codecControlFlags, flags);
+    m_codecControlFlags = flags;
+
+    if (flags & DVD_CODEC_CTRL_DROP)
+      m_videobuffer.iFlags |= DVP_FLAG_DROPPED;
+    else
+      m_videobuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+    if (m_codec)
+      m_codec->setDrain((flags & DVD_CODEC_CTRL_DRAIN) != 0);
+  }
+}
+
+void CDVDVideoCodecAmlogic::SetSpeed(int iSpeed)
+{
+  if (m_codec)
+    m_codec->setSpeed(iSpeed);
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h
new file mode 100644
index 0000000000..fb51cbccf7
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h
@@ -0,0 +1,89 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "threads/CriticalSection.h"
+#include "cores/VideoPlayer/Buffers/VideoBuffer.h"
+
+#include <set>
+#include <atomic>
+#include "amlogic/AMLVideoCodec.h"
+
+class CDVDVideoCodecAmlogic;
+
+class CAMLVideoBuffer : public CVideoBuffer
+{
+public:
+  CAMLVideoBuffer(int id) : CVideoBuffer(id) {};
+  void Set(CDVDVideoCodecAmlogic *codec, std::shared_ptr<amlogic::AMLVideoCodec> amlcodec, int omxPts, int amlDuration, uint32_t bufferIndex)
+  {
+    m_codec = codec;
+    m_amlCodec = amlcodec;
+    m_omxPts = omxPts;
+    m_amlDuration = amlDuration;
+    m_bufferIndex = bufferIndex;
+  }
+
+  CDVDVideoCodecAmlogic* m_codec;
+  std::shared_ptr<amlogic::AMLVideoCodec> m_amlCodec;
+  int m_omxPts, m_amlDuration;
+  uint32_t m_bufferIndex;
+};
+
+class CAMLVideoBufferPool : public IVideoBufferPool
+{
+public:
+  virtual ~CAMLVideoBufferPool();
+
+  virtual CVideoBuffer* Get() override;
+  virtual void Return(int id) override;
+
+private:
+  CCriticalSection m_criticalSection;;
+  std::vector<CAMLVideoBuffer*> m_videoBuffers;
+  std::vector<int> m_freeBuffers;
+};
+
+class CDVDVideoCodecAmlogic : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecAmlogic(CProcessInfo &processInfo);
+  virtual ~CDVDVideoCodecAmlogic();
+
+  static std::unique_ptr<CDVDVideoCodec> Create(CProcessInfo& processInfo);
+  static bool Register();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
+  virtual bool AddData(const DemuxPacket &packet) override;
+  virtual void Reset() override;
+  virtual VCReturn GetPicture(VideoPicture* pVideoPicture) override;
+  virtual void SetSpeed(int iSpeed) override;
+  virtual void SetCodecControl(int flags) override;
+  virtual const char* GetName(void) override { return (const char*)m_pFormatName; }
+  virtual bool SupportsExtention() { return true; }
+
+protected:
+  void            Dispose(void);
+
+  std::shared_ptr<amlogic::AMLVideoCodec> m_codec;
+
+  const char     *m_pFormatName;
+  VideoPicture m_videobuffer;
+  bool            m_opened;
+  int             m_codecControlFlags;
+  CDVDStreamInfo  m_hints;
+  float           m_aspect_ratio;
+
+private:
+  std::shared_ptr<CAMLVideoBufferPool> m_videoBufferPool;
+  static std::atomic<bool> m_InstanceGuard;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.cpp
new file mode 100644
index 0000000000..e831e9ecb6
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.cpp
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AMLCodecList.h"
+
+#include "AMLVideoCodecInfo.h"
+
+#include "threads/SingleLock.h"
+#include "threads/CriticalSection.h"
+
+
+using namespace amlogic;
+
+CCriticalSection AMLCodecList::m_mutex;
+AMLCodecList *AMLCodecList::m_instance = nullptr;
+
+AMLCodecList::AMLCodecList()
+{
+}
+
+AMLCodecList::~AMLCodecList()
+{
+	std::unique_lock<CCriticalSection> lock(m_mutex);
+
+	m_instance = nullptr;
+}
+
+AMLCodecList &AMLCodecList::getInstance()
+{
+	std::unique_lock<CCriticalSection> lock(m_mutex);
+
+	if (m_instance == nullptr) {
+		m_instance = new AMLCodecList();
+	}
+
+	return *m_instance;
+}
+
+void AMLCodecList::registerAmlVideoCodec(AMLVideoCodecInfo *info)
+{
+	std::unique_lock<CCriticalSection> lock(m_mutex);
+
+	m_codecInfo.push_back(info);
+}
+
+unsigned AMLCodecList::getCodecCount() const
+{
+	return m_codecInfo.size();
+}
+
+AMLVideoCodecInfo &AMLCodecList::getCodecInfoAt(unsigned index) const
+{
+	return *m_codecInfo.at(index);
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.h
new file mode 100644
index 0000000000..ef2832e1cb
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLCodecList.h
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "threads/CriticalSection.h"
+
+#include "namespace.h"
+
+#include <vector>
+
+class amlogic::AMLCodecList
+{
+private:
+	static CCriticalSection	 m_mutex;
+	static AMLCodecList		*m_instance;
+
+	std::vector<AMLVideoCodecInfo*> m_codecInfo;
+
+	AMLCodecList();
+	~AMLCodecList();
+
+public:
+	static AMLCodecList &getInstance();
+
+	void registerAmlVideoCodec(AMLVideoCodecInfo *info);
+
+	unsigned getCodecCount() const;
+	AMLVideoCodecInfo &getCodecInfoAt(unsigned index) const;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.cpp
new file mode 100644
index 0000000000..4638117817
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.cpp
@@ -0,0 +1,1357 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AMLVideoCodecConstants.h"
+#include "AMLVideoCodecDataTypes.h"
+
+#include "LibAmcodec.h"
+#include "PosixFile.h"
+
+#include "OSMCSecureOS.h"
+
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "utils/AMLUtils.h"
+#include "utils/StringUtils.h"
+#include "settings/Settings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/SettingsComponent.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/Resolution.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/StereoscopicsManager.h"
+
+#include "ServiceBroker.h"
+
+#include <string.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <linux/videodev2.h>
+#include <thread>
+
+#include "AMLInsecureVideoCodec.h"
+
+extern "C" {
+	#include <libavcodec/packet.h>
+}
+
+CEvent g_aml_codec_sync_event;
+
+using namespace amlogic;
+
+static const uint64_t UINT64_0 	= 0x8000000000000000ULL;
+
+static const int RW_WAIT_TIME = 5 * 1000; // 5 ms
+
+static const unsigned int STATE_HASPTS     = 2;
+
+
+/*************************************************************************/
+
+extern "C" void libamlcodec_logger(const char *format, ...)
+{
+  va_list arglist;
+  char buf[512];
+
+  va_start(arglist, format);
+  vsnprintf(buf, sizeof(buf), format, arglist);
+  va_end(arglist);
+
+  CLog::Log(LOGINFO, buf);
+}
+
+/*************************************************************************/
+
+AMLInsecureVideoCodec::AMLInsecureVideoCodec(CProcessInfo &processInfo)
+	: AMLVideoCodec(processInfo), m_sleepDurationInMs(0), m_opened(false), m_speed(DVD_PLAYSPEED_NORMAL), m_cur_pts(DVD_NOPTS_VALUE),
+	  m_last_pts(DVD_NOPTS_VALUE) , m_bufferIndex(-1), m_state(0), m_frameSizeSum(0), m_secureOSMC(&OSMCSecureOS::getInstance())
+{
+	m_am_private = new am_private_t;
+	memset(m_am_private, 0, sizeof(am_private_t));
+
+	m_libamcodec = new LibAmcodec();
+
+	// set logging callback
+	m_libamcodec->setLogCallback(libamlcodec_logger);
+}
+
+AMLInsecureVideoCodec::~AMLInsecureVideoCodec()
+{
+	delete m_am_private, m_am_private = nullptr;
+	delete m_libamcodec, m_libamcodec = nullptr;
+}
+
+int AMLInsecureVideoCodec::poll()
+{
+	if (m_libamcodec == nullptr) {
+		// no codec, no reason to poll
+		return 0;
+	}
+
+	std::chrono::time_point<std::chrono::system_clock> now(std::chrono::system_clock::now());
+
+	if (m_libamcodec->poll(50)) {
+		g_aml_codec_sync_event.Set();
+		int elapsed = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - now).count();
+		CLog::Log(LOGDEBUG, LOGAVTIMING, "AMLInsecureVideoCodec::pollFrame elapsed:{:0.3f}ms", elapsed / 1000.0);
+		return 1;
+	}
+	return 0;
+}
+
+int AMLInsecureVideoCodec::calculateSleepDuration()
+{
+	// Calculate the thread sleep duration in ms.
+	//
+	// The render thread is used to sleep between frames. This keeps the CPU load and CPU
+	// temperature low. When polling is being used to let the thread sleep until the next
+	// vsync event occurs, the Linux scheduler wakeup latency might be too high (around 6 ms)
+	// and could cause some glitches like frame skips. Further, that thread needs another (up
+	// to) 6 ms to prepare the next frame before it is being displayed. This gives a total
+	// (worst case) latency of about 12 ms.
+	//
+	// The resulting sleep duration depends on the fps. For instance, for 24 fps (42 ms per
+	// frame) the thread should sleep for 42 - 6 - 6 = 30 ms. BUT: if Kodi sets a different
+	// refresh rate (eg. 50 Hz instead of 25 Hz) we must rely on that refresh rate.
+	//
+	// It doesn't matter that the thread doesn't send a frame exactly every e.g. 42 ms. The
+	// kernel will display frames only when a vsync event occurs. We just have to make sure
+	// that there's at least one frame available when the kernel needs it.
+
+	double refreshRate = (double) m_hints.fpsrate / (double) m_hints.fpsscale;
+	RESOLUTION_INFO res;
+
+	if (aml_get_native_resolution(&res)) {
+		refreshRate = res.fRefreshRate;
+	}
+
+	int sleepDurationInMs = int(1000.0 / refreshRate - 0.5) - 6 - 6;
+
+	if (sleepDurationInMs < 2) {
+		// if the sleep duration is too low, we do not sleep at all
+		sleepDurationInMs = 0;
+	}
+
+	return sleepDurationInMs;
+}
+
+int AMLInsecureVideoCodec::getSleepDurationInMs() const
+{
+	return m_sleepDurationInMs;
+}
+
+void AMLInsecureVideoCodec::setVfmMap(const std::string &name, const std::string &map)
+{
+	SysfsUtils::SetString("/sys/class/vfm/map", "rm " + name);
+	SysfsUtils::SetString("/sys/class/vfm/map", "add " + name + " " + map);
+}
+
+std::string AMLInsecureVideoCodec::getVfmMap(const std::string &name) const
+{
+	std::string vfmMap;
+	SysfsUtils::GetString("/sys/class/vfm/map", vfmMap);
+	std::vector < std::string > sections = StringUtils::Split(vfmMap, '\n');
+	std::string sectionMap;
+
+	for (size_t i = 0; i < sections.size(); ++i) {
+		if (StringUtils::StartsWith(sections[i], name + " {")) {
+			sectionMap = sections[i];
+			break;
+		}
+	}
+
+	int openingBracePos = sectionMap.find('{') + 1;
+	sectionMap = sectionMap.substr(openingBracePos,
+			sectionMap.size() - openingBracePos - 1);
+	StringUtils::Replace(sectionMap, "(0)", "");
+
+	return sectionMap;
+}
+
+bool AMLInsecureVideoCodec::openAmlVideo(const CDVDStreamInfo &hints)
+{
+	PosixFilePtr amlVideoFile = std::make_shared<PosixFile>();
+	if (!amlVideoFile->Open("/dev/video10", O_RDONLY | O_NONBLOCK)) {
+		CLog::Log(LOGERROR, "AMLInsecureVideoCodec::openAmlVideo - cannot open V4L amlvideo device /dev/video10: {}", strerror(errno));
+		return false;
+	}
+
+	m_amlVideoFile = amlVideoFile;
+
+	m_defaultVfmMap = getVfmMap("default");
+
+	setVfmMap("default", "decoder ppmgr amlvideo amvideo");
+
+	int hdrMode = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_HDR_PROCESS);
+
+	SysfsUtils::SetInt("/sys/module/am_vecm/parameters/hdr_mode", hdrMode);
+
+	int maxLum = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOSCREEN_MAXLUM);
+	SysfsUtils::SetInt("/sys/module/am_vecm/parameters/customer_panel_lumin", maxLum);
+
+	SysfsUtils::SetInt("/sys/class/video/freerun_mode", 3);
+
+	return true;
+}
+
+void AMLInsecureVideoCodec::closeAmlVideo()
+{
+	m_amlVideoFile.reset();
+	setVfmMap("default", m_defaultVfmMap);
+	m_amlVideoFile = nullptr;
+}
+
+void AMLInsecureVideoCodec::showMainVideo(const bool show)
+{
+  static int saved_disable_video = -1;
+
+  int disable_video = show ? 0:1;
+  if (saved_disable_video == disable_video)
+    return;
+
+  SysfsUtils::SetInt("/sys/class/video/disable_video", disable_video);
+  saved_disable_video = disable_video;
+}
+
+void AMLInsecureVideoCodec::am_packet_init(am_packet_t *pkt) const
+{
+  memset(&pkt->avpkt, 0, sizeof(AVPacket));
+  pkt->avpts      = 0;
+  pkt->avdts      = 0;
+  pkt->avduration = 0;
+  pkt->isvalid    = 0;
+  pkt->newflag    = 0;
+  pkt->lastpts    = UINT64_0;
+  pkt->data       = NULL;
+  pkt->buf        = NULL;
+  pkt->data_size  = 0;
+  pkt->buf_size   = 0;
+  pkt->hdr        = new hdr_buf;
+}
+
+pstream_type AMLInsecureVideoCodec::getStreamType() const
+{
+	return AM_STREAM_ES;
+}
+
+unsigned int AMLInsecureVideoCodec::getVideoRate(const CDVDStreamInfo &hints) const
+{
+	unsigned int video_rate = 0;
+
+	if (hints.fpsrate > 0 && hints.fpsscale != 0) {
+		// then ffmpeg avg_frame_rate next
+		video_rate = 0.5 + (float) UNIT_FREQ * hints.fpsscale / hints.fpsrate;
+	}
+
+	// check for 1920x1080, interlaced, 25 fps
+	// incorrectly reported as 50 fps (yes, video_rate == 1920)
+	if (hints.width == 1920 && video_rate == 1920) {
+		CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::getVideoRate: video_rate exception");
+		video_rate = 0.5 + (float) UNIT_FREQ * 1001 / 25000;
+	}
+
+	return video_rate;
+}
+
+void AMLInsecureVideoCodec::getExtradata(const CDVDStreamInfo &hints, uint8_t *&extradata, unsigned int &extrasize) const
+{
+	if (hints.extrasize == 0) {
+		extradata = nullptr;
+		extrasize = 0;
+		return;
+	}
+
+	extradata = (uint8_t*)malloc(hints.extrasize);
+	extrasize = hints.extrasize;
+	memcpy(extradata, hints.extradata, hints.extrasize);
+}
+
+bool AMLInsecureVideoCodec::handleMasteringMetadata(const CDVDStreamInfo &hints) const
+{
+	char customMastering[256];
+	int len = 0;
+
+	if (hints.colorTransferCharacteristic > 3) {
+		len = snprintf(customMastering, 256, "%d,%d", hints.colorPrimaries, hints.colorTransferCharacteristic);
+	}
+
+	if (hints.masteringMetadata) {
+		int i, j;
+		if (hints.masteringMetadata->has_primaries) {
+			/* we have found headers with metadata differing from standard values in the 5th decimal place */
+			CLog::Log(LOGDEBUG,
+					"AMLInsecureVideoCodec::handleMasteringMetadata Mastering Display Primaries Red: {:.5f} {:.5f} Green: {:.5f} {:.5f} Blue: {:.5f} {:.5f} White: {:.5f} {:.5f}",
+					av_q2d(hints.masteringMetadata->display_primaries[0][0]),
+					av_q2d(hints.masteringMetadata->display_primaries[0][1]),
+					av_q2d(hints.masteringMetadata->display_primaries[1][0]),
+					av_q2d(hints.masteringMetadata->display_primaries[1][1]),
+					av_q2d(hints.masteringMetadata->display_primaries[2][0]),
+					av_q2d(hints.masteringMetadata->display_primaries[2][1]),
+					av_q2d(hints.masteringMetadata->white_point[0]),
+					av_q2d(hints.masteringMetadata->white_point[1]));
+			for (i = 0; i < 3; i++) {
+				for (j = 0; j < 2; j++) {
+					/* all standard primary triads are no more than 3 dec places */
+					len += snprintf(customMastering + len, 256 - len, ",%d",
+						(int) ((av_q2d(hints.masteringMetadata->display_primaries[(i + 1) % 3][j]) + 0.0005) * 1000) * 50);
+				}
+			}
+			for (i = 0; i < 2; i++) {
+				/* white points are up to 4 dec places */
+				len += snprintf(customMastering + len, 256 - len, ",%d",
+					(int) ((av_q2d(hints.masteringMetadata->white_point[i]) + 0.00005) * 10000) * 5);
+			}
+		} else {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata No mastering primaries found");
+			for (i = 0; i < 7; i++) {
+				len += snprintf(customMastering + len, 256 - len, ",0");
+			}
+		}
+
+		if (hints.masteringMetadata->has_luminance) {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata Max mastering luminance: {:.0f}, Min mastering luminance {:.4f}",
+					av_q2d(hints.masteringMetadata->max_luminance), av_q2d(hints.masteringMetadata->min_luminance));
+			len += snprintf(customMastering + len, 256 - len, ",%ld,%d",
+				(long) (av_q2d(hints.masteringMetadata->max_luminance) + 0.5) * 10000,
+				(int) (av_q2d(hints.masteringMetadata->min_luminance) * 10000 + 0.5));
+		} else {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata No mastering luminances found");
+			len += snprintf(customMastering + len, 256 - len, ",0,0");
+		}
+
+		if (hints.contentLightMetadata) {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata Content Light Levels MaxCLL: {}, MaxFALL {}",
+					hints.contentLightMetadata->MaxCLL, hints.contentLightMetadata->MaxFALL);
+			len += snprintf(customMastering + len, 256 - len, ",%d,%d",
+					hints.contentLightMetadata->MaxCLL, hints.contentLightMetadata->MaxFALL);
+		} else {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata No content light levels in stream header");
+			len += snprintf(customMastering + len, 256 - len, ",0,0");
+		}
+	}
+
+	if (len > 0) {
+		CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::handleMasteringMetadata Custom mastering data {}", customMastering);
+		SysfsUtils::SetString("/sys/module/am_vecm/parameters/customer_master_display_param", customMastering);
+
+		if (hints.colorTransferCharacteristic == AVCOL_TRC_ARIB_STD_B67) { // ARIB STD-B67, known as "Hybrid log-gamma"
+			enableCustomMasterDataDisplay();
+		}
+	}
+
+	return len > 0;
+}
+
+void AMLInsecureVideoCodec::enableCustomMasterDataDisplay(bool enable) const
+{
+	SysfsUtils::SetInt("/sys/module/am_vecm/parameters/customer_master_display_en", enable ? 1 : 0);
+}
+
+void AMLInsecureVideoCodec::getDeinterlacingMethods(std::list<EINTERLACEMETHOD> &methods) const
+{
+	methods.clear();
+}
+
+std::string AMLInsecureVideoCodec::getCodecPrivateConfiguration() const
+{
+	// nothing to configure yet
+	return "";
+}
+
+void AMLInsecureVideoCodec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	params.noblock      = 0;
+	params.video_pid    = m_am_private->video_pid;
+	params.video_type   = m_am_private->video_format;
+	params.stream_type  = STREAM_TYPE_ES_VIDEO;
+	params.decoder_type = DECODER_TYPE_SINGLE_MODE;
+	params.video_path   = FRAME_BASE_PATH_AMVIDEO;
+	params.display_mode	= DISPLAY_MODE_AMVIDEO;
+	params.format       = m_am_private->video_codec_type;
+	params.width        = m_am_private->video_width;
+	params.height       = m_am_private->video_height;
+	params.rate         = m_am_private->video_rate;
+	params.ratio        = m_am_private->video_ratio;
+	params.ratio64      = m_am_private->video_ratio64;
+	params.param        = NULL;
+}
+
+int AMLInsecureVideoCodec::handle_pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	pkt->hdr->alloc(HDR_BUF_SIZE);
+	if (!pkt->hdr->data) {
+		//CLog::Log(LOGDEBUG, "[pre_header_feeding] NOMEM!");
+		return PLAYER_NOMEM;
+	}
+
+	int ret = pre_header_feeding(para, pkt);
+	if (ret == PLAYER_SUCCESS && !pkt->hdr->isEmpty()) {
+		// we write the header only if we were able to create it
+		ret = write_av_packet(para, pkt);
+	}
+
+	pkt->hdr->free();
+
+	return ret;
+}
+
+int AMLInsecureVideoCodec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	pkt->hdr->size = 0; // no header => no size
+
+	return PLAYER_SUCCESS;
+}
+
+void AMLInsecureVideoCodec::playbackPause()
+{
+	m_libamcodec->setControlMode(TRICKMODE_NONE);
+}
+
+void AMLInsecureVideoCodec::playbackResume()
+{
+	m_libamcodec->setControlMode(TRICKMODE_NONE);
+}
+
+void AMLInsecureVideoCodec::playbackResume(int speed)
+{
+	m_libamcodec->setControlMode(TRICKMODE_I);
+}
+
+void AMLInsecureVideoCodec::setSpeed(int speed)
+{
+	if (m_speed == speed) {
+		return;
+	}
+
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::SetSpeed, speed({})", speed);
+
+	// update internal vars regardless of if we are open or not.
+	m_speed = speed;
+
+	if (!m_opened) {
+		return;
+	}
+
+	switch (speed) {
+		case DVD_PLAYSPEED_PAUSE:
+			playbackPause();
+			break;
+		case DVD_PLAYSPEED_NORMAL:
+			playbackResume();
+			m_libamcodec->setControlMode(TRICKMODE_NONE);
+			break;
+		default:
+			playbackResume(speed);
+			break;
+	}
+}
+
+bool AMLInsecureVideoCodec::openDecoder(CDVDStreamInfo &hints)
+{
+	m_speed = DVD_PLAYSPEED_NORMAL;
+	m_drain = false;
+	m_cur_pts = DVD_NOPTS_VALUE;
+	m_dst_rect.SetRect(0, 0, 0, 0);
+	m_zoom = -1.0f;
+	m_contrast = -1;
+	m_brightness = -1;
+	m_hints = hints;
+	m_state = 0;
+	m_frameSizes.clear();
+	m_frameSizeSum = 0;
+
+	if (!openAmlVideo(hints)) {
+		CLog::Log(LOGERROR, "AMLInsecureVideoCodec::openDecoder - cannot open amlvideo device");
+		return false;
+	}
+
+	showMainVideo(false);
+
+	am_packet_init(&m_am_private->am_pkt);
+
+	// default stream type
+	m_am_private->stream_type = getStreamType();
+
+	// handle hints.
+	m_am_private->video_width = hints.width;
+	m_am_private->video_height = hints.height;
+	m_am_private->video_codec_id = hints.codec;
+	m_am_private->video_codec_tag = hints.codec_tag;
+
+	// handle video ratio
+	AVRational video_ratio = av_d2q(1, SHRT_MAX);
+	m_am_private->video_ratio = ((int32_t) video_ratio.num << 16) | video_ratio.den;
+	m_am_private->video_ratio64 = ((int64_t) video_ratio.num << 32) | video_ratio.den;
+
+	// handle video rate
+	m_am_private->video_rate = getVideoRate(hints);
+
+	// handle orientation
+	m_am_private->video_rotation_degree = 0;
+	if (hints.orientation == 90) {
+		m_am_private->video_rotation_degree = 1;
+	} else if (hints.orientation == 180) {
+		m_am_private->video_rotation_degree = 2;
+	} else if (hints.orientation == 270) {
+		m_am_private->video_rotation_degree = 3;
+	}
+
+	m_am_private->video_format = getVideoFormat(hints);
+	m_am_private->video_codec_type = getVideoCodecType(hints);
+
+	getExtradata(hints, m_am_private->extradata, m_am_private->extrasize);
+
+	CLog::Log(LOGDEBUG,
+		"AMLInsecureVideoCodec::openDecoder hints.width({}), hints.height({}), hints.codec({}), hints.codec_tag({:4.4s})",
+		hints.width, hints.height, hints.codec, (char*) &hints.codec_tag);
+	CLog::Log(LOGDEBUG,
+		"AMLInsecureVideoCodec::openDecoder hints.fpsrate({}), hints.fpsscale({}), video_rate({}), hints.bitsperpixel({})",
+		hints.fpsrate, hints.fpsscale, m_am_private->video_rate, hints.bitsperpixel);
+	CLog::Log(LOGDEBUG,
+		"AMLInsecureVideoCodec::openDecoder hints.aspect({:f}), video_ratio.num({}), video_ratio.den({})",
+		hints.aspect, video_ratio.num, video_ratio.den);
+	CLog::Log(LOGDEBUG,
+		"AMLInsecureVideoCodec::openDecoder hints.orientation({}), hints.forced_aspect({}), hints.extrasize({})",
+		hints.orientation, hints.forced_aspect, hints.extrasize);
+	CLog::Log(LOGDEBUG,
+		"AMLInsecureVideoCodec::openDecoder hints primaries {}, transfer characteristic {}, colourspace {}",
+		hints.colorPrimaries, hints.colorTransferCharacteristic, hints.colorSpace);
+
+	if (!handleMasteringMetadata(hints)) {
+		CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::openDecoder No Mastering Display data in stream header");
+	}
+
+	std::list<EINTERLACEMETHOD> methods;
+
+	getDeinterlacingMethods(methods);
+	m_processInfo.UpdateDeinterlacingMethods(methods);
+
+	// setup video codec parameters
+	setupVideoCodecParams(m_am_private->gcodec);
+
+	// setup private, codec specific configuration
+	std::string codecConfig = getCodecPrivateConfiguration();
+	if (!codecConfig.empty()) {
+		m_am_private->gcodec.config = const_cast<char*> (codecConfig.c_str());
+		m_am_private->gcodec.config_len = (int) codecConfig.size();
+	}
+
+	m_am_private->gcodec.param = (void *)((std::uintptr_t)m_am_private->gcodec.param | (m_am_private->video_rotation_degree << 16));
+
+	int ret = m_libamcodec->init(m_am_private->gcodec);
+	if (ret != CODEC_ERROR_NONE) {
+		CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::openDecoder codec init failed, ret=0x{:x}", -ret);
+		return false;
+	}
+
+	m_libamcodec->pause();
+
+	m_libamcodec->setControlMode(TRICKMODE_NONE);
+	m_libamcodec->setVideoDelayLimitedMs(1000);
+
+	m_libamcodec->setControlAvThreshold(AV_SYNC_THRESH);
+	m_libamcodec->setControlSyncThreshold(0);
+
+	// disable tsync, we are playing video disconnected from audio.
+	SysfsUtils::SetInt("/sys/class/tsync/enable", 0);
+
+	handle_pre_header_feeding(m_am_private, &m_am_private->am_pkt);
+
+	m_display_rect = CRect(0, 0,
+		CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iWidth,
+		CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iHeight);
+
+	std::string strScaler;
+	SysfsUtils::GetString("/sys/class/ppmgr/ppscaler", strScaler);
+	if (strScaler.find("enabled") == std::string::npos) {
+		// Scaler not enabled, use screen size
+		m_display_rect = CRect(0, 0,
+			CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenWidth,
+			CDisplaySettings::GetInstance().GetCurrentResolutionInfo().iScreenHeight);
+	}
+
+	SysfsUtils::SetInt("/sys/class/video/freerun_mode", 1);
+
+	m_opened = true;
+
+	// vcodec is open, update speed if it was
+	// changed before VideoPlayer called OpenDecoder.
+	setSpeed(m_speed);
+
+	m_sleepDurationInMs = calculateSleepDuration();
+
+	return true;
+}
+
+void AMLInsecureVideoCodec::am_packet_release(am_packet_t *pkt)
+{
+	if (pkt->buf != nullptr) {
+		free(pkt->buf), pkt->buf = nullptr;
+	}
+
+	delete pkt->hdr, pkt->hdr = nullptr;
+}
+
+void AMLInsecureVideoCodec::closeDecoder()
+{
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::closeDecoder");
+
+	// never leave vcodec ff/rw or paused.
+	if (m_speed != DVD_PLAYSPEED_NORMAL) {
+		//m_dll->codec_resume(&am_private->vcodec);
+		m_libamcodec->setControlMode(TRICKMODE_NONE);
+	}
+
+	m_libamcodec->close();
+	m_opened = false;
+
+	am_packet_release(&m_am_private->am_pkt);
+	free(m_am_private->extradata);
+	m_am_private->extradata = nullptr;
+
+	// return tsync to default so external apps work
+	SysfsUtils::SetInt("/sys/class/tsync/enable", 1);
+
+	/* disable custom master data */
+	enableCustomMasterDataDisplay(false);
+
+	setVideoContrast(50);
+	setVideoBrightness(50);
+
+	showMainVideo(false);
+
+	closeAmlVideo();
+}
+
+void AMLInsecureVideoCodec::setVideoContrast(const int contrast) const
+{
+  // input contrast range is 0 to 100 with default of 50.
+  // output contrast range is -127 to 127 with default of 0.
+  int aml_contrast = (127.0f * (contrast - 50.0f)) / 50.0f + 0.5f;
+  SysfsUtils::SetInt("/sys/class/video/contrast", aml_contrast);
+}
+
+int AMLInsecureVideoCodec::getVideoContrast() const
+{
+	std::string aml_contrast;
+
+	SysfsUtils::GetString("/sys/class/video/contrast", aml_contrast);
+	return std::stoi(aml_contrast) * 50.0f / 127.0f + 50.5f;
+}
+
+void AMLInsecureVideoCodec::setVideoBrightness(const int brightness) const
+{
+  // input brightness range is 0 to 100 with default of 50.
+  // output brightness range is -512 to 511 with default of 0.
+  // we limit that to -256 to 255 with default of 0.
+  int aml_brightness = (255.0f * (brightness - 50.0f)) / 50.0f + 0.5f;
+  SysfsUtils::SetInt("/sys/class/video/brightness", aml_brightness);
+}
+
+int AMLInsecureVideoCodec::getVideoBrightness() const
+{
+	std::string aml_brightness;
+
+	SysfsUtils::GetString("/sys/class/video/brightness", aml_brightness);
+	return std::stoi(aml_brightness) * 50.0f / 255.0f + 50.5f;
+}
+
+bool AMLInsecureVideoCodec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	// nothing to do here
+	return true;
+}
+
+int AMLInsecureVideoCodec::set_header_info(am_private_t *para) const
+{
+	// nothing to do here
+	return PLAYER_SUCCESS;
+}
+
+int AMLInsecureVideoCodec::check_in_pts(am_private_t *para, am_packet_t *pkt) const
+{
+	if (para->stream_type == AM_STREAM_ES && UINT64_0 != pkt->avpts && m_libamcodec->checkinPts64(pkt->avpts) != 0) {
+		CLog::Log(LOGDEBUG, "ERROR check in pts error!");
+		return PLAYER_PTS_ERROR;
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+int AMLInsecureVideoCodec::write_header(am_private_t *para, am_packet_t *pkt) const
+{
+	unsigned int write_bytes = 0, len = 0;
+
+	if (pkt->hdr->isEmpty()) {
+		return PLAYER_SUCCESS;
+	}
+
+	if (m_libamcodec == nullptr || !m_libamcodec->isValid()) {
+		CLog::Log(LOGDEBUG, "[write_header]codec null!");
+		return PLAYER_EMPTY_P;
+	}
+
+	while (1) {
+		write_bytes = m_libamcodec->write(pkt->hdr->data + len, pkt->hdr->size - len);
+		if (write_bytes < 0 || write_bytes > (pkt->hdr->size - len)) {
+			if (-errno != AVERROR(EAGAIN)) {
+				CLog::Log(LOGDEBUG, "ERROR:write header failed!");
+				return PLAYER_WR_FAILED;
+			} else {
+				continue;
+			}
+		} else {
+			len += write_bytes;
+			if (len == pkt->hdr->size) {
+				break;
+			}
+		}
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+int AMLInsecureVideoCodec::write_av_packet(am_private_t *para, am_packet_t *pkt) const
+{
+	int write_bytes = 0, len = 0, ret;
+	unsigned char *buf;
+	int size;
+
+	// do we need to check in pts or write the header ?
+	if (pkt->newflag) {
+		if (pkt->isvalid) {
+			ret = check_in_pts(para, pkt);
+			if (ret != PLAYER_SUCCESS) {
+				CLog::Log(LOGDEBUG, "check in pts failed");
+				return PLAYER_WR_FAILED;
+			}
+		}
+		if (write_header(para, pkt) == PLAYER_WR_FAILED) {
+			CLog::Log(LOGDEBUG, "[{}]write header failed!", __FUNCTION__);
+			return PLAYER_WR_FAILED;
+		}
+		pkt->newflag = 0;
+	}
+
+	buf = pkt->data;
+	size = pkt->data_size;
+	if (size == 0 && pkt->isvalid) {
+		pkt->isvalid = 0;
+		pkt->data_size = 0;
+	}
+
+	while (size > 0 && pkt->isvalid) {
+		write_bytes = m_libamcodec->write(buf, size);
+		if (write_bytes < 0 || write_bytes > size) {
+			CLog::Log(LOGDEBUG, "write codec data failed, write_bytes({}), errno({}), size({})", write_bytes, errno, size);
+			if (-errno != AVERROR(EAGAIN)) {
+				CLog::Log(LOGDEBUG, "write codec data failed!");
+				return PLAYER_WR_FAILED;
+			} else {
+				// adjust for any data we already wrote into codec.
+				// we sleep a bit then exit as we will get called again
+				// with the same pkt because pkt->isvalid has not been cleared.
+				pkt->data += len;
+				pkt->data_size -= len;
+				usleep(RW_WAIT_TIME);
+				CLog::Log(LOGDEBUG, "Codec buffer full, try after {} ms, len({})", RW_WAIT_TIME / 1000, len);
+				return PLAYER_SUCCESS;
+			}
+		} else {
+			// keep track of what we write into codec from this pkt
+			// in case we get hit with EAGAIN.
+			len += write_bytes;
+			if (len == pkt->data_size) {
+				pkt->isvalid = 0;
+				pkt->data_size = 0;
+				break;
+			} else if (len < pkt->data_size) {
+				buf += write_bytes;
+				size -= write_bytes;
+			} else {
+				// writing more that we should is a failure.
+				return PLAYER_WR_FAILED;
+			}
+		}
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+bool AMLInsecureVideoCodec::addData(uint8_t *pData, size_t iSize, double dts, double pts, uint8_t subtitlePlane)
+{
+	/* if passing through HDR, ignore contrast and brightness
+	 * thus users can view HDR on both HDR and SDR screens without faff */
+	int curCscType, hdrProcessMode;
+	std::string cur_csc_type;
+	SysfsUtils::GetString("/sys/module/am_vecm/parameters/cur_csc_type", cur_csc_type);
+	curCscType = std::stoi(cur_csc_type.substr(0, 2));
+	SysfsUtils::GetInt("/sys/module/am_vecm/parameters/hdr_process_mode", hdrProcessMode);
+	bool isHDR = curCscType == 64 && hdrProcessMode == 0;
+
+	// video contrast adjustment.
+	int contrast = m_processInfo.GetVideoSettings().m_Contrast;
+	if (isHDR) {
+		contrast = 50;
+	}
+
+	m_contrast = getVideoContrast();
+	if (contrast != m_contrast) {
+		setVideoContrast(contrast);
+		m_contrast = contrast;
+	}
+
+	// video brightness adjustment.
+	int brightness = m_processInfo.GetVideoSettings().m_Brightness;
+	if (isHDR) {
+		brightness = 50;
+	}
+
+	m_brightness = getVideoBrightness();
+	if (brightness != m_brightness) {
+		setVideoBrightness(brightness);
+		m_brightness = brightness;
+	}
+
+	// band fix
+	SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/debug", "round1");
+
+	// check if decoder is still accepting data
+	struct buf_status bs;
+	m_libamcodec->getVbufState(bs);
+	if (iSize > (size_t) bs.free_len) {
+		CLog::Log(LOGERROR, "AMLInsecureVideoCodec::addData: packet too big: {}, probably corrupted", iSize);
+		return false;
+	}
+	m_frameSizes.push_back(iSize);
+	m_frameSizeSum += iSize;
+
+	// setup packet
+	m_am_private->am_pkt.data = pData;
+	m_am_private->am_pkt.data_size = iSize;
+
+	m_am_private->am_pkt.newflag = 1;
+	m_am_private->am_pkt.isvalid = 1;
+	m_am_private->am_pkt.avduration = 0;
+
+	// setup dts/pts
+	if (m_hints.ptsinvalid || pts == DVD_NOPTS_VALUE) {
+		m_am_private->am_pkt.avpts = UINT64_0;
+	} else {
+		m_am_private->am_pkt.avpts = pts;
+		m_state |= STATE_HASPTS;
+	}
+
+	if (dts == DVD_NOPTS_VALUE) {
+		m_am_private->am_pkt.avdts = m_am_private->am_pkt.avpts;
+	} else {
+		m_am_private->am_pkt.avdts = dts;
+
+		// For VC1 AML decoder uses PTS only on I-Frames
+		if (m_am_private->am_pkt.avpts == UINT64_0 && (((size_t) m_am_private->gcodec.param) & KEYFRAME_PTS_ONLY)) {
+			m_am_private->am_pkt.avpts = m_am_private->am_pkt.avdts;
+		}
+	}
+
+	// We use this to determine the fill state if no PTS is given
+	if (m_cur_pts == DVD_NOPTS_VALUE) {
+		m_cur_pts = m_am_private->am_pkt.avdts;
+
+		// No PTS given -> use first DTS for AML ptsserver initialization
+		if ((m_state & STATE_HASPTS) == 0) {
+			m_am_private->am_pkt.avpts = m_am_private->am_pkt.avdts;
+		}
+	}
+
+	// some formats need header/data tweaks.
+	// the actual write occurs once in write_av_packet
+	// and is controlled by am_pkt.newflag.
+	set_header_info(m_am_private);
+
+	// pass along the frame to secureOSMC
+	m_secureOSMC->parseFrame(m_hints.codec_tag, subtitlePlane, m_am_private->am_pkt.avpts * PTS_FREQ / DVD_TIME_BASE, pData, iSize);
+
+	// loop until we write all into codec, am_pkt.isvalid
+	// will get set to zero once everything is consumed.
+	// PLAYER_SUCCESS means all is ok, not all bytes were written.
+	int loop = 0;
+	while (m_am_private->am_pkt.isvalid && loop < 100) {
+		// abort on any errors.
+		if (write_av_packet(m_am_private, &m_am_private->am_pkt) != PLAYER_SUCCESS) {
+			break;
+		}
+
+		if (m_am_private->am_pkt.isvalid) {
+			CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::addData: write_av_packet looping");
+		}
+		loop++;
+	}
+
+	if (loop == 100) {
+		// Decoder got stuck; Reset
+		reset();
+		return false;
+	}
+
+	if (iSize > 50000) {
+		usleep(2000); // wait 2ms to process larger packets
+	}
+
+	m_libamcodec->getVbufState(bs);
+	if (iSize > 0) {
+		CLog::Log(LOGDEBUG, LOGVIDEO, "AMLInsecureVideoCodec::addData: dl:{} sum:{} sz:{} dts_in:{:0.3f} pts_in:{:0.3f} ptsOut:{:0.3f}", bs.data_len, m_frameSizeSum,
+			static_cast<unsigned int>(iSize),
+			dts / DVD_TIME_BASE,
+			pts / DVD_TIME_BASE,
+			static_cast<float>(m_cur_pts) / DVD_TIME_BASE);
+	}
+
+	return true;
+}
+
+void AMLInsecureVideoCodec::reset()
+{
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::reset");
+
+	if (!m_opened) {
+		return;
+	}
+
+	// set the system blackout_policy to leave the last frame showing
+	int blackout_policy;
+	SysfsUtils::GetInt("/sys/class/video/blackout_policy", blackout_policy);
+	SysfsUtils::SetInt("/sys/class/video/blackout_policy", 0);
+
+	// restore the speed (some amcodec versions require this)
+	if (m_speed != DVD_PLAYSPEED_NORMAL) {
+		m_libamcodec->setControlMode(TRICKMODE_NONE);
+	}
+	m_libamcodec->pause();
+
+	// reset the decoder
+	m_libamcodec->reset();
+	m_libamcodec->setVideoDelayLimitedMs(1000);
+
+	// re-init our am_pkt
+	am_packet_release(&m_am_private->am_pkt);
+	am_packet_init(&m_am_private->am_pkt);
+	handle_pre_header_feeding(m_am_private, &m_am_private->am_pkt);
+
+	// restore the saved system blackout_policy value
+	SysfsUtils::SetInt("/sys/class/video/blackout_policy", blackout_policy);
+
+	// reset some interal vars
+	m_cur_pts = DVD_NOPTS_VALUE;
+	m_state = 0;
+	m_frameSizes.clear();
+	m_frameSizeSum = 0;
+
+	setSpeed(m_speed);
+}
+
+void AMLInsecureVideoCodec::setDrain(bool drain)
+{
+	m_drain = drain;
+}
+
+float AMLInsecureVideoCodec::getTimeSize()
+{
+	struct buf_status bs;
+
+	m_libamcodec->getVbufState(bs);
+
+	CLog::Log(LOGDEBUG, LOGVIDEO, "AMLInsecureVideoCodec::getTimeSize: len:{} dl:{} fs:{} front:{}",
+		m_frameSizes.size(), bs.data_len, m_frameSizeSum, m_frameSizes.front());
+	while (m_frameSizeSum > (unsigned int) bs.data_len) {
+		m_frameSizeSum -= m_frameSizes.front();
+		m_frameSizes.pop_front();
+		CLog::Log(LOGDEBUG, LOGVIDEO, "AMLInsecureVideoCodec::getTimeSize: len:{} dl:{} fs:{} front:{}",
+			m_frameSizes.size(), bs.data_len, m_frameSizeSum, m_frameSizes.front());
+	}
+
+	if (bs.free_len < (bs.data_len >> 1)) {
+		return 7.0;
+	}
+
+	return (float) (m_frameSizes.size() * m_am_private->video_rate) / UNIT_FREQ;
+}
+
+int AMLInsecureVideoCodec::dequeueBuffer()
+{
+	v4l2_buffer vbuf = { 0 };
+	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	//Driver change from 10 to 0ms latency, throttle here
+	std::chrono::time_point<std::chrono::system_clock> now(std::chrono::system_clock::now());
+
+	unsigned int waitTime = 5;
+	bool timeout = false;
+
+DRAIN:
+	if (m_amlVideoFile->IOControl(VIDIOC_DQBUF, &vbuf) < 0) {
+		if (errno != EAGAIN) {
+			CLog::Log(LOGERROR, "AMLInsecureVideoCodec::dequeueBuffer - VIDIOC_DQBUF failed: {}", strerror(errno));
+		}
+
+		std::chrono::milliseconds elapsed(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count());
+
+		if (elapsed < std::chrono::milliseconds(waitTime)) {
+			std::this_thread::sleep_for(std::chrono::milliseconds(waitTime) - elapsed);
+		}
+
+		timeout = elapsed >= std::chrono::milliseconds(300);
+
+		if (m_drain && !timeout) {
+			goto DRAIN;
+		}
+
+		if (m_drain && timeout) {
+			CLog::Log(LOGDEBUG, LOGAVTIMING, "AMLInsecureVideoCodec::dequeueBuffer timeout!");
+		}
+
+		return -errno;
+	}
+
+	if (m_drain) {
+		int waited = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count();
+		CLog::Log(LOGDEBUG, LOGAVTIMING, "AMLInsecureVideoCodec::dequeueBuffer waited:{:0.3f}ms", waited / 1000.0);
+	}
+
+	m_last_pts = m_cur_pts;
+
+	m_cur_pts = static_cast<uint64_t>(vbuf.timestamp.tv_sec) << 32;
+	m_cur_pts |= static_cast<uint64_t>(vbuf.timestamp.tv_usec & 0xFFFFFFFF);
+
+	CLog::Log(LOGDEBUG, LOGAVTIMING, "AMLInsecureVideoCodec::dequeueBuffer: pts:{:0.3f} idx:{}", static_cast<double>(m_cur_pts) / DVD_TIME_BASE, vbuf.index);
+
+	m_bufferIndex = vbuf.index;
+
+	return 0;
+}
+
+void AMLInsecureVideoCodec::setPictureStereoMode(VideoPicture *pVideoPicture)
+{
+	pVideoPicture->stereoMode = m_hints.stereo_mode;
+
+	if (pVideoPicture->stereoMode.empty() || !m_processInfo.GetVideoSettings().m_StereoInvert) {
+		// either no stereo mode or it shouldn't be inverted
+		return;
+	}
+
+	if (pVideoPicture->stereoMode == "left_right") {
+		pVideoPicture->stereoMode = "right_left";
+	} else if (pVideoPicture->stereoMode == "right_left") {
+		pVideoPicture->stereoMode = "left_right";
+	} else if (pVideoPicture->stereoMode == "top_bottom") {
+		pVideoPicture->stereoMode = "bottom_top";
+	} else if (pVideoPicture->stereoMode == "bottom_top") {
+		pVideoPicture->stereoMode = "top_bottom";
+	} else if (pVideoPicture->stereoMode == "block_lr") {
+		pVideoPicture->stereoMode = "block_rl";
+	} else if (pVideoPicture->stereoMode == "block_rl") {
+		pVideoPicture->stereoMode = "block_lr";
+	}
+}
+
+CDVDVideoCodec::VCReturn AMLInsecureVideoCodec::getPicture(VideoPicture *pVideoPicture)
+{
+	if (!m_opened) {
+		return CDVDVideoCodec::VC_ERROR;
+	}
+
+	float timesize = getTimeSize();
+
+	if (!m_drain && timesize < 0.2) {
+		return CDVDVideoCodec::VC_BUFFER;
+	}
+
+	if (dequeueBuffer() == 0) {
+		pVideoPicture->iFlags = 0;
+
+		if (m_last_pts == DVD_NOPTS_VALUE) {
+			pVideoPicture->iDuration = static_cast<double>(m_am_private->video_rate * DVD_TIME_BASE) / UNIT_FREQ;
+		} else {
+			pVideoPicture->iDuration = static_cast<double>(m_cur_pts - m_last_pts);
+		}
+
+		pVideoPicture->dts = DVD_NOPTS_VALUE;
+		pVideoPicture->pts = static_cast<double>(m_cur_pts);
+
+		CLog::Log(LOGDEBUG, LOGVIDEO, "AMLInsecureVideoCodec::getPicture: index: {}, pts: {:0.3f}, dur:{:0.3f}ms",
+			m_bufferIndex, pVideoPicture->pts / DVD_TIME_BASE, pVideoPicture->iDuration / 1000);
+
+		setPictureStereoMode(pVideoPicture);
+
+		return CDVDVideoCodec::VC_PICTURE;
+	} else if (m_drain) {
+		return CDVDVideoCodec::VC_EOF;
+	} else if (timesize < 1.0 || m_libamcodec->isVCodecBuffering()) {
+		return CDVDVideoCodec::VC_BUFFER;
+	}
+
+	return CDVDVideoCodec::VC_NONE;
+}
+
+int AMLInsecureVideoCodec::getOMXPts() const
+{
+	return static_cast<int>(m_cur_pts);
+}
+
+uint32_t AMLInsecureVideoCodec::getBufferIndex() const
+{
+	return m_bufferIndex;
+}
+
+int AMLInsecureVideoCodec::getAmlDuration() const
+{
+	return m_am_private ? (m_am_private->video_rate * PTS_FREQ) / UNIT_FREQ : 0;
+}
+
+int AMLInsecureVideoCodec::releaseFrame(const uint32_t index, bool drop)
+{
+	if (!m_amlVideoFile) {
+		return 0;
+	}
+
+	v4l2_buffer vbuf = { 0 };
+	vbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	vbuf.index = index;
+
+	if (drop) {
+		vbuf.flags |= V4L2_BUF_FLAG_DONE;
+	}
+
+	CLog::Log(LOGDEBUG, LOGVIDEO, "AMLInsecureVideoCodec::releaseFrame idx:{}, drop:{}", index, static_cast<int>(drop));
+
+	int ret;
+	if ((ret = m_amlVideoFile->IOControl(VIDIOC_QBUF, &vbuf)) < 0) {
+		CLog::Log(LOGERROR, "AMLInsecureVideoCodec::releaseFrame - VIDIOC_QBUF failed: {}", strerror(errno));
+	}
+
+	return ret;
+}
+
+unsigned int AMLInsecureVideoCodec::getDecoderVideoRate() const
+{
+	if (m_speed != DVD_PLAYSPEED_NORMAL || !m_libamcodec->isValid()) {
+		return 0;
+	}
+
+	struct vdec_status vs;
+	m_libamcodec->getVdecState(vs);
+	if (vs.fps > 0) {
+		return static_cast<unsigned int>(0.5 + (static_cast<float>(UNIT_FREQ) / static_cast<float>(vs.fps)));
+	} else {
+		return 0;
+	}
+}
+
+void AMLInsecureVideoCodec::setFramepackingResolution(const int width, const int height, const int blanking) const
+{
+  SysfsUtils::SetInt("/sys/module/amvideo/parameters/framepacking_width", width);
+  SysfsUtils::SetInt("/sys/module/amvideo/parameters/framepacking_height", height * 2 + blanking);
+  SysfsUtils::SetInt("/sys/module/amvideo/parameters/framepacking_blank", blanking);
+}
+
+void AMLInsecureVideoCodec::setVideoRect(const CRect &SrcRect, const CRect &DestRect)
+{
+	// this routine gets called every video frame
+	// and is in the context of the renderer thread so
+	// do not do anything stupid here.
+	bool update = false;
+
+	// video zoom adjustment.
+	float zoom = m_processInfo.GetVideoSettings().m_CustomZoomAmount;
+	if ((int) (zoom * 1000) != (int) (m_zoom * 1000)) {
+		m_zoom = zoom;
+	}
+
+	// video rate adjustment.
+	unsigned int video_rate = getDecoderVideoRate();
+	if (video_rate > 0 && video_rate != m_am_private->video_rate) {
+		CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect: decoder fps has changed, video_rate adjusted from {} to {}", m_am_private->video_rate, video_rate);
+		m_am_private->video_rate = video_rate;
+	}
+
+	// video view mode
+	int view_mode = m_processInfo.GetVideoSettings().m_ViewMode;
+	if (m_view_mode != view_mode) {
+		m_view_mode = view_mode;
+		update = true;
+	}
+
+	// video orientation
+	int orientation = m_processInfo.GetVideoSettings().m_Orientation;
+	if (m_orientation != orientation) {
+		m_orientation = orientation;
+		update = true;
+	}
+
+	// GUI stereo mode/view.
+	RENDER_STEREO_MODE guiStereoMode = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+	if (m_guiStereoMode != guiStereoMode) {
+		m_guiStereoMode = guiStereoMode;
+		update = true;
+	}
+	RENDER_STEREO_VIEW guiStereoView = CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoView();
+	if (m_guiStereoView != guiStereoView) {
+		// left/right/top/bottom eye,
+		// this might change every other frame.
+		// we do not care but just track it.
+		m_guiStereoView = guiStereoView;
+	}
+
+	// dest_rect
+	CRect dst_rect = DestRect;
+	if (m_dst_rect != dst_rect) {
+		m_dst_rect = dst_rect;
+		update = true;
+	}
+
+	RESOLUTION video_res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
+	if (m_video_res != video_res) {
+		m_video_res = video_res;
+		update = true;
+	}
+
+	std::string videoStereoMode = m_processInfo.GetVideoStereoMode();
+	if (m_video_stereo_mode != videoStereoMode) {
+		m_video_stereo_mode = videoStereoMode;
+		update = true;
+	}
+
+	if (!update) {
+		// mainvideo 'should' be showing already if we get here, make sure.
+		showMainVideo(true);
+		return;
+	}
+
+	CRect gui, display;
+
+	const RESOLUTION_INFO &video_res_info = CDisplaySettings::GetInstance().GetResolutionInfo(video_res);
+	display = m_display_rect = CRect(0, 0, video_res_info.iScreenWidth, video_res_info.iScreenHeight);
+	gui = CRect(0, 0, video_res_info.iWidth, video_res_info.iHeight);
+
+	if (gui != display) {
+		float xscale = display.Width() / gui.Width();
+		float yscale = display.Height() / gui.Height();
+		if (m_guiStereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+			xscale /= 2.0;
+		else if (m_guiStereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+			yscale /= 2.0;
+		dst_rect.x1 *= xscale;
+		dst_rect.x2 *= xscale;
+		dst_rect.y1 *= yscale;
+		dst_rect.y2 *= yscale;
+	}
+
+	if (m_guiStereoMode == RENDER_STEREO_MODE_MONO) {
+		std::string videoStereoMode = m_processInfo.GetVideoStereoMode();
+		if (videoStereoMode == "left_right" || videoStereoMode == "right_left")
+			dst_rect.x2 *= 2.0;
+		else if (videoStereoMode == "top_bottom" || videoStereoMode == "bottom_top")
+			dst_rect.y2 *= 2.0;
+	} else if (m_guiStereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL) {
+		dst_rect.x2 *= 2.0;
+	} else if (m_guiStereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) {
+		dst_rect.y2 *= 2.0;
+	} else if (m_guiStereoMode == RENDER_STEREO_MODE_HARDWAREBASED) {
+		// 3D frame packed output: get the screen height from the graphic context
+		// (will work in fullscreen mode only)
+		RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo();
+		dst_rect.y2 = info.iHeight * 2 + info.iBlanking;
+		setFramepackingResolution(info.iWidth, info.iHeight, info.iBlanking);
+	}
+
+	setVideoMode(videoStereoMode, m_guiStereoMode);
+
+	std::string s_dst_rect = StringUtils::Format("{},{},{},{}", (int) dst_rect.x1, (int) dst_rect.y1, (int) dst_rect.Width(), (int) dst_rect.Height());
+	std::string s_m_dst_rect = StringUtils::Format("{},{},{},{}", (int) m_dst_rect.x1, (int) m_dst_rect.y1, (int) m_dst_rect.Width(),
+		(int) m_dst_rect.Height());
+	std::string s_display = StringUtils::Format("{},{},{},{}", (int) m_display_rect.x1, (int) m_display_rect.y1, (int) m_display_rect.Width(),
+		(int) m_display_rect.Height());
+	std::string s_gui = StringUtils::Format("{},{},{},{}", (int) gui.x1, (int) gui.y1, (int) gui.Width(), (int) gui.Height());
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:display({})", s_display);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:gui({})", s_gui);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:m_dst_rect({})", s_m_dst_rect);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:dst_rect({})", s_dst_rect);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:m_guiStereoMode({})", m_guiStereoMode);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect:m_guiStereoView({})", m_guiStereoView);
+	CLog::Log(LOGDEBUG, "AMLInsecureVideoCodec::setVideoRect video rotation {} user rotation {}", m_am_private->video_rotation_degree * 90, m_orientation * 90);
+
+	// goofy 0/1 based difference in aml axis coordinates.
+	// fix them.
+	dst_rect.x2--;
+	dst_rect.y2--;
+
+	char video_axis[256] = { };
+	sprintf(video_axis, "%d %d %d %d", (int) dst_rect.x1, (int) dst_rect.y1, (int) dst_rect.x2, (int) dst_rect.y2);
+
+	int screen_mode = CDisplaySettings::GetInstance().IsNonLinearStretched() ? 4 : 1;
+
+	SysfsUtils::SetString("/sys/class/video/axis", video_axis);
+	SysfsUtils::SetInt("/sys/class/video/screen_mode", screen_mode);
+	SysfsUtils::SetInt("/sys/class/ppmgr/orientation", m_orientation);
+
+	// we only get called once gui has changed to something
+	// that would show video playback, so show it.
+	showMainVideo(true);
+}
+
+void AMLInsecureVideoCodec::setVideoMode(std::string videoInputMode, RENDER_STEREO_MODE videoOutputMode)
+{
+	video_input_mode vimode = VIDEO_INPUT_MODE_2D;
+	video_output_mode vomode = VIDEO_OUTPUT_MODE_2D;
+	bool leftEyeFirst = true;
+
+	if (videoInputMode == "left_right") {
+		vimode = VIDEO_INPUT_MODE_HSBS;
+	} else if (videoInputMode == "right_left") {
+		vimode = VIDEO_INPUT_MODE_HSBS;
+		leftEyeFirst = false;
+	} else if (videoInputMode == "top_bottom") {
+		vimode = VIDEO_INPUT_MODE_HTAB;
+	} else if (videoInputMode == "bottom_top") {
+		vimode = VIDEO_INPUT_MODE_HTAB;
+		leftEyeFirst = false;
+	} else if (videoInputMode == "block_lr") {
+		vimode = VIDEO_INPUT_MODE_MVC;
+	} else if (videoInputMode == "block_rl") {
+		vimode = VIDEO_INPUT_MODE_MVC;
+		leftEyeFirst = false;
+	}
+
+	if (vimode != VIDEO_INPUT_MODE_2D) {
+		switch (videoOutputMode) {
+			case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+				vomode = VIDEO_OUTPUT_MODE_HSBS;
+				break;
+
+			case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+				vomode = VIDEO_OUTPUT_MODE_HTAB;
+				break;
+
+			case RENDER_STEREO_MODE_HARDWAREBASED:
+				vomode = VIDEO_OUTPUT_MODE_FP;
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	m_libamcodec->setVideoMode(vimode, vomode, leftEyeFirst);
+}
+
+double AMLInsecureVideoCodec::getAspectRatio() const
+{
+	return m_opened ? m_hints.aspect : 0;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.h
new file mode 100644
index 0000000000..8981269775
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLInsecureVideoCodec.h
@@ -0,0 +1,152 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <deque>
+#include <string>
+#include <list>
+
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "cores/VideoSettings.h"
+#include "utils/Geometry.h"
+#include "rendering/RenderSystem.h"
+#include "windowing/Resolution.h"
+
+extern "C" {
+	#include <amcodec/codec.h>
+}
+
+#include "AMLVideoCodec.h"
+
+#include "AMLVideoCodecDataTypes.h"
+
+class OSMCSecureOS;
+
+typedef struct am_packet am_packet_t;
+typedef std::shared_ptr<amlogic::PosixFile> PosixFilePtr;
+
+class amlogic::AMLInsecureVideoCodec : public amlogic::AMLVideoCodec
+{
+private:
+	int m_sleepDurationInMs;
+
+	void am_packet_release(am_packet_t *pkt);
+
+	float getTimeSize();
+	int dequeueBuffer();
+
+	void setVideoContrast(const int contrast) const;
+	void setVideoBrightness(const int brightness) const;
+
+	void setFramepackingResolution(const int width, const int height, const int blanking) const;
+
+	int getVideoContrast() const;
+	int getVideoBrightness() const;
+	unsigned int getDecoderVideoRate() const;
+
+	int check_in_pts(am_private_t *para, am_packet_t *pkt) const;
+	int write_av_packet(am_private_t *para, am_packet_t *pkt) const;
+
+	int handle_pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+
+protected:
+	amlogic::LibAmcodec	*m_libamcodec;
+
+	am_private_t		*m_am_private;
+
+	bool				 m_opened;
+	int					 m_speed;
+	uint64_t			 m_cur_pts;
+	uint64_t			 m_last_pts;
+	uint32_t			 m_bufferIndex;
+	unsigned int		 m_state;
+	std::uint32_t		 m_frameSizeSum;
+	std::deque<uint32_t> m_frameSizes;
+
+	bool			 m_drain = false;
+	CRect			 m_dst_rect;
+	CRect			 m_display_rect;
+	float			 m_zoom = -1.0f;
+	int				 m_contrast = -1;
+	int				 m_brightness = -1;
+	int				 m_orientation = 0;
+	CDVDStreamInfo	 m_hints;
+
+	int					 m_view_mode = -1;
+	RENDER_STEREO_MODE	 m_guiStereoMode = RENDER_STEREO_MODE_OFF;
+	RENDER_STEREO_VIEW	 m_guiStereoView = RENDER_STEREO_VIEW_OFF;
+	RESOLUTION			 m_video_res = RES_INVALID;
+	std::string			 m_video_stereo_mode;
+
+	PosixFilePtr	 m_amlVideoFile;
+	std::string		 m_defaultVfmMap;
+
+	OSMCSecureOS	*m_secureOSMC;
+
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const = 0;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const = 0;
+
+	virtual bool openAmlVideo(const CDVDStreamInfo &hints);
+	virtual void closeAmlVideo();
+
+	virtual void showMainVideo(const bool show);
+	virtual void setVfmMap(const std::string &name, const std::string &map);
+
+	virtual std::string getVfmMap(const std::string &name) const;
+	virtual void am_packet_init(am_packet_t *pkt) const;
+	virtual pstream_type getStreamType() const;
+	virtual unsigned int getVideoRate(const CDVDStreamInfo &hints) const;
+	virtual void getExtradata(const CDVDStreamInfo &hints, uint8_t *&extradata, unsigned int &extrasize) const;
+	virtual bool handleMasteringMetadata(const CDVDStreamInfo &hints) const;
+	virtual void enableCustomMasterDataDisplay(bool enable = true) const;
+	virtual void getDeinterlacingMethods(std::list<EINTERLACEMETHOD> &methods) const;
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+	virtual std::string getCodecPrivateConfiguration() const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+	virtual int set_header_info(am_private_t *para) const;
+
+	virtual int write_header(am_private_t *para, am_packet_t *pkt) const;
+
+	virtual int poll();
+	virtual int getSleepDurationInMs() const;
+	virtual int calculateSleepDuration();
+
+	virtual void playbackPause();
+	virtual void playbackResume();
+	virtual void playbackResume(int speed);
+
+	virtual void setVideoMode(std::string videoInputMode, RENDER_STEREO_MODE videoOutputMode);
+	virtual void setPictureStereoMode(VideoPicture *pVideoPicture);
+
+public:
+	AMLInsecureVideoCodec(CProcessInfo &processInfo);
+	virtual ~AMLInsecureVideoCodec();
+
+	virtual bool openDecoder(CDVDStreamInfo &hints);
+	virtual void closeDecoder();
+
+	virtual int getOMXPts() const;
+	virtual uint32_t getBufferIndex() const;
+	virtual int getAmlDuration() const;
+
+	virtual double getAspectRatio() const;
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+	virtual bool addData(uint8_t *pData, size_t iSize, double dts, double pts, uint8_t subtitlePlane);
+	virtual CDVDVideoCodec::VCReturn getPicture(VideoPicture *pVideoPicture);
+	virtual int releaseFrame(const uint32_t index, bool drop=false);
+
+	virtual void setVideoRect(const CRect &SrcRect, const CRect &DestRect);
+
+	virtual void setSpeed(int speed);
+	virtual void setDrain(bool drain);
+
+	virtual void reset();
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.cpp
new file mode 100644
index 0000000000..877c7baf08
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.cpp
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AMLVideoCodec.h"
+
+#include <chrono>
+#include <thread>
+
+using namespace amlogic;
+
+static std::mutex m_pollSync;
+AMLVideoCodec *AMLVideoCodec::m_videoCodec;
+
+AMLVideoCodec::AMLVideoCodec(CProcessInfo &processInfo)
+	: m_processInfo(processInfo)
+{
+	m_videoCodec = this;
+}
+
+AMLVideoCodec::~AMLVideoCodec()
+{
+	m_videoCodec = nullptr;
+}
+
+int AMLVideoCodec::pollFrame()
+{
+	std::lock_guard<std::mutex> lock(m_pollSync);
+
+	if (m_videoCodec == nullptr) {
+		// no codec, no reason to poll
+		return 0;
+	}
+
+	return m_videoCodec->poll();
+}
+
+/*
+ * Just sleep a while until we think the next frame could be ready
+ */
+void AMLVideoCodec::sleep()
+{
+	if (m_videoCodec == nullptr) {
+		return;
+	}
+
+	std::this_thread::sleep_for(std::chrono::milliseconds(m_videoCodec->getSleepDurationInMs()));
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.h
new file mode 100644
index 0000000000..51fc7d2306
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodec.h
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <string>
+#include <mutex>
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "utils/Geometry.h"
+
+#include "namespace.h"
+
+class CDVDStreamInfo;
+class CProcessInfo;
+class VideoPicture;
+
+class amlogic::AMLVideoCodec
+{
+private:
+	static AMLVideoCodec	*m_videoCodec;
+
+protected:
+	CProcessInfo &m_processInfo;
+
+	virtual int poll() = 0;
+	virtual int getSleepDurationInMs() const = 0;
+
+public:
+	AMLVideoCodec(CProcessInfo &processInfo);
+	virtual ~AMLVideoCodec();
+
+	virtual bool openDecoder(CDVDStreamInfo &hints) = 0;
+	virtual void closeDecoder() = 0;
+
+	virtual std::string getFormatName() const = 0;
+
+	virtual int getOMXPts() const = 0;
+	virtual uint32_t getBufferIndex() const = 0;
+	virtual int getAmlDuration() const = 0;
+
+	virtual double getAspectRatio() const = 0;
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts) = 0;
+	virtual bool addData(uint8_t *pData, size_t iSize, double dts, double pts, uint8_t subtitlePlane) = 0;
+	virtual CDVDVideoCodec::VCReturn getPicture(VideoPicture *pVideoPicture) = 0;
+	virtual int releaseFrame(const uint32_t index, bool drop=false) = 0;
+
+	virtual void setVideoRect(const CRect &SrcRect, const CRect &DestRect) = 0;
+
+	virtual void setSpeed(int speed) = 0;
+	virtual void setDrain(bool drain) = 0;
+
+	static int pollFrame();
+	static void sleep();
+
+	virtual void reset() = 0;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecConstants.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecConstants.h
new file mode 100644
index 0000000000..d84ec3af3d
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecConstants.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#define HDR_BUF_SIZE 1024
+
+#define TRICKMODE_NONE  0x00
+#define TRICKMODE_I     0x01
+#define TRICKMODE_FFFB  0x02
+
+#define P_PRE           (0x02000000)
+//#define F_PRE           (0x03000000)
+
+#define PLAYER_SUCCESS          (0)
+#define PLAYER_FAILED           (-(P_PRE|0x01))
+#define PLAYER_NOMEM            (-(P_PRE|0x02))
+#define PLAYER_EMPTY_P          (-(P_PRE|0x03))
+
+#define PLAYER_WR_FAILED        (-(P_PRE|0x21))
+//#define PLAYER_WR_EMPTYP        (-(P_PRE|0x22))
+//#define PLAYER_WR_FINISH        (P_PRE|0x1)
+
+#define PLAYER_PTS_ERROR        (-(P_PRE|0x31))
+//#define PLAYER_UNSUPPORT        (-(P_PRE|0x35))
+//#define PLAYER_CHECK_CODEC_ERROR  (-(P_PRE|0x39))
+
+#define EXTERNAL_PTS    (1)
+#define SYNC_OUTSIDE    (2)
+#define KEYFRAME_PTS_ONLY 0x100
+
+#define PTS_FREQ        90000
+#define UNIT_FREQ       96000
+#define AV_SYNC_THRESH  PTS_FREQ*30
+
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecDataTypes.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecDataTypes.h
new file mode 100644
index 0000000000..1f54531bf1
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecDataTypes.h
@@ -0,0 +1,101 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "LibAmcodec.h"
+
+extern "C" {
+	#include <libavcodec/packet.h>
+}
+
+typedef enum {
+    AM_STREAM_UNKNOWN = 0,
+    AM_STREAM_TS,
+    AM_STREAM_PS,
+    AM_STREAM_ES,
+    AM_STREAM_RM,
+    AM_STREAM_AUDIO,
+    AM_STREAM_VIDEO,
+} pstream_type;
+
+struct hdr_buf
+{
+private:
+	unsigned m_realSize;
+
+public:
+	hdr_buf() : m_realSize(0), data(nullptr), size(0) {}
+	~hdr_buf() {
+		if (data) {
+			delete[] data, data = nullptr;
+			m_realSize = size = 0;
+		}
+	}
+
+	void alloc(unsigned newSize) {
+		if (newSize > m_realSize) {
+			if (data) {
+				delete[] data;
+			}
+			data = new unsigned char[newSize];
+			m_realSize = size = newSize;
+		} else {
+			size = newSize;
+		}
+	}
+
+	void free() {
+		size = 0;
+	}
+
+	bool isEmpty() {
+		return size == 0 || data == nullptr;
+	}
+
+    unsigned char *data;
+    unsigned size;
+};
+
+typedef struct am_packet {
+    AVPacket      avpkt;
+    uint64_t      avpts;
+    uint64_t      avdts;
+    int           avduration;
+    int           isvalid;
+    int           newflag;
+    uint64_t      lastpts;
+    unsigned char *data;
+    unsigned char *buf;
+    int           data_size;
+    int           buf_size;
+    hdr_buf       *hdr;
+} am_packet_t;
+
+typedef struct am_private_t
+{
+	am_packet_t am_pkt;
+	aml_generic_param gcodec;
+
+	pstream_type stream_type;
+	int check_first_pts;
+
+	vformat_t video_format;
+	int video_pid;
+	unsigned int video_codec_id;
+	unsigned int video_codec_tag;
+	vdec_type_t video_codec_type;
+	unsigned int video_width;
+	unsigned int video_height;
+	unsigned int video_ratio;
+	unsigned int video_ratio64;
+	unsigned int video_rate;
+	unsigned int video_rotation_degree;
+	unsigned int extrasize;
+	uint8_t *extradata;
+} am_private_t;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecInfo.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecInfo.h
new file mode 100644
index 0000000000..0c7740448b
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AMLVideoCodecInfo.h
@@ -0,0 +1,33 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "namespace.h"
+
+#include <string>
+
+extern "C" {
+	#include <libavcodec/codec_id.h>
+}
+
+class CDVDStreamInfo;
+class CProcessInfo;
+
+class amlogic::AMLVideoCodecInfo
+{
+private:
+
+public:
+	virtual ~AMLVideoCodecInfo() = default;
+
+	virtual std::string getCodecName() const = 0;
+	virtual bool isSecure() const = 0;
+	virtual bool canPlay(const CDVDStreamInfo &hints) const = 0;
+	virtual AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) = 0;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.cpp
new file mode 100644
index 0000000000..19a46ef1a9
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.cpp
@@ -0,0 +1,584 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AV1Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/log.h"
+#include "utils/AMLUtils.h"
+#include "utils/log.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
+#include "settings/SettingsComponent.h"
+
+using namespace amlogic;
+
+// This code below is partly taken from the Amlogic vdec_av1_if.c kernel module.
+
+enum OBU_TYPE {
+	OBU_SEQUENCE_HEADER = 1,
+	OBU_TEMPORAL_DELIMITER = 2,
+	OBU_FRAME_HEADER = 3,
+	OBU_TILE_GROUP = 4,
+	OBU_METADATA = 5,
+	OBU_FRAME = 6,
+	OBU_REDUNDANT_FRAME_HEADER = 7,
+	OBU_TILE_LIST = 8,
+	OBU_PADDING = 15,
+};
+
+struct amlogic::ObuHeader {
+	size_t size;	// Size (1 or 2 bytes) of the OBU header (including the
+					// optional OBU extension header) in the bitstream.
+	enum OBU_TYPE type;
+	int has_size_field;
+	int has_extension;
+	// The following fields come from the OBU extension header and therefore are
+	// only used if has_extension is true.
+	int temporal_layer_id;
+	int spatial_layer_id;
+};
+
+enum OBU_METADATA_TYPE {
+	OBU_METADATA_TYPE_RESERVED_0 = 0,
+	OBU_METADATA_TYPE_HDR_CLL = 1,
+	OBU_METADATA_TYPE_HDR_MDCV = 2,
+	OBU_METADATA_TYPE_SCALABILITY = 3,
+	OBU_METADATA_TYPE_ITUT_T35 = 4,
+	OBU_METADATA_TYPE_TIMECODE = 5,
+};
+
+struct amlogic::read_bit_buffer {
+	const uint8_t *bit_buffer;
+	const uint8_t *bit_buffer_end;
+	uint32_t bit_offset;
+};
+
+static const size_t kMaximumLeb128Size = 8;
+static const uint8_t kLeb128ByteMask = 0x7f;
+
+class AV1CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	AV1CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "AV1"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_AV1) {
+			return false;
+		}
+
+		if (!aml_support_av1() || CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_USEAMCODECAV1)) {
+			// AV1 playback is either not supported or intentionally deactivated
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new AV1Codec(processInfo);
+	}
+
+} av1CodecInfo;
+
+AV1Codec::AV1Codec(CProcessInfo &processInfo)
+	: AMLInsecureVideoCodec(processInfo)
+{
+}
+
+AV1Codec::~AV1Codec()
+{
+	if (m_data_buffer.data != nullptr) {
+		m_data_buffer.size = 0;
+		delete[] m_data_buffer.data, m_data_buffer.data = nullptr;
+	}
+}
+
+std::string AV1Codec::getFormatName() const
+{
+	return "am-av1";
+}
+
+vformat_t AV1Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_AV1;
+}
+
+vdec_type_t AV1Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	return VIDEO_DEC_FORMAT_AV1;
+}
+
+void AV1Codec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	params.format = VIDEO_DEC_FORMAT_AV1;
+	params.decoder_type = DECODER_TYPE_FRAME_MODE;
+	params.param = (void*) EXTERNAL_PTS;
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) (EXTERNAL_PTS | SYNC_OUTSIDE);
+	}
+}
+
+bool AV1Codec::handleMasteringMetadata(const CDVDStreamInfo &hints) const
+{
+	if (!AMLInsecureVideoCodec::handleMasteringMetadata(hints)) {
+		return false;
+	}
+
+	enableCustomMasterDataDisplay();
+
+	return true;
+}
+
+int AV1Codec::av1_fixup_frame(DataBuffer &db_in)
+{
+  uint8_t meta_buffer[1024] = {0};
+  uint32_t meta_size = 0;
+  uint32_t length = 0;
+
+  uint8_t *src = (uint8_t *) db_in.data;
+  uint32_t size = db_in.size;
+
+  if (m_data_buffer.size < size + 0x1000) {
+	  if (m_data_buffer.data != nullptr) {
+		  delete[] m_data_buffer.data;
+	  }
+	  m_data_buffer.data = new uint8_t[size + 0x1000];
+	  m_data_buffer.size = size + 0x1000;
+  }
+
+  uint8_t *data = (uint8_t *) m_data_buffer.data;
+
+  av1_parser_frame(0, src, src + size, data, &length, meta_buffer, &meta_size);
+
+  db_in.data = m_data_buffer.data;
+  db_in.size = length;
+
+  return PLAYER_SUCCESS;
+}
+
+bool AV1Codec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	DataBuffer db(data, size);
+
+	av1_fixup_frame(db);
+
+	data = (uint8_t*) db.data;
+	size = db.size;
+
+	return true;
+}
+
+int AV1Codec::valid_obu_type(int obu_type) const
+{
+	int valid_type = 0;
+
+	switch (obu_type) {
+		case OBU_SEQUENCE_HEADER:
+		case OBU_TEMPORAL_DELIMITER:
+		case OBU_FRAME_HEADER:
+		case OBU_TILE_GROUP:
+		case OBU_METADATA:
+		case OBU_FRAME:
+		case OBU_REDUNDANT_FRAME_HEADER:
+		case OBU_TILE_LIST:
+		case OBU_PADDING:
+			valid_type = 1;
+			break;
+		default:
+			break;
+	}
+
+	return valid_type;
+}
+
+int AV1Codec::uleb_decode(const uint8_t *buffer, size_t available, uint64_t *value, size_t *length) const
+{
+	size_t i;
+
+	if (buffer && value) {
+		*value = 0;
+
+		for (i = 0; i < kMaximumLeb128Size && i < available; ++i) {
+			const uint8_t decoded_byte = *(buffer + i) & kLeb128ByteMask;
+
+			*value |= ((uint64_t)decoded_byte) << (i * 7);
+			if ((*(buffer + i) >> 7) == 0) {
+				if (length) {
+					*length = i + 1;
+				}
+
+				// Fail on values larger than 32-bits to ensure consistent behavior on
+				// 32 and 64 bit targets: value is typically used to determine buffer
+				// allocation size.
+				if (*value > ULONG_MAX)
+					return -1;
+
+				return 0;
+			}
+		}
+	}
+
+	// If we get here, either the buffer/value pointers were invalid,
+	// or we ran over the available space
+	return -1;
+}
+
+int AV1Codec::rb_read_bit(struct read_bit_buffer *rb) const
+{
+	const uint32_t off = rb->bit_offset;
+	const uint32_t p = off >> 3;
+	const int q = 7 - (int)(off & 0x7);
+
+	if (rb->bit_buffer + p < rb->bit_buffer_end) {
+		const int bit = (rb->bit_buffer[p] >> q) & 1;
+
+		rb->bit_offset = off + 1;
+		return bit;
+	} else {
+		return 0;
+	}
+}
+
+int AV1Codec::rb_read_literal(struct read_bit_buffer *rb, int bits) const
+{
+	int value = 0, bit;
+
+	for (bit = bits - 1; bit >= 0; bit--)
+		value |= rb_read_bit(rb) << bit;
+
+	return value;
+}
+
+int AV1Codec::read_obu_size(const uint8_t *data, size_t bytes_available, size_t *const obu_size, size_t *const length_field_size) const
+{
+	uint64_t u_obu_size = 0;
+
+	if (uleb_decode(data, bytes_available, &u_obu_size, length_field_size) != 0) {
+		return -1;
+	}
+
+	if (u_obu_size > ULONG_MAX)
+		return -1;
+
+	*obu_size = (size_t) u_obu_size;
+
+	return 0;
+}
+
+// Parses OBU header and stores values in 'header'.
+int AV1Codec::read_obu_header(struct read_bit_buffer *rb, int is_annexb, struct ObuHeader *header) const
+{
+	int bit_buffer_byte_length;
+
+	if (!rb || !header)
+		return -1;
+
+	bit_buffer_byte_length = rb->bit_buffer_end - rb->bit_buffer;
+
+	if (bit_buffer_byte_length < 1)
+		return -1;
+
+	header->size = 1;
+
+	if (rb_read_bit(rb) != 0) {
+		// Forbidden bit. Must not be set.
+		return -1;
+	}
+
+	header->type = (enum OBU_TYPE) rb_read_literal(rb, 4);
+	if (!valid_obu_type(header->type))
+		return -1;
+
+	header->has_extension = rb_read_bit(rb);
+	header->has_size_field = rb_read_bit(rb);
+
+	if (!header->has_size_field && !is_annexb) {
+		// section 5 obu streams must have obu_size field set.
+		return -1;
+	}
+
+	if (rb_read_bit(rb) != 0) {
+		// obu_reserved_1bit must be set to 0.
+		return -1;
+	}
+
+	if (header->has_extension) {
+		if (bit_buffer_byte_length == 1)
+			return -1;
+
+		header->size += 1;
+		header->temporal_layer_id = rb_read_literal(rb, 3);
+		header->spatial_layer_id = rb_read_literal(rb, 2);
+		if (rb_read_literal(rb, 3) != 0) {
+			// extension_header_reserved_3bits must be set to 0.
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+int AV1Codec::read_obu_header_and_size(const uint8_t *data, size_t bytes_available, int is_annexb,
+	struct ObuHeader *obu_header, size_t *const payload_size, size_t *const bytes_read) const
+{
+	size_t length_field_size_obu = 0;
+	size_t length_field_size_payload = 0;
+	size_t obu_size = 0;
+	int status = 0;
+	struct read_bit_buffer rb = { data + length_field_size_obu, data + bytes_available, 0};
+
+	if (is_annexb) {
+		// Size field comes before the OBU header, and includes the OBU header
+		status = read_obu_size(data, bytes_available, &obu_size, &length_field_size_obu);
+		if (status != 0)
+			return status;
+	}
+
+	status = read_obu_header(&rb, is_annexb, obu_header);
+	if (status != 0)
+		return status;
+
+	if (!obu_header->has_size_field) {
+		// Derive the payload size from the data we've already read
+		if (obu_size < obu_header->size)
+			return -1;
+
+		*payload_size = obu_size - obu_header->size;
+	} else {
+		// Size field comes after the OBU header, and is just the payload size
+		status = read_obu_size(data + length_field_size_obu + obu_header->size,
+			bytes_available - length_field_size_obu - obu_header->size,
+			payload_size, &length_field_size_payload);
+		if (status != 0)
+			return status;
+	}
+
+	*bytes_read = length_field_size_obu + obu_header->size + length_field_size_payload;
+
+	return 0;
+}
+
+int AV1Codec::av1_parser_frame(int is_annexb, uint8_t *data, const uint8_t *data_end,
+		uint8_t *dst_data, uint32_t *frame_len, uint8_t *meta_buf, uint32_t *meta_len) const
+{
+	int frame_decoding_finished = 0;
+	uint32_t obu_size = 0;
+	int seen_frame_header = 0;
+	struct DataBuffer obu_size_hdr;
+	uint8_t header[20] = {0};
+	uint8_t *p = NULL;
+	uint32_t rpu_size = 0;
+	struct ObuHeader obu_header;
+
+	memset(&obu_header, 0, sizeof(obu_header));
+
+	// decode frame as a series of OBUs
+	while (!frame_decoding_finished) {
+		//	struct read_bit_buffer rb;
+		size_t payload_size = 0;
+		size_t header_size = 0;
+		size_t bytes_read = 0;
+		const size_t bytes_available = data_end - data;
+		enum OBU_METADATA_TYPE meta_type;
+		int status;
+		uint64_t type = 0;
+		uint32_t i;
+
+		if (bytes_available == 0 && !seen_frame_header) {
+			break;
+		}
+
+		status = read_obu_header_and_size(data, bytes_available, is_annexb,
+			&obu_header, &payload_size, &bytes_read);
+		if (status != 0) {
+			return -1;
+		}
+
+		// Record obu size header information.
+		obu_size_hdr.data = data + obu_header.size;
+		obu_size_hdr.size = bytes_read - obu_header.size;
+
+		// Note: read_obu_header_and_size() takes care of checking that this
+		// doesn't cause 'data' to advance past 'data_end'.
+
+		if ((size_t)(data_end - data - bytes_read) < payload_size) {
+			return -1;
+		}
+
+		if (!is_annexb) {
+			obu_size = bytes_read + payload_size + 4;
+			header_size = 20;
+		} else {
+			obu_size = bytes_read + payload_size;
+			header_size = 16;
+		}
+
+		header[0] = ((obu_size + 4) >> 24) & 0xff;
+		header[1] = ((obu_size + 4) >> 16) & 0xff;
+		header[2] = ((obu_size + 4) >> 8) & 0xff;
+		header[3] = ((obu_size + 4) >> 0) & 0xff;
+		header[4] = header[0] ^ 0xff;
+		header[5] = header[1] ^ 0xff;
+		header[6] = header[2] ^ 0xff;
+		header[7] = header[3] ^ 0xff;
+		header[8] = 0;
+		header[9] = 0;
+		header[10] = 0;
+		header[11] = 1;
+		header[12] = 'A';
+		header[13] = 'M';
+		header[14] = 'L';
+		header[15] = 'V';
+
+		// put new size to here as annexb
+		header[16] = (obu_size & 0xff) | 0x80;
+		header[17] = ((obu_size >> 7) & 0xff) | 0x80;
+		header[18] = ((obu_size >> 14) & 0xff) | 0x80;
+		header[19] = ((obu_size >> 21) & 0xff) | 0x00;
+
+		memcpy(dst_data, header, header_size);
+		dst_data += header_size;
+		memcpy(dst_data, data, bytes_read + payload_size);
+		dst_data += (bytes_read + payload_size);
+
+		data += bytes_read;
+		*frame_len += (header_size + bytes_read + payload_size);
+
+		switch (obu_header.type) {
+			case OBU_TEMPORAL_DELIMITER:
+				seen_frame_header = 0;
+				break;
+			case OBU_SEQUENCE_HEADER:
+				// The sequence header should not change in the middle of a frame.
+				if (seen_frame_header) {
+					return -1;
+				}
+				break;
+			case OBU_FRAME_HEADER:
+				if (data_end == data + payload_size) {
+					frame_decoding_finished = 1;
+				} else {
+					seen_frame_header = 1;
+				}
+				break;
+			case OBU_REDUNDANT_FRAME_HEADER:
+			case OBU_FRAME:
+				if (obu_header.type == OBU_REDUNDANT_FRAME_HEADER) {
+					if (!seen_frame_header) {
+						return -1;
+					}
+				} else {
+					// OBU_FRAME_HEADER or OBU_FRAME.
+					if (seen_frame_header) {
+						return -1;
+					}
+				}
+				if (obu_header.type == OBU_FRAME) {
+					if (data_end == data + payload_size) {
+						frame_decoding_finished = 1;
+						seen_frame_header = 0;
+					}
+				}
+				break;
+			case OBU_TILE_GROUP:
+				if (!seen_frame_header) {
+					return -1;
+				}
+				if (data + payload_size == data_end)
+					frame_decoding_finished = 1;
+				if (frame_decoding_finished)
+					seen_frame_header = 0;
+				break;
+			case OBU_METADATA:
+				uleb_decode(data, 8, &type, &bytes_read);
+				if (type < 6)
+					meta_type = (OBU_METADATA_TYPE) type;
+				else
+					meta_type = OBU_METADATA_TYPE_RESERVED_0;
+
+				p = data + bytes_read;
+
+				if (meta_type == OBU_METADATA_TYPE_ITUT_T35) {
+	#if 0 /* for dumping original obu payload */
+					for (i = 0; i < payload_size - bytes_read; i++) {
+						pr_info("%02x ", p[i]);
+						if (i % 16 == 15)
+							pr_info("\n");
+					}
+					if (i % 16 != 0)
+						pr_info("\n");
+	#endif
+					if ((p[0] == 0xb5) /* country code */
+						&& ((p[1] == 0x00) && (p[2] == 0x3b)) /* terminal_provider_code */
+						&& ((p[3] == 0x00) && (p[4] == 0x00) && (p[5] == 0x08) && (p[6] == 0x00))) { /* terminal_provider_oriented_code */
+						meta_buf[0] = meta_buf[1] = meta_buf[2] = 0;
+						meta_buf[3] = 0x01;
+						meta_buf[4] = 0x19;
+
+						if (p[11] & 0x10) {
+							rpu_size = 0x100;
+							rpu_size |= (p[11] & 0x0f) << 4;
+							rpu_size |= (p[12] >> 4) & 0x0f;
+							if (p[12] & 0x08) {
+								break;
+							}
+							for (i = 0; i < rpu_size; i++) {
+								meta_buf[5 + i] = (p[12 + i] & 0x07) << 5;
+								meta_buf[5 + i] |= (p[13 + i] >> 3) & 0x1f;
+							}
+							rpu_size += 5;
+						} else {
+							rpu_size = (p[10] & 0x1f) << 3;
+							rpu_size |= (p[11] >> 5) & 0x07;
+							for (i = 0; i < rpu_size; i++) {
+								meta_buf[5 + i] = (p[11 + i] & 0x0f) << 4;
+								meta_buf[5 + i] |= (p[12 + i] >> 4) & 0x0f;
+							}
+							rpu_size += 5;
+						}
+						*meta_len = rpu_size;
+					}
+				} else if (meta_type == OBU_METADATA_TYPE_HDR_CLL) {
+					CLog::Log(LOGDEBUG, "AV1: hdr10 cll:");
+					CLog::Log(LOGDEBUG, "AV1: max_cll = {}", (p[0] << 8) | p[1]);
+					CLog::Log(LOGDEBUG, "AV1: max_fall = {}", (p[2] << 8) | p[3]);
+				} else if (meta_type == OBU_METADATA_TYPE_HDR_MDCV) {
+					CLog::Log(LOGDEBUG, "AV1: hdr10 primaries[r,g,b] = ");
+					for (i = 0; i < 3; i++) {
+						CLog::Log(LOGDEBUG, "       0x{:x}, 0x{:x}\n", (p[i * 4] << 8) | p[i * 4 + 1], (p[i * 4 + 2] << 8) | p[i * 4 + 3]);
+					}
+
+					CLog::Log(LOGDEBUG, "AV1: white point = 0x{:x}, 0x{:x}\n", (p[12] << 8) | p[13], (p[14] << 8) | p[15]);
+					CLog::Log(LOGDEBUG, "AV1: maxl = 0x{:x}\n", (p[16] << 24) | (p[17] << 16) | (p[18] << 8) | p[19]);
+					CLog::Log(LOGDEBUG, "AV1: minl = 0x{:x}\n", (p[20] << 24) | (p[21] << 16) | (p[22] << 8) | p[23]);
+				}
+				break;
+			case OBU_TILE_LIST:
+				break;
+			case OBU_PADDING:
+				break;
+			default:
+				// Skip unrecognized OBUs
+				break;
+		}
+
+		data += payload_size;
+	}
+
+	return 0;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.h
new file mode 100644
index 0000000000..f88d71e135
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/AV1Codec.h
@@ -0,0 +1,58 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+namespace amlogic {
+	struct read_bit_buffer;
+	struct ObuHeader;
+
+	struct DataBuffer
+	{
+		DataBuffer() : data(nullptr), size(0) {}
+		DataBuffer(const uint8_t *d, size_t s) : data(d), size(s) {}
+
+		const uint8_t *data;
+		size_t size;
+	};
+}
+
+class amlogic::AV1Codec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	DataBuffer m_data_buffer;
+
+	int valid_obu_type(int obu_type) const;
+	int uleb_decode(const uint8_t *buffer, size_t available, uint64_t *value, size_t *length) const;
+	int rb_read_bit(struct read_bit_buffer *rb) const;
+	int rb_read_literal(struct read_bit_buffer *rb, int bits) const;
+	int read_obu_size(const uint8_t *data, size_t bytes_available, size_t *const obu_size, size_t *const length_field_size) const;
+	int read_obu_header(struct read_bit_buffer *rb, int is_annexb, struct ObuHeader *header) const;
+	int read_obu_header_and_size(const uint8_t *data, size_t bytes_available, int is_annexb,
+		struct ObuHeader *obu_header, size_t *const payload_size, size_t *const bytes_read) const;
+	int av1_parser_frame(int is_annexb, uint8_t *data, const uint8_t *data_end,
+			uint8_t *dst_data, uint32_t *frame_len, uint8_t *meta_buf, uint32_t *meta_len) const;
+	int av1_fixup_frame(DataBuffer &db_in);
+
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+	virtual bool handleMasteringMetadata(const CDVDStreamInfo &hints) const;
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+public:
+	AV1Codec(CProcessInfo &processInfo);
+	virtual ~AV1Codec();
+
+	virtual std::string getFormatName() const;
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.cpp
new file mode 100644
index 0000000000..e0c7cc5add
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.cpp
@@ -0,0 +1,251 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "H264Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "OSMCSecureOS.h"
+
+#include "utils/AMLUtils.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/log.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
+#include "settings/SettingsComponent.h"
+
+#ifndef CODEC_TAG_AMVC
+	#define CODEC_TAG_AMVC  (0x43564d41)
+#endif
+
+#ifndef CODEC_TAG_MVC1
+	#define CODEC_TAG_MVC1  (0x3143564d)
+#endif
+
+using namespace amlogic;
+
+class H264CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	H264CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "H.264/MVC"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_H264) {
+			return false;
+		}
+
+		int resolutionLimit = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_USEAMCODECH264);
+		if (hints.width <= resolutionLimit) {
+			CLog::Log(LOGDEBUG, "H264CodecInfo: size check failed {}", resolutionLimit);
+			return false;
+		}
+
+		switch (hints.profile) {
+			case FF_PROFILE_H264_HIGH_10:
+			case FF_PROFILE_H264_HIGH_10_INTRA:
+			case FF_PROFILE_H264_HIGH_422:
+			case FF_PROFILE_H264_HIGH_422_INTRA:
+			case FF_PROFILE_H264_HIGH_444_PREDICTIVE:
+			case FF_PROFILE_H264_HIGH_444_INTRA:
+			case FF_PROFILE_H264_CAVLC_444:
+				CLog::Log(LOGDEBUG, "H264CodecInfo: profile {} not supported", hints.profile);
+				return false;
+		}
+
+		if ((aml_support_h264_4k2k() == AML_NO_H264_4K2K) && (hints.width > 1920 || hints.height > 1088)) {
+			// 4K is supported only on Amlogic S802/S812 chip
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		bool requestMvc = hints.codec_tag == CODEC_TAG_AMVC || hints.codec_tag == CODEC_TAG_MVC1;
+		bool request4k = !requestMvc && aml_support_h264_4k2k() == AML_HAS_H264_4K2K && (hints.width > 1920 || hints.height > 1088);
+
+		return new H264Codec(processInfo, request4k, requestMvc);
+	}
+
+} h264CodecInfo;
+
+
+H264Codec::H264Codec(CProcessInfo &processInfo, bool request4k, bool requestMvc)
+	: AMLInsecureVideoCodec(processInfo), m_is4k(request4k), m_isMvc(requestMvc), m_hasKeyframe(false),
+	  m_bitstream(nullptr), m_bitparser(nullptr)
+{
+}
+
+H264Codec::~H264Codec()
+{
+	if (m_bitstream) {
+		delete m_bitstream, m_bitstream = nullptr;
+	}
+	if (m_bitparser) {
+		delete m_bitparser, m_bitparser = nullptr;
+	}
+}
+
+std::string H264Codec::getFormatName() const
+{
+	return m_isMvc ? "am-h264mvc" : "am-h264";
+}
+
+vformat_t H264Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return m_isMvc ? VFORMAT_H264MVC : (m_is4k ? VFORMAT_H264_4K2K : VFORMAT_H264);
+}
+
+vdec_type_t H264Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	return m_is4k ? VIDEO_DEC_FORMAT_H264_4K2K : VIDEO_DEC_FORMAT_H264;
+}
+
+int H264Codec::calculateSleepDuration()
+{
+	// we need a shorter sleep period for MVC playback to avoid Kodi skipping like hell
+	return AMLInsecureVideoCodec::calculateSleepDuration() / (m_isMvc ? 2 : 1);
+}
+
+void H264Codec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	params.param = (void*) EXTERNAL_PTS;
+	// h264 in an avi file
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) (EXTERNAL_PTS | SYNC_OUTSIDE);
+	}
+}
+
+int H264Codec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	if (para->extradata) {
+		pkt->hdr->alloc(para->extrasize);
+		if (!pkt->hdr->data) {
+			return PLAYER_NOMEM;
+		}
+
+		memcpy(pkt->hdr->data, para->extradata, para->extrasize);
+		pkt->hdr->size = para->extrasize;
+	}
+
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
+
+void H264Codec::playbackResume(int speed)
+{
+	m_libamcodec->setControlMode(TRICKMODE_FFFB);
+}
+
+unsigned int H264Codec::getVideoRate(const CDVDStreamInfo &hints) const
+{
+	unsigned int rate = AMLInsecureVideoCodec::getVideoRate(hints);
+
+	// check for SD h264 content incorrectly reported as 60 fps
+	// mp4/avi containers :(
+	if (hints.width <= 720 && rate == 1602) {
+		CLog::Log(LOGDEBUG, "H264Codec::getVideoRate video_rate exception");
+		rate = 0.5 + (float) UNIT_FREQ * 1001 / 24000;
+	}
+
+	// check for SD h264 content incorrectly reported as some form of 30 fps
+	// mp4/avi containers :(
+	if (hints.width <= 720 && rate >= 3200 && rate <= 3210) {
+		CLog::Log(LOGDEBUG, "H264Codec::getVideoRate video_rate exception");
+		rate = 0.5 + (float) UNIT_FREQ * 1001 / 24000;
+	}
+
+	return rate;
+}
+
+CDVDVideoCodec::VCReturn H264Codec::getPicture(VideoPicture *pVideoPicture)
+{
+	CDVDVideoCodec::VCReturn ret = AMLInsecureVideoCodec::getPicture(pVideoPicture);
+
+	if (m_isMvc && ret == CDVDVideoCodec::VC_PICTURE) {
+		pVideoPicture->m_3dSubtitleDepth = m_secureOSMC->getMvcSubtitleDepth(pVideoPicture->pts/DVD_TIME_BASE);
+	}
+
+	return ret;
+}
+
+bool H264Codec::openDecoder(CDVDStreamInfo &hints)
+{
+	if (AMLInsecureVideoCodec::openDecoder(hints)) {
+		m_hasKeyframe = false;
+		return true;
+	}
+
+	return false;
+}
+
+void H264Codec::reset()
+{
+	AMLInsecureVideoCodec::reset();
+
+	m_hasKeyframe = false;
+	if (m_bitstream) {
+		m_bitstream->ResetStartDecode();
+	}
+}
+
+bool H264Codec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	if (m_bitstream == nullptr && m_bitparser == nullptr) {
+		// convert h264-avcC to h264-annex-b as h264-avcC
+		// under streamers can have issues when seeking.
+		if (hints.extradata && *(uint8_t*) hints.extradata == 1) {
+			m_bitstream = new CBitstreamConverter;
+
+			m_bitstream->Open(hints.codec, (uint8_t*) hints.extradata, hints.extrasize, true);
+			m_bitstream->ResetStartDecode();
+
+			// make sure we do not leak the existing hints.extradata
+			free(hints.extradata);
+
+			hints.extrasize = m_bitstream->GetExtraSize();
+			hints.extradata = malloc(hints.extrasize);
+			memcpy(hints.extradata, m_bitstream->GetExtraData(), hints.extrasize);
+		} else {
+			m_bitparser = new CBitstreamParser();
+			m_bitparser->Open();
+		}
+	}
+
+    if (m_bitstream) {
+		if (!m_bitstream->Convert(data, size)) {
+			return false;
+		}
+
+		if (!m_bitstream->CanStartDecode()) {
+			CLog::Log(LOGDEBUG, "H264Codec::prepareFrame waiting for keyframe (bitstream)");
+			return false;
+		}
+
+		data = m_bitstream->GetConvertBuffer();
+		size = m_bitstream->GetConvertSize();
+	} else if (!m_hasKeyframe && m_bitparser) {
+		if (!m_bitparser->CanStartDecode(data, size)) {
+			CLog::Log(LOGDEBUG, "H264Codec::prepareFrame waiting for keyframe (bitparser)");
+			return false;
+		} else {
+			m_hasKeyframe = true;
+		}
+	}
+
+    return true;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.h
new file mode 100644
index 0000000000..1f3fa3e1df
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/H264Codec.h
@@ -0,0 +1,52 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+class CBitstreamConverter;
+class CBitstreamParser;
+
+class amlogic::H264Codec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	bool	m_is4k;
+	bool	m_isMvc;
+	bool	m_hasKeyframe;
+
+	CBitstreamConverter	*m_bitstream;
+	CBitstreamParser	*m_bitparser;
+
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+	virtual unsigned int getVideoRate(const CDVDStreamInfo &hints) const;
+
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+
+	virtual void playbackResume(int speed);
+
+	virtual int calculateSleepDuration();
+
+public:
+	H264Codec(CProcessInfo &processInfo, bool request4k, bool requestMvc);
+	virtual ~H264Codec();
+
+	virtual std::string getFormatName() const;
+
+	virtual bool openDecoder(CDVDStreamInfo &hints);
+
+	virtual CDVDVideoCodec::VCReturn getPicture(VideoPicture *pVideoPicture);
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+
+	virtual void reset();
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.cpp
new file mode 100644
index 0000000000..5b9c49dc1c
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.cpp
@@ -0,0 +1,142 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "HEVCCodec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/AMLUtils.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/log.h"
+
+using namespace amlogic;
+
+class HEVCCodecInfo : public AMLVideoCodecInfo
+{
+public:
+	HEVCCodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "HEVC"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_HEVC) {
+			return false;
+		}
+
+		if (aml_support_hevc()) {
+			if (!aml_support_hevc_4k2k() && (hints.width > 1920 || hints.height > 1088)) {
+				// 4K HEVC is supported only on Amlogic S812 chip
+				return false;
+			}
+		} else {
+			// HEVC supported only on S805 and S812.
+			return false;
+		}
+
+		if (hints.profile == FF_PROFILE_HEVC_MAIN_10 && !aml_support_hevc_10bit()) {
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new HEVCCodec(processInfo);
+	}
+
+} hevcCodecInfo;
+
+
+HEVCCodec::HEVCCodec(CProcessInfo &processInfo)
+	: AMLInsecureVideoCodec(processInfo), m_bitstream(nullptr)
+{
+}
+
+HEVCCodec::~HEVCCodec()
+{
+	if (m_bitstream) {
+		delete m_bitstream, m_bitstream = nullptr;
+	}
+}
+
+std::string HEVCCodec::getFormatName() const
+{
+	return "am-h265";
+}
+
+vformat_t HEVCCodec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_HEVC;
+}
+
+vdec_type_t HEVCCodec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	return VIDEO_DEC_FORMAT_HEVC;
+}
+
+void HEVCCodec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	params.decoder_type = DECODER_TYPE_FRAME_MODE;
+	params.param = (void*) EXTERNAL_PTS;
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) (EXTERNAL_PTS | SYNC_OUTSIDE);
+	}
+}
+
+int HEVCCodec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	if (para->extradata) {
+		pkt->hdr->alloc(para->extrasize);
+		if (!pkt->hdr->data) {
+			return PLAYER_NOMEM;
+		}
+
+		memcpy(pkt->hdr->data, para->extradata, para->extrasize);
+		pkt->hdr->size = para->extrasize;
+	}
+
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
+
+bool HEVCCodec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	if (m_bitstream == nullptr) {
+		m_bitstream = new CBitstreamConverter();
+
+		m_bitstream->Open(hints.codec, (uint8_t*)hints.extradata, hints.extrasize, true);
+
+		// make sure we do not leak the existing m_hints.extradata
+		free(hints.extradata);
+
+		hints.extrasize = m_bitstream->GetExtraSize();
+		hints.extradata = malloc(hints.extrasize);
+		memcpy(hints.extradata, m_bitstream->GetExtraData(), hints.extrasize);
+	}
+
+	if (!m_bitstream->Convert(data, size)) {
+		return false;
+	}
+
+	if (!m_bitstream->CanStartDecode()) {
+		CLog::Log(LOGDEBUG, "HEVCCodec::prepareFrame waiting for keyframe (bitstream)");
+		return false;
+	}
+
+	data = m_bitstream->GetConvertBuffer();
+	size = m_bitstream->GetConvertSize();
+
+	return true;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.h
new file mode 100644
index 0000000000..5c8655bd15
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/HEVCCodec.h
@@ -0,0 +1,35 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+class CBitstreamConverter;
+
+class amlogic::HEVCCodec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	CBitstreamConverter	*m_bitstream;
+
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+
+public:
+	HEVCCodec(CProcessInfo &processInfo);
+	virtual ~HEVCCodec();
+
+	virtual std::string getFormatName() const;
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.cpp
new file mode 100644
index 0000000000..ce0113740e
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.cpp
@@ -0,0 +1,304 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "LibAmcodec.h"
+
+#include "DynamicDll.h"
+#include "PlatformDefs.h"
+
+#include "utils/log.h"
+
+#include <poll.h>
+
+#define LIBAMCODEC	"/usr/osmc/lib/libamcodec.so"
+
+using namespace amlogic;
+
+// ----------------------------------------------------------------------------
+
+class LibamCodecInterface
+{
+public:
+  virtual ~LibamCodecInterface() {};
+
+  virtual int codec_init(codec_para_t *pcodec)=0;
+  virtual int codec_close(codec_para_t *pcodec)=0;
+  virtual int codec_reset(codec_para_t *pcodec)=0;
+  virtual int codec_pause(codec_para_t *pcodec)=0;
+  virtual int codec_resume(codec_para_t *pcodec)=0;
+  virtual int codec_write(codec_para_t *pcodec, void *buffer, int len)=0;
+  virtual int codec_checkin_pts(codec_para_t *pcodec, unsigned long pts)=0;
+  virtual int codec_checkin_pts64(codec_para_t *pcodec, unsigned long long pts64)=0;
+  virtual int codec_get_vbuf_state(codec_para_t *pcodec, struct buf_status *buf)=0;
+  virtual int codec_get_vdec_state(codec_para_t *pcodec, struct vdec_status *vdec)=0;
+
+  virtual int codec_get_vdec_is_buffering(codec_para_t *pcodec, unsigned long *buffering)=0;
+
+  virtual int codec_init_cntl(codec_para_t *pcodec)=0;
+  virtual int codec_poll_cntl(codec_para_t *pcodec)=0;
+  virtual int codec_set_cntl_mode(codec_para_t *pcodec, unsigned int mode)=0;
+  virtual int codec_set_cntl_avthresh(codec_para_t *pcodec, unsigned int avthresh)=0;
+  virtual int codec_set_cntl_syncthresh(codec_para_t *pcodec, unsigned int syncthresh)=0;
+
+  virtual int codec_set_av_threshold(codec_para_t *pcodec, int threshold)=0;
+  virtual int codec_set_video_delay_limited_ms(codec_para_t *pcodec,int delay_ms)=0;
+  virtual int codec_get_video_delay_limited_ms(codec_para_t *pcodec,int *delay_ms)=0;
+  virtual int codec_get_video_cur_delay_ms(codec_para_t *pcodec,int *delay_ms)=0;
+
+  virtual void codec_set_log_callback(void (*logf)(const char *, ...))=0;
+  virtual int codec_set_3d_video_mode(codec_para_t *pcodec, video_mode_3d_t mode)=0;
+  virtual int codec_set_video_mode(codec_para_t *pcodec, video_input_mode vimode, video_output_mode vomode, int left_eye_first)=0;
+  virtual int codec_set_hdr10p_metadata(codec_para_t *pcodec, void *metadata, int metadata_size)=0;
+};
+
+class amlogic::DllLibAmCodec : public DllDynamic, LibamCodecInterface
+{
+  DECLARE_DLL_WRAPPER(DllLibAmCodec, LIBAMCODEC)
+
+  DEFINE_METHOD1(int, codec_init,               (codec_para_t *p1))
+  DEFINE_METHOD1(int, codec_close,              (codec_para_t *p1))
+  DEFINE_METHOD1(int, codec_reset,              (codec_para_t *p1))
+  DEFINE_METHOD1(int, codec_pause,              (codec_para_t *p1))
+  DEFINE_METHOD1(int, codec_resume,             (codec_para_t *p1))
+  DEFINE_METHOD3(int, codec_write,              (codec_para_t *p1, void *p2, int p3))
+  DEFINE_METHOD2(int, codec_checkin_pts,        (codec_para_t *p1, unsigned long p2))
+  DEFINE_METHOD2(int, codec_checkin_pts64,      (codec_para_t *p1, unsigned long long p2))
+  DEFINE_METHOD2(int, codec_get_vbuf_state,     (codec_para_t *p1, struct buf_status * p2))
+  DEFINE_METHOD2(int, codec_get_vdec_state,     (codec_para_t *p1, struct vdec_status * p2))
+
+  DEFINE_METHOD2(int, codec_get_vdec_is_buffering,     (codec_para_t *p1, unsigned long *p2))
+
+  DEFINE_METHOD1(int, codec_init_cntl,          (codec_para_t *p1))
+  DEFINE_METHOD1(int, codec_poll_cntl,          (codec_para_t *p1))
+  DEFINE_METHOD2(int, codec_set_cntl_mode,      (codec_para_t *p1, unsigned int p2))
+  DEFINE_METHOD2(int, codec_set_cntl_avthresh,  (codec_para_t *p1, unsigned int p2))
+  DEFINE_METHOD2(int, codec_set_cntl_syncthresh,(codec_para_t *p1, unsigned int p2))
+
+  DEFINE_METHOD2(int, codec_set_av_threshold,   (codec_para_t *p1, int p2))
+  DEFINE_METHOD2(int, codec_set_video_delay_limited_ms, (codec_para_t *p1, int p2))
+  DEFINE_METHOD2(int, codec_get_video_delay_limited_ms, (codec_para_t *p1, int *p2))
+  DEFINE_METHOD2(int, codec_get_video_cur_delay_ms, (codec_para_t *p1, int *p2))
+
+  DEFINE_METHOD_FP(void, codec_set_log_callback, (void (*)(const char *, ...)))
+  DEFINE_METHOD2(int, codec_set_3d_video_mode,   (codec_para_t *p1, video_mode_3d_t p2))
+  DEFINE_METHOD4(int, codec_set_video_mode,      (codec_para_t *p1, video_input_mode p2, video_output_mode p3, int p4))
+  DEFINE_METHOD3(int, codec_set_hdr10p_metadata, (codec_para_t *p1, void *p2, int p3))
+
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(codec_init)
+    RESOLVE_METHOD(codec_close)
+    RESOLVE_METHOD(codec_reset)
+    RESOLVE_METHOD(codec_pause)
+    RESOLVE_METHOD(codec_resume)
+    RESOLVE_METHOD(codec_write)
+    RESOLVE_METHOD(codec_checkin_pts)
+    RESOLVE_METHOD(codec_checkin_pts64)
+    RESOLVE_METHOD(codec_get_vbuf_state)
+    RESOLVE_METHOD(codec_get_vdec_state)
+
+    RESOLVE_METHOD_OPTIONAL(codec_get_vdec_is_buffering)
+
+    RESOLVE_METHOD(codec_init_cntl)
+    RESOLVE_METHOD(codec_poll_cntl)
+    RESOLVE_METHOD(codec_set_cntl_mode)
+    RESOLVE_METHOD(codec_set_cntl_avthresh)
+    RESOLVE_METHOD(codec_set_cntl_syncthresh)
+
+    RESOLVE_METHOD(codec_set_av_threshold)
+    RESOLVE_METHOD(codec_set_video_delay_limited_ms)
+    RESOLVE_METHOD(codec_get_video_delay_limited_ms)
+    RESOLVE_METHOD(codec_get_video_cur_delay_ms)
+
+    RESOLVE_METHOD_OPTIONAL_FP(codec_set_log_callback)
+    RESOLVE_METHOD(codec_set_3d_video_mode)
+    RESOLVE_METHOD(codec_set_video_mode)
+    RESOLVE_METHOD(codec_set_hdr10p_metadata)
+  END_METHOD_RESOLVE()
+
+public:
+	void codec_set_log_callback(void (*logf)(const char*, ...))
+	{
+		if (m_codec_set_log_callback_ptr) {
+			m_codec_set_log_callback(logf);
+		}
+	}
+
+	bool IsVCodecBuffering(codec_para_t *param)
+	{
+		unsigned long parm = 0;
+
+		if (m_codec_get_vdec_is_buffering_ptr == nullptr
+				|| codec_get_vdec_is_buffering(param, &parm)) {
+			return false;
+		}
+
+		return parm != 0;
+	}
+
+};
+
+// ----------------------------------------------------------------------------
+
+LibAmcodec::LibAmcodec()
+{
+	m_dll = new DllLibAmCodec();
+	if (!m_dll->Load()) {
+		CLog::Log(LOGWARNING, "LibAmcodec::LibAmcodec " LIBAMCODEC " not found");
+		delete m_dll, m_dll = nullptr;
+	}
+
+	m_codec = new codec_para_t;
+	m_codec->handle             = -1; //init to invalid
+	m_codec->cntl_handle        = -1;
+	m_codec->sub_handle         = -1;
+	m_codec->audio_utils_handle = -1;
+}
+
+LibAmcodec::~LibAmcodec()
+{
+	delete m_codec, m_codec = nullptr;
+
+	delete m_dll, m_dll = nullptr;
+}
+
+int LibAmcodec::checkinPts64(uint64_t pts64)
+{
+	return m_dll->codec_checkin_pts64(m_codec, pts64);
+}
+
+void LibAmcodec::setLogCallback(void (*logf)(const char *, ...))
+{
+	m_dll->codec_set_log_callback(logf);
+}
+
+int LibAmcodec::init(const aml_generic_param &gparam)
+{
+	memset(m_codec, 0x00, sizeof(codec_para_t));
+
+	// direct struct usage, we do not know which flavor
+	// so just use what we get from headers and pray.
+	m_codec->handle				= -1; //init to invalid
+	m_codec->cntl_handle		= -1;
+	m_codec->sub_handle			= -1;
+	m_codec->audio_utils_handle	= -1;
+	m_codec->has_video			= 1;
+	m_codec->noblock			= gparam.noblock;
+	m_codec->video_pid			= gparam.video_pid;
+	m_codec->video_type			= gparam.video_type;
+	m_codec->video_path			= gparam.video_path;
+	m_codec->stream_type		= gparam.stream_type;
+	m_codec->decoder_type		= gparam.decoder_type;
+	m_codec->display_mode		= gparam.display_mode;
+	m_codec->config				= gparam.config;
+	m_codec->config_len			= gparam.config_len;
+	m_codec->am_sysinfo.format	= gparam.format;
+	m_codec->am_sysinfo.width	= gparam.width;
+	m_codec->am_sysinfo.height	= gparam.height;
+	m_codec->am_sysinfo.rate	= gparam.rate;
+	m_codec->am_sysinfo.extra	= gparam.extra;
+	m_codec->am_sysinfo.status	= gparam.status;
+	m_codec->am_sysinfo.ratio	= gparam.ratio;
+	m_codec->am_sysinfo.ratio64	= gparam.ratio64;
+	m_codec->am_sysinfo.param	= gparam.param;
+
+	return m_dll->codec_init(m_codec);
+}
+
+int LibAmcodec::pause()
+{
+	return m_dll->codec_pause(m_codec);
+}
+
+int LibAmcodec::close()
+{
+	return m_dll->codec_close(m_codec);
+}
+
+int LibAmcodec::reset()
+{
+	return m_dll->codec_reset(m_codec);
+}
+
+int LibAmcodec::setControlMode(unsigned int mode)
+{
+	return m_dll->codec_set_cntl_mode(m_codec, mode);
+}
+
+int LibAmcodec::setVideoDelayLimitedMs(int delay)
+{
+	return m_dll->codec_set_video_delay_limited_ms(m_codec, delay);
+}
+
+int LibAmcodec::setControlAvThreshold(unsigned int threshold)
+{
+	return m_dll->codec_set_cntl_avthresh(m_codec, threshold);
+}
+
+int LibAmcodec::setControlSyncThreshold(unsigned int threshold)
+{
+	return m_dll->codec_set_cntl_syncthresh(m_codec, threshold);
+}
+
+int LibAmcodec::getVbufState(struct buf_status &bs) const
+{
+	return m_dll->codec_get_vbuf_state(m_codec, &bs);
+}
+
+bool LibAmcodec::isVCodecBuffering() const
+{
+	return m_dll->IsVCodecBuffering(m_codec);
+}
+
+int LibAmcodec::set3dVideoMode(video_mode_3d_t mode)
+{
+	return m_dll->codec_set_3d_video_mode(m_codec, mode);
+}
+
+int LibAmcodec::setVideoMode(video_input_mode vimode, video_output_mode vomode, bool leftEyeFirst)
+{
+	return m_dll->codec_set_video_mode(m_codec, vimode, vomode, leftEyeFirst ? 1 : 0);
+}
+
+int LibAmcodec::setHdr10pMetadata(unsigned char *metadata, int metadata_length)
+{
+	return m_dll->codec_set_hdr10p_metadata(m_codec, metadata, metadata_length);
+}
+
+int LibAmcodec::getVdecState(struct vdec_status &vs) const
+{
+	return m_dll->codec_get_vdec_state(m_codec, &vs);
+}
+
+int LibAmcodec::write(unsigned char *buf, unsigned int size)
+{
+	return m_dll->codec_write(m_codec, buf, (int) size);
+}
+
+int LibAmcodec::poll(unsigned int timeoutMs)
+{
+	struct pollfd codec_poll_fd[1];
+
+	codec_poll_fd[0].fd = m_codec->cntl_handle;
+	codec_poll_fd[0].events = POLLOUT;
+
+	if (::poll(codec_poll_fd, 1, timeoutMs) > 0) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void LibAmcodec::setNoBlockMode(bool noblock)
+{
+	m_codec->noblock = noblock ? 1 : 0;
+}
+
+void LibAmcodec::setStreamType(stream_type_t type)
+{
+	m_codec->stream_type = type;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.h
new file mode 100644
index 0000000000..d7d36411a1
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/LibAmcodec.h
@@ -0,0 +1,99 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+extern "C" {
+	#include <amcodec/codec.h>
+}
+
+#include "namespace.h"
+
+typedef enum {
+	VIDEO_MODE_3D_MVC_FP = 1,
+	VIDEO_MODE_3D_MVC_SBS = 2,
+	VIDEO_MODE_3D_MVC_HTAB = 3,
+	VIDEO_MODE_3D_MVC_MONO = 4
+} video_mode_3d_t;
+
+typedef enum {
+	VIDEO_INPUT_MODE_2D = 1,
+	VIDEO_INPUT_MODE_HSBS = 2,
+	VIDEO_INPUT_MODE_HTAB = 3,
+	VIDEO_INPUT_MODE_FSBS = 4,
+	VIDEO_INPUT_MODE_FTAB = 5,
+	VIDEO_INPUT_MODE_MVC = 6
+} video_input_mode;
+
+typedef enum {
+	VIDEO_OUTPUT_MODE_2D = 1,
+	VIDEO_OUTPUT_MODE_HSBS = 2,
+	VIDEO_OUTPUT_MODE_HTAB = 3,
+	VIDEO_OUTPUT_MODE_FP = 4
+} video_output_mode;
+
+typedef struct {
+	bool noblock;
+	int video_pid;
+	int video_type;
+	enum FRAME_BASE_VIDEO_PATH video_path;
+	stream_type_t stream_type;
+	decoder_type_t decoder_type;
+	display_mode_type_t display_mode;
+	unsigned int format;
+	unsigned int width;
+	unsigned int height;
+	unsigned int rate;
+	unsigned int extra;
+	unsigned int status;
+	unsigned int ratio;
+	unsigned long long ratio64;
+	void *param;
+	int config_len;
+	char *config;
+} aml_generic_param;
+
+class amlogic::LibAmcodec
+{
+private:
+	DllLibAmCodec	*m_dll;
+	codec_para_t	*m_codec;
+
+public:
+	LibAmcodec();
+	virtual ~LibAmcodec();
+
+	bool inline isValid() const { return m_dll != nullptr; }
+
+	int init(const aml_generic_param &gparam);
+	int close();
+
+	int pause();
+	int reset();
+	int write(unsigned char *buf, unsigned int size);
+	int poll(unsigned int timeoutMs);
+
+	int getVbufState(struct buf_status &bs) const;
+	int getVdecState(struct vdec_status &vs) const;
+	bool isVCodecBuffering() const;
+
+	int checkinPts64(uint64_t pts64);
+
+	void setLogCallback(void (*logf)(const char *, ...));
+	int setControlMode(unsigned int mode);
+	int setControlAvThreshold(unsigned int threshold);
+	int setControlSyncThreshold(unsigned int threshold);
+	int setVideoDelayLimitedMs(int delay);
+	int set3dVideoMode(video_mode_3d_t mode);
+	int setVideoMode(video_input_mode vimode, video_output_mode vomode, bool leftEyeFirst);
+	int setHdr10pMetadata(unsigned char *metadata, int metadata_length);
+	void setNoBlockMode(bool noblock);
+	void setStreamType(stream_type_t type);
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.cpp
new file mode 100644
index 0000000000..df27646ab0
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.cpp
@@ -0,0 +1,127 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MJPEGCodec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/log.h"
+
+using namespace amlogic;
+
+class MJPEGCodecInfo : public AMLVideoCodecInfo
+{
+public:
+	MJPEGCodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "MJPEG"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_MJPEG) {
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new MJPEGCodec(processInfo);
+	}
+
+} mjpegCodecInfo;
+
+
+MJPEGCodec::MJPEGCodec(CProcessInfo &processInfo)
+	: AMLInsecureVideoCodec(processInfo)
+{
+}
+
+MJPEGCodec::~MJPEGCodec()
+{
+}
+
+std::string MJPEGCodec::getFormatName() const
+{
+	return "am-mjpeg";
+}
+
+vformat_t MJPEGCodec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_MJPEG;
+}
+
+vdec_type_t MJPEGCodec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	switch (hints.codec_tag) {
+		case CODEC_TAG_MJPEG:
+		case CODEC_TAG_mjpeg:
+		case CODEC_TAG_jpeg:
+		case CODEC_TAG_mjpa:
+			return VIDEO_DEC_FORMAT_MJPEG;
+
+		default:
+			return VIDEO_DEC_FORMAT_UNKNOW;
+	}
+}
+
+static int mjpeg_data_prefeeding(am_packet_t *pkt)
+{
+	static const unsigned char mjpeg_addon_data[] = {
+		0xff, 0xd8, 0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,
+		0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
+		0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01, 0x00, 0x03, 0x01,
+		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10,
+		0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00,
+		0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31,
+		0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1,
+		0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72,
+		0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
+		0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47,
+		0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64,
+		0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+		0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95,
+		0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9,
+		0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4,
+		0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
+		0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1,
+		0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0x11, 0x00, 0x02, 0x01,
+		0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,
+		0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51,
+		0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1,
+		0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24,
+		0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a,
+		0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+		0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
+		0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82,
+		0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
+		0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
+		0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
+		0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9,
+		0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4,
+		0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa
+	};
+
+	memcpy(pkt->hdr->data, &mjpeg_addon_data, sizeof(mjpeg_addon_data));
+	pkt->hdr->size = sizeof(mjpeg_addon_data);
+
+	return PLAYER_SUCCESS;
+}
+
+int MJPEGCodec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	mjpeg_data_prefeeding(pkt);
+
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.h
new file mode 100644
index 0000000000..6e7c0cb1fc
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MJPEGCodec.h
@@ -0,0 +1,27 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+class amlogic::MJPEGCodec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+
+public:
+	MJPEGCodec(CProcessInfo &processInfo);
+	virtual ~MJPEGCodec();
+
+	virtual std::string getFormatName() const;
+
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.cpp
new file mode 100644
index 0000000000..75a6d7e81a
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.cpp
@@ -0,0 +1,138 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MPEG12Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/BitstreamConverter.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
+#include "settings/SettingsComponent.h"
+
+using namespace amlogic;
+
+class MPEG12CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	MPEG12CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "MPEG-1/MPEG-2"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_MPEG1VIDEO && hints.codec != AV_CODEC_ID_MPEG2VIDEO) {
+			return false;
+		}
+
+		if (hints.width <= CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_USEAMCODECMPEG2)) {
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new MPEG12Codec(processInfo, hints);
+	}
+
+} mpeg12CodecInfo;
+
+
+MPEG12Codec::MPEG12Codec(CProcessInfo &processInfo, const CDVDStreamInfo &hints)
+	: AMLInsecureVideoCodec(processInfo), m_mpeg2_sequence_pts(0), m_aspect_ratio(hints.aspect),
+	  m_framerate(0.0)
+{
+	m_mpeg2_sequence = new mpeg2_sequence;
+	m_mpeg2_sequence->width = hints.width;
+	m_mpeg2_sequence->height = hints.height;
+	m_mpeg2_sequence->ratio = hints.aspect;
+	m_mpeg2_sequence->fps_rate = hints.fpsrate;
+	m_mpeg2_sequence->fps_scale = hints.fpsscale;
+}
+
+MPEG12Codec::~MPEG12Codec()
+{
+	if (m_mpeg2_sequence) {
+		delete m_mpeg2_sequence, m_mpeg2_sequence = nullptr;
+	}
+}
+
+std::string MPEG12Codec::getFormatName() const
+{
+	return "am-mpeg2";
+}
+
+vformat_t MPEG12Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_MPEG12;
+}
+
+vdec_type_t MPEG12Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	return VIDEO_DEC_FORMAT_UNKNOW;
+}
+
+void MPEG12Codec::reset()
+{
+	AMLInsecureVideoCodec::reset();
+
+	m_mpeg2_sequence_pts = 0;
+}
+
+double MPEG12Codec::getAspectRatio() const
+{
+	return m_aspect_ratio;
+}
+
+CDVDVideoCodec::VCReturn MPEG12Codec::getPicture(VideoPicture *pVideoPicture)
+{
+	CDVDVideoCodec::VCReturn ret = AMLInsecureVideoCodec::getPicture(pVideoPicture);
+
+	// check for mpeg2 aspect ratio changes
+	if (pVideoPicture->pts >= m_mpeg2_sequence_pts) {
+		m_aspect_ratio = m_mpeg2_sequence->ratio;
+	}
+
+	return ret;
+}
+
+bool MPEG12Codec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	// probe demux for sequence_header_code NAL and
+	// decode aspect ratio and frame rate.
+	if (CBitstreamConverter::mpeg2_sequence_header(data, size, m_mpeg2_sequence) && (m_mpeg2_sequence->fps_rate > 0) && (m_mpeg2_sequence->fps_scale > 0)) {
+		m_mpeg2_sequence_pts = pts;
+		if (m_mpeg2_sequence_pts == DVD_NOPTS_VALUE) {
+			m_mpeg2_sequence_pts = dts;
+		}
+
+		hints.fpsrate = m_mpeg2_sequence->fps_rate;
+		hints.fpsscale = m_mpeg2_sequence->fps_scale;
+
+		m_framerate = static_cast<float>(m_mpeg2_sequence->fps_rate) / m_mpeg2_sequence->fps_scale;
+
+		hints.width = m_mpeg2_sequence->width;
+		hints.height = m_mpeg2_sequence->height;
+		hints.aspect = m_mpeg2_sequence->ratio;
+
+		m_processInfo.SetVideoFps(m_framerate);
+		m_processInfo.SetVideoDAR(hints.aspect);
+	}
+
+	return true;
+}
+
+void MPEG12Codec::getExtradata(const CDVDStreamInfo &hints, uint8_t *&extradata, unsigned int &extrasize) const
+{
+	extradata = nullptr;
+	extrasize = 0;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.h
new file mode 100644
index 0000000000..b7408f0d4e
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG12Codec.h
@@ -0,0 +1,41 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+typedef struct mpeg2_sequence mpeg2_sequence;
+
+class amlogic::MPEG12Codec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	mpeg2_sequence	*m_mpeg2_sequence;
+	double			 m_mpeg2_sequence_pts;
+	double			 m_aspect_ratio;
+	double			 m_framerate;
+
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual void getExtradata(const CDVDStreamInfo &hints, uint8_t *&extradata, unsigned int &extrasize) const;
+
+public:
+	MPEG12Codec(CProcessInfo &processInfo, const CDVDStreamInfo &hints);
+	virtual ~MPEG12Codec();
+
+	virtual std::string getFormatName() const;
+	virtual double getAspectRatio() const;
+	virtual CDVDVideoCodec::VCReturn getPicture(VideoPicture *pVideoPicture);
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+
+	virtual void reset();
+
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.cpp
new file mode 100644
index 0000000000..ede8092933
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.cpp
@@ -0,0 +1,211 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "MPEG4Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/log.h"
+#include "settings/Settings.h"
+#include "ServiceBroker.h"
+#include "settings/SettingsComponent.h"
+
+#define DIVX311_CHUNK_HEAD_SIZE 13
+
+
+using namespace amlogic;
+
+class MPEG4CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	MPEG4CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "MPEG-4"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_MPEG4 && hints.codec != AV_CODEC_ID_MSMPEG4V2 && hints.codec != AV_CODEC_ID_MSMPEG4V3) {
+			return false;
+		}
+
+		if (hints.width <= CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_USEAMCODECMPEG4)) {
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new MPEG4Codec(processInfo);
+	}
+
+} mpeg4CodecInfo;
+
+
+MPEG4Codec::MPEG4Codec(CProcessInfo &processInfo)
+	: AMLInsecureVideoCodec(processInfo)
+{
+}
+
+MPEG4Codec::~MPEG4Codec()
+{
+}
+
+std::string MPEG4Codec::getFormatName() const
+{
+	return "am-mpeg4";
+}
+
+vformat_t MPEG4Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_MPEG4;
+}
+
+vdec_type_t MPEG4Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	switch (hints.codec_tag) {
+		case CODEC_TAG_XVID:
+		case CODEC_TAG_xvid:
+		case CODEC_TAG_XVIX:
+			// xvid
+			return VIDEO_DEC_FORMAT_MPEG4_5;
+
+		case CODEC_TAG_COL1:
+		case CODEC_TAG_DIV3:
+		case CODEC_TAG_MP43:
+			// divx3.11
+			return VIDEO_DEC_FORMAT_MPEG4_3;
+
+		case CODEC_TAG_DIV4:
+		case CODEC_TAG_DIVX:
+			// divx4
+			return VIDEO_DEC_FORMAT_MPEG4_4;
+
+		case CODEC_TAG_DIV5:
+		case CODEC_TAG_DX50:
+		case CODEC_TAG_M4S2:
+		case CODEC_TAG_FMP4:
+			// divx5
+			return VIDEO_DEC_FORMAT_MPEG4_5;
+
+		case CODEC_TAG_DIV6:
+			// divx6
+			return VIDEO_DEC_FORMAT_MPEG4_5;
+
+		case CODEC_TAG_MP4V:
+		case CODEC_TAG_RMP4:
+		case CODEC_TAG_MPG4:
+		case CODEC_TAG_mp4v:
+			// mp4
+			return VIDEO_DEC_FORMAT_MPEG4_5;
+
+		default:
+			return VIDEO_DEC_FORMAT_MPEG4_5;
+	}
+}
+
+static int divx3_write_header(am_private_t *para, am_packet_t *pkt)
+{
+	CLog::Log(LOGDEBUG, "divx3_write_header");
+
+	unsigned i = (para->video_width << 12) | (para->video_height & 0xfff);
+	unsigned char divx311_add[10] = {
+		0x00, 0x00, 0x00, 0x01,
+		0x20, 0x00, 0x00, 0x00,
+		0x00, 0x00
+	};
+
+	divx311_add[5] = (i >> 16) & 0xff;
+	divx311_add[6] = (i >> 8) & 0xff;
+	divx311_add[7] = i & 0xff;
+
+	memcpy(pkt->hdr->data, divx311_add, sizeof(divx311_add));
+	pkt->hdr->size = sizeof(divx311_add);
+
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "m4s2_dx50_mp4v_write_header");
+
+	pkt->hdr->alloc(para->extrasize);
+	if (!pkt->hdr->data) {
+		CLog::Log(LOGDEBUG, "[m4s2_dx50_mp4v_write_header] NOMEM!");
+		return PLAYER_NOMEM;
+	}
+
+	pkt->hdr->size = para->extrasize;
+	memcpy(pkt->hdr->data, para->extradata, para->extrasize);
+
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
+
+int MPEG4Codec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	int ret = PLAYER_SUCCESS;
+
+	if (para->video_codec_type == VIDEO_DEC_FORMAT_MPEG4_3) {
+		ret = divx3_write_header(para, pkt);
+	} else if (para->video_codec_tag == CODEC_TAG_M4S2 || para->video_codec_tag == CODEC_TAG_DX50 || para->video_codec_tag == CODEC_TAG_mp4v) {
+		ret = m4s2_dx50_mp4v_write_header(para, pkt);
+	}
+
+	return ret;
+}
+
+static int divx3_prefix(am_packet_t *pkt)
+{
+	const unsigned char divx311_chunk_prefix[DIVX311_CHUNK_HEAD_SIZE] = {
+		0x00, 0x00, 0x00, 0x01, 0xb6, 'D', 'I', 'V', 'X', '3', '.', '1', '1'
+	};
+
+	pkt->hdr->alloc(DIVX311_CHUNK_HEAD_SIZE + 4);
+	if (!pkt->hdr->data) {
+		CLog::Log(LOGDEBUG, "[divx3_prefix] NOMEM!");
+		return PLAYER_NOMEM;
+	}
+
+	memcpy(pkt->hdr->data, divx311_chunk_prefix, DIVX311_CHUNK_HEAD_SIZE);
+
+	pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 0] = (pkt->data_size >> 24) & 0xff;
+	pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 1] = (pkt->data_size >> 16) & 0xff;
+	pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 2] = (pkt->data_size >> 8) & 0xff;
+	pkt->hdr->data[DIVX311_CHUNK_HEAD_SIZE + 3] = pkt->data_size & 0xff;
+
+	pkt->hdr->size = DIVX311_CHUNK_HEAD_SIZE + 4;
+	pkt->newflag = 1;
+
+	return PLAYER_SUCCESS;
+}
+
+int MPEG4Codec::set_header_info(am_private_t *para) const
+{
+	if (para->video_codec_type == VIDEO_DEC_FORMAT_MPEG4_3) {
+		return divx3_prefix(&para->am_pkt);
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+void MPEG4Codec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	params.param = (void*) EXTERNAL_PTS;
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) (EXTERNAL_PTS | KEYFRAME_PTS_ONLY);
+	}
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.h
new file mode 100644
index 0000000000..26ddcd801f
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/MPEG4Codec.h
@@ -0,0 +1,29 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+class amlogic::MPEG4Codec : public amlogic::AMLInsecureVideoCodec
+{
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+	virtual int set_header_info(am_private_t *para) const;
+
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+public:
+	MPEG4Codec(CProcessInfo &processInfo);
+	virtual ~MPEG4Codec();
+
+	virtual std::string getFormatName() const;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/PosixFile.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/PosixFile.h
new file mode 100644
index 0000000000..b590b4d18e
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/PosixFile.h
@@ -0,0 +1,48 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#include <string>
+
+#include "namespace.h"
+
+class amlogic::PosixFile
+{
+private:
+	int m_fd;
+
+public:
+	PosixFile() : m_fd(-1) {}
+
+	PosixFile(int fd) : m_fd(fd) {}
+
+	~PosixFile() {
+		if (m_fd >= 0) {
+			close(m_fd);
+		}
+	}
+
+	bool Open(const std::string &pathName, int flags) {
+		m_fd = open(pathName.c_str(), flags);
+		return m_fd >= 0;
+	}
+
+	int GetDescriptor() const {
+		return m_fd;
+	}
+
+	int IOControl(unsigned long request, void *param) {
+		return ioctl(m_fd, request, param);
+	}
+};
+
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.cpp
new file mode 100644
index 0000000000..80c3321ff5
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.cpp
@@ -0,0 +1,371 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+
+#include "VC1Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+
+using namespace amlogic;
+
+class VC1CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	VC1CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "VC-1"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		return hints.codec == AV_CODEC_ID_VC1 || hints.codec == AV_CODEC_ID_WMV3;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new VC1Codec(processInfo, hints.codec == AV_CODEC_ID_VC1 ? "am-vc1" : "am-wmv3");
+	}
+
+} vc1CodecInfo;
+
+VC1Codec::VC1Codec(CProcessInfo &processInfo, std::string formatName)
+	: AMLInsecureVideoCodec(processInfo), m_formatName(formatName)
+{
+}
+
+VC1Codec::~VC1Codec()
+{
+}
+
+std::string VC1Codec::getFormatName() const
+{
+	return m_formatName;
+}
+
+vformat_t VC1Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_VC1;
+}
+
+vdec_type_t VC1Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	switch (hints.codec_tag) {
+		case CODEC_TAG_WMV3:
+			// wmv3
+			return VIDEO_DEC_FORMAT_WMV3;
+
+		case CODEC_TAG_VC_1:
+		case CODEC_TAG_WVC1:
+		case CODEC_TAG_WMVA:
+			// vc1
+			return VIDEO_DEC_FORMAT_WVC1;
+
+		default:
+			return VIDEO_DEC_FORMAT_WVC1;
+	}
+}
+
+void VC1Codec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) KEYFRAME_PTS_ONLY;
+	}
+}
+
+bool VC1Codec::prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts)
+{
+	char fcm;
+	std::string FCM;
+	bool interlaced = true;
+	unsigned int i;
+	int progressive, frameinterlace, hdr_start = 0;
+
+	if ( !((data) && (size >= 4)
+		&& (data[0] == 0) && (data[1] == 0)
+		&& (data[2] == 1) && (data[3] == 0xd || data[3] == 0xf)))
+	{
+		CLog::Log(LOGDEBUG, "VC1Codec::prepareFrame No start code at start of packet");
+		// nothing to do here
+		return true;
+	}
+
+	if (data[3] == 0xf && size > 9) {
+		interlaced = data[9] & 0x40;
+		// sequence start - look for the first frame
+		for (i=4; i < size - 5; i++)
+		{
+			if ((data[i] << 24 | data[i+1] << 16 | data[i+2] << 8 | data[i+3]) == 0x0000010d)
+			{
+				hdr_start = i + 4;
+				break;
+			}
+		}
+		if (hdr_start == 0)
+			return true;
+	}
+	else if (data[3] == 0xd  && size > 4)
+		hdr_start = 4;
+
+	fcm = 0;
+	if (interlaced)
+		fcm = data[hdr_start] >> 6;
+	if (fcm < 0x2)
+		fcm = 0;
+
+	if (fcm == 0)
+		FCM = "Progressive";
+	else if (fcm == 0x2)
+		FCM = "Frame interlace";
+	else
+		FCM = "Field interlace";
+
+	if (hdr_start > 4)
+	{
+		if ( SysfsUtils::GetInt("/sys/module/amvdec_vc1/parameters/force_frameint", frameinterlace))
+			return true;
+		if (m_processInfo.GetVideoSettings().m_InterlaceMethod == VS_INTERLACEMETHOD_DEINTERLACE)
+		{
+			progressive = 0;
+			FCM = "Field interlace";
+		}
+		else if (m_processInfo.GetVideoSettings().m_InterlaceMethod == VS_INTERLACEMETHOD_NONE)
+		{
+			progressive = 1;
+			FCM = "Frame interlace/progressive";
+		}
+		else
+			progressive = fcm < 3 ? 1 : 0;
+
+		if (frameinterlace != progressive)
+		{
+			SysfsUtils::SetInt("/sys/module/amvdec_vc1/parameters/force_frameint", progressive);
+			CLog::Log(LOGDEBUG, "VC1Codec::prepareFrame deinterlace changed to {}", FCM);
+		}
+	}
+
+	return true;
+}
+
+void VC1Codec::getDeinterlacingMethods(std::list<EINTERLACEMETHOD> &methods) const
+{
+	/* add deinterlace options */
+	methods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_NONE);
+	methods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+	methods.push_back(EINTERLACEMETHOD::VS_INTERLACEMETHOD_AUTO);
+	m_processInfo.SetDeinterlacingMethodDefault(EINTERLACEMETHOD::VS_INTERLACEMETHOD_DEINTERLACE);
+}
+
+int VC1Codec::write_header(am_private_t *para, am_packet_t *pkt) const
+{
+	if (pkt->hdr->isEmpty()) {
+		return PLAYER_SUCCESS;
+	}
+
+	if (para->video_format == VFORMAT_VC1 && para->video_codec_type == VIDEO_DEC_FORMAT_WVC1) {
+		if ((pkt->data) && (pkt->data_size >= 4)
+			&& (pkt->data[0] == 0) && (pkt->data[1] == 0)
+			&& (pkt->data[2] == 1) && (pkt->data[3] == 0xd || pkt->data[3] == 0xf)) {
+			return PLAYER_SUCCESS;
+		}
+	}
+
+	return AMLInsecureVideoCodec::write_header(para, pkt);
+}
+
+int VC1Codec::set_header_info(am_private_t *para) const
+{
+	am_packet_t *pkt = &para->am_pkt;
+
+	pkt->hdr->free();
+
+	if (para->video_codec_type == VIDEO_DEC_FORMAT_WMV3) {
+		unsigned i, check_sum = 0, data_len = 0;
+
+		if (pkt->avpkt.flags) {
+			pkt->hdr->alloc(para->extrasize + 26 + 22);
+			if (pkt->hdr->data == nullptr) {
+				return PLAYER_FAILED;
+			}
+
+			pkt->hdr->data[0] = 0;
+			pkt->hdr->data[1] = 0;
+			pkt->hdr->data[2] = 1;
+			pkt->hdr->data[3] = 0x10;
+
+			data_len = para->extrasize + 4;
+			pkt->hdr->data[4] = 0;
+			pkt->hdr->data[5] = (data_len >> 16) & 0xff;
+			pkt->hdr->data[6] = 0x88;
+			pkt->hdr->data[7] = (data_len >> 8) & 0xff;
+			pkt->hdr->data[8] = data_len & 0xff;
+			pkt->hdr->data[9] = 0x88;
+
+			pkt->hdr->data[10] = 0xff;
+			pkt->hdr->data[11] = 0xff;
+			pkt->hdr->data[12] = 0x88;
+			pkt->hdr->data[13] = 0xff;
+			pkt->hdr->data[14] = 0xff;
+			pkt->hdr->data[15] = 0x88;
+
+			for (i = 4; i < 16; i++) {
+				check_sum += pkt->hdr->data[i];
+			}
+
+			pkt->hdr->data[16] = (check_sum >> 8) & 0xff;
+			pkt->hdr->data[17] = check_sum & 0xff;
+			pkt->hdr->data[18] = 0x88;
+			pkt->hdr->data[19] = (check_sum >> 8) & 0xff;
+			pkt->hdr->data[20] = check_sum & 0xff;
+			pkt->hdr->data[21] = 0x88;
+
+			pkt->hdr->data[22] = (para->video_width >> 8) & 0xff;
+			pkt->hdr->data[23] = para->video_width & 0xff;
+			pkt->hdr->data[24] = (para->video_height >> 8) & 0xff;
+			pkt->hdr->data[25] = para->video_height & 0xff;
+
+			memcpy(pkt->hdr->data + 26, para->extradata, para->extrasize);
+
+			check_sum = 0;
+			data_len = para->extrasize + 26;
+		} else {
+			pkt->hdr->alloc(22);
+			if (pkt->hdr->data == nullptr) {
+				return PLAYER_FAILED;
+			}
+		}
+
+		pkt->hdr->data[data_len + 0] = 0;
+		pkt->hdr->data[data_len + 1] = 0;
+		pkt->hdr->data[data_len + 2] = 1;
+		pkt->hdr->data[data_len + 3] = 0xd;
+
+		pkt->hdr->data[data_len + 4] = 0;
+		pkt->hdr->data[data_len + 5] = (pkt->data_size >> 16) & 0xff;
+		pkt->hdr->data[data_len + 6] = 0x88;
+		pkt->hdr->data[data_len + 7] = (pkt->data_size >> 8) & 0xff;
+		pkt->hdr->data[data_len + 8] = pkt->data_size & 0xff;
+		pkt->hdr->data[data_len + 9] = 0x88;
+
+		pkt->hdr->data[data_len + 10] = 0xff;
+		pkt->hdr->data[data_len + 11] = 0xff;
+		pkt->hdr->data[data_len + 12] = 0x88;
+		pkt->hdr->data[data_len + 13] = 0xff;
+		pkt->hdr->data[data_len + 14] = 0xff;
+		pkt->hdr->data[data_len + 15] = 0x88;
+
+		for (i = data_len + 4; i < data_len + 16; i++) {
+			check_sum += pkt->hdr->data[i];
+		}
+
+		pkt->hdr->data[data_len + 16] = (check_sum >> 8) & 0xff;
+		pkt->hdr->data[data_len + 17] = check_sum & 0xff;
+		pkt->hdr->data[data_len + 18] = 0x88;
+		pkt->hdr->data[data_len + 19] = (check_sum >> 8) & 0xff;
+		pkt->hdr->data[data_len + 20] = check_sum & 0xff;
+		pkt->hdr->data[data_len + 21] = 0x88;
+
+		pkt->hdr->size = data_len + 22;
+		pkt->newflag = 1;
+	} else if (para->video_codec_type == VIDEO_DEC_FORMAT_WVC1) {
+		pkt->hdr->alloc(4);
+		if (pkt->hdr->data == nullptr) {
+			CLog::Log(LOGDEBUG, "[wvc1_prefix] NOMEM!");
+			return PLAYER_FAILED;
+		}
+
+		pkt->hdr->data[0] = 0;
+		pkt->hdr->data[1] = 0;
+		pkt->hdr->data[2] = 1;
+		pkt->hdr->data[3] = 0xd;
+		pkt->hdr->size = 4;
+		pkt->newflag = 1;
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+void VC1Codec::wmv3_set_header(am_private_t *para, am_packet_t *pkt) const
+{
+	CLog::Log(LOGDEBUG, "wmv3_write_header");
+
+	unsigned i, check_sum = 0;
+	unsigned data_len = para->extrasize + 4;
+
+	pkt->hdr->data[0] = 0;
+	pkt->hdr->data[1] = 0;
+	pkt->hdr->data[2] = 1;
+	pkt->hdr->data[3] = 0x10;
+
+	pkt->hdr->data[4] = 0;
+	pkt->hdr->data[5] = (data_len >> 16) & 0xff;
+	pkt->hdr->data[6] = 0x88;
+	pkt->hdr->data[7] = (data_len >> 8) & 0xff;
+	pkt->hdr->data[8] = data_len & 0xff;
+	pkt->hdr->data[9] = 0x88;
+
+	pkt->hdr->data[10] = 0xff;
+	pkt->hdr->data[11] = 0xff;
+	pkt->hdr->data[12] = 0x88;
+	pkt->hdr->data[13] = 0xff;
+	pkt->hdr->data[14] = 0xff;
+	pkt->hdr->data[15] = 0x88;
+
+	for (i = 4; i < 16; i++) {
+		check_sum += pkt->hdr->data[i];
+	}
+
+	pkt->hdr->data[16] = (check_sum >> 8) & 0xff;
+	pkt->hdr->data[17] = check_sum & 0xff;
+	pkt->hdr->data[18] = 0x88;
+	pkt->hdr->data[19] = (check_sum >> 8) & 0xff;
+	pkt->hdr->data[20] = check_sum & 0xff;
+	pkt->hdr->data[21] = 0x88;
+
+	pkt->hdr->data[22] = (para->video_width >> 8) & 0xff;
+	pkt->hdr->data[23] = para->video_width & 0xff;
+	pkt->hdr->data[24] = (para->video_height >> 8) & 0xff;
+	pkt->hdr->data[25] = para->video_height & 0xff;
+
+	memcpy(pkt->hdr->data + 26, para->extradata, para->extrasize);
+	pkt->hdr->size = para->extrasize + 26;
+	pkt->newflag = 1;
+}
+
+void VC1Codec::wvc1_set_header(am_private_t *para, am_packet_t *pkt) const
+{
+    CLog::Log(LOGDEBUG, "wvc1_write_header");
+
+    memcpy(pkt->hdr->data, para->extradata + 1, para->extrasize - 1);
+    pkt->hdr->size = para->extrasize - 1;
+    pkt->newflag = 1;
+}
+
+int VC1Codec::pre_header_feeding(am_private_t *para, am_packet_t *pkt) const
+{
+	if (para->video_codec_tag == CODEC_TAG_WMV3) {
+		CLog::Log(LOGDEBUG, "CODEC_TAG_WMV3 == para->video_codec_tag");
+		wmv3_set_header(para, pkt);
+	} else if ((CODEC_TAG_WVC1 == para->video_codec_tag) || (CODEC_TAG_VC_1 == para->video_codec_tag) || (CODEC_TAG_WMVA == para->video_codec_tag)) {
+		if (para->extrasize > 4 && !*para->extradata && !*(para->extradata + 1) && *(para->extradata + 2) == 0x01 && *(para->extradata + 3) == 0x0f
+			&& ((*(para->extradata + 4) & 0x03) == 0x03)) {
+			CLog::Log(LOGDEBUG, "CODEC_TAG_WVC1 == para->video_codec_tag, using wmv3_write_header");
+			wmv3_set_header(para, pkt);
+		} else {
+			CLog::Log(LOGDEBUG, "CODEC_TAG_WVC1 == para->video_codec_tag");
+			wvc1_set_header(para, pkt);
+		}
+	}
+
+	return PLAYER_SUCCESS;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.h
new file mode 100644
index 0000000000..19a19e3fd5
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VC1Codec.h
@@ -0,0 +1,42 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+#include <string>
+
+class amlogic::VC1Codec : public amlogic::AMLInsecureVideoCodec
+{
+private:
+	std::string	m_formatName;
+
+	void wmv3_set_header(am_private_t *para, am_packet_t *pkt) const;
+	void wvc1_set_header(am_private_t *para, am_packet_t *pkt) const;
+
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual void getDeinterlacingMethods(std::list<EINTERLACEMETHOD> &methods) const;
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+	virtual int pre_header_feeding(am_private_t *para, am_packet_t *pkt) const;
+	virtual int set_header_info(am_private_t *para) const;
+	virtual int write_header(am_private_t *para, am_packet_t *pkt) const;
+
+public:
+	VC1Codec(CProcessInfo &processInfo, std::string formatName);
+	virtual ~VC1Codec();
+
+	virtual std::string getFormatName() const;
+
+	virtual bool prepareFrame(CDVDStreamInfo &hints, uint8_t *&data, size_t &size, double dts, double pts);
+
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.cpp
new file mode 100644
index 0000000000..60b9c6cb89
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.cpp
@@ -0,0 +1,222 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VP9Codec.h"
+
+#include "AMLCodecList.h"
+#include "AMLVideoCodecInfo.h"
+#include "AMLVideoCodecConstants.h"
+
+#include "utils/AMLUtils.h"
+#include "utils/log.h"
+
+using namespace amlogic;
+
+class VP9CodecInfo : public AMLVideoCodecInfo
+{
+public:
+	VP9CodecInfo() {
+		AMLCodecList::getInstance().registerAmlVideoCodec(this);
+	}
+
+	std::string getCodecName() const { return "VP9"; }
+	bool isSecure() const { return false; }
+	bool canPlay(const CDVDStreamInfo &hints) const {
+		if (hints.codec != AV_CODEC_ID_VP9) {
+			return false;
+		}
+
+		if (!aml_support_vp9()) {
+			return false;
+		}
+
+		return true;
+	}
+
+	AMLVideoCodec *createCodec(CProcessInfo &processInfo, const CDVDStreamInfo &hints) {
+		return new VP9Codec(processInfo);
+	}
+
+} vp9CodecInfo;
+
+
+VP9Codec::VP9Codec(CProcessInfo &processInfo)
+	: AMLInsecureVideoCodec(processInfo)
+{
+}
+
+VP9Codec::~VP9Codec()
+{
+}
+
+std::string VP9Codec::getFormatName() const
+{
+	return "am-vp9";
+}
+
+vformat_t VP9Codec::getVideoFormat(const CDVDStreamInfo &hints) const
+{
+	return VFORMAT_VP9;
+}
+
+vdec_type_t VP9Codec::getVideoCodecType(const CDVDStreamInfo &hints) const
+{
+	return VIDEO_DEC_FORMAT_VP9;
+}
+
+int VP9Codec::set_header_info(am_private_t *para) const
+{
+	am_packet_t *pkt = &para->am_pkt;
+	int dsize = pkt->data_size;
+	unsigned char *buf = pkt->data;
+	unsigned char marker;
+	int frame_number;
+	int cur_frame, cur_mag, mag, index_sz, offset[9], size[8], tframesize[9];
+	int mag_ptr;
+	int ret;
+	unsigned char *old_header = NULL;
+	int total_datasize = 0;
+
+	pkt->avpkt.data = pkt->data;
+	pkt->avpkt.size = pkt->data_size;
+
+	if (buf == NULL) {
+		return PLAYER_SUCCESS; /*something error. skip add header*/
+	}
+
+	marker = buf[dsize - 1];
+
+	if ((marker & 0xe0) == 0xc0) {
+		frame_number = (marker & 0x7) + 1;
+		mag = ((marker >> 3) & 0x3) + 1;
+		index_sz = 2 + mag * frame_number;
+		CLog::Log(LOGDEBUG, " frame_number : {}, mag : {}; index_sz : {}\n", frame_number, mag, index_sz);
+
+		offset[0] = 0;
+		mag_ptr = dsize - mag * frame_number - 2;
+		if (buf[mag_ptr] != marker) {
+			CLog::Log(LOGDEBUG, " Wrong marker2 : 0x{:X} --> 0x{:X}\n", marker, buf[mag_ptr]);
+			return PLAYER_SUCCESS;
+		}
+
+		mag_ptr++;
+
+		for (cur_frame = 0; cur_frame < frame_number; cur_frame++) {
+			size[cur_frame] = 0; // or size[0] = bytes_in_buffer - 1; both OK
+
+			for (cur_mag = 0; cur_mag < mag; cur_mag++) {
+				size[cur_frame] = size[cur_frame] | (buf[mag_ptr] << (cur_mag * 8));
+				mag_ptr++;
+			}
+
+			offset[cur_frame + 1] = offset[cur_frame] + size[cur_frame];
+
+			if (cur_frame == 0) {
+				tframesize[cur_frame] = size[cur_frame];
+			} else {
+				tframesize[cur_frame] = tframesize[cur_frame - 1] + size[cur_frame];
+			}
+
+			total_datasize += size[cur_frame];
+		}
+	} else {
+		frame_number = 1;
+		offset[0] = 0;
+		size[0] = dsize; // or size[0] = bytes_in_buffer - 1; both OK
+		total_datasize += dsize;
+		tframesize[0] = dsize;
+	}
+
+	if (total_datasize > dsize) {
+		CLog::Log(LOGDEBUG, "DATA overflow : 0x{:X} --> 0x{:X}\n", total_datasize, dsize);
+		return PLAYER_SUCCESS;
+	}
+
+	if (frame_number >= 1) {
+		/*
+		 * if only one frame, can used headers.
+		 */
+		int need_more = total_datasize + frame_number * 16 - dsize;
+
+		av_buffer_unref(&pkt->avpkt.buf);
+		ret = av_grow_packet(&(pkt->avpkt), need_more);
+		if (ret < 0) {
+			CLog::Log(LOGDEBUG, "ERROR!!! grow_packet for apk failed.!!!\n");
+			return ret;
+		}
+
+		pkt->data = pkt->avpkt.data;
+		pkt->data_size = pkt->avpkt.size;
+	}
+
+	for (cur_frame = frame_number - 1; cur_frame >= 0; cur_frame--) {
+		AVPacket *avpkt = &(pkt->avpkt);
+		int framesize = size[cur_frame];
+		int oldframeoff = tframesize[cur_frame] - framesize;
+		int outheaderoff = oldframeoff + cur_frame * 16;
+		uint8_t *fdata = avpkt->data + outheaderoff;
+		uint8_t *old_framedata = avpkt->data + oldframeoff;
+
+		memmove(fdata + 16, old_framedata, framesize);
+		framesize += 4;/*add 4. for shift.....*/
+
+		/*add amlogic frame headers.*/
+		fdata[0] = (framesize >> 24) & 0xff;
+		fdata[1] = (framesize >> 16) & 0xff;
+		fdata[2] = (framesize >> 8) & 0xff;
+		fdata[3] = (framesize >> 0) & 0xff;
+		fdata[4] = ((framesize >> 24) & 0xff) ^ 0xff;
+		fdata[5] = ((framesize >> 16) & 0xff) ^ 0xff;
+		fdata[6] = ((framesize >> 8) & 0xff) ^ 0xff;
+		fdata[7] = ((framesize >> 0) & 0xff) ^ 0xff;
+		fdata[8] = 0;
+		fdata[9] = 0;
+		fdata[10] = 0;
+		fdata[11] = 1;
+		fdata[12] = 'A';
+		fdata[13] = 'M';
+		fdata[14] = 'L';
+		fdata[15] = 'V';
+		framesize -= 4;/*del 4 to real framesize for check.....*/
+
+		if (!old_header) {
+			// do nothing
+		} else if (old_header > fdata + 16 + framesize) {
+			CLog::Log(LOGDEBUG, "data has gaps,set to 0\n");
+			memset(fdata + 16 + framesize, 0, (old_header - fdata + 16 + framesize));
+		} else if (old_header < fdata + 16 + framesize) {
+			CLog::Log(LOGDEBUG, "ERROR!!! data over writed!!!! over write {}\n", fdata + 16 + framesize - old_header);
+		}
+
+		old_header = fdata;
+	}
+
+	return PLAYER_SUCCESS;
+}
+
+bool VP9Codec::handleMasteringMetadata(const CDVDStreamInfo &hints) const
+{
+	if (!AMLInsecureVideoCodec::handleMasteringMetadata(hints)) {
+		return false;
+	}
+
+	enableCustomMasterDataDisplay();
+
+	return true;
+}
+
+void VP9Codec::setupVideoCodecParams(aml_generic_param &params) const
+{
+	AMLInsecureVideoCodec::setupVideoCodecParams(params);
+
+	params.decoder_type = DECODER_TYPE_FRAME_MODE;
+	params.param = (void*) EXTERNAL_PTS;
+	if (m_hints.ptsinvalid) {
+		params.param = (void*) (EXTERNAL_PTS | SYNC_OUTSIDE);
+	}
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.h
new file mode 100644
index 0000000000..a6bf4c91a7
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/VP9Codec.h
@@ -0,0 +1,29 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AMLInsecureVideoCodec.h"
+
+class amlogic::VP9Codec : public amlogic::AMLInsecureVideoCodec
+{
+protected:
+	virtual vformat_t getVideoFormat(const CDVDStreamInfo &hints) const;
+	virtual vdec_type_t getVideoCodecType(const CDVDStreamInfo &hints) const;
+
+	virtual bool handleMasteringMetadata(const CDVDStreamInfo &hints) const;
+	virtual int set_header_info(am_private_t *para) const;
+
+	virtual void setupVideoCodecParams(aml_generic_param &params) const;
+
+public:
+	VP9Codec(CProcessInfo &processInfo);
+	virtual ~VP9Codec();
+
+	virtual std::string getFormatName() const;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/namespace.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/namespace.h
new file mode 100644
index 0000000000..3fa2a24ad1
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/amlogic/namespace.h
@@ -0,0 +1,30 @@
+/*
+ *  Copyright (C) 2005-2022 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+namespace amlogic {
+	// base classes
+	class AMLCodecList;
+	class AMLInsecureVideoCodec;
+	class AMLVideoCodec;
+	class AMLVideoCodecInfo;
+	class DllLibAmCodec;
+	class LibAmcodec;
+	class PosixFile;
+
+	// insecure decoders
+	class AV1Codec;
+	class H264Codec;
+	class HEVCCodec;
+	class MJPEGCodec;
+	class MPEG12Codec;
+	class MPEG4Codec;
+	class VC1Codec;
+	class VP9Codec;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
index 48710f847c..72caa812c0 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/CMakeLists.txt
@@ -5,6 +5,8 @@ set(SOURCES DemuxMultiSource.cpp
             DVDDemuxCDDA.cpp
             DVDDemuxClient.cpp
             DVDDemuxFFmpeg.cpp
+            DemuxStreamSSIF.cpp
+            DemuxMVC.cpp
             DVDDemuxUtils.cpp
             DVDDemuxVobsub.cpp
             DVDFactoryDemuxer.cpp)
@@ -16,6 +18,8 @@ set(HEADERS DemuxMultiSource.h
             DVDDemuxCDDA.h
             DVDDemuxClient.h
             DVDDemuxFFmpeg.h
+            DemuxStreamSSIF.h
+            DemuxMVC.h
             DVDDemuxUtils.h
             DVDDemuxVobsub.h
             DVDFactoryDemuxer.h)
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
index f4f71618a4..f7289ffc40 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
@@ -187,7 +187,10 @@ public:
     : CDemuxStream()
   {
     type = STREAM_SUBTITLE;
+    m_3dSubtitlePlane = 0;
   }
+
+  int m_3dSubtitlePlane;
 };
 
 class CDemuxStreamTeletext : public CDemuxStream
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
index 2bdc3ea5a9..e33e03502a 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
@@ -696,6 +696,7 @@ bool CDVDDemuxClient::SeekTime(double timems, bool backwards, double *startpts)
 {
   if (m_IDemux)
   {
+    CLog::Log(LOGDEBUG, LOGVIDEO, "CDVDDemuxClient::SeekTime: {:.3f}", timems / 1000.0);
     m_displayTime = 0;
     m_dtsAtDisplayTime = DVD_NOPTS_VALUE;
     return m_IDemux->SeekTime(timems, backwards, startpts);
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 739bf51922..2f5461f030 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,6 +18,8 @@
 #include "cores/FFmpeg.h"
 #include "cores/MenuType.h"
 #include "cores/VideoPlayer/Interface/TimingConstants.h" // for DVD_TIME_BASE
+#include "DVDCodecs/DVDCodecUtils.h"
+#include "DemuxMVC.h"
 #include "filesystem/CurlFile.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
@@ -206,6 +208,7 @@ CDVDDemuxFFmpeg::CDVDDemuxFFmpeg() : CDVDDemux()
   m_bMatroska = false;
   m_bAVI = false;
   m_bSup = false;
+  m_pSSIF = nullptr;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_program = UINT_MAX;
   m_pkt.result = -1;
@@ -532,7 +535,7 @@ bool CDVDDemuxFFmpeg::Open(const std::shared_ptr<CDVDInputStream>& pInput, bool
       m_pFormatContext->nb_streams > 0 && m_pFormatContext->streams != nullptr &&
       m_pFormatContext->streams[0]->codecpar->codec_id != AV_CODEC_ID_HEVC)
   {
-    av_opt_set_int(m_pFormatContext, "analyzeduration", 500000, 0);
+    av_opt_set_int(m_pFormatContext, "analyzeduration", 20000000, 0);
     m_checkTransportStream = true;
     skipCreateStreams = true;
   }
@@ -671,17 +674,6 @@ bool CDVDDemuxFFmpeg::Open(const std::shared_ptr<CDVDInputStream>& pInput, bool
   m_startTime = 0;
   m_seekStream = -1;
 
-  if (m_checkTransportStream && m_streaminfo)
-  {
-    int64_t duration = m_pFormatContext->duration;
-    std::shared_ptr<CDVDInputStream> pInputStream = m_pInput;
-    Dispose();
-    m_reopen = true;
-    if (!Open(pInputStream, false))
-      return false;
-    m_pFormatContext->duration = duration;
-  }
-
   return true;
 }
 
@@ -690,6 +682,9 @@ void CDVDDemuxFFmpeg::Dispose()
   m_pkt.result = -1;
   av_packet_unref(&m_pkt.pkt);
 
+  delete m_pSSIF;
+  m_pSSIF = nullptr;
+
   if (m_pFormatContext)
   {
     if (m_ioContext && m_pFormatContext->pb && m_pFormatContext->pb != m_ioContext)
@@ -1091,6 +1086,8 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
 
         m_pkt.result = -1;
         av_packet_unref(&m_pkt.pkt);
+        if (m_pSSIF)
+          m_pSSIF->Flush();
       }
       else
       {
@@ -1116,7 +1113,8 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
 
         if (IsTransportStreamReady())
         {
-          if (m_program != UINT_MAX)
+        // libavformat is confused by the interleaved SSIF.
+        if ((!m_pSSIF || m_pSSIF->IsBluRay()) && m_program != UINT_MAX)
           {
             /* check so packet belongs to selected program */
             for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes;
@@ -1228,7 +1226,8 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
     else if (stream->type == STREAM_VIDEO)
     {
       if (static_cast<CDemuxStreamVideo*>(stream)->iWidth != m_pFormatContext->streams[pPacket->iStreamId]->codecpar->width ||
-          static_cast<CDemuxStreamVideo*>(stream)->iHeight != m_pFormatContext->streams[pPacket->iStreamId]->codecpar->height)
+          static_cast<CDemuxStreamVideo*>(stream)->iHeight != m_pFormatContext->streams[pPacket->iStreamId]->codecpar->height ||
+		  (stream->disabled && stream->ExtraSize != m_pFormatContext->streams[pPacket->iStreamId]->codecpar->extradata_size))
       {
         // content has changed
         stream = AddStream(pPacket->iStreamId);
@@ -1237,6 +1236,12 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         pPacket->recoveryPoint = m_seekToKeyFrame;
       m_seekToKeyFrame = false;
     }
+    if (stream && m_pSSIF)
+    {
+      pPacket = m_pSSIF->AddPacket(pPacket);
+      if (stream->type == STREAM_DATA && stream->codec == AV_CODEC_ID_H264_MVC && pPacket->iSize)
+        stream = GetStream(pPacket->iStreamId);
+    }
     if (!stream)
     {
       CDVDDemuxUtils::FreeDemuxPacket(pPacket);
@@ -1280,6 +1285,9 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double* startpts)
     return true;
   }
 
+  else if (m_pSSIF)
+	  m_pSSIF->Flush();
+
   if (!m_pInput->Seek(0, SEEK_POSSIBLE) &&
       !m_pInput->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
   {
@@ -1304,6 +1312,9 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double* startpts)
       m_pkt.result = -1;
       av_packet_unref(&m_pkt.pkt);
 
+      if (m_pSSIF)
+        m_pSSIF->Flush();
+
       if (timer.IsTimePast())
       {
         CLog::Log(LOGERROR, "CDVDDemuxFFmpeg::{} - Timed out waiting for video to be ready",
@@ -1361,8 +1372,8 @@ bool CDVDDemuxFFmpeg::SeekTime(double time, bool backwards, double* startpts)
   if (m_currentPts == DVD_NOPTS_VALUE)
     CLog::Log(LOGDEBUG, "{} - unknown position after seek", __FUNCTION__);
   else
-    CLog::Log(LOGDEBUG, "{} - seek ended up on time {}", __FUNCTION__,
-              (int)(m_currentPts / DVD_TIME_BASE * 1000));
+    CLog::Log(LOGDEBUG, "{} - seek ended up on time {:.3f}", __FUNCTION__,
+              (float)(m_currentPts / DVD_TIME_BASE));
 
   // in this case the start time is requested time
   if (startpts)
@@ -1592,6 +1603,17 @@ void CDVDDemuxFFmpeg::DisposeStreams()
   m_parsers.clear();
 }
 
+bool CDVDDemuxFFmpeg::isFpsNonsense(const AVRational &frameRate)
+{
+  if (frameRate.num == 0 || frameRate.den == 0)
+  {
+	return true;
+  }
+
+  const double fps = (double) frameRate.num / (double) frameRate.den;
+  return fps > 500.;
+}
+
 CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
 {
   AVStream* pStream = m_pFormatContext->streams[streamIdx];
@@ -1633,6 +1655,15 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
       }
       case AVMEDIA_TYPE_VIDEO:
       {
+        if (pStream->codecpar->codec_id == AV_CODEC_ID_H264_MVC)
+        {
+          stream = new CDemuxStream();
+          stream->type = STREAM_DATA;
+          stream->disabled = true;
+          pStream->need_parsing = AVSTREAM_PARSE_NONE;
+          pStream->codecpar->codec_type = AVMEDIA_TYPE_DATA;
+          break;
+        }
         CDemuxStreamVideoFFmpeg* st = new CDemuxStreamVideoFFmpeg(pStream);
         stream = st;
         if (strcmp(m_pFormatContext->iformat->name, "flv") == 0)
@@ -1641,11 +1672,23 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
           st->bVFR = false;
 
         // never trust pts in avi files with h264.
-        if (m_bAVI && pStream->codecpar->codec_id == AV_CODEC_ID_H264)
+        if (m_bAVI && (pStream->codecpar->codec_id == AV_CODEC_ID_H264 || pStream->codecpar->codec_id == AV_CODEC_ID_H264_MVC))
           st->bPTSInvalid = true;
 
         AVRational r_frame_rate = pStream->r_frame_rate;
 
+        if (isFpsNonsense(r_frame_rate))
+        {
+          r_frame_rate.num = 0;
+          r_frame_rate.den = 0;
+        }
+
+        if (isFpsNonsense(pStream->avg_frame_rate))
+        {
+          pStream->avg_frame_rate.num = 0;
+          pStream->avg_frame_rate.den = 0;
+        }
+
         //average fps is more accurate for mkv files
         if (m_bMatroska && pStream->avg_frame_rate.den && pStream->avg_frame_rate.num)
         {
@@ -1657,6 +1700,11 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
           st->iFpsRate = r_frame_rate.num;
           st->iFpsScale = r_frame_rate.den;
         }
+        else if(pStream->avg_frame_rate.den && pStream->avg_frame_rate.num)
+        {
+          st->iFpsRate = pStream->avg_frame_rate.num;
+          st->iFpsScale = pStream->avg_frame_rate.den;
+        }
         else
         {
           st->iFpsRate  = 0;
@@ -1679,7 +1727,16 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
         if (pStream->codecpar->height)
           st->fAspect *= (double)pStream->codecpar->width / pStream->codecpar->height;
         st->iOrientation = 0;
-        st->iBitsPerPixel = pStream->codecpar->bits_per_coded_sample;
+        st->iBitsPerPixel = pStream->codecpar->bits_per_raw_sample;
+        if (st->iBitsPerPixel == 0) {
+          if (pStream->codec->color_trc == AVCOL_TRC_BT2020_12)
+            st->iBitsPerPixel = 12;
+        else if(pStream->codec->color_trc >= AVCOL_TRC_BT2020_10)
+            /* Assume all 10-bit until 12-bit gets common */
+            st->iBitsPerPixel = 10;
+            else
+            st->iBitsPerPixel = 8;
+        }
         st->iBitRate = static_cast<int>(pStream->codecpar->bit_rate);
         st->bitDepth = 8;
         const AVPixFmtDescriptor* desc =
@@ -1740,7 +1797,63 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
         }
         if (av_dict_get(pStream->metadata, "title", NULL, 0))
           st->m_description = av_dict_get(pStream->metadata, "title", NULL, 0)->value;
+        if (pStream->codecpar->codec_id == AV_CODEC_ID_H264)
+        {
+          if (CDVDCodecUtils::IsH264AnnexB(m_pFormatContext->iformat->name, pStream))
+          {
+            int mvcIndex;
+            AVStream *mvcStream = nullptr;
+            const std::shared_ptr<CDVDInputStream::IExtentionStream> pExt = std::dynamic_pointer_cast<CDVDInputStream::IExtentionStream>(m_pInput);
+
+            if (pExt && pExt->HasExtention())
+            {
+              delete m_pSSIF;
+              m_pSSIF = new CDemuxStreamSSIF();
+              m_pSSIF->SetH264StreamId(streamIdx);
+              m_pSSIF->SetBluRay(pExt);
+
+              st->stereo_mode = pExt && pExt->AreEyesFlipped() ? "block_rl" : "block_lr";
+
+              CDemuxMVC *extDemux = static_cast<CDemuxMVC*>(pExt->GetExtentionDemux());
+              extDemux->SetStartTime(m_pFormatContext->start_time);
+              mvcStream = extDemux->GetAVStream();
+            }
+            else if (CDVDCodecUtils::GetH264MvcStreamIndex(m_pFormatContext, &mvcIndex))
+            {
+              if (!m_pSSIF)
+                m_pSSIF = new CDemuxStreamSSIF();
+              m_pSSIF->SetH264StreamId(streamIdx);
+              m_pSSIF->SetMVCStreamId(mvcIndex);
+
+              // use lr if we don't know what the stereo mode is
+              st->stereo_mode = stereoMode.empty() ? "block_lr" : stereoMode;
+              mvcStream = m_pFormatContext->streams[m_pSSIF->GetMVCStreamId()];
+            }
+
+            if (mvcStream)
+            {
+              pStream->codecpar->codec_tag = MKTAG('A', 'M', 'V', 'C');
+
+              if (pStream->codecpar->extradata_size > 0 && mvcStream->codecpar->extradata_size > 0)
+              {
+                uint8_t* extr = pStream->codecpar->extradata;
+
+                pStream->codecpar->extradata = (uint8_t*)av_mallocz(pStream->codecpar->extradata_size + mvcStream->codecpar->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
+                memcpy(pStream->codecpar->extradata, extr, pStream->codecpar->extradata_size);
+                memcpy(pStream->codecpar->extradata + pStream->codecpar->extradata_size, mvcStream->codecpar->extradata, mvcStream->codecpar->extradata_size);
+                pStream->codecpar->extradata_size += mvcStream->codecpar->extradata_size;
+                av_free(extr);
+              }
+            }
+          }
+          else if (CDVDCodecUtils::ProcessH264MVCExtradata(pStream->codecpar->extradata, pStream->codecpar->extradata_size))
+          {
+            pStream->codecpar->codec_tag = MKTAG('M', 'V', 'C', '1');
 
+            // use lr if we don't know what the stereo mode is
+            st->stereo_mode = stereoMode.empty() ? "block_lr" : stereoMode;
+          }
+        }
         break;
       }
       case AVMEDIA_TYPE_DATA:
@@ -1766,6 +1879,16 @@ CDemuxStream* CDVDDemuxFFmpeg::AddStream(int streamIdx)
           if (av_dict_get(pStream->metadata, "title", NULL, 0))
             st->m_description = av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 
+          AVDictionaryEntry *tag = av_dict_get(pStream->metadata, "3d-plane", NULL, AV_DICT_IGNORE_SUFFIX);
+          if (tag && tag->value && *tag->value) {
+            st->m_3dSubtitlePlane = std::atoi(tag->value);
+          }
+
+          if (m_pInput->IsStreamType(DVDSTREAM_TYPE_BLURAY)) {
+            st->m_3dSubtitlePlane = std::static_pointer_cast<CDVDInputStreamBluray>(m_pInput)->Get3dSubtitlePlane(pStream->id);
+          }
+
+          CLog::Log(LOGDEBUG, "{} - 3d subtitle plane = #{}", __FUNCTION__, st->m_3dSubtitlePlane);
           break;
         }
       }
@@ -2081,7 +2204,20 @@ bool CDVDDemuxFFmpeg::SeekChapter(int chapter, double* startpts)
 
   AVChapter* ch = m_pFormatContext->chapters[chapter - 1];
   double dts = ConvertTimestamp(ch->start, ch->time_base.den, ch->time_base.num);
-  return SeekTime(DVD_TIME_TO_MSEC(dts), true, startpts);
+  bool rtn = SeekTime(DVD_TIME_TO_MSEC(dts), true, startpts);
+  if (rtn)
+  {
+    double startpts_b;
+    if (SeekTime(DVD_TIME_TO_MSEC(dts), false, &startpts_b))
+    {
+      if (*startpts - dts < dts -startpts_b)
+        rtn = SeekTime(DVD_TIME_TO_MSEC(dts), true, startpts);
+      else
+        *startpts = startpts_b;
+    }
+  }
+  CLog::Log(LOGDEBUG, "CDVDDemuxFFmpeg::{} - seeking chapter:{:d} start:{:.3f} key-frame:{:.3f} ", __FUNCTION__, chapter, DVD_TIME_TO_MSEC(dts) / 1000.0, m_currentPts / DVD_TIME_BASE);
+  return rtn;
 }
 
 std::string CDVDDemuxFFmpeg::GetStreamCodecName(int iStreamId)
@@ -2112,6 +2248,11 @@ std::string CDVDDemuxFFmpeg::GetStreamCodecName(int iStreamId)
 
 bool CDVDDemuxFFmpeg::IsProgramChange()
 {
+  // libavformat is confused by the interleaved SSIF.
+  // disable program management for those
+  if (m_pSSIF && !m_pSSIF->IsBluRay())
+    return false;
+     
   if (m_program == UINT_MAX)
     return false;
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 966817d543..951de9f818 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "DVDDemux.h"
+#include "DemuxStreamSSIF.h"
 #include "threads/CriticalSection.h"
 #include "threads/SystemClock.h"
 #include <map>
@@ -152,6 +153,7 @@ protected:
   bool     m_bMatroska;
   bool     m_bAVI;
   bool     m_bSup;
+  CDemuxStreamSSIF* m_pSSIF;
   int      m_speed;
   unsigned int m_program;
   unsigned int m_streamsInProgram;
@@ -177,5 +179,8 @@ protected:
   double m_dtsAtDisplayTime;
   bool m_seekToKeyFrame = false;
   double m_startTime = 0;
+
+private:
+  bool isFpsNonsense(const AVRational &frameRate);
 };
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.cpp
new file mode 100644
index 0000000000..0cf88618fc
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.cpp
@@ -0,0 +1,272 @@
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DemuxMVC.h"
+#include "DVDDemuxUtils.h"
+#include "DVDInputStreams/DVDInputStream.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "cores/FFmpeg.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/opt.h"
+};
+
+#define MVC_SEEK_TIME_WINDOW 75000 // experimental value depends on seeking accurate
+
+static int mvc_file_read(void *h, uint8_t* buf, int size)
+{
+  CDVDInputStream* pInputStream = static_cast<CDemuxMVC*>(h)->m_pInput;
+  return pInputStream->Read(buf, size);
+}
+
+static int64_t mvc_file_seek(void *h, int64_t pos, int whence)
+{
+  CDVDInputStream* pInputStream = static_cast<CDemuxMVC*>(h)->m_pInput;
+  if (whence == AVSEEK_SIZE)
+    return pInputStream->GetLength();
+  else
+    return pInputStream->Seek(pos, whence & ~AVSEEK_FORCE);
+}
+
+CDemuxMVC::CDemuxMVC()
+{
+  m_ioContext = nullptr;
+  m_pFormatContext = nullptr;
+  m_pInput = nullptr;
+  m_nStreamIndex = -1;
+}
+
+CDemuxMVC::~CDemuxMVC()
+{
+  Dispose();
+}
+
+bool CDemuxMVC::Open(CDVDInputStream* pInput)
+{
+  int ret;
+
+  if (!pInput)
+    return false;
+  m_pInput = pInput;
+
+  int bufferSize = 4096;
+  int blockSize = m_pInput->GetBlockSize();
+  if (blockSize > 1)
+    bufferSize = blockSize;
+  unsigned char* buffer = (unsigned char*)av_malloc(bufferSize);
+  m_ioContext = avio_alloc_context(buffer, bufferSize, 0, this, mvc_file_read, NULL, mvc_file_seek);
+
+    m_pFormatContext = avformat_alloc_context();
+  m_pFormatContext->pb = m_ioContext;
+
+  AVInputFormat *format = av_find_input_format("mpegts");
+  ret = avformat_open_input(&m_pFormatContext, m_pInput->GetFileName().c_str(), format, nullptr);
+  if (ret < 0)
+  {
+    CLog::Log(LOGDEBUG, "{}: Opening MVC demuxing context failed ({})", __FUNCTION__, ret);
+    Dispose();
+    return false;
+  }
+
+  av_opt_set_int(m_pFormatContext, "analyzeduration", 500000, 0);
+  av_opt_set_int(m_pFormatContext, "correct_ts_overflow", 0, 0);
+  m_pFormatContext->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;
+
+  // Find the streams
+  ret = avformat_find_stream_info(m_pFormatContext, nullptr);
+  //it always returns -1 so just ignore it
+  //if (ret < 0)
+  //{
+  //  CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::OpenMVCDemuxer(): avformat_find_stream_info failed ({})", ret);
+  //  Dispose();
+  //  return false;
+  //}
+
+  // print some extra information
+  av_dump_format(m_pFormatContext, 0, m_pInput->GetFileName().c_str(), 0);
+
+  // Find and select our MVC stream
+  CLog::Log(LOGDEBUG, "{}: MVC m2ts has {} streams", __FUNCTION__, m_pFormatContext->nb_streams);
+  for (unsigned i = 0; i < m_pFormatContext->nb_streams; i++)
+  {
+    if (m_pFormatContext->streams[i]->codecpar->codec_id == AV_CODEC_ID_H264_MVC
+      && m_pFormatContext->streams[i]->codecpar->extradata_size > 0)
+    {
+      m_nStreamIndex = i;
+      break;
+    }
+    else
+      m_pFormatContext->streams[i]->discard = AVDISCARD_ALL;
+  }
+
+  if (m_nStreamIndex < 0)
+  {
+    CLog::Log(LOGDEBUG, "{}: MVC Stream not found", __FUNCTION__);
+    Dispose();
+    return false;
+  }
+
+  return true;
+}
+
+bool CDemuxMVC::Reset()
+{
+  CDVDInputStream* pInput = m_pInput;
+  Dispose();
+  Open(pInput);
+  return true;
+}
+
+void CDemuxMVC::Abort()
+{
+}
+
+void CDemuxMVC::Flush()
+{
+  if (m_pFormatContext)
+  {
+    if (m_pFormatContext->pb)
+      avio_flush(m_pFormatContext->pb);
+    avformat_flush(m_pFormatContext);
+  }
+}
+
+DemuxPacket* CDemuxMVC::Read()
+{
+  int ret;
+  AVPacket mvcPacket = { 0 };
+  av_init_packet(&mvcPacket);
+
+  while (true)
+  {
+    ret = av_read_frame(m_pFormatContext, &mvcPacket);
+
+    if (ret == AVERROR(EINTR) || ret == AVERROR(EAGAIN))
+      continue;
+    else if (ret == AVERROR_EOF)
+      break;
+    else if (mvcPacket.size <= 0 || mvcPacket.stream_index != m_nStreamIndex)
+    {
+      av_packet_unref(&mvcPacket);
+      continue;
+    }
+    else
+    {
+      AVStream *stream = m_pFormatContext->streams[mvcPacket.stream_index];
+      double dts = ConvertTimestamp(mvcPacket.dts, stream->time_base.den, stream->time_base.num);
+      double pts = ConvertTimestamp(mvcPacket.pts, stream->time_base.den, stream->time_base.num);
+
+      DemuxPacket* newPkt = CDVDDemuxUtils::AllocateDemuxPacket(mvcPacket.size);
+      if (mvcPacket.data)
+        memcpy(newPkt->pData, mvcPacket.data, mvcPacket.size);
+      newPkt->iSize = mvcPacket.size;
+      newPkt->dts = dts;
+      newPkt->pts = pts;
+      newPkt->iStreamId = stream->id;
+
+      av_packet_unref(&mvcPacket);
+      return newPkt;
+    }
+  }
+
+  return nullptr;
+}
+
+bool CDemuxMVC::SeekTime(double time, bool backwords, double* startpts)
+{
+  if (!m_pInput)
+    return false;
+
+  AVRational time_base = m_pFormatContext->streams[m_nStreamIndex]->time_base;
+  int64_t seek_pts = av_rescale(DVD_MSEC_TO_TIME(time), time_base.den, (int64_t)time_base.num * AV_TIME_BASE);
+  int64_t starttime = 0;
+
+  if (m_pFormatContext->start_time != (int64_t)AV_NOPTS_VALUE)
+    starttime = av_rescale(m_pFormatContext->start_time, time_base.den, (int64_t)time_base.num * AV_TIME_BASE);
+  if (starttime != 0)
+    seek_pts += starttime;
+  if (seek_pts < MVC_SEEK_TIME_WINDOW)
+    seek_pts = 0;
+  else
+    seek_pts -= MVC_SEEK_TIME_WINDOW;
+
+  av_seek_frame(m_pFormatContext, m_nStreamIndex, seek_pts, AVSEEK_FLAG_BACKWARD);
+  return true;
+}
+
+std::string CDemuxMVC::GetFileName()
+{
+  return m_pInput->GetFileName();
+}
+
+AVStream* CDemuxMVC::GetAVStream()
+{
+  return m_pFormatContext ? m_pFormatContext->streams[m_nStreamIndex] : nullptr;
+}
+
+void CDemuxMVC::Dispose()
+{
+  if (m_pFormatContext)
+    avformat_close_input(&m_pFormatContext);
+
+  if (m_ioContext)
+  {
+    av_free(m_ioContext->buffer);
+    av_free(m_ioContext);
+  }
+
+  m_ioContext = nullptr;
+  m_pFormatContext = nullptr;
+  m_pInput = nullptr;
+  m_nStreamIndex = -1;
+}
+
+double CDemuxMVC::ConvertTimestamp(int64_t pts, int den, int num)
+{
+  if (pts == (int64_t)AV_NOPTS_VALUE)
+    return DVD_NOPTS_VALUE;
+
+  // do calculations in floats as they can easily overflow otherwise
+  // we don't care for having a completly exact timestamp anyway
+  double timestamp = (double)pts * num / den;
+  double starttime = 0.0f;
+
+  CDVDInputStream::IMenus *menu = dynamic_cast<CDVDInputStream::IMenus*>(m_pInput);
+  if ((!menu || menu->GetSupportedMenuType() != MenuType::NATIVE) &&
+      m_pFormatContext->start_time != static_cast<int64_t>(AV_NOPTS_VALUE))
+  {
+    starttime = static_cast<double>(m_start_time) / AV_TIME_BASE;
+  }
+
+  if (timestamp > starttime)
+    timestamp -= starttime;
+  // allow for largest possible difference in pts and dts for a single packet
+  else if (timestamp + 0.5f > starttime)
+    timestamp = 0;
+
+  return timestamp * DVD_TIME_BASE;
+}
+
+std::vector<CDemuxStream*> CDemuxMVC::GetStreams() const
+{
+  std::vector<CDemuxStream*> streams;
+  return streams;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.h
new file mode 100644
index 0000000000..77ddc0ea3e
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxMVC.h
@@ -0,0 +1,61 @@
+#pragma once
+
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DVDDemux.h"
+
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
+class CDemuxMVC : public CDVDDemux
+{
+public:
+  CDemuxMVC();
+  virtual ~CDemuxMVC();
+  bool Open(CDVDInputStream* pInput);
+  virtual bool Reset();
+  virtual void Abort();
+  virtual void Flush();
+  virtual DemuxPacket* Read();
+  virtual bool SeekTime(double time, bool backwords = false, double* startpts = nullptr);
+  virtual void SetSpeed(int iSpeed) { };
+  virtual int GetStreamLength() { return 0; };
+  virtual CDemuxStream* GetStream(int iStreamId) const override { return nullptr; };
+  virtual std::vector<CDemuxStream*> GetStreams() const override;
+  virtual int GetNrOfStreams() const override { return 1; };
+  virtual std::string GetFileName();
+
+  void SetStartTime(int64_t start_time) { m_start_time = start_time; }
+  int64_t GetStartTime() const { return m_start_time; }
+
+  AVStream* GetAVStream();
+  CDVDInputStream*    m_pInput;
+
+private:
+  void Dispose();
+  double ConvertTimestamp(int64_t pts, int den, int num);
+
+  AVIOContext        *m_ioContext = nullptr;
+  AVFormatContext    *m_pFormatContext = nullptr;
+  int                 m_nStreamIndex = -1;
+  int64_t			  m_start_time = 0;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.cpp
new file mode 100644
index 0000000000..cb63e797f2
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.cpp
@@ -0,0 +1,197 @@
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#include "DemuxStreamSSIF.h"
+#include "cores/VideoPlayer/DVDDemuxers/DVDDemux.h"
+#include "cores/VideoPlayer/Interface/TimingConstants.h"
+#include "DVDDemuxUtils.h"
+#include "utils/log.h"
+
+//#define DEBUG_VERBOSE
+#define MVC_QUEUE_SIZE 100
+
+DemuxPacket* CDemuxStreamSSIF::AddPacket(DemuxPacket* &srcPkt)
+{
+  if (srcPkt->iStreamId != m_h264StreamId &&
+      srcPkt->iStreamId != m_mvcStreamId)
+    return srcPkt;
+
+  if (srcPkt->iStreamId == m_h264StreamId)
+  {
+    if (m_bluRay && !m_bluRay->HasExtention())
+      return srcPkt;
+    m_H264queue.push(srcPkt);
+  }
+  else if (srcPkt->iStreamId == m_mvcStreamId)
+  {
+    AddMVCExtPacket(srcPkt);
+  }
+
+  return GetMVCPacket();
+}
+
+void CDemuxStreamSSIF::Flush()
+{
+  while (!m_H264queue.empty())
+  {
+    CDVDDemuxUtils::FreeDemuxPacket(m_H264queue.front());
+    m_H264queue.pop();
+  }
+  while (!m_MVCqueue.empty())
+  {
+    CDVDDemuxUtils::FreeDemuxPacket(m_MVCqueue.front());
+    m_MVCqueue.pop();
+  }
+}
+
+DemuxPacket* CDemuxStreamSSIF::MergePacket(DemuxPacket* &srcPkt, DemuxPacket* &appendPkt)
+{
+  DemuxPacket* newpkt = NULL;
+  newpkt = CDVDDemuxUtils::AllocateDemuxPacket(srcPkt->iSize + appendPkt->iSize);
+  newpkt->iSize = srcPkt->iSize + appendPkt->iSize;
+
+  newpkt->pts = srcPkt->pts;
+  newpkt->dts = srcPkt->dts;
+  newpkt->duration = srcPkt->duration;
+  newpkt->iGroupId = srcPkt->iGroupId;
+  newpkt->iStreamId = srcPkt->iStreamId;
+  memcpy(newpkt->pData, srcPkt->pData, srcPkt->iSize);
+  memcpy(newpkt->pData + srcPkt->iSize, appendPkt->pData, appendPkt->iSize);
+
+  CDVDDemuxUtils::FreeDemuxPacket(srcPkt);
+  srcPkt = NULL;
+  CDVDDemuxUtils::FreeDemuxPacket(appendPkt);
+  appendPkt = NULL;
+
+  return newpkt;
+}
+
+DemuxPacket* CDemuxStreamSSIF::GetMVCPacket()
+{
+  // if input is a bluray fill mvc queue before processing
+  if (m_bluRay && m_MVCqueue.empty() && !m_H264queue.empty())
+    FillMVCQueue(m_H264queue.front()->dts);
+
+  // Here, we recreate a h264 MVC packet from the base one + buffered MVC NALU's
+  while (!m_H264queue.empty() && !m_MVCqueue.empty())
+  {
+    DemuxPacket* h264pkt = m_H264queue.front();
+    double tsH264 = (h264pkt->dts != DVD_NOPTS_VALUE ? h264pkt->dts : h264pkt->pts);
+    DemuxPacket* mvcpkt = m_MVCqueue.front();
+    double tsMVC = (mvcpkt->dts != DVD_NOPTS_VALUE ? mvcpkt->dts : mvcpkt->pts);
+
+    if (tsH264 == tsMVC)
+    {
+      m_H264queue.pop();
+      m_MVCqueue.pop();
+
+      while (!m_H264queue.empty())
+      {
+        DemuxPacket* pkt = m_H264queue.front();
+        double ts = (pkt->dts != DVD_NOPTS_VALUE ? pkt->dts : pkt->pts);
+        if (ts == DVD_NOPTS_VALUE)
+        {
+#if defined(DEBUG_VERBOSE)
+          CLog::Log(LOGDEBUG, ">>> MVC merge h264 fragment: {:6}+{:6}, pts({:.3f}/{:.3f}) dts({:.3f}/{:.3f})", h264pkt->iSize, pkt->iSize, h264pkt->pts*1e-6, pkt->pts*1e-6, h264pkt->dts*1e-6, pkt->dts*1e-6);
+#endif
+          h264pkt = MergePacket(h264pkt, pkt);
+          m_H264queue.pop();
+        }
+        else
+          break;
+      }
+      while (!m_MVCqueue.empty())
+      {
+        DemuxPacket* pkt = m_MVCqueue.front();
+        double ts = (pkt->dts != DVD_NOPTS_VALUE ? pkt->dts : pkt->pts);
+        if (ts == DVD_NOPTS_VALUE)
+        {
+#if defined(DEBUG_VERBOSE)
+          CLog::Log(LOGDEBUG, ">>> MVC merge mvc fragment: {:6}+{:6}, pts({:.3f}/{:.3f}) dts({:.3f}/{:.3f})", mvcpkt->iSize, pkt->iSize, mvcpkt->pts*1e-6, pkt->pts*1e-6, mvcpkt->dts*1e-6, pkt->dts*1e-6);
+#endif
+          mvcpkt = MergePacket(mvcpkt, pkt);
+          m_MVCqueue.pop();
+        }
+        else
+          break;
+      }
+
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC merge packet: {:6}+{:6}, pts({:.3f}/{:.3f}) dts({:.3f}/{:.3f})", h264pkt->iSize, mvcpkt->iSize, h264pkt->pts*1e-6, mvcpkt->pts*1e-6, h264pkt->dts*1e-6, mvcpkt->dts*1e-6);
+#endif
+      return MergePacket(h264pkt, mvcpkt);
+    }
+    else if (tsH264 > tsMVC)
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC discard  mvc: {:6}, pts({:.3f}) dts({:.3f})", mvcpkt->iSize, mvcpkt->pts*1e-6, mvcpkt->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(mvcpkt);
+      m_MVCqueue.pop();
+    }
+    else
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC discard h264: {6}, pts({:.3f}) dts({:.3f})", h264pkt->iSize, h264pkt->pts*1e-6, h264pkt->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(h264pkt);
+      m_H264queue.pop();
+    }
+  }
+
+#if defined(DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, ">>> MVC waiting. MVC({}) H264({})", m_MVCqueue.size(), m_H264queue.size());
+#endif
+  return CDVDDemuxUtils::AllocateDemuxPacket(0);
+}
+
+void CDemuxStreamSSIF::AddMVCExtPacket(DemuxPacket* &mvcExtPkt)
+{
+  m_MVCqueue.push(mvcExtPkt);
+}
+
+bool CDemuxStreamSSIF::FillMVCQueue(double dtsBase)
+{
+  if (!m_bluRay)
+    return false;
+
+  CDVDDemux* demux = m_bluRay->GetExtentionDemux();
+  DemuxPacket* mvc;
+  while ((m_MVCqueue.size() < MVC_QUEUE_SIZE) && (mvc = demux->Read()))
+  {
+    if (dtsBase == DVD_NOPTS_VALUE || mvc->dts == DVD_NOPTS_VALUE)
+    {
+      // do nothing, can't compare timestamps when they are not set
+    }
+    else if (mvc->dts < dtsBase)
+    {
+#if defined(DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, ">>> MVC drop mvc: {:6}, pts({:.3f}) dts({:.3f})", mvc->iSize, mvc->pts*1e-6, mvc->dts*1e-6);
+#endif
+      CDVDDemuxUtils::FreeDemuxPacket(mvc);
+      continue;
+    }
+    AddMVCExtPacket(mvc);
+  };
+  if (m_MVCqueue.size() != MVC_QUEUE_SIZE)
+    m_bluRay->OpenNextStream();
+
+  return true;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.h
new file mode 100644
index 0000000000..48007ec4ad
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DemuxStreamSSIF.h
@@ -0,0 +1,59 @@
+#pragma once
+
+/*
+*      Copyright (C) 2005-2013 Team XBMC
+*      http://xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+#if defined(HAVE_LIBBLURAY)
+#include "DVDInputStreams/DVDInputStreamBluray.h"
+#endif
+#include "DVDInputStreams/DVDInputStream.h"
+#include <queue>
+
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
+class CDemuxStreamSSIF
+{
+public:
+  CDemuxStreamSSIF() {};
+  ~CDemuxStreamSSIF() { Flush(); }
+
+  DemuxPacket* AddPacket(DemuxPacket* &scrPkt);
+  void Flush();
+  void SetH264StreamId(int id) { m_h264StreamId = id; };
+  void SetMVCStreamId(int id) { m_mvcStreamId = id; };
+  int GetH264StreamId() { return m_h264StreamId; };
+  int GetMVCStreamId() { return m_mvcStreamId; };
+  void AddMVCExtPacket(DemuxPacket* &scrPkt);
+  void SetBluRay(const std::shared_ptr<CDVDInputStream::IExtentionStream> &bluRay) { m_bluRay = bluRay; };
+  bool IsBluRay() { return m_bluRay != nullptr; };
+
+private:
+  DemuxPacket* GetMVCPacket();
+  DemuxPacket* MergePacket(DemuxPacket* &srcPkt, DemuxPacket* &appendPkt);
+  bool FillMVCQueue(double dtsBase);
+
+  std::shared_ptr<CDVDInputStream::IExtentionStream> m_bluRay = nullptr;
+  std::queue<DemuxPacket*> m_H264queue;
+  std::queue<DemuxPacket*> m_MVCqueue;
+  int m_h264StreamId = -1;
+  int m_mvcStreamId = -1;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
index 0860b40475..d02b247d93 100644
--- a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
@@ -207,8 +207,8 @@ bool CDVDFileInfo::ExtractThumb(const CFileItem& fileItem,
       if (pDemuxer->SeekTime(static_cast<double>(nSeekTo), true))
       {
         CDVDVideoCodec::VCReturn iDecoderState = CDVDVideoCodec::VC_NONE;
-        VideoPicture picture = {};
-
+        VideoPicture picture;
+        picture.Reset();
         // num streams * 160 frames, should get a valid frame, if not abort.
         int abort_index = pDemuxer->GetNrOfStreams() * 160;
         do
@@ -231,6 +231,7 @@ bool CDVDFileInfo::ExtractThumb(const CFileItem& fileItem,
           iDecoderState = CDVDVideoCodec::VC_NONE;
           while (iDecoderState == CDVDVideoCodec::VC_NONE)
           {
+            picture.Reset();
             iDecoderState = pVideoCodec->GetPicture(&picture);
           }
 
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
index 46337576ab..763c45dec6 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
@@ -46,6 +46,7 @@ namespace XFILE
 
 struct DemuxPacket;
 class CDemuxStream;
+class CDVDDemux;
 
 class CDVDInputStream
 {
@@ -152,6 +153,17 @@ public:
     }
   };
 
+  class IExtentionStream
+  {
+    public:
+    virtual ~IExtentionStream() {}
+    virtual bool HasExtention() = 0;
+    virtual bool AreEyesFlipped() = 0;
+    virtual CDVDDemux* GetExtentionDemux() = 0;
+    virtual void DisableExtention() = 0;
+    virtual bool OpenNextStream() = 0;
+  };
+
   enum ENextStream
   {
     NEXTSTREAM_NONE,
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
index 8a1f6bc27d..3eee69098a 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
@@ -10,6 +10,8 @@
 
 #include "DVDCodecs/Overlay/DVDOverlay.h"
 #include "DVDCodecs/Overlay/DVDOverlayImage.h"
+#include "DVDInputStreamFile.h"
+#include "DVDDemuxers/DemuxMVC.h"
 #include "IVideoPlayer.h"
 #include "LangInfo.h"
 #include "ServiceBroker.h"
@@ -32,9 +34,11 @@
 #include <limits>
 
 #include <libbluray/bluray.h>
+#include <libbluray/mpls_data.h>
 #include <libbluray/log_control.h>
 
 #define LIBBLURAY_BYTESEEK 0
+#define EMPTY_QUEUE(x) { while(!x.empty()) x.pop(); }
 
 using namespace XFILE;
 
@@ -94,10 +98,8 @@ bool CDVDInputStreamBluray::IsEOF()
 
 BLURAY_TITLE_INFO* CDVDInputStreamBluray::GetTitleLongest()
 {
-  int titles = bd_get_titles(m_bd, TITLES_RELEVANT, 0);
-
   BLURAY_TITLE_INFO *s = nullptr;
-  for(int i=0; i < titles; i++)
+  for(int i=0; i < m_nTitles; i++)
   {
     BLURAY_TITLE_INFO *t = bd_get_title_info(m_bd, i, 0);
     if(!t)
@@ -259,6 +261,7 @@ bool CDVDInputStreamBluray::Open()
 
   bd_get_event(m_bd, nullptr);
 
+  m_root = root;
   const BLURAY_DISC_INFO *disc_info = bd_get_disc_info(m_bd);
 
   if (!disc_info)
@@ -301,6 +304,7 @@ bool CDVDInputStreamBluray::Open()
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - no menus (libmmbd, or profile 6 bdj)  : {}",
               disc_info->no_menu_support);
 #endif
+    CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::Open - 3D content exist    : {}", disc_info->content_exist_3D);
   }
   else
     CLog::Log(LOGERROR, "CDVDInputStreamBluray::Open - BluRay not detected");
@@ -319,6 +323,7 @@ bool CDVDInputStreamBluray::Open()
     return false;
   }
 
+  m_nTitles = bd_get_titles(m_bd, TITLES_RELEVANT, 0);
   int mode = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_DISC_PLAYBACK);
 
   if (URIUtils::HasExtension(filename, ".mpls"))
@@ -384,19 +389,21 @@ bool CDVDInputStreamBluray::Open()
                 m_titleInfo->idx);
       return false;
     }
-    m_clip = nullptr;
   }
 
   // Process any events that occurred during opening
   while (bd_get_event(m_bd, &m_event))
     ProcessEvent();
 
+  OpenNextStream();
+
   return true;
 }
 
 // close file and reset everything
 void CDVDInputStreamBluray::Close()
 {
+  CloseMVCDemux();
   FreeTitleInfo();
 
   if(m_bd)
@@ -421,7 +428,7 @@ void CDVDInputStreamBluray::FreeTitleInfo()
 
 void CDVDInputStreamBluray::ProcessEvent() {
 
-  int pid = -1;
+  int pid = -1, ret;
   switch (m_event.event) {
 
    /* errors */
@@ -536,14 +543,17 @@ void CDVDInputStreamBluray::ProcessEvent() {
   case BD_EVENT_PLAYLIST:
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYLIST {}", m_event.param);
     m_playlist = m_event.param;
-    FreeTitleInfo();
-    m_titleInfo = bd_get_playlist_info(m_bd, m_playlist, m_angle);
+    ProcessItem(m_playlist);
     break;
 
   case BD_EVENT_PLAYITEM:
     CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - BD_EVENT_PLAYITEM {}", m_event.param);
     if (m_titleInfo && m_event.param < m_titleInfo->clip_count)
       m_clip = &m_titleInfo->clips[m_event.param];
+    uint64_t clip_start, clip_in, bytepos;
+    ret = bd_get_clip_infos(m_bd, m_event.param, &clip_start, &clip_in, &bytepos, nullptr);
+    if (ret)
+      m_clipStartTime = clip_start / 90;
     break;
 
   case BD_EVENT_CHAPTER:
@@ -626,6 +636,25 @@ void CDVDInputStreamBluray::ProcessEvent() {
 
   /* event has been consumed */
   m_event.event = BD_EVENT_NONE;
+
+  if ( m_bMVCPlayback && m_clip
+    && m_titleInfo
+    && m_clip < m_titleInfo->clips + m_titleInfo->clip_count
+    && m_nMVCClip != m_clip
+    && (m_clipQueue.empty()
+      || m_clip != m_titleInfo->clips + m_clipQueue.front()))
+  {
+    m_clipQueue.push(m_clip - m_titleInfo->clips);
+    if (m_pMVCDemux == NULL)
+      OpenNextStream();
+  }
+}
+
+void CDVDInputStreamBluray::DisableExtention()
+{
+  CloseMVCDemux();
+  m_bMVCDisabled = true;
+  m_bMVCPlayback = false;
 }
 
 int CDVDInputStreamBluray::Read(uint8_t* buf, int buf_size)
@@ -933,9 +962,15 @@ bool CDVDInputStreamBluray::PosTime(int ms)
   if(bd_seek_time(m_bd, ms * 90) < 0)
     return false;
 
+  EMPTY_QUEUE(m_clipQueue);
   while (bd_get_event(m_bd, &m_event))
     ProcessEvent();
 
+  if (m_bMVCPlayback)
+  {
+    OpenNextStream();
+    SeekMVCDemux(ms - m_clipStartTime);
+  }
   return true;
 }
 
@@ -960,9 +995,15 @@ bool CDVDInputStreamBluray::SeekChapter(int ch)
   if(m_titleInfo && bd_seek_chapter(m_bd, ch-1) < 0)
     return false;
 
+  EMPTY_QUEUE(m_clipQueue);
   while (bd_get_event(m_bd, &m_event))
     ProcessEvent();
 
+  if (m_bMVCPlayback)
+  {
+    OpenNextStream();
+    SeekMVCDemux(GetChapterPos(ch) * 1000 - m_clipStartTime);
+  }
   return true;
 }
 
@@ -1202,6 +1243,151 @@ MenuType CDVDInputStreamBluray::GetSupportedMenuType()
   return MenuType::NONE;
 }
 
+bool CDVDInputStreamBluray::ProcessItem(int playitem)
+{
+  FreeTitleInfo();
+
+  m_titleInfo = bd_get_playlist_info(m_bd, playitem, m_angle);
+
+  if (!m_bMVCDisabled)
+  {
+    MPLS_PL * mpls = bd_get_title_mpls(m_bd);
+    if (mpls)
+    {
+      for (int i = 0; i < mpls->ext_sub_count; i++)
+      {
+        if (mpls->ext_sub_path[i].type == 8
+          && mpls->ext_sub_path[i].sub_playitem_count == mpls->list_count)
+        {
+          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - Enabling BD3D MVC demuxing");
+          CLog::Log(LOGDEBUG, "CDVDInputStreamBluray - MVC_Base_view_R_flag: {}", m_titleInfo->mvc_base_view_r_flag);
+          m_bMVCPlayback = true;
+          m_nMVCSubPathIndex = i;
+          m_bFlipEyes = m_titleInfo->mvc_base_view_r_flag != 0;
+          break;
+        }
+      }
+    }
+  }
+  CloseMVCDemux();
+  return true;
+}
+
+int CDVDInputStreamBluray::Get3dSubtitlePlane(uint16_t pid)
+{
+  if (!m_bMVCDisabled)
+  {
+    MPLS_PL *mpls = bd_get_title_mpls(m_bd);
+    if (mpls)
+    {
+      for (int i = 0; i < mpls->list_count; i++)
+      {
+        for (int s = 0; s < mpls->play_item[i].stn.num_pg; s++)
+        {
+          if (mpls->play_item[i].stn.pg[s].pid == pid && mpls->play_item[i].stn.pg[s].ss_offset_sequence_id != 0xff)
+            return mpls->play_item[i].stn.pg[s].ss_offset_sequence_id;
+        }
+      }
+    }
+  }
+
+  return 0;
+}
+
+bool CDVDInputStreamBluray::OpenNextStream()
+{
+  if (m_clipQueue.empty())
+    return false;
+
+  int clip = m_clipQueue.front();
+  m_clipQueue.pop();
+
+  CDemuxMVC *pMVCDemux = dynamic_cast<CDemuxMVC*>(m_pMVCDemux);
+  if (!pMVCDemux) {
+    // either it's not a CDemuxMVC or it's 2D playback
+    CloseMVCDemux();
+    return OpenMVCDemux(clip);
+  }
+
+  // save start time for the next clip
+  int64_t start_time = pMVCDemux->GetStartTime();
+
+  CloseMVCDemux();
+
+  bool res = OpenMVCDemux(clip);
+  if (res) {
+    CDemuxMVC *nextDemux = dynamic_cast<CDemuxMVC*>(m_pMVCDemux);
+    if (nextDemux) {
+      // set start time for next clip
+      nextDemux->SetStartTime(start_time);
+    }
+  }
+
+  return res;
+}
+
+bool CDVDInputStreamBluray::OpenMVCDemux(int playItem)
+{
+  MPLS_PL *pl = bd_get_title_mpls(m_bd);
+  if (!pl)
+    return false;
+
+  std::string strFileName;
+  strFileName.append(m_root);
+  strFileName.append("/BDMV/STREAM/");
+  strFileName.append(pl->ext_sub_path[m_nMVCSubPathIndex].sub_play_item[playItem].clip->clip_id);
+  strFileName.append(".m2ts");
+
+  CLog::Log(LOGDEBUG, "CDVDInputStreamBluray::OpenMVCDemuxer(): Opening MVC extension stream at {}", strFileName);
+
+  CFileItem fileitem(CURL(strFileName), false);
+  m_pMVCInput = new CDVDInputStreamFile(fileitem, 0);
+
+  // Try to open the MVC stream
+  if (!m_pMVCInput->Open())
+  {
+    CloseMVCDemux();
+    m_bMVCPlayback = false;
+    return false;
+  }
+
+  if (m_pMVCDemux)
+    delete m_pMVCDemux;
+
+  CDemuxMVC* pMVCDemux = new CDemuxMVC;
+  m_pMVCDemux = pMVCDemux;
+
+  if (!pMVCDemux->Open(m_pMVCInput))
+  {
+    CloseMVCDemux();
+    m_bMVCPlayback = false;
+    return false;
+  }
+
+  m_nMVCClip = m_titleInfo->clips + playItem;
+  return true;
+}
+
+bool CDVDInputStreamBluray::CloseMVCDemux()
+{
+  if (m_pMVCDemux)
+  {
+    delete m_pMVCDemux;
+    m_pMVCDemux = nullptr;
+  }
+
+  delete m_pMVCInput;
+  m_pMVCInput = nullptr;
+  m_nMVCClip = nullptr;
+  return true;
+}
+
+void CDVDInputStreamBluray::SeekMVCDemux(int64_t time)
+{
+  if (m_bMVCPlayback && m_pMVCDemux)
+    m_pMVCDemux->SeekTime(time);
+}
+
 void CDVDInputStreamBluray::SetupPlayerSettings()
 {
   int region = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_BLURAY_PLAYERREGION);
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
index 05af77ecef..7950f712b3 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
@@ -13,6 +13,7 @@
 
 #include <list>
 #include <memory>
+#include <queue>
 
 extern "C"
 {
@@ -42,6 +43,7 @@ extern "C"
 
 class CDVDOverlayImage;
 class IVideoPlayer;
+class CDVDDemux;
 
 class CDVDInputStreamBluray
   : public CDVDInputStream
@@ -49,6 +51,7 @@ class CDVDInputStreamBluray
   , public CDVDInputStream::IChapter
   , public CDVDInputStream::IPosTime
   , public CDVDInputStream::IMenus
+  , public CDVDInputStream::IExtentionStream
 {
 public:
   CDVDInputStreamBluray() = delete;
@@ -125,6 +128,8 @@ public:
 
   void GetStreamInfo(int pid, std::string &language);
 
+  int Get3dSubtitlePlane(uint16_t pid);
+
   void OverlayCallback(const BD_OVERLAY * const);
 #ifdef HAVE_LIBBLURAY_BDJ
   void OverlayCallbackARGB(const struct bd_argb_overlay_s * const);
@@ -134,6 +139,11 @@ public:
   BLURAY_TITLE_INFO* GetTitleFile(const std::string& name);
 
   void ProcessEvent();
+  CDVDDemux* GetExtentionDemux() override { return m_pMVCDemux; };
+  bool HasExtention() override { return m_bMVCPlayback; }
+  bool AreEyesFlipped() override { return m_bFlipEyes; }
+  void DisableExtention() override;
+  bool OpenNextStream() override;
 
 protected:
   struct SPlane;
@@ -142,6 +152,11 @@ protected:
   void OverlayClose();
   static void OverlayClear(SPlane& plane, int x, int y, int w, int h);
   static void OverlayInit (SPlane& plane, int w, int h);
+  bool ProcessItem(int playitem);
+
+  bool OpenMVCDemux(int playItem);
+  bool CloseMVCDemux();
+  void SeekMVCDemux(int64_t time);
 
   IVideoPlayer* m_player = nullptr;
   BLURAY* m_bd = nullptr;
@@ -155,6 +170,19 @@ protected:
   bool m_hasOverlay = false;
   bool m_navmode = false;
   int m_dispTimeBeforeRead = 0;
+  int                 m_nTitles = -1;
+  std::string         m_root;
+
+  // MVC related members
+  CDVDDemux*          m_pMVCDemux = nullptr;
+  CDVDInputStream    *m_pMVCInput = nullptr;
+  bool                m_bMVCPlayback = false;
+  int                 m_nMVCSubPathIndex = 0;
+  BLURAY_CLIP_INFO*   m_nMVCClip = nullptr;
+  bool                m_bFlipEyes = false;
+  bool                m_bMVCDisabled = false;
+  uint64_t            m_clipStartTime = 0;
+  std::queue<int>     m_clipQueue;
 
   typedef std::shared_ptr<CDVDOverlayImage> SOverlay;
   typedef std::list<SOverlay> SOverlays;
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
index f8f7c71943..04272b8b5e 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
@@ -73,6 +73,7 @@ void CDVDStreamInfo::Clear()
 
   orientation = 0;
   bitdepth = 0;
+  m_3dSubtitlePlane = 0;
 }
 
 bool CDVDStreamInfo::Equal(const CDVDStreamInfo& right, int compare)
@@ -160,6 +161,8 @@ bool CDVDStreamInfo::Equal(const CDVDStreamInfo& right, int compare)
     return false;
 
   // SUBTITLE
+  if (m_3dSubtitlePlane != right.m_3dSubtitlePlane)
+    return false;
 
   // Crypto
   if ((cryptoSession == nullptr) != (right.cryptoSession == nullptr))
@@ -244,6 +247,7 @@ void CDVDStreamInfo::Assign(const CDVDStreamInfo& right, bool withextradata)
   channellayout = right.channellayout;
 
   // SUBTITLE
+  m_3dSubtitlePlane = right.m_3dSubtitlePlane;
 }
 
 void CDVDStreamInfo::Assign(const CDemuxStream& right, bool withextradata)
@@ -306,5 +310,7 @@ void CDVDStreamInfo::Assign(const CDemuxStream& right, bool withextradata)
   }
   else if (right.type == STREAM_SUBTITLE)
   {
+    const CDemuxStreamSubtitle *stream = static_cast<const CDemuxStreamSubtitle*>(&right);
+    m_3dSubtitlePlane = stream->m_3dSubtitlePlane;
   }
 }
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.h b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
index 8a3da27225..8541dbaffa 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.h
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
@@ -85,6 +85,7 @@ public:
   uint64_t channellayout;
 
   // SUBTITLE
+  int m_3dSubtitlePlane;
 
   // CODEC EXTRADATA
   void*        extradata; // extra data for codec to use
diff --git a/xbmc/cores/VideoPlayer/DVDSubtitles/DVDSubtitlesLibass.cpp b/xbmc/cores/VideoPlayer/DVDSubtitles/DVDSubtitlesLibass.cpp
index 98d9cdfa19..93510f9fd6 100644
--- a/xbmc/cores/VideoPlayer/DVDSubtitles/DVDSubtitlesLibass.cpp
+++ b/xbmc/cores/VideoPlayer/DVDSubtitles/DVDSubtitlesLibass.cpp
@@ -276,7 +276,8 @@ ASS_Image* CDVDSubtitlesLibass::RenderImage(double pts,
   // Reversed par value
   // from: >1 tighter pixels, <1 wider pixels
   // to: <1 tighter pixels, >1 wider pixels
-  float par = (opts.m_par - 2.0f) * -1;
+  float par = 1.0f / opts.m_par;
+
   ass_set_pixel_aspect(m_renderer, static_cast<double>(par));
 
   ass_set_frame_size(m_renderer, static_cast<int>(opts.frameWidth),
diff --git a/xbmc/cores/VideoPlayer/IVideoPlayer.h b/xbmc/cores/VideoPlayer/IVideoPlayer.h
index cf30266692..5284442a3a 100644
--- a/xbmc/cores/VideoPlayer/IVideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/IVideoPlayer.h
@@ -95,7 +95,8 @@ public:
   virtual std::string GetPlayerInfo() = 0;
   virtual int GetVideoBitrate() = 0;
   virtual void SetSpeed(int iSpeed) = 0;
-  virtual bool IsEOS() { return false; }
+  virtual bool IsEOS() { return false; };
+  virtual bool SupportsExtention() const = 0;
 };
 
 class CDVDAudioCodec;
diff --git a/xbmc/cores/VideoPlayer/Interface/DemuxPacket.h b/xbmc/cores/VideoPlayer/Interface/DemuxPacket.h
index a8ffb9807b..25f43406b0 100644
--- a/xbmc/cores/VideoPlayer/Interface/DemuxPacket.h
+++ b/xbmc/cores/VideoPlayer/Interface/DemuxPacket.h
@@ -38,6 +38,8 @@ extern "C"
       dispTime = 0;
       recoveryPoint = false;
 
+      subtitlePlane = 0;
+
       cryptoInfo = nullptr;
     }
 
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index 88b0344658..39b7b8c8f7 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -1329,17 +1329,14 @@ void CVideoPlayer::Prepare()
     if (m_pDemuxer)
     {
       if (m_pDemuxer->SeekTime(starttime, true, &startpts))
-      {
-        FlushBuffers(starttime / 1000 * AV_TIME_BASE, true, true);
         CLog::Log(LOGDEBUG, "{} - starting demuxer from: {}", __FUNCTION__, starttime);
-      }
       else
         CLog::Log(LOGDEBUG, "{} - failed to start demuxing from: {}", __FUNCTION__, starttime);
     }
 
     if (m_pSubtitleDemuxer)
     {
-      if(m_pSubtitleDemuxer->SeekTime(starttime, true, &startpts))
+      if(m_pSubtitleDemuxer->SeekTime(starttime, false, &startpts))
         CLog::Log(LOGDEBUG, "{} - starting subtitle demuxer from: {}", __FUNCTION__, starttime);
       else
         CLog::Log(LOGDEBUG, "{} - failed to start subtitle demuxing from: {}", __FUNCTION__,
@@ -1569,6 +1566,11 @@ void CVideoPlayer::Process()
     CheckBetterStream(m_CurrentRadioRDS, pStream);
     CheckBetterStream(m_CurrentAudioID3, pStream);
 
+    // if it's a video packet then set the 3D MVC subtitle plane
+    if (CheckIsCurrent(m_CurrentVideo, pStream, pPacket)) {
+      pPacket->subtitlePlane = m_CurrentSubtitle.hint.m_3dSubtitlePlane;
+    }
+
     // demux video stream
     if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_SUBTITLES_PARSECAPTIONS) && CheckIsCurrent(m_CurrentVideo, pStream, pPacket))
     {
@@ -1729,6 +1731,11 @@ void CVideoPlayer::ProcessVideoData(CDemuxStream* pStream, DemuxPacket* pPacket)
   if (CheckSceneSkip(m_CurrentVideo))
     drop = true;
 
+  m_CurrentVideo.lastdts = pPacket->dts;
+
+  CLog::Log(LOGDEBUG, LOGVIDEO, "CVideoPlayer::ProcessVideoData size:{} dts:{:.3f} pts:{:.3f} dur:{:.3f}ms, clock:{:.3f} level:{}",
+    pPacket->iSize, pPacket->dts/1000000, pPacket->pts/1000000, pPacket->duration/1000.0, m_clock.GetClock()/1000000.0, m_processInfo->GetLevelVQ());
+
   m_VideoPlayerVideo->SendMessage(std::make_shared<CDVDMsgDemuxerPacket>(pPacket, drop));
 
   if (!drop)
@@ -1866,7 +1873,7 @@ void CVideoPlayer::HandlePlaySpeed()
     {
       if (level < 0.0)
       {
-        CGUIDialogKaiToast::QueueNotification(g_localizeStrings.Get(21454), g_localizeStrings.Get(21455));
+        //CGUIDialogKaiToast::QueueNotification(g_localizeStrings.Get(21454), g_localizeStrings.Get(21455));
         SetCaching(CACHESTATE_INIT);
       }
       if (level >= 1.0)
@@ -1968,10 +1975,10 @@ void CVideoPlayer::HandlePlaySpeed()
         if (m_CurrentAudio.id >= 0)
         {
           double adjust = -1.0; // a unique value
-          if (m_clock.GetSpeedAdjust() >= 0 && m_VideoPlayerAudio->GetLevel() < 5)
+          if (m_clock.GetSpeedAdjust() >= 0 && m_VideoPlayerAudio->GetLevel() < 15)
             adjust = -0.05;
 
-          if (m_clock.GetSpeedAdjust() < 0 && m_VideoPlayerAudio->GetLevel() > 10)
+          if (m_clock.GetSpeedAdjust() < 0 && m_VideoPlayerAudio->GetLevel() > 20)
             adjust = 0.0;
 
           if (adjust != -1.0)
@@ -2011,6 +2018,7 @@ void CVideoPlayer::HandlePlaySpeed()
              (m_CurrentVideo.avsync == CCurrentStream::AV_SYNC_CONT ||
              m_CurrentAudio.syncState == IDVDStreamPlayer::SYNC_INSYNC))
     {
+      CLog::Log(LOGDEBUG, LOGVIDEO, "VideoPlayer::Sync - Video - Waiting, clock: {:.3f}", m_clock.GetClock());
       m_CurrentVideo.syncState = IDVDStreamPlayer::SYNC_INSYNC;
       m_CurrentVideo.avsync = CCurrentStream::AV_SYNC_NONE;
       m_VideoPlayerVideo->SendMessage(
@@ -2164,18 +2172,19 @@ void CVideoPlayer::HandlePlaySpeed()
             errorwin = 8;
           error /= errorwin;
         }
+        CLog::Log(LOGDEBUG, LOGVIDEO, "CVideoPlayer::Process - ffd/rwd: lastpts:{:.3f} clock:{:.3f} lastseekpts:{:.3f} speed:{:d} error:{:.3f}",
+          m_SpeedState.lastpts / 1000000.0, m_clock.GetClock() / 1000000.0, m_SpeedState.lastseekpts / 1000000.0, (int)m_playSpeed, error / 1000000.0);
 
-        if (error > DVD_MSEC_TO_TIME(1000))
+        if (std::abs(error) > DVD_MSEC_TO_TIME(1000))
         {
           error  = (m_clock.GetClock() - m_SpeedState.lastseekpts) / 1000;
 
           if (std::abs(error) > 1000 || (m_VideoPlayerVideo->IsRewindStalled() && std::abs(error) > 100))
           {
-            CLog::Log(LOGDEBUG, "CVideoPlayer::Process - Seeking to catch up, error was: {:f}",
-                      error);
             m_SpeedState.lastseekpts = m_clock.GetClock();
             int direction = (m_playSpeed > 0) ? 1 : -1;
             double iTime = (m_clock.GetClock() + m_State.time_offset + 1000000.0 * direction) / 1000;
+            CLog::Log(LOGDEBUG, LOGVIDEO, "CVideoPlayer::Process - Seeking to catch up, error was: {:.3f} time:{:.3f}", error / 1000.0, iTime/1000.0);
             CDVDMsgPlayerSeek::CMode mode;
             mode.time = iTime;
             mode.backward = (m_playSpeed < 0);
@@ -2694,14 +2703,14 @@ void CVideoPlayer::HandleMessages()
       if (m_pInputStream->GetIPosTime() == nullptr)
         time -= m_State.time_offset/1000l;
 
-      CLog::Log(LOGDEBUG, "demuxer seek to: {:f}", time);
+      CLog::Log(LOGDEBUG, "CVideoPlayer::HandleMessages: demuxer seek to: {:f}", time);
       if (m_pDemuxer && m_pDemuxer->SeekTime(time, msg.GetBackward(), &start))
       {
-        CLog::Log(LOGDEBUG, "demuxer seek to: {:f}, success", time);
+        CLog::Log(LOGDEBUG, "CVideoPlayer::HandleMessages: demuxer seek to: {:f}, success", time);
         if(m_pSubtitleDemuxer)
         {
           if(!m_pSubtitleDemuxer->SeekTime(time, msg.GetBackward()))
-            CLog::Log(LOGDEBUG, "failed to seek subtitle demuxer: {:f}, success", time);
+            CLog::Log(LOGDEBUG, "CVideoPlayer::HandleMessages: failed to seek subtitle demuxer: {:f}, success", time);
         }
         // dts after successful seek
         if (start == DVD_NOPTS_VALUE)
@@ -2711,6 +2720,7 @@ void CVideoPlayer::HandleMessages()
         m_State.lastSeek = m_clock.GetAbsoluteClock();
 
         FlushBuffers(start, msg.GetAccurate(), msg.GetSync());
+        CLog::Log(LOGDEBUG, LOGVIDEO, "CVideoPlayer::HandleMessages: flush buffers: dts:{:.3f} lastSeek:{:.3f} clock:{:.3f}", start / 1000000., m_State.lastSeek / 1000000.0, m_clock.GetClock() / 1000000.0);
       }
       else if (m_pDemuxer)
       {
@@ -3078,7 +3088,9 @@ void CVideoPlayer::SetCaching(ECacheState state)
   if(m_caching == state)
     return;
 
-  CLog::Log(LOGDEBUG, "CVideoPlayer::SetCaching - caching state {}", state);
+  CLog::Log(LOGDEBUG, LOGVIDEO, "CVideoPlayer::SetCaching - caching state {:d} clock:{:.3f} start pts:{:.3f}",
+    state, m_clock.GetClock() / 1000000.0,
+    m_CurrentVideo.starttime == DVD_NOPTS_VALUE ? -1.0 : m_CurrentVideo.starttime / 1000000.0);
   if (state == CACHESTATE_FULL ||
       state == CACHESTATE_INIT)
   {
@@ -3738,20 +3750,6 @@ bool CVideoPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
   if (hint.flags & AV_DISPOSITION_ATTACHED_PIC)
     return false;
 
-  // set desired refresh rate
-  if (m_CurrentVideo.id < 0 && m_playerOptions.fullscreen &&
-      CServiceBroker::GetWinSystem()->GetGfxContext().IsFullScreenRoot() && hint.fpsrate != 0 &&
-      hint.fpsscale != 0)
-  {
-    if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF)
-    {
-      double framerate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration((double)DVD_TIME_BASE * hint.fpsscale / hint.fpsrate);
-      RESOLUTION res = CResolutionUtils::ChooseBestResolution(static_cast<float>(framerate), hint.width, hint.height, !hint.stereo_mode.empty());
-      CServiceBroker::GetWinSystem()->GetGfxContext().SetVideoResolution(res, false);
-      m_renderManager.TriggerUpdateResolution(framerate, hint.width, hint.height, hint.stereo_mode);
-    }
-  }
-
   IDVDStreamPlayer* player = GetStreamPlayer(m_CurrentVideo.player);
   if(player == nullptr)
     return false;
@@ -3765,8 +3763,30 @@ bool CVideoPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
     if (!player->OpenStream(hint))
       return false;
 
+    // set desired refresh rate
+    if (m_playerOptions.fullscreen && CServiceBroker::GetWinSystem()->GetGfxContext().IsFullScreenRoot() &&
+        hint.fpsrate != 0 && hint.fpsscale != 0)
+    {
+      if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF)
+      {
+        double framerate = DVD_TIME_BASE / CDVDCodecUtils::NormalizeFrameduration((double)DVD_TIME_BASE * hint.fpsscale / hint.fpsrate);
+
+        CServiceBroker::GetGUI()->GetStereoscopicsManager().OnStreamChange();
+        RENDER_STEREO_MODE rsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+        uint32_t mode3dFlags = CServiceBroker::GetWinSystem()->GetGfxContext().ConvertRenderStereoModeToMode3dFlags(rsm);
+
+        RESOLUTION res = CResolutionUtils::ChooseBestResolution(static_cast<float>(framerate), hint.width, hint.height, mode3dFlags);
+        CServiceBroker::GetWinSystem()->GetGfxContext().SetVideoResolution(res, false);
+        m_renderManager.TriggerUpdateResolution(framerate, hint.width, hint.height, hint.stereo_mode);
+      }
+    }
+
     player->SendMessage(std::make_shared<CDVDMsgBool>(CDVDMsg::GENERAL_PAUSE, m_displayLost), 1);
 
+    const std::shared_ptr<CDVDInputStream::IExtentionStream>  pExt = std::dynamic_pointer_cast<CDVDInputStream::IExtentionStream>(m_pInputStream);
+    if (pExt && !static_cast<IDVDStreamPlayerVideo*>(player)->SupportsExtention())
+      pExt->DisableExtention();
+
     // look for any EDL files
     m_Edl.Clear();
     float fFramesPerSecond = 0.0f;
@@ -3952,6 +3972,7 @@ void CVideoPlayer::FlushBuffers(double pts, bool accurate, bool sync)
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
   m_CurrentVideo.packets = 0;
+  m_CurrentVideo.lastdts = DVD_NOPTS_VALUE;
 
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
@@ -3998,7 +4019,8 @@ void CVideoPlayer::FlushBuffers(double pts, bool accurate, bool sync)
   }
 
   if(pts != DVD_NOPTS_VALUE && sync)
-    m_clock.Discontinuity(pts);
+    m_clock.Discontinuity(pts - DVD_TIME_BASE/2);
+
   UpdatePlayState(0);
 
   m_demuxerSpeed = DVD_PLAYSPEED_NORMAL;
@@ -4877,15 +4899,7 @@ void CVideoPlayer::UpdatePlayState(double timeout)
 
     bool realtime = m_pInputStream->IsRealtime();
 
-    if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK) &&
-        !realtime)
-    {
-      state.cantempo = true;
-    }
-    else
-    {
-      state.cantempo = false;
-    }
+    state.cantempo = false;
 
     m_processInfo->SetStateRealtime(realtime);
   }
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
index 6ab5b5d944..cf6609a023 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
@@ -77,7 +77,7 @@ CVideoPlayerAudio::~CVideoPlayerAudio()
 bool CVideoPlayerAudio::OpenStream(CDVDStreamInfo hints)
 {
   CLog::Log(LOGINFO, "Finding audio codec for: {}", hints.codec);
-  bool allowpassthrough = !CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK);
+  bool allowpassthrough = true;
   if (m_processInfo.IsRealtimeStream())
     allowpassthrough = false;
 
@@ -131,9 +131,7 @@ void CVideoPlayerAudio::OpenStream(CDVDStreamInfo& hints, std::unique_ptr<CDVDAu
 
   m_prevsynctype = -1;
   m_synctype = SYNC_DISCON;
-  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK))
-    m_synctype = SYNC_RESAMPLE;
-  else if (m_processInfo.IsRealtimeStream())
+  if (m_processInfo.IsRealtimeStream())
     m_synctype = SYNC_RESAMPLE;
 
   if (m_synctype == SYNC_DISCON)
@@ -675,7 +673,7 @@ bool CVideoPlayerAudio::SwitchCodecIfNeeded()
 
   m_displayReset = false;
 
-  bool allowpassthrough = !CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK);
+  bool allowpassthrough = true;
   if (m_processInfo.IsRealtimeStream() || m_synctype == SYNC_RESAMPLE)
     allowpassthrough = false;
 
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 20f6b3b1cb..de33455777 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -310,6 +310,7 @@ void CVideoPlayerVideo::Process()
   int iDropDirective;
   bool onlyPrioMsgs = false;
 
+  m_picture.Reset();
   m_videoStats.Start();
   m_droppingStats.Reset();
   m_iDroppedFrames = 0;
@@ -705,6 +706,11 @@ bool CVideoPlayerVideo::ProcessDecoderOutput(double &frametime, double &pts)
           if (m_processInfo.GetVideoSettings().m_StereoInvert)
             stereoMode = "bottom_top";
           break;
+        case RENDER_STEREO_MODE_HARDWAREBASED:
+          stereoMode = "block_lr";
+          if (m_processInfo.GetVideoSettings().m_StereoInvert)
+            stereoMode = "block_rl";
+          break;
         default:
           stereoMode = m_hints.stereo_mode;
           break;
@@ -816,6 +822,8 @@ void CVideoPlayerVideo::ProcessOverlays(const VideoPicture* pSource, double pts)
 
       if((pOverlay->iPTSStartTime <= pts2 && (pOverlay->iPTSStopTime > pts2 || pOverlay->iPTSStopTime == 0LL)))
       {
+        pOverlay->m_3dSubtitleDepth = pSource->m_3dSubtitleDepth;
+
         if(pOverlay->IsOverlayType(DVDOVERLAY_TYPE_GROUP))
           overlays.insert(overlays.end(), static_cast<CDVDOverlayGroup*>(pOverlay)->m_overlays.begin()
                                         , static_cast<CDVDOverlayGroup*>(pOverlay)->m_overlays.end());
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.h b/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
index e5d725482f..fe0fd9532e 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
@@ -72,6 +72,7 @@ public:
   std::string GetPlayerInfo() override;
   int GetVideoBitrate() override;
   void SetSpeed(int iSpeed) override;
+  bool SupportsExtention() const override { return m_pVideoCodec && m_pVideoCodec->SupportsExtention(); }
 
   // classes
   CDVDOverlayContainer* m_pOverlayContainer;
diff --git a/xbmc/cores/VideoPlayer/VideoReferenceClock.cpp b/xbmc/cores/VideoPlayer/VideoReferenceClock.cpp
index 7508978594..eff9c4d8c0 100644
--- a/xbmc/cores/VideoPlayer/VideoReferenceClock.cpp
+++ b/xbmc/cores/VideoPlayer/VideoReferenceClock.cpp
@@ -46,8 +46,8 @@ CVideoReferenceClock::~CVideoReferenceClock()
 
 void CVideoReferenceClock::Start()
 {
-  if(CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEDISPLAYASCLOCK) && !IsRunning())
-    Create();
+  /* We don't use this on AML */
+  return;
 }
 
 void CVideoReferenceClock::CBUpdateClock(int NrVBlanks, uint64_t time, void *clock)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
index b8649daaa8..f85ff3e490 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
@@ -19,7 +19,11 @@
 #include "settings/lib/SettingDefinitions.h"
 #include "utils/MathUtils.h"
 #include "utils/log.h"
+#include "utils/StringUtils.h"
 #include "windowing/GraphicContext.h"
+#include "utils/SysfsUtils.h"
+#include "xbmc/application/Application.h"
+#include "application/ApplicationPlayer.h"
 
 #include <algorithm>
 #include <cstdlib> // std::abs(int) prototype
@@ -126,6 +130,46 @@ void CBaseRenderer::CalcDestRect(float offsetX,
   // and the output pixel ratio setting)
 
   float outputFrameRatio = inputFrameRatio / CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().fPixelRatio;
+  
+  static int countdown = 0;
+
+  std::string hdmiAspect;
+  SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/aspect", hdmiAspect);
+  
+  if (((MathUtils::FloatEquals(inputFrameRatio, 4.0f / 3.0f, 0.01f) &&
+      !MathUtils::FloatEquals(inputFrameRatio, (float) m_sourceWidth / (float) m_sourceHeight, 0.01f)) ||
+      (StringUtils::EndsWith(hdmiAspect, "0x01/0x08") && countdown > 0)) &&
+      CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_STRETCH43) == ViewModeHDMIAVI &&
+      m_videoSettings.m_ViewMode == ViewModeNormal)
+  {
+    auto& components = CServiceBroker::GetAppComponents();
+    const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+    if (appPlayer->IsPaused())
+      countdown = 20;
+    else if (countdown > 0)
+      countdown--;
+
+    if (countdown > 0 || MathUtils::FloatEquals(inputFrameRatio, 4.0f / 3.0f, 0.01f))
+    {
+      if (!StringUtils::EndsWith(hdmiAspect, "0x01/0x08"))
+      {
+        CLog::Log(LOGDEBUG, "CBaseRenderer::CalcNormalRenderRect Setting aspect to 4:3");
+        SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/aspect", 1);
+      }
+      outputFrameRatio = ((float) CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iWidth) /
+          ((float) CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iHeight);
+    }
+  }
+  else
+  {
+    if (!StringUtils::EndsWith(hdmiAspect, "0x02/0x08"))
+    {
+      CLog::Log(LOGDEBUG, "CBaseRenderer::CalcNormalRenderRect Setting aspect to 16:9");
+      SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/aspect", 2);
+    }
+    if (CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iWidth == 720)
+      outputFrameRatio *= 3.0f / 4.0f;
+  }
 
   // allow a certain error to maximize size of render area
   float fCorrection = width / height / outputFrameRatio - 1.0f;
@@ -166,6 +210,14 @@ void CBaseRenderer::CalcDestRect(float offsetX,
       newWidth = std::min(width, height);
       newHeight = newWidth * outputFrameRatio;
     }
+    if (CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iWidth == 720) {
+      if (CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iHeight == 576)
+        newWidth *= (225.0f / 256.0f);
+      if (CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo().iHeight == 480)
+        newWidth *= (81.0f / 64.0f);
+      if (MathUtils::FloatEquals(inputFrameRatio, 1.7777f, 0.01f))
+        newWidth *= (9.0f / 16.0f);
+    }
   }
 
   // Scale the movie up by set zoom amount
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
index 67871f9b9d..7f942b0068 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
@@ -20,7 +20,7 @@
 #include <vector>
 
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 6
+#define NUM_BUFFERS 8
 
 class CSetting;
 struct IntegerSettingOption;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
index edafa9ed0b..49029ece88 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
@@ -46,6 +46,7 @@ endif()
 if(OPENGLES_FOUND AND ("android" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "ios" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "tvos" IN_LIST CORE_PLATFORM_NAME_LC OR
+                       "aml" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "gbm" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "x11" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "wayland" IN_LIST CORE_PLATFORM_NAME_LC))
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
index b1286231c4..aff1b4fd41 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/CMakeLists.txt
@@ -39,6 +39,11 @@ if(CORE_SYSTEM_NAME STREQUAL darwin_embedded)
   endif()
 endif()
 
+if(AML_FOUND)
+  list(APPEND SOURCES RendererAML.cpp)
+  list(APPEND HEADERS RendererAML.h)
+endif()
+
 if(CORE_SYSTEM_NAME STREQUAL android)
   list(APPEND SOURCES RendererMediaCodec.cpp
                       RendererMediaCodecSurface.cpp)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp
new file mode 100644
index 0000000000..47b2274d22
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp
@@ -0,0 +1,214 @@
+/*
+ *  Copyright (C) 2007-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RendererAML.h"
+
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "utils/ScreenshotAML.h"
+#include "settings/MediaSettings.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderCapture.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFactory.h"
+#include "cores/VideoPlayer/VideoRenderers/RenderFlags.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+
+#include "windowing/GraphicContext.h"
+#include "ServiceBroker.h"
+
+#include <chrono>
+#include <thread>
+
+CRendererAML::CRendererAML()
+ : m_prevVPts(-1)
+ , m_bConfigured(false)
+{
+  CLog::Log(LOGINFO, "Constructing CRendererAML");
+}
+
+CRendererAML::~CRendererAML()
+{
+  Reset();
+}
+
+CBaseRenderer* CRendererAML::Create(CVideoBuffer *buffer)
+{
+  if (buffer && dynamic_cast<CAMLVideoBuffer*>(buffer))
+    return new CRendererAML();
+  return nullptr;
+}
+
+bool CRendererAML::Register()
+{
+  VIDEOPLAYER::CRendererFactory::RegisterRenderer("amlogic", CRendererAML::Create);
+  return true;
+}
+
+float CRendererAML::GetVideoRefreshRate() const
+{
+  RESOLUTION res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
+  const RESOLUTION_INFO& video_res_info = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+
+  return video_res_info.fRefreshRate;
+}
+
+bool CRendererAML::Configure(const VideoPicture &picture, float fps, unsigned int orientation)
+{
+  m_sourceWidth = picture.iWidth;
+  m_sourceHeight = picture.iHeight;
+  m_renderOrientation = orientation;
+
+  m_iFlags = GetFlagsChromaPosition(picture.chroma_position) |
+             GetFlagsColorMatrix(picture.color_space, picture.iWidth, picture.iHeight) |
+             GetFlagsColorPrimaries(picture.color_primaries) |
+             GetFlagsStereoMode(picture.stereoMode);
+
+  // Calculate the input frame aspect ratio.
+  CalculateFrameAspectRatio(picture.iDisplayWidth, picture.iDisplayHeight);
+  SetViewMode(m_videoSettings.m_ViewMode);
+  ManageRenderArea();
+
+  m_bConfigured = true;
+
+  return true;
+}
+
+CRenderInfo CRendererAML::GetRenderInfo()
+{
+  CRenderInfo info;
+  info.max_buffer_size = m_numRenderBuffers;
+  info.optimal_buffer_size = m_numRenderBuffers;
+  info.opaque_pointer = (void *)this;
+  return info;
+}
+
+bool CRendererAML::RenderCapture(CRenderCapture* capture)
+{
+  capture->BeginRender();
+  capture->EndRender();
+  CScreenshotAML::CaptureVideoFrame((unsigned char *)capture->GetRenderBuffer(), capture->GetWidth(), capture->GetHeight(), false);
+  return true;
+}
+
+void CRendererAML::AddVideoPicture(const VideoPicture &picture, int index)
+{
+  ReleaseBuffer(index);
+
+  BUFFER &buf(m_buffers[index]);
+  if (picture.videoBuffer)
+  {
+    buf.videoBuffer = picture.videoBuffer;
+    buf.videoBuffer->Acquire();
+  }
+}
+
+void CRendererAML::ReleaseBuffer(int idx)
+{
+  BUFFER &buf(m_buffers[idx]);
+  if (buf.videoBuffer)
+  {
+    CAMLVideoBuffer *amli(dynamic_cast<CAMLVideoBuffer*>(buf.videoBuffer));
+    if (amli)
+    {
+      if (amli->m_amlCodec)
+      {
+        amli->m_amlCodec->releaseFrame(amli->m_bufferIndex, true);
+        amli->m_amlCodec = nullptr; // Released
+      }
+      amli->Release();
+    }
+    buf.videoBuffer = nullptr;
+  }
+}
+
+bool CRendererAML::Supports(ERENDERFEATURE feature) const
+{
+  if (feature == RENDERFEATURE_ZOOM ||
+      feature == RENDERFEATURE_CONTRAST ||
+      feature == RENDERFEATURE_BRIGHTNESS ||
+      feature == RENDERFEATURE_NONLINSTRETCH ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT ||
+      feature == RENDERFEATURE_STRETCH ||
+      feature == RENDERFEATURE_PIXEL_RATIO ||
+      feature == RENDERFEATURE_ROTATION)
+    return true;
+
+  return false;
+}
+
+void CRendererAML::Reset()
+{
+  std::array<int, 2> reset_arr[m_numRenderBuffers];
+  m_prevVPts = -1;
+
+  for (int i = 0 ; i < m_numRenderBuffers ; ++i)
+  {
+    reset_arr[i][0] = i;
+
+    if (m_buffers[i].videoBuffer)
+      reset_arr[i][1] = dynamic_cast<CAMLVideoBuffer *>(m_buffers[i].videoBuffer)->m_bufferIndex;
+    else
+      reset_arr[i][1] = 0;
+  }
+
+  std::sort(std::begin(reset_arr), std::end(reset_arr),
+    [](const std::array<int, 2>& u, const std::array<int, 2>& v)
+    {
+      return u[1] < v[1];
+    });
+
+  for (int i = 0; i < m_numRenderBuffers; ++i)
+  {
+    if (m_buffers[reset_arr[i][0]].videoBuffer)
+    {
+      m_buffers[reset_arr[i][0]].videoBuffer->Release();
+      m_buffers[reset_arr[i][0]].videoBuffer = nullptr;
+    }
+  }
+}
+
+bool CRendererAML::Flush(bool saveBuffers)
+{
+  Reset();
+  return saveBuffers;
+};
+
+void CRendererAML::RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha)
+{
+  ManageRenderArea();
+
+  CAMLVideoBuffer *amli = dynamic_cast<CAMLVideoBuffer *>(m_buffers[index].videoBuffer);
+  if(amli && amli->m_amlCodec)
+  {
+    int pts = amli->m_omxPts;
+    if (pts != m_prevVPts)
+    {
+      amli->m_amlCodec->releaseFrame(amli->m_bufferIndex);
+      amli->m_amlCodec->setVideoRect(m_sourceRect, m_destRect);
+      amli->m_amlCodec = nullptr; //Mark frame as processed
+      m_prevVPts = pts;
+    }
+  }
+
+#if 0
+  // Use polling to sync with the kernel's vsync IRQ. It turned out that the
+  // Linux schedulers wakeup latency varies too much. Wakeup delays of up to 6 ms
+  // are too big and are causing 'stutters' like skipped/dropped frames. However,
+  // this can be avoided if we let Kodi run with realtime priority.
+  //
+  amlogic::AMLVideoCodec::pollFrame();
+#else
+  // We do not use polling in this case. The vsync IRQ will handle 'ready' frames anyway.
+  // Just sleep a bit here to avoid high CPU usage and temperature.
+  //
+  // Note: you want to use polling if you enable the 'sync-to-display' option.
+  //
+  amlogic::AMLVideoCodec::sleep();
+#endif
+}
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.h
new file mode 100644
index 0000000000..66b1f4a564
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.h
@@ -0,0 +1,59 @@
+/*
+ *  Copyright (C) 2007-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
+
+class CRendererAML : public CBaseRenderer
+{
+public:
+  CRendererAML();
+  virtual ~CRendererAML();
+
+  // Registration
+  static CBaseRenderer* Create(CVideoBuffer *buffer);
+  static bool Register();
+
+  virtual bool RenderCapture(CRenderCapture* capture) override;
+  virtual void AddVideoPicture(const VideoPicture &picture, int index) override;
+  virtual void ReleaseBuffer(int idx) override;
+  virtual bool Configure(const VideoPicture &picture, float fps, unsigned int orientation) override;
+  virtual bool IsConfigured() override { return m_bConfigured; };
+  virtual bool ConfigChanged(const VideoPicture &picture) { return false; };
+  virtual CRenderInfo GetRenderInfo() override;
+  virtual void UnInit() override {};
+  virtual void Update() override {};
+  virtual void RenderUpdate(int index, int index2, bool clear, unsigned int flags, unsigned int alpha) override;
+  virtual bool SupportsMultiPassRendering()override { return false; };
+  virtual bool Flush(bool saveBuffers) override;
+
+  // Player functions
+  virtual bool IsGuiLayer() override { return false; };
+
+  // Feature support
+  virtual bool Supports(ESCALINGMETHOD method) const override { return false; };
+  virtual bool Supports(ERENDERFEATURE feature) const override;
+
+private:
+  void Reset();
+
+  float GetVideoRefreshRate() const;
+
+  static const int m_numRenderBuffers = 8;
+
+  struct BUFFER
+  {
+    BUFFER() : videoBuffer(nullptr) {};
+    CVideoBuffer *videoBuffer;
+    int duration;
+  } m_buffers[m_numRenderBuffers];
+
+  int m_prevVPts;
+  bool m_bConfigured;
+};
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.cpp
index b6f5e5ea73..58924c801c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.cpp
@@ -258,7 +258,7 @@ void CRenderer::Render(COverlay* o)
     }
   }
 
-  state.x += GetStereoscopicDepth();
+  state.x += GetStereoscopicDepth(o->m_pgsSubtitle, o->m_3dSubtitleDepth);
 
   o->Render(state);
 }
@@ -435,20 +435,6 @@ COverlay* CRenderer::ConvertLibass(
   rOpts.frameWidth = m_rv.Width();
   rOpts.frameHeight = m_rv.Height();
 
-  // Render subtitle of half-sbs and half-ou video in full screen, not in half screen
-  if (m_stereomode == "left_right" || m_stereomode == "right_left")
-  {
-    // only half-sbs video, sbs video don't need to change source size
-    if (rOpts.sourceWidth / rOpts.sourceHeight < 1.2f)
-      rOpts.sourceWidth = m_rs.Width() * 2;
-  }
-  else if (m_stereomode == "top_bottom" || m_stereomode == "bottom_top")
-  {
-    // only half-ou video, ou video don't need to change source size
-    if (rOpts.sourceWidth / rOpts.sourceHeight > 2.5f)
-      rOpts.sourceHeight = m_rs.Height() * 2;
-  }
-
   // Set position of subtitles based on video calibration settings
   RESOLUTION_INFO resInfo = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo();
   // Keep track of subtitle position value change,
@@ -489,13 +475,21 @@ COverlay* CRenderer::ConvertLibass(
     // Note also that the displacement compensation will cause a different
     // default position of the text, different from the other alignment positions
     double posPx = static_cast<double>(m_subtitlePosition - resInfo.Overscan.top);
+    double frameHeight = static_cast<double>(rOpts.frameHeight);
+
+    if (m_stereomode == "top_bottom" || m_stereomode == "bottom_top")
+    {
+      // only half-ou video, ou video don't need to correct frame height
+      if (rOpts.sourceWidth / rOpts.sourceHeight > 1.2f)
+        frameHeight *= 2.0;
+    }
 
     int assPlayResY = o->GetLibassHandler()->GetPlayResY();
     double assVertMargin = static_cast<double>(overlayStyle->marginVertical) *
                            (static_cast<double>(assPlayResY) / 720);
-    double vertMarginScaled = assVertMargin / assPlayResY * static_cast<double>(rOpts.frameHeight);
+    double vertMarginScaled = assVertMargin / assPlayResY * frameHeight;
+    double pos = posPx / (frameHeight - vertMarginScaled);
 
-    double pos = posPx / (static_cast<double>(rOpts.frameHeight) - vertMarginScaled);
     rOpts.position = 100 - pos * 100;
   }
   else if (m_subtitleAlign == SUBTITLES::Align::BOTTOM_OUTSIDE)
@@ -602,6 +596,12 @@ COverlay* CRenderer::Convert(CDVDOverlay* o, double pts)
     r = new COverlayImageDX(static_cast<CDVDOverlaySpu*>(o));
 #endif
 
+if (r)
+  {
+    r->m_3dSubtitleDepth = o->m_3dSubtitleDepth;
+    r->m_pgsSubtitle = o->IsOverlayType(DVDOVERLAY_TYPE_IMAGE);
+  }
+
   m_textureCache[m_textureid] = r;
   o->m_textureid = m_textureid;
   m_textureid++;
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.h
index 54e48c0ee1..4494a76762 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRenderer.h
@@ -73,6 +73,9 @@ namespace OVERLAY {
     float m_source_width{0}; // Video source width resolution used to calculate aspect ratio
     float m_source_height{0}; // Video source height resolution used to calculate aspect ratio
 
+    int m_3dSubtitleDepth{0};
+    bool m_pgsSubtitle{false};
+
   protected:
     /*!
      * \brief Given the resolution ratio determines if it is a 4/3 resolution
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.cpp
index a21800e067..9a79c56f86 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.cpp
@@ -273,18 +273,27 @@ bool convert_quad(ASS_Image* images, SQuads& quads, int max_x)
   return true;
 }
 
-int GetStereoscopicDepth()
+int GetStereoscopicDepth(bool isPgs, int subtitleDepth)
 {
-  int depth = 0;
+  RENDER_STEREO_MODE stereoMode = CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
 
-  if(CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode() != RENDER_STEREO_MODE_MONO
-  && CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode() != RENDER_STEREO_MODE_OFF)
+  if (stereoMode == RENDER_STEREO_MODE_MONO || stereoMode == RENDER_STEREO_MODE_OFF)
   {
-    depth  = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_SUBTITLES_STEREOSCOPICDEPTH);
-    depth *= (CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoView() == RENDER_STEREO_VIEW_LEFT ? 1 : -1);
+    // 2D display, so there's no subtitle depth
+    return 0;
   }
 
-  return depth;
+  // get configured depth
+  int depth = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_SUBTITLES_STEREOSCOPICDEPTH);
+
+  // in case of MVC playback and PGS subtitles, use the subtitle depth info additionally to the configured one
+  if(stereoMode == RENDER_STEREO_MODE_HARDWAREBASED && isPgs)
+  {
+    depth += subtitleDepth;
+  }
+
+  // correct depth according to the current left/right eye view
+  return depth * (CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoView() == RENDER_STEREO_VIEW_LEFT ? 1 : -1);
 }
 
 }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.h b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.h
index 96db7397a6..e923510417 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/OverlayRendererUtil.h
@@ -45,6 +45,6 @@ void convert_rgba(CDVDOverlaySpu* o,
                   int& max_y,
                   std::vector<uint32_t>& rgba);
 bool convert_quad(ASS_Image* images, SQuads& quads, int max_x);
-int GetStereoscopicDepth();
+int GetStereoscopicDepth(bool isPgs, int subtitleDepth);
 
 } // namespace OVERLAY
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
index 5a4a2e6e90..0e5fa5659e 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.cpp
@@ -81,8 +81,8 @@ unsigned int GetFlagsStereoMode(const std::string& mode)
     convert["right_left"]             = CONF_FLAGS_STEREO_MODE_SBS | CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT;
     convert["anaglyph_green_magenta"] = 0u;
     convert["anaglyph_yellow_blue"]   = 0u;
-    convert["block_lr"]               = 0u;
-    convert["block_rl"]               = 0u;
+    convert["block_lr"]               = CONF_FLAGS_STEREO_MODE_FP | CONF_FLAGS_STEREO_CADANCE_LEFT_RIGHT;
+    convert["block_rl"]               = CONF_FLAGS_STEREO_MODE_FP | CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT;
   }
   return convert[mode];
 }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
index 54f0524848..ae9ec99dc1 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderFlags.h
@@ -57,6 +57,7 @@
 #define CONF_FLAGS_STEREO_MODE_MASK(a) ((a) & 0x007000)
 #define CONF_FLAGS_STEREO_MODE_SBS     0x001000
 #define CONF_FLAGS_STEREO_MODE_TAB     0x002000
+#define CONF_FLAGS_STEREO_MODE_FP      0x004000
 
 #define CONF_FLAGS_STEREO_CADENCE(a) ((a) & 0x008000)
 #define CONF_FLAGS_STEREO_CADANCE_LEFT_RIGHT 0x000000
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index ceeded1e0e..c570bf1042 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -24,6 +24,8 @@
 #include "utils/log.h"
 #include "windowing/GraphicContext.h"
 #include "windowing/WinSystem.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/StereoscopicsManager.h"
 
 #include <mutex>
 
@@ -693,7 +695,11 @@ RESOLUTION CRenderManager::GetResolution()
     return res;
 
   if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF)
-    res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, !m_stereomode.empty());
+  {
+    RENDER_STEREO_MODE rsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+    uint32_t mode3dFlags = CServiceBroker::GetWinSystem()->GetGfxContext().ConvertRenderStereoModeToMode3dFlags(rsm);
+    res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, mode3dFlags);
+  }
 
   return res;
 }
@@ -896,7 +902,10 @@ void CRenderManager::UpdateResolution()
     {
       if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_OFF && m_fps > 0.0f)
       {
-        RESOLUTION res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, !m_stereomode.empty());
+        RENDER_STEREO_MODE rsm = CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode();
+        uint32_t mode3dFlags = CServiceBroker::GetWinSystem()->GetGfxContext().ConvertRenderStereoModeToMode3dFlags(rsm);
+        RESOLUTION res = CResolutionUtils::ChooseBestResolution(m_fps, m_width, m_height, mode3dFlags);
+
         CServiceBroker::GetWinSystem()->GetGfxContext().SetVideoResolution(res, false);
         UpdateLatencyTweak();
         if (m_pRenderer)
@@ -1193,7 +1202,9 @@ void CRenderManager::PrepareNextRender()
     // see if any future queued frames are already due
     auto iter = m_queued.begin();
     int idx = *iter;
-    ++iter;
+    int lateframes = 0;
+    int queue_size = m_queued.size();
+
     while (iter != m_queued.end())
     {
       // the slot for rendering in time is [pts .. (pts +  x * frametime)]
@@ -1201,8 +1212,10 @@ void CRenderManager::PrepareNextRender()
       // we are really late. The likelihood that we recover decreases the greater m_lateframes
       // get. Skipping a frame is easier than having decoder dropping one (lateframes > 10)
       double x = (m_lateframes <= 6) ? 0.98 : 0;
-      if (renderPts < m_Queue[*iter].pts + x * frametime)
+      if ((renderPts - frametime * queue_size) < (m_Queue[*iter].pts + x * frametime))
         break;
+      lateframes++;
+      queue_size--;
       idx = *iter;
       ++iter;
     }
@@ -1210,17 +1223,17 @@ void CRenderManager::PrepareNextRender()
     // skip late frames
     while (m_queued.front() != idx)
     {
+      m_presentsourcePast = m_queued.front();
+      m_queued.pop_front();
+
       if (m_presentsourcePast >= 0)
       {
         m_discard.push_back(m_presentsourcePast);
         m_QueueSkip++;
+        m_presentsourcePast = -1;
       }
-      m_presentsourcePast = m_queued.front();
-      m_queued.pop_front();
     }
 
-    int lateframes = static_cast<int>((renderPts - m_Queue[idx].pts) *
-                                      static_cast<double>(m_fps / DVD_TIME_BASE));
     if (lateframes)
       m_lateframes += lateframes;
     else
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
index 6b71389043..cc3f52725f 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
@@ -29,6 +29,7 @@ endif()
 if(OPENGLES_FOUND AND ("android" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "ios" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "tvos" IN_LIST CORE_PLATFORM_NAME_LC OR
+                       "aml" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "gbm" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "x11" IN_LIST CORE_PLATFORM_NAME_LC OR
                        "wayland" IN_LIST CORE_PLATFORM_NAME_LC))
diff --git a/xbmc/cores/VideoSettings.h b/xbmc/cores/VideoSettings.h
index a7135da5d8..aeedf893cd 100644
--- a/xbmc/cores/VideoSettings.h
+++ b/xbmc/cores/VideoSettings.h
@@ -188,7 +188,8 @@ enum ViewMode
   ViewModeCustom,
   ViewModeStretch16x9Nonlin,
   ViewModeZoom120Width,
-  ViewModeZoom110Width
+  ViewModeZoom110Width,
+  ViewModeHDMIAVI
 };
 
 class CVideoSettings
diff --git a/xbmc/guilib/StereoscopicsManager.cpp b/xbmc/guilib/StereoscopicsManager.cpp
index 3aa269bca3..67c2b4dc8a 100644
--- a/xbmc/guilib/StereoscopicsManager.cpp
+++ b/xbmc/guilib/StereoscopicsManager.cpp
@@ -61,8 +61,8 @@ static const struct StereoModeMap VideoModeToGuiModeMap[] =
   { "anaglyph_cyan_red",        RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN },
   { "anaglyph_green_magenta",   RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA },
   { "anaglyph_yellow_blue",     RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE },
-  { "block_lr",                 RENDER_STEREO_MODE_OFF }, // unsupported
-  { "block_rl",                 RENDER_STEREO_MODE_OFF }, // unsupported
+  { "block_lr",                 RENDER_STEREO_MODE_HARDWAREBASED },
+  { "block_rl",                 RENDER_STEREO_MODE_HARDWAREBASED },
   {}
 };
 
@@ -130,10 +130,76 @@ void CStereoscopicsManager::SetStereoMode(const RENDER_STEREO_MODE &mode)
   RENDER_STEREO_MODE currentMode = GetStereoMode();
   RENDER_STEREO_MODE applyMode = mode;
 
+  const auto& components = CServiceBroker::GetAppComponents();
+  const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+
   // resolve automatic mode before applying
   if (mode == RENDER_STEREO_MODE_AUTO)
     applyMode = GetStereoModeOfPlayingVideo();
 
+  // Check if we're allowed to switch the stereo mode
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) == ADJUST_REFRESHRATE_OFF)
+  {
+    // mode switches are not allowed
+    if (currentMode == RENDER_STEREO_MODE_MONO || currentMode == RENDER_STEREO_MODE_OFF)
+    {
+      // we are in 2D mode
+      if (IsVideoStereoscopic())
+      {
+        // no mode switches allowed, but we've got a 3D video and are running in 2D then set the stereo mode to mono
+        applyMode = RENDER_STEREO_MODE_MONO;
+      }
+    }
+    else if (IsVideoStereoscopic())
+    {
+      // no mode switches allowed, and we've got a 3D video and are running in 3D => done
+      applyMode = currentMode;
+    }
+    else
+    {
+      // TODO: we're in 3D mode, the video is 2D and mode switching is not allowed,
+      // then we've a bit of bad luck because we can't do anything about it :-(
+      applyMode = currentMode;
+    }
+
+    CLog::Log(LOGDEBUG, "StereoscopicsManager: mode switching not allowed, using stereo mode {}", ConvertGuiStereoModeToString(applyMode));
+  }
+  else if (appPlayer->IsPlaying() && IsVideoStereoscopic())
+  {
+    // a 3D video is playing, let's check if we really support the requested stereoscopic mode
+    float fps = CServiceBroker::GetDataCacheCore().GetVideoFps();
+    int width = CServiceBroker::GetDataCacheCore().GetVideoWidth();
+    int height = CServiceBroker::GetDataCacheCore().GetVideoHeight();
+
+    // request a matching resolution
+    uint32_t mode3dFlags = CServiceBroker::GetWinSystem()->GetGfxContext().ConvertRenderStereoModeToMode3dFlags(applyMode);
+    RESOLUTION res = CResolutionUtils::ChooseBestResolution(static_cast<float>(fps), width, height, mode3dFlags);
+    RENDER_STEREO_MODE rsm = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderStereoModeFromResolution(res);
+
+    // check if we've got what we've requested
+    if (rsm != applyMode && rsm == RENDER_STEREO_MODE_OFF)
+    {
+      // nope, check for possible fallbacks in case of MVC/FP playback
+      if (applyMode == RENDER_STEREO_MODE_HARDWAREBASED)
+      {
+        // check SBS fallback for MVC/FP output
+   	    res = CResolutionUtils::ChooseBestResolution(static_cast<float>(fps), width, height, D3DPRESENTFLAG_MODE3DSBS);
+   	    rsm = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderStereoModeFromResolution(res);
+   	    if (rsm != RENDER_STEREO_MODE_SPLIT_VERTICAL)
+   	    {
+          // check TAB fallback for MVC/FP output
+   	      res = CResolutionUtils::ChooseBestResolution(static_cast<float>(fps), width, height, D3DPRESENTFLAG_MODE3DTB);
+   	      rsm = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderStereoModeFromResolution(res);
+          if (rsm != RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+        	rsm = RENDER_STEREO_MODE_MONO;
+   	    }
+      	applyMode = rsm;
+      }
+      else
+        applyMode = RENDER_STEREO_MODE_MONO;
+    }
+  }
+
   if (applyMode != currentMode && applyMode >= RENDER_STEREO_MODE_OFF)
   {
     if (CServiceBroker::GetRenderSystem()->SupportsStereo(applyMode))
@@ -198,6 +264,15 @@ std::string CStereoscopicsManager::DetectStereoModeByString(const std::string &n
   if (re.RegFind(searchString) > -1)
     stereoMode = "top_bottom";
 
+  if (!re.RegComp(CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_stereoscopicregex_mvc))
+  {
+    CLog::Log(LOGERROR, "{}: Invalid RegExp for matching 3d MVC content:'{}'", __FUNCTION__, CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_stereoscopicregex_mvc);
+    return stereoMode;
+  }
+
+  if (re.RegFind(searchString) > -1)
+    stereoMode = "block_lr";
+
   return stereoMode;
 }
 
@@ -304,7 +379,7 @@ int CStereoscopicsManager::ConvertVideoToGuiStereoMode(const std::string &mode)
   size_t i = 0;
   while (VideoModeToGuiModeMap[i].name)
   {
-    if (mode == VideoModeToGuiModeMap[i].name)
+    if (mode == VideoModeToGuiModeMap[i].name && CServiceBroker::GetRenderSystem()->SupportsStereo(VideoModeToGuiModeMap[i].mode))
       return VideoModeToGuiModeMap[i].mode;
     i++;
   }
diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.cpp b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
index 67f3d14875..d2d785ef4c 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.cpp
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
@@ -60,6 +60,8 @@ bool CLanguageInvokerThread::execute(const std::string &script, const std::vecto
 
   //Todo wait until running
 
+  SetPriority(ThreadPriority::BELOW_NORMAL);
+
   return true;
 }
 
@@ -130,4 +132,4 @@ void CLanguageInvokerThread::OnException()
 
   m_invoker->onExecutionFailed();
   m_invocationManager->OnExecutionDone(GetId());
-}
\ No newline at end of file
+}
diff --git a/xbmc/messaging/ApplicationMessenger.h b/xbmc/messaging/ApplicationMessenger.h
index d09549e215..05111e81f5 100644
--- a/xbmc/messaging/ApplicationMessenger.h
+++ b/xbmc/messaging/ApplicationMessenger.h
@@ -87,6 +87,8 @@
 /// @brief Called from the player when its current item is updated
 #define TMSG_UPDATE_PLAYER_ITEM TMSG_MASK_APPLICATION + 35
 
+#define TMSG_AML_RESIZE                   TMSG_MASK_APPLICATION + 36
+
 #define TMSG_GUI_INFOLABEL                TMSG_MASK_GUIINFOMANAGER + 0
 #define TMSG_GUI_INFOBOOL                 TMSG_MASK_GUIINFOMANAGER + 1
 #define TMSG_UPDATE_CURRENT_ITEM          TMSG_MASK_GUIINFOMANAGER + 2
@@ -94,6 +96,7 @@
 #define TMSG_CECTOGGLESTATE               TMSG_MASK_PERIPHERALS + 1
 #define TMSG_CECACTIVATESOURCE            TMSG_MASK_PERIPHERALS + 2
 #define TMSG_CECSTANDBY                   TMSG_MASK_PERIPHERALS + 3
+#define TMSG_CECACTIVATESOURCEOSMCWAKEUP  TMSG_MASK_PERIPHERALS + 4
 
 #define TMSG_GUI_DIALOG_OPEN              TMSG_MASK_WINDOWMANAGER + 1
 #define TMSG_GUI_ACTIVATE_WINDOW          TMSG_MASK_WINDOWMANAGER + 2
diff --git a/xbmc/network/Network.cpp b/xbmc/network/Network.cpp
index 69a1513627..1dede45766 100644
--- a/xbmc/network/Network.cpp
+++ b/xbmc/network/Network.cpp
@@ -18,6 +18,8 @@
 #include "settings/Settings.h"
 #include "settings/SettingsComponent.h"
 #include "utils/log.h"
+#include "application/ApplicationComponents.h"
+#include "application/ApplicationPowerHandling.h"
 #ifdef TARGET_WINDOWS
 #include "platform/win32/WIN32Util.h"
 #include "utils/CharsetConverter.h"
@@ -227,6 +229,13 @@ void CNetworkBase::NetworkMessage(EMESSAGE message, int param)
 
 bool CNetworkBase::WakeOnLan(const char* mac)
 {
+  auto& components = CServiceBroker::GetAppComponents();
+  const auto appPower = components.GetComponent<CApplicationPowerHandling>();
+  if (appPower->isVeroStandby())
+  {
+    CLog::Log(LOGDEBUG, "{} - Vero is in standby, not sending WOL packet", __FUNCTION__);
+    return false;
+  }
   int i, j, packet;
   unsigned char ethaddr[8];
   unsigned char buf [128];
@@ -459,9 +468,9 @@ std::vector<SOCKET> CreateTCPServerSocket(const int port, const bool bindLocal,
 
 void CNetworkBase::WaitForNet()
 {
-  const int timeout = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_POWERMANAGEMENT_WAITFORNETWORK);
+  int timeout = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_POWERMANAGEMENT_WAITFORNETWORK);
   if (timeout <= 0)
-    return; // wait for network is disabled
+    timeout = 1;
 
   // check if we have at least one network interface to wait for
   if (!IsAvailable())
diff --git a/xbmc/peripherals/Peripherals.cpp b/xbmc/peripherals/Peripherals.cpp
index 3dc5ca6a9c..ab7fb88b80 100644
--- a/xbmc/peripherals/Peripherals.cpp
+++ b/xbmc/peripherals/Peripherals.cpp
@@ -1001,6 +1001,10 @@ void CPeripherals::OnApplicationMessage(MESSAGING::ThreadMessage* pMsg)
       ToggleDeviceState(STATE_ACTIVATE_SOURCE);
       break;
 
+    case TMSG_CECACTIVATESOURCEOSMCWAKEUP:
+      ToggleDeviceState(STATE_ACTIVATE_SOURCE_OSMC_WAKEUP);
+      break;
+
     case TMSG_CECSTANDBY:
       ToggleDeviceState(STATE_STANDBY);
       break;
diff --git a/xbmc/peripherals/devices/Peripheral.h b/xbmc/peripherals/devices/Peripheral.h
index 8c4049b67a..b10ae211f4 100644
--- a/xbmc/peripherals/devices/Peripheral.h
+++ b/xbmc/peripherals/devices/Peripheral.h
@@ -56,7 +56,8 @@ typedef enum
 {
   STATE_SWITCH_TOGGLE,
   STATE_ACTIVATE_SOURCE,
-  STATE_STANDBY
+  STATE_STANDBY,
+  STATE_ACTIVATE_SOURCE_OSMC_WAKEUP
 } CecStateChange;
 
 class CPeripheral : public KODI::JOYSTICK::IInputProvider,
diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index f27dcfbbba..456d566510 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -1836,7 +1836,7 @@ bool CPeripheralCecAdapter::ToggleDeviceState(CecStateChange mode /*= STATE_SWIT
     StandbyDevices();
     return false;
   }
-  else if (mode == STATE_SWITCH_TOGGLE || mode == STATE_ACTIVATE_SOURCE)
+  else if (mode == STATE_SWITCH_TOGGLE || mode == STATE_ACTIVATE_SOURCE || mode == STATE_ACTIVATE_SOURCE_OSMC_WAKEUP)
   {
     CLog::Log(LOGDEBUG, "{} - waking up CEC device...", __FUNCTION__);
     ActivateSource();
diff --git a/xbmc/platform/linux/CMakeLists.txt b/xbmc/platform/linux/CMakeLists.txt
index 31f4cefd3c..e0b93006c7 100644
--- a/xbmc/platform/linux/CMakeLists.txt
+++ b/xbmc/platform/linux/CMakeLists.txt
@@ -29,4 +29,9 @@ if(ADDONS_CONFIGURE_AT_STARTUP)
   add_compile_definitions(ADDONS_CONFIGURE_AT_STARTUP)
 endif()
 
+if("aml" IN_LIST CORE_PLATFORM_NAME_LC)
+  list(APPEND SOURCES ScreenshotSurfaceAML.cpp)
+  list(APPEND HEADERS ScreenshotSurfaceAML.h)
+endif()
+
 core_add_library(linuxsupport)
diff --git a/xbmc/platform/linux/PlatformLinux.cpp b/xbmc/platform/linux/PlatformLinux.cpp
index a7af09824d..0ee39231fd 100644
--- a/xbmc/platform/linux/PlatformLinux.cpp
+++ b/xbmc/platform/linux/PlatformLinux.cpp
@@ -32,6 +32,9 @@
 #if defined(HAVE_GBM)
 #include "windowing/gbm/WinSystemGbmGLESContext.h"
 #endif
+#if defined(HAS_LIBAMCODEC)
+#include "windowing/amlogic/WinSystemAmlogicGLESContext.h"
+#endif
 #endif
 
 #if defined(HAS_GL)
@@ -71,6 +74,9 @@ bool CPlatformLinux::InitStageOne()
 #if defined(HAVE_GBM)
   KODI::WINDOWING::GBM::CWinSystemGbmGLESContext::Register();
 #endif
+#if defined(HAS_LIBAMCODEC)
+  KODI::WINDOWING::AML::CWinSystemAmlogicGLESContext::Register();
+#endif
 #endif
 
 #if defined(HAS_GL)
diff --git a/xbmc/platform/linux/ScreenshotSurfaceAML.cpp b/xbmc/platform/linux/ScreenshotSurfaceAML.cpp
new file mode 100644
index 0000000000..82468ab615
--- /dev/null
+++ b/xbmc/platform/linux/ScreenshotSurfaceAML.cpp
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  Copyright (C) 2020-present Team CoreELEC (https://coreelec.org)
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "ServiceBroker.h"
+#include "threads/SingleLock.h"
+#include "ScreenshotSurfaceAML.h"
+#include "utils/Screenshot.h"
+#include "utils/ScreenshotAML.h"
+#include "utils/log.h"
+#include "system_gl.h"
+
+void CScreenshotSurfaceAML::Register()
+{
+  CScreenShot::Register(CScreenshotSurfaceAML::CreateSurface);
+}
+
+std::unique_ptr<IScreenshotSurface> CScreenshotSurfaceAML::CreateSurface()
+{
+  return std::unique_ptr<CScreenshotSurfaceAML>(new CScreenshotSurfaceAML());
+}
+
+bool CScreenshotSurfaceAML::Capture()
+{
+  std::unique_lock<CCriticalSection> lock(CServiceBroker::GetWinSystem()->GetGfxContext());
+  CServiceBroker::GetGUI()->GetWindowManager().Render();
+
+#ifndef HAS_GLES
+  glReadBuffer(GL_BACK);
+#endif
+
+  //get current viewport
+  GLint viewport[4];
+  glGetIntegerv(GL_VIEWPORT, viewport);
+
+  m_width  = viewport[2] - viewport[0];
+  m_height = viewport[3] - viewport[1];
+  m_stride = m_width * 4;
+  unsigned char* surface = new unsigned char[m_stride * m_height];
+
+  //read pixels from the backbuffer
+#if HAS_GLES >= 2
+  glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid*)surface);
+#else
+  glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)surface);
+#endif
+
+  //make a new buffer and copy the read image to it with the Y axis inverted
+  m_buffer = new unsigned char[m_stride * m_height];
+  for (int y = 0; y < m_height; y++)
+  {
+#ifdef HAS_GLES
+    // we need to save in BGRA order so XOR Swap RGBA -> BGRA
+    unsigned char* swap_pixels = surface + (m_height - y - 1) * m_stride;
+    for (int x = 0; x < m_width; x++, swap_pixels+=4)
+    {
+      std::swap(swap_pixels[0], swap_pixels[2]);
+    }
+#endif
+    memcpy(m_buffer + y * m_stride, surface + (m_height - y - 1) *m_stride, m_stride);
+  }
+
+  delete [] surface;
+
+  // Captures the current visible videobuffer and blend it into m_buffer (captured overlay)
+  CScreenshotAML::CaptureVideoFrame(m_buffer, m_width, m_height);
+  return true;
+}
diff --git a/xbmc/platform/linux/ScreenshotSurfaceAML.h b/xbmc/platform/linux/ScreenshotSurfaceAML.h
new file mode 100644
index 0000000000..49ee74c757
--- /dev/null
+++ b/xbmc/platform/linux/ScreenshotSurfaceAML.h
@@ -0,0 +1,23 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  Copyright (C) 2020-present Team CoreELEC (https://coreelec.org)
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "utils/IScreenshotSurface.h"
+
+#include <memory>
+
+class CScreenshotSurfaceAML : public IScreenshotSurface
+{
+public:
+  static void Register();
+  static std::unique_ptr<IScreenshotSurface> CreateSurface();
+
+  bool Capture() override;
+};
diff --git a/xbmc/platform/linux/input/CMakeLists.txt b/xbmc/platform/linux/input/CMakeLists.txt
index ebb2ccd585..07c39b6058 100644
--- a/xbmc/platform/linux/input/CMakeLists.txt
+++ b/xbmc/platform/linux/input/CMakeLists.txt
@@ -6,7 +6,8 @@ if(LIRCCLIENT_FOUND)
   list(APPEND HEADERS LIRC.h)
 endif()
 
-if("gbm" IN_LIST CORE_PLATFORM_NAME_LC)
+if("aml" IN_LIST CORE_PLATFORM_NAME_LC OR
+   "gbm" IN_LIST CORE_PLATFORM_NAME_LC)
   if(LIBINPUT_FOUND)
     list(APPEND SOURCES LibInputHandler.cpp
                         LibInputKeyboard.cpp
diff --git a/xbmc/platform/linux/storage/UDevProvider.cpp b/xbmc/platform/linux/storage/UDevProvider.cpp
index 2d94c39daa..58e17c1882 100644
--- a/xbmc/platform/linux/storage/UDevProvider.cpp
+++ b/xbmc/platform/linux/storage/UDevProvider.cpp
@@ -142,6 +142,13 @@ void CUDevProvider::GetDisks(VECSOURCES& disks, bool removable)
 
    // filter out osmc boot partition
    if (strcmp(mountpoint, "/boot") == 0)
+   {
+      udev_device_unref(device);
+      continue;
+   }
+
+   // filter out tee partition
+   if (strcmp(mountpoint, "/tee") == 0)
    {
       udev_device_unref(device);
       continue;
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 3c30817331..58eec643ec 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -123,7 +123,11 @@ bool CPowerManager::Powerdown()
 
 bool CPowerManager::Suspend()
 {
-  return (CanSuspend() && m_instance->Suspend());
+  CLog::Log(LOGINFO, "Activating standby mode");
+  auto& components = CServiceBroker::GetAppComponents();
+  const auto appPower = components.GetComponent<CApplicationPowerHandling>();
+  appPower->ActivateScreenSaverStandby();
+  return true;
 }
 
 bool CPowerManager::Hibernate()
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 67c13ab3f0..197ce567c6 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -433,7 +433,7 @@ void CAdvancedSettings::Initialize()
 
   m_pictureExtensions = ".png|.jpg|.jpeg|.bmp|.gif|.ico|.tif|.tiff|.tga|.pcx|.cbz|.zip|.rss|.webp|.jp2|.apng";
   m_musicExtensions = ".nsv|.m4a|.flac|.aac|.strm|.pls|.rm|.rma|.mpa|.wav|.wma|.ogg|.mp3|.mp2|.m3u|.gdm|.imf|.m15|.sfx|.uni|.ac3|.dts|.cue|.aif|.aiff|.wpl|.xspf|.ape|.mac|.mpc|.mp+|.mpp|.shn|.zip|.wv|.dsp|.xsp|.xwav|.waa|.wvs|.wam|.gcm|.idsp|.mpdsp|.mss|.spt|.rsd|.sap|.cmc|.cmr|.dmc|.mpt|.mpd|.rmt|.tmc|.tm8|.tm2|.oga|.url|.pxml|.tta|.rss|.wtv|.mka|.tak|.opus|.dff|.dsf|.m4b|.dtshd";
-  m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.mpd|.m3u|.m3u8|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.udf|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.mk3d|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.001|.wpl|.xspf|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls|.mpl|.webm|.bdmv|.bdm|.wtv|.trp|.f4v";
+  m_videoExtensions = ".m4v|.3g2|.3gp|.nsv|.tp|.ts|.ty|.strm|.pls|.rm|.rmvb|.mpd|.m3u|.m3u8|.ifo|.mov|.qt|.divx|.xvid|.bivx|.vob|.nrg|.img|.iso|.udf|.pva|.wmv|.asf|.asx|.ogm|.m2v|.avi|.bin|.dat|.mpg|.mpeg|.mp4|.mkv|.mk3d|.avc|.vp3|.svq3|.nuv|.viv|.dv|.fli|.flv|.001|.wpl|.xspf|.zip|.vdr|.dvr-ms|.xsp|.mts|.m2t|.m2ts|.evo|.ogv|.sdp|.avs|.rec|.url|.pxml|.vc1|.h264|.rcv|.rss|.mpls|.mpl|.webm|.bdmv|.bdm|.wtv|.trp|.f4v|.ssif";
   m_subtitlesExtensions = ".utf|.utf8|.utf-8|.sub|.srt|.smi|.rt|.txt|.ssa|.text|.ssa|.aqt|.jss|"
                           ".ass|.vtt|.idx|.ifo|.zip|.sup";
   m_discStubExtensions = ".disc";
@@ -445,6 +445,7 @@ void CAdvancedSettings::Initialize()
   m_stereoscopicregex_3d = "[-. _]3d[-. _]";
   m_stereoscopicregex_sbs = "[-. _]h?sbs[-. _]";
   m_stereoscopicregex_tab = "[-. _]h?tab[-. _]";
+  m_stereoscopicregex_mvc = "[-. _]h?mvc[-. _]";
 
   m_logLevelHint = m_logLevel = LOG_LEVEL_NORMAL;
 
@@ -607,6 +608,7 @@ void CAdvancedSettings::ParseSettingsFile(const std::string &file)
     XMLUtils::GetString(pElement, "stereoscopicregex3d", m_stereoscopicregex_3d);
     XMLUtils::GetString(pElement, "stereoscopicregexsbs", m_stereoscopicregex_sbs);
     XMLUtils::GetString(pElement, "stereoscopicregextab", m_stereoscopicregex_tab);
+    XMLUtils::GetString(pElement, "stereoscopicregexmvc", m_stereoscopicregex_mvc);
     XMLUtils::GetFloat(pElement, "subsdelayrange", m_videoSubsDelayRange, 10, 600);
     XMLUtils::GetFloat(pElement, "audiodelayrange", m_videoAudioDelayRange, 10, 600);
     XMLUtils::GetString(pElement, "defaultplayer", m_videoDefaultPlayer);
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 4ba4e7e8b0..40433f443d 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -376,6 +376,7 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     std::string m_stereoscopicregex_3d;
     std::string m_stereoscopicregex_sbs;
     std::string m_stereoscopicregex_tab;
+    std::string m_stereoscopicregex_mvc;
 
     bool m_openGlDebugging;
 
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
old mode 100644
new mode 100755
index 725bbc46c7..bb48ce302c
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -23,6 +23,7 @@
 #include "settings/lib/SettingDefinitions.h"
 #include "storage/MediaManager.h"
 #include "utils/StringUtils.h"
+#include "utils/SysfsUtils.h"
 #include "utils/Variant.h"
 #include "utils/XMLUtils.h"
 #include "utils/log.h"
@@ -73,6 +74,8 @@ static std::string ModeFlagsToString(unsigned int flags, bool identifier)
     res += "sbs";
   else if(flags & D3DPRESENTFLAG_MODE3DTB)
     res += "tab";
+  else if(flags & D3DPRESENTFLAG_MODE3DFP)
+    res += "fp";
   else if(identifier)
     res += "std";
   return res;
@@ -251,7 +254,6 @@ bool CDisplaySettings::OnSettingChanging(const std::shared_ptr<const CSetting>&
 {
   if (setting == NULL)
     return false;
-
   const std::string &settingId = setting->GetId();
   if (settingId == CSettings::SETTING_VIDEOSCREEN_RESOLUTION ||
       settingId == CSettings::SETTING_VIDEOSCREEN_SCREEN)
@@ -288,10 +290,21 @@ bool CDisplaySettings::OnSettingChanging(const std::shared_ptr<const CSetting>&
     // in which case we don't show any prompt to the user
     if (oldRes != RES_WINDOW && newRes != RES_WINDOW && oldRes != newRes)
     {
-      if (!m_resolutionChangeAborted)
-      {
-        if (HELPERS::ShowYesNoDialogText(CVariant{13110}, CVariant{13111}, CVariant{""},
-                                         CVariant{""}, 15000) != DialogResponse::CHOICE_YES)
+        if (!m_resolutionChangeAborted)
+        {
+          /* If new resolution is 4K, then warn user this is not advised */
+          RESOLUTION_INFO resInfo = GetResolutionInfo(newRes);
+          if (resInfo.iScreenHeight >= 2160)
+          {
+            CLog::Log(LOGWARNING, "The user has chosen a UHD resolution. We will warn them not to apply this");
+            if (HELPERS::ShowYesNoDialogText(CVariant{13110}, CVariant{40064}, CVariant{""}, CVariant{""}, 15000) != DialogResponse::CHOICE_YES)
+            {
+              m_resolutionChangeAborted = true;
+              return false;
+            }
+        }
+        if (HELPERS::ShowYesNoDialogText(CVariant{13110}, CVariant{13111}, CVariant{""}, CVariant{""}, 15000) !=
+          DialogResponse::CHOICE_YES)
         {
           m_resolutionChangeAborted = true;
           return false;
@@ -330,6 +343,49 @@ bool CDisplaySettings::OnSettingChanging(const std::shared_ptr<const CSetting>&
     return true;
 #endif
   }
+  else if (settingId == CSettings::SETTING_VIDEOSCREEN_FORCE422){
+    std::string attr = "";
+    SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/attr", attr);
+
+    if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_FORCE422)) {
+      if (attr.find("444") != std::string::npos ||
+          attr.find("422") != std::string::npos ||
+          attr.find("420") != std::string::npos)
+        attr.replace(attr.find("4"),3,"422").append("now");
+      else
+        attr.append("422now");
+    }
+    else {
+      if (attr.find("422") != std::string::npos)
+        attr.erase(attr.find("4"),3);
+      attr.append("now");
+    }
+    CLog::Log(LOGDEBUG, "CDisplaySettings::OnSettingChanging -- setting 422 output, attr = {}", attr);
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/attr", attr.c_str());
+  }
+  else if (settingId == CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGEAML)
+  {
+    int range_control;
+    std::string attr = "";
+
+    SysfsUtils::GetInt("/sys/module/am_vecm/parameters/range_control", range_control);
+    if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGEAML)) 
+      range_control &= 1;
+    else
+      range_control |= 2;
+    CLog::Log(LOGDEBUG, "CDisplaySettings::OnSettingChanging -- setting quantization range to {}", range_control & 2 ? "full" : "limited");
+    SysfsUtils::SetInt("/sys/module/am_vecm/parameters/range_control", range_control);
+    SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/attr", attr);
+    attr.append("now");
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/attr", attr.c_str());
+  }
+  else if (settingId == CSettings::SETTING_VIDEOSCREEN_MAXLUM)
+  {
+     int maxlum = 100;
+     maxlum = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOSCREEN_MAXLUM);
+     CLog::Log(LOGDEBUG, "CDisplaySettings::OnSettingChanging -- setting max lum to {}", maxlum);
+     SysfsUtils::SetInt("/sys/module/am_vecm/parameters/customer_panel_lumin", maxlum);
+  }
 #if defined(HAVE_X11) || defined(TARGET_WINDOWS_DESKTOP) || defined(TARGET_DARWIN_OSX)
   else if (settingId == CSettings::SETTING_VIDEOSCREEN_BLANKDISPLAYS)
   {
@@ -488,24 +544,6 @@ void CDisplaySettings::AddResolutionInfo(const RESOLUTION_INFO &resolution)
   std::unique_lock<CCriticalSection> lock(m_critical);
   RESOLUTION_INFO res(resolution);
 
-  if((res.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-  {
-    /* add corrections for some special case modes frame packing modes */
-
-    if(res.iScreenWidth  == 1920
-    && res.iScreenHeight == 2205)
-    {
-      res.iBlanking = 45;
-      res.dwFlags  |= D3DPRESENTFLAG_MODE3DTB;
-    }
-
-    if(res.iScreenWidth  == 1280
-    && res.iScreenHeight == 1470)
-    {
-      res.iBlanking = 30;
-      res.dwFlags  |= D3DPRESENTFLAG_MODE3DTB;
-    }
-  }
   m_resolutions.push_back(res);
 }
 
@@ -518,7 +556,14 @@ void CDisplaySettings::ApplyCalibrations()
     // find resolutions
     for (size_t res = RES_DESKTOP; res < m_resolutions.size(); ++res)
     {
-      if (StringUtils::EqualsNoCase(itCal->strMode, m_resolutions[res].strMode))
+      if (StringUtils::EqualsNoCase(itCal->strMode, m_resolutions[res].strMode) && (m_resolutions[res].dwFlags & D3DPRESENTFLAG_MODE3DMASK))
+      {
+        // in case of 3D resolutions we ignore overscan settings and just update the subtitle position
+        m_resolutions[res].iSubtitles = itCal->iSubtitles;
+        if (m_resolutions[res].iSubtitles < 0)
+          m_resolutions[res].iSubtitles = 0;
+      }
+      else if (StringUtils::EqualsNoCase(itCal->strMode, m_resolutions[res].strMode))
       {
         // overscan
         m_resolutions[res].Overscan.left = itCal->Overscan.left;
@@ -556,7 +601,6 @@ void CDisplaySettings::ApplyCalibrations()
           m_resolutions[res].fPixelRatio = 0.5f;
         if (m_resolutions[res].fPixelRatio > 2.0f)
           m_resolutions[res].fPixelRatio = 2.0f;
-        break;
       }
     }
   }
@@ -586,6 +630,8 @@ void CDisplaySettings::UpdateCalibrations()
       cal = *res;
     }
   }
+
+  ApplyCalibrations();
 }
 
 void CDisplaySettings::ClearCalibrations()
@@ -652,6 +698,8 @@ RESOLUTION CDisplaySettings::GetResolutionFromString(const std::string &strResol
       flags |= D3DPRESENTFLAG_MODE3DSBS;
     else if(StringUtils::Mid(strResolution, 20,3) == "tab")
       flags |= D3DPRESENTFLAG_MODE3DTB;
+    else if(StringUtils::Mid(strResolution, 20, 2) == "fp")
+      flags |= D3DPRESENTFLAG_MODE3DFP;
 
     std::map<RESOLUTION, RESOLUTION_INFO> resolutionInfos;
     for (size_t resolution = RES_DESKTOP; resolution < CDisplaySettings::GetInstance().ResolutionInfoSize(); resolution++)
@@ -663,6 +711,33 @@ RESOLUTION CDisplaySettings::GetResolutionFromString(const std::string &strResol
   return RES_DESKTOP;
 }
 
+std::string CDisplaySettings::GetDisplayStringFromRes(const RESOLUTION res, bool withRefreshRate) const
+{
+  RESOLUTION_INFO info = GetResolutionInfo(res);
+
+  std::string stereo = "(2D)";
+
+  if (info.dwFlags & D3DPRESENTFLAG_MODE3DMASK)
+  {
+    stereo = "(3D ";
+    if (info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+      stereo += "SBS)";
+    else if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+      stereo += "TAB)";
+    else if(info.dwFlags & D3DPRESENTFLAG_MODE3DFP)
+      stereo += "FP)";
+  }
+
+  std::string refRate = "";
+  if (withRefreshRate) {
+	  refRate = StringUtils::Format("{:0.2f} Hz ", info.fRefreshRate);
+  }
+
+  return StringUtils::Format("{}x{}{} {}{}",
+      info.iScreenWidth, info.iScreenHeight, info.dwFlags & D3DPRESENTFLAG_INTERLACED ? 'i' : 'p',
+      refRate, stereo);
+}
+
 std::string CDisplaySettings::GetStringFromResolution(RESOLUTION resolution, float refreshrate /* = 0.0f */)
 {
   if (resolution == RES_WINDOW)
@@ -671,13 +746,9 @@ std::string CDisplaySettings::GetStringFromResolution(RESOLUTION resolution, flo
   if (resolution >= RES_DESKTOP && resolution < (RESOLUTION)CDisplaySettings::GetInstance().ResolutionInfoSize())
   {
     const RESOLUTION_INFO &info = CDisplaySettings::GetInstance().GetResolutionInfo(resolution);
-    // also handle RES_DESKTOP resolutions with non-default refresh rates
-    if (resolution != RES_DESKTOP || (refreshrate > 0.0f && refreshrate != info.fRefreshRate))
-    {
-      return StringUtils::Format("{:05}{:05}{:09.5f}{}", info.iScreenWidth, info.iScreenHeight,
-                                 refreshrate > 0.0f ? refreshrate : info.fRefreshRate,
-                                 ModeFlagsToString(info.dwFlags, true));
-    }
+    return StringUtils::Format("{:05}{:05}{:09.5f}{}",
+        info.iScreenWidth, info.iScreenHeight,
+        refreshrate > 0.0f ? refreshrate : info.fRefreshRate, ModeFlagsToString(info.dwFlags, true));
   }
 
   return "DESKTOP";
@@ -707,14 +778,8 @@ void CDisplaySettings::SettingOptionsModesFiller(const std::shared_ptr<const CSe
     const auto mode = CDisplaySettings::GetInstance().GetResolutionInfo(index);
 
     if (mode.dwFlags ^ D3DPRESENTFLAG_INTERLACED)
-    {
-      auto setting = GetStringFromResolution((RESOLUTION)index, mode.fRefreshRate);
-
-      list.emplace_back(
-          StringUtils::Format("{}x{}{} {:0.2f}Hz", mode.iScreenWidth, mode.iScreenHeight,
-                              ModeFlagsToString(mode.dwFlags, false), mode.fRefreshRate),
-          setting);
-    }
+      list.emplace_back(CDisplaySettings::GetInstance().GetDisplayStringFromRes((RESOLUTION)index),
+                        GetStringFromResolution((RESOLUTION)index, mode.fRefreshRate));
   }
 
   std::sort(list.begin(), list.end(), ModeSort);
@@ -786,10 +851,7 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const SettingConstPtr& se
     std::vector<RESOLUTION_WHR> resolutions = CServiceBroker::GetWinSystem()->ScreenResolutions(info.fRefreshRate);
     for (std::vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
-      list.emplace_back(StringUtils::Format("{}x{}{}", resolution->width, resolution->height,
-                                            ModeFlagsToString(resolution->flags, false)),
-                        resolution->ResInfo_Index);
-
+      list.emplace_back(CDisplaySettings::GetInstance().GetDisplayStringFromRes((RESOLUTION)resolution->ResInfo_Index, false), resolution->ResInfo_Index);
       resolutionInfos.insert(std::make_pair((RESOLUTION)resolution->ResInfo_Index, CDisplaySettings::GetInstance().GetResolutionInfo(resolution->ResInfo_Index)));
     }
 
diff --git a/xbmc/settings/DisplaySettings.h b/xbmc/settings/DisplaySettings.h
index e02e80c8e3..2bf70694f8 100644
--- a/xbmc/settings/DisplaySettings.h
+++ b/xbmc/settings/DisplaySettings.h
@@ -73,6 +73,7 @@ public:
   RESOLUTION_INFO& GetCurrentResolutionInfo() { return GetResolutionInfo(m_currentResolution); }
   RESOLUTION GetResFromString(const std::string &strResolution) { return GetResolutionFromString(strResolution); }
   std::string GetStringFromRes(const RESOLUTION resolution, float refreshrate = 0.0f) { return GetStringFromResolution(resolution, refreshrate); }
+  std::string GetDisplayStringFromRes(const RESOLUTION resolution, bool withRefreshRate = true) const;
 
   void ApplyCalibrations();
   void UpdateCalibrations();
diff --git a/xbmc/settings/SettingConditions.cpp b/xbmc/settings/SettingConditions.cpp
index bb85e97b67..b4bd620df5 100644
--- a/xbmc/settings/SettingConditions.cpp
+++ b/xbmc/settings/SettingConditions.cpp
@@ -24,6 +24,9 @@
 #include "settings/SettingAddon.h"
 #include "settings/SettingsComponent.h"
 #include "utils/FontUtils.h"
+#if defined(HAS_LIBAMCODEC)
+#include "utils/AMLUtils.h"
+#endif // defined(HAS_LIBAMCODEC)
 #include "utils/StringUtils.h"
 #include "windowing/WinSystem.h"
 
@@ -397,6 +400,10 @@ void CSettingConditions::Initialize()
 #ifdef TARGET_DARWIN_TVOS
   m_simpleConditions.emplace("have_tvos");
 #endif
+#ifdef HAS_LIBAMCODEC
+  if (aml_present())
+    m_simpleConditions.insert("have_amcodec");
+#endif
 #if defined(TARGET_WINDOWS)
   m_simpleConditions.emplace("has_dx");
   m_simpleConditions.emplace("hasdxva2");
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index c5486af7b8..8193b54094 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -143,6 +143,11 @@ constexpr const char* CSettings::SETTING_VIDEOPLAYER_STEREOSCOPICPLAYBACKMODE;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_QUITSTEREOMODEONSTOP;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_HQSCALERS;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEAMCODEC;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEAMCODECMPEG2;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEAMCODECMPEG4;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEAMCODECH264;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEAMCODECAV1;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEMEDIACODEC;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEMEDIACODECSURFACE;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEVDPAU;
@@ -153,6 +158,7 @@ constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEVDPAUVC1;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEDXVA2;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEVTB;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER;
+constexpr const char* CSettings::SETTING_VIDEOPLAYER_HDR_PROCESS;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_USESTAGEFRIGHT;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_LIMITGUIUPDATE;
 constexpr const char* CSettings::SETTING_VIDEOPLAYER_SUPPORTMVC;
@@ -359,6 +365,11 @@ constexpr const char* CSettings::SETTING_VIDEOSCREEN_RESOLUTION;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_SCREENMODE;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_FAKEFULLSCREEN;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_BLANKDISPLAYS;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_FORCERGB;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_LOCKHPD;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_MUTEHDMI;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_FORCE422;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_MAXLUM;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_STEREOSCOPICMODE;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_PREFEREDSTEREOSCOPICMODE;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_NOOFBUFFERS;
@@ -366,7 +377,7 @@ constexpr const char* CSettings::SETTING_VIDEOSCREEN_3DLUT;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_DISPLAYPROFILE;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_GUICALIBRATION;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_TESTPATTERN;
-constexpr const char* CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGE;
+constexpr const char* CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGEAML;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_FRAMEPACKING;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_10BITSURFACES;
 constexpr const char* CSettings::SETTING_VIDEOSCREEN_GUISDRPEAKLUMINANCE;
@@ -982,6 +993,8 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_SCREEN);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_RESOLUTION);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_SCREENMODE);
+  settingSet.insert(CSettings::SETTING_VIDEOSCREEN_FORCE422);
+  settingSet.insert(CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGEAML);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_MONITOR);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_PREFEREDSTEREOSCOPICMODE);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_3DLUT);
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index cdd2d31ae3..ae8ee4a8c8 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -115,6 +115,11 @@ public:
       "videoplayer.quitstereomodeonstop";
   static constexpr auto SETTING_VIDEOPLAYER_RENDERMETHOD = "videoplayer.rendermethod";
   static constexpr auto SETTING_VIDEOPLAYER_HQSCALERS = "videoplayer.hqscalers";
+  static constexpr auto SETTING_VIDEOPLAYER_USEAMCODEC = "videoplayer.useamcodec";
+  static constexpr auto SETTING_VIDEOPLAYER_USEAMCODECMPEG2 = "videoplayer.useamcodecmpeg2";
+  static constexpr auto SETTING_VIDEOPLAYER_USEAMCODECMPEG4 = "videoplayer.useamcodecmpeg4";
+  static constexpr auto SETTING_VIDEOPLAYER_USEAMCODECH264 = "videoplayer.useamcodech264";
+  static constexpr auto SETTING_VIDEOPLAYER_USEAMCODECAV1 = "videoplayer.useamcodecav1";
   static constexpr auto SETTING_VIDEOPLAYER_USEMEDIACODEC = "videoplayer.usemediacodec";
   static constexpr auto SETTING_VIDEOPLAYER_USEMEDIACODECSURFACE =
       "videoplayer.usemediacodecsurface";
@@ -126,6 +131,7 @@ public:
   static constexpr auto SETTING_VIDEOPLAYER_USEDXVA2 = "videoplayer.usedxva2";
   static constexpr auto SETTING_VIDEOPLAYER_USEVTB = "videoplayer.usevtb";
   static constexpr auto SETTING_VIDEOPLAYER_USEPRIMEDECODER = "videoplayer.useprimedecoder";
+  static constexpr auto SETTING_VIDEOPLAYER_HDR_PROCESS = "videoplayer.amlhdrmodes";
   static constexpr auto SETTING_VIDEOPLAYER_USESTAGEFRIGHT = "videoplayer.usestagefright";
   static constexpr auto SETTING_VIDEOPLAYER_LIMITGUIUPDATE = "videoplayer.limitguiupdate";
   static constexpr auto SETTING_VIDEOPLAYER_SUPPORTMVC = "videoplayer.supportmvc";
@@ -354,6 +360,11 @@ public:
   static constexpr auto SETTING_VIDEOSCREEN_SCREENMODE = "videoscreen.screenmode";
   static constexpr auto SETTING_VIDEOSCREEN_FAKEFULLSCREEN = "videoscreen.fakefullscreen";
   static constexpr auto SETTING_VIDEOSCREEN_BLANKDISPLAYS = "videoscreen.blankdisplays";
+  static constexpr auto SETTING_VIDEOSCREEN_FORCERGB = "videoscreen.forcergb";
+  static constexpr auto SETTING_VIDEOSCREEN_LOCKHPD = "videoscreen.lockhpd";
+  static constexpr auto SETTING_VIDEOSCREEN_MUTEHDMI = "videoscreen.mutehdmi";
+  static constexpr auto SETTING_VIDEOSCREEN_FORCE422 = "videoscreen.force422";
+  static constexpr auto SETTING_VIDEOSCREEN_MAXLUM = "videoscreen.maxlum";
   static constexpr auto SETTING_VIDEOSCREEN_STEREOSCOPICMODE = "videoscreen.stereoscopicmode";
   static constexpr auto SETTING_VIDEOSCREEN_PREFEREDSTEREOSCOPICMODE =
       "videoscreen.preferedstereoscopicmode";
@@ -363,6 +374,7 @@ public:
   static constexpr auto SETTING_VIDEOSCREEN_GUICALIBRATION = "videoscreen.guicalibration";
   static constexpr auto SETTING_VIDEOSCREEN_TESTPATTERN = "videoscreen.testpattern";
   static constexpr auto SETTING_VIDEOSCREEN_LIMITEDRANGE = "videoscreen.limitedrange";
+  static constexpr auto SETTING_VIDEOSCREEN_LIMITEDRANGEAML = "videoscreen.limitedrangeaml";
   static constexpr auto SETTING_VIDEOSCREEN_FRAMEPACKING = "videoscreen.framepacking";
   static constexpr auto SETTING_VIDEOSCREEN_10BITSURFACES = "videoscreen.10bitsurfaces";
   static constexpr auto SETTING_VIDEOSCREEN_GUISDRPEAKLUMINANCE = "videoscreen.guisdrpeakluminance";
diff --git a/xbmc/storage/MediaManager.cpp b/xbmc/storage/MediaManager.cpp
index 442f8366a8..a23986f928 100644
--- a/xbmc/storage/MediaManager.cpp
+++ b/xbmc/storage/MediaManager.cpp
@@ -697,6 +697,8 @@ void CMediaManager::OnStorageAdded(const MEDIA_DETECT::STORAGE::StorageDevice& d
 {
 if (device.path == "/boot")
   return;
+if (device.path == "/tee")
+  return;
 #ifdef HAS_DVD_DRIVE
   const std::shared_ptr<CSettings> settings = CServiceBroker::GetSettingsComponent()->GetSettings();
   if (settings->GetInt(CSettings::SETTING_AUDIOCDS_AUTOACTION) != AUTOCD_NONE || settings->GetBool(CSettings::SETTING_DVDS_AUTORUN))
diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
new file mode 100644
index 0000000000..c52421d237
--- /dev/null
+++ b/xbmc/utils/AMLUtils.cpp
@@ -0,0 +1,903 @@
+/*
+ *  Copyright (C) 2011-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <string>
+
+#include "AMLUtils.h"
+#include "utils/CPUInfo.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "utils/StringUtils.h"
+#include "windowing/GraphicContext.h"
+#include "utils/RegExp.h"
+#include "filesystem/SpecialProtocol.h"
+#include "rendering/RenderSystem.h"
+
+#include "linux/fb.h"
+#include <sys/ioctl.h>
+
+
+bool aml_present()
+{
+  static int has_aml = -1;
+  if (has_aml == -1)
+  {
+    if (SysfsUtils::Has("/sys/class/audiodsp/digital_raw"))
+      has_aml = 1;
+    else
+      has_aml = 0;
+    if (has_aml)
+      CLog::Log(LOGINFO, "AML device detected");
+  }
+  return has_aml == 1;
+}
+
+bool aml_permissions()
+{
+  if (!aml_present())
+    return false;
+
+  static int permissions_ok = -1;
+  if (permissions_ok == -1)
+  {
+    permissions_ok = 1;
+
+    if (!SysfsUtils::HasRW("/dev/tee0"))
+    {
+      CLog::Log(LOGWARNING, "AML: no rw on /dev/tee0");
+    }
+    if (!SysfsUtils::HasRW("/dev/amvideo"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /dev/amvideo");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/dev/amstream_mpts"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /dev/amstream*");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/class/video/axis"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/video/axis");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/class/video/screen_mode"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/video/screen_mode");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/class/video/disable_video"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/video/disable_video");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/class/tsync/pts_pcrscr"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/tsync/pts_pcrscr");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/dev/video10"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /dev/video10");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amlvideodri/parameters/freerun_mode"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amlvideodri/parameters/freerun_mode");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/video/freerun_mode"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/video/freerun_mode");
+      permissions_ok = 0;
+    }
+    if (!SysfsUtils::HasRW("/sys/class/audiodsp/digital_raw"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/audiodsp/digital_raw");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/amhdmitx/amhdmitx0/config"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/amhdmitx/amhdmitx0/config");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/vfm/map"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/vfm/map");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/tsync/enable"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/tsync/enable");
+    }
+    if (!SysfsUtils::HasRW("/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq");
+    }
+    if (!SysfsUtils::HasRW("/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq");
+    }
+    if (!SysfsUtils::HasRW("/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor");
+    }
+    if (aml_has_frac_rate_policy() && !SysfsUtils::HasRW("/sys/class/amhdmitx/amhdmitx0/frac_rate_policy"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/amhdmitx/amhdmitx0/frac_rate_policy");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/di/parameters/bypass_prog"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/di/parameters/bypass_prog");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/display/mode"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/display/mode");
+    }
+    if (!SysfsUtils::HasRW("/sys/class/amhdmitx/amhdmitx0/phy"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/class/amhdmitx/amhdmitx0/phy");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amvideo/parameters/framepacking_support"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amvideo/parameters/framepacking_support");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amvideo/parameters/framepacking_width"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amvideo/parameters/framepacking_width");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amvideo/parameters/framepacking_height"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amvideo/parameters/framepacking_height");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amvideo/parameters/framepacking_blank"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amvideo/parameters/framepacking_blank");
+    }
+    if (!SysfsUtils::HasRW("/sys/module/amvdec_h264mvc/parameters/view_mode"))
+    {
+      CLog::Log(LOGERROR, "AML: no rw on /sys/module/amvdec_h264mvc/parameters/view_mode");
+    }
+  }
+
+  return permissions_ok == 1;
+}
+
+bool aml_support_hevc()
+{
+  static int has_hevc = -1;
+
+  if (has_hevc == -1)
+  {
+    std::string valstr;
+    if(SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_hevc = 0;
+    else
+      has_hevc = (valstr.find("hevc:") != std::string::npos) ? 1: 0;
+  }
+  return (has_hevc == 1);
+}
+
+bool aml_support_hevc_4k2k()
+{
+  static int has_hevc_4k2k = -1;
+
+  if (has_hevc_4k2k == -1)
+  {
+    CRegExp regexp;
+    regexp.RegComp("hevc:.*4k");
+    std::string valstr;
+    if (SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_hevc_4k2k = 0;
+    else
+      has_hevc_4k2k = (regexp.RegFind(valstr) >= 0) ? 1 : 0;
+  }
+  return (has_hevc_4k2k == 1);
+}
+
+bool aml_support_hevc_10bit()
+{
+  static int has_hevc_10bit = -1;
+
+  if (has_hevc_10bit == -1)
+  {
+    CRegExp regexp;
+    regexp.RegComp("hevc:.*10bit");
+    std::string valstr;
+    if (SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_hevc_10bit = 0;
+    else
+      has_hevc_10bit = (regexp.RegFind(valstr) >= 0) ? 1 : 0;
+  }
+  return (has_hevc_10bit == 1);
+}
+
+AML_SUPPORT_H264_4K2K aml_support_h264_4k2k()
+{
+  static AML_SUPPORT_H264_4K2K has_h264_4k2k = AML_SUPPORT_H264_4K2K_UNINIT;
+
+  if (has_h264_4k2k == AML_SUPPORT_H264_4K2K_UNINIT)
+  {
+    std::string valstr;
+    if (SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_h264_4k2k = AML_NO_H264_4K2K;
+    else if (valstr.find("h264:4k") != std::string::npos)
+      has_h264_4k2k = AML_HAS_H264_4K2K_SAME_PROFILE;
+    else if (valstr.find("h264_4k2k:") != std::string::npos)
+      has_h264_4k2k = AML_HAS_H264_4K2K;
+    else
+      has_h264_4k2k = AML_NO_H264_4K2K;
+  }
+  return has_h264_4k2k;
+}
+
+bool aml_support_vp9()
+{
+  static int has_vp9 = -1;
+
+  if (has_vp9 == -1)
+  {
+    CRegExp regexp;
+    regexp.RegComp("vp9:.*compressed");
+    std::string valstr;
+    if (SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_vp9 = 0;
+    else
+      has_vp9 = (regexp.RegFind(valstr) >= 0) ? 1 : 0;
+  }
+  return (has_vp9 == 1);
+}
+
+bool aml_support_av1()
+{
+  static int has_av1 = -1;
+
+  if (has_av1 == -1)
+  {
+    CRegExp regexp;
+    regexp.RegComp("av1:.*compressed");
+    std::string valstr;
+    if (SysfsUtils::GetString("/sys/class/amstream/vcodec_profile", valstr) != 0)
+      has_av1 = 0;
+    else
+      has_av1 = (regexp.RegFind(valstr) >= 0) ? 1 : 0;
+  }
+  return (has_av1 == 1);
+}
+
+bool aml_has_frac_rate_policy()
+{
+  static int has_frac_rate_policy = -1;
+
+  if (has_frac_rate_policy == -1)
+    has_frac_rate_policy = SysfsUtils::Has("/sys/class/amhdmitx/amhdmitx0/frac_rate_policy");
+
+  return (has_frac_rate_policy == 1);
+}
+
+void aml_set_audio_passthrough(bool passthrough)
+{
+  SysfsUtils::SetInt("/sys/class/audiodsp/digital_raw", passthrough ? 2:0);
+}
+
+void aml_probe_hdmi_audio()
+{
+  // Audio {format, channel, freq, cce}
+  // {1, 7, 7f, 7}
+  // {7, 5, 1e, 0}
+  // {2, 5, 7, 0}
+  // {11, 7, 7e, 1}
+  // {10, 7, 6, 0}
+  // {12, 7, 7e, 0}
+
+  int fd = open("/sys/class/amhdmitx/amhdmitx0/edid", O_RDONLY);
+  if (fd >= 0)
+  {
+    char valstr[1024] = {0};
+
+    read(fd, valstr, sizeof(valstr) - 1);
+    valstr[strlen(valstr)] = '\0';
+    close(fd);
+
+    std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+
+    for (std::vector<std::string>::const_iterator i = probe_str.begin(); i != probe_str.end(); ++i)
+    {
+      if (i->find("Audio") == std::string::npos)
+      {
+        for (std::vector<std::string>::const_iterator j = i + 1; j != probe_str.end(); ++j)
+        {
+          if      (j->find("{1,")  != std::string::npos)
+            printf(" PCM found {1,\n");
+          else if (j->find("{2,")  != std::string::npos)
+            printf(" AC3 found {2,\n");
+          else if (j->find("{3,")  != std::string::npos)
+            printf(" MPEG1 found {3,\n");
+          else if (j->find("{4,")  != std::string::npos)
+            printf(" MP3 found {4,\n");
+          else if (j->find("{5,")  != std::string::npos)
+            printf(" MPEG2 found {5,\n");
+          else if (j->find("{6,")  != std::string::npos)
+            printf(" AAC found {6,\n");
+          else if (j->find("{7,")  != std::string::npos)
+            printf(" DTS found {7,\n");
+          else if (j->find("{8,")  != std::string::npos)
+            printf(" ATRAC found {8,\n");
+          else if (j->find("{9,")  != std::string::npos)
+            printf(" One_Bit_Audio found {9,\n");
+          else if (j->find("{10,") != std::string::npos)
+            printf(" Dolby found {10,\n");
+          else if (j->find("{11,") != std::string::npos)
+            printf(" DTS_HD found {11,\n");
+          else if (j->find("{12,") != std::string::npos)
+            printf(" MAT found {12,\n");
+          else if (j->find("{13,") != std::string::npos)
+            printf(" ATRAC found {13,\n");
+          else if (j->find("{14,") != std::string::npos)
+            printf(" WMA found {14,\n");
+          else
+            break;
+        }
+        break;
+      }
+    }
+  }
+}
+
+int aml_axis_value(AML_DISPLAY_AXIS_PARAM param)
+{
+  std::string axis;
+  int value[8];
+
+  SysfsUtils::GetString("/sys/class/display/axis", axis);
+  sscanf(axis.c_str(), "%d %d %d %d %d %d %d %d", &value[0], &value[1], &value[2], &value[3], &value[4], &value[5], &value[6], &value[7]);
+
+  return value[param];
+}
+
+bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight= 0;
+
+  if(!mode)
+    return false;
+
+  std::string fromMode = mode;
+  StringUtils::Trim(fromMode);
+  // strips, for example, 720p* to 720p
+  // the * indicate the 'native' mode of the display
+  if (StringUtils::EndsWith(fromMode, "*"))
+    fromMode.erase(fromMode.size() - 1);
+
+  int rrate = 60;
+
+  if (StringUtils::EqualsNoCase(fromMode, "panel"))
+  {
+    res->iWidth = aml_axis_value(AML_DISPLAY_AXIS_PARAM_WIDTH);
+    res->iHeight= aml_axis_value(AML_DISPLAY_AXIS_PARAM_HEIGHT);
+    res->iScreenWidth = aml_axis_value(AML_DISPLAY_AXIS_PARAM_WIDTH);
+    res->iScreenHeight= aml_axis_value(AML_DISPLAY_AXIS_PARAM_HEIGHT);
+    res->fRefreshRate = 60;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "4k2ksmpte") || StringUtils::EqualsNoCase(fromMode, "smpte24hz"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 4096;
+    res->iScreenHeight= 2160;
+    res->fRefreshRate = 24;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else
+  {
+    int width = 0, height = 0;
+    char smode = 'p';
+
+    if (sscanf(fromMode.c_str(), "%dx%dp%dhz", &width, &height, &rrate) == 3)
+    {
+      smode = 'p';
+    }
+    else if (sscanf(fromMode.c_str(), "%d%[ip]%dhz", &height, &smode, &rrate) >= 2)
+    {
+      switch (height)
+      {
+        case 480:
+        case 576:
+          width = 720;
+          break;
+        case 720:
+          width = 1280;
+          break;
+        case 1080:
+          width = 1920;
+          break;
+        case 2160:
+          width = 3840;
+          break;
+      }
+    }
+    else if (sscanf(fromMode.c_str(), "%dcvbs", &height) == 1)
+    {
+      width = 720;
+      smode = 'i';
+      rrate = (height == 576) ? 50 : 60;
+    }
+    else if (sscanf(fromMode.c_str(), "4k2k%d", &rrate) == 1)
+    {
+      width = 3840;
+      height = 2160;
+      smode = 'p';
+    }
+    else
+    {
+      return false;
+    }
+
+    res->iWidth = (width < 3840) ? width : 1920;
+    res->iHeight= (height < 2160) ? height : 1080;
+    res->iScreenWidth = width;
+    res->iScreenHeight = height;
+    res->dwFlags = (smode == 'p') ? D3DPRESENTFLAG_PROGRESSIVE : D3DPRESENTFLAG_INTERLACED;
+
+    switch (rrate)
+    {
+      case 23:
+      case 29:
+      case 59:
+        res->fRefreshRate = (float)((rrate + 1)/1.001);
+        break;
+      default:
+        res->fRefreshRate = (float)rrate;
+        break;
+    }
+  }
+
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  if (res->iHeight == 576)
+    res->fPixelRatio = 16.0f / 15.0f;
+  if (res->iHeight == 480)
+    res->fPixelRatio = 8.0f / 9.0f;
+  res->strId         = fromMode;
+  res->strMode       = StringUtils::Format("{:d}x{:d} @ {:.2f}{} - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+    res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  if (fromMode.find("FramePacking") != std::string::npos)
+  {
+    /* add corrections for some special case modes frame packing modes */
+
+    if (res->iScreenWidth == 1920)
+    {
+      res->iBlanking = 45;
+    }
+
+    if (res->iScreenWidth == 1280)
+    {
+      res->iBlanking = 30;
+    }
+
+    res->strId = StringUtils::Format("{}fp{}hz", res->iScreenHeight, rrate);
+    res->dwFlags |= D3DPRESENTFLAG_MODE3DFP;
+  }
+
+  if (fromMode.find("TopBottom") != std::string::npos)
+  {
+    res->iHeight         /= 2;
+    res->iSubtitles      /= 2;
+    res->fPixelRatio     /= 2;
+    res->iBlanking        = 0;
+    res->dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
+  }
+
+  if (fromMode.find("SidebySide") != std::string::npos)
+  {
+    res->iWidth          /= 2;
+    res->fPixelRatio     *= 2;
+    res->iBlanking        = 0;
+    res->dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
+  }
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
+bool aml_get_native_resolution(RESOLUTION_INFO *res)
+{
+  std::string mode;
+  SysfsUtils::GetString("/sys/class/display/mode", mode);
+  bool result = aml_mode_to_resolution(mode.c_str(), res);
+
+  if (aml_has_frac_rate_policy())
+  {
+    int fractional_rate;
+    SysfsUtils::GetInt("/sys/class/amhdmitx/amhdmitx0/frac_rate_policy", fractional_rate);
+    if (fractional_rate == 1)
+      res->fRefreshRate /= 1.001;
+  }
+
+  return result;
+}
+
+static void aml_enable_PHY(bool enable)
+{
+    int phy_delay = 0;
+    char *phy_env = getenv("phydelay");
+    if (phy_env != NULL) {
+        phy_delay = atoi(phy_env);
+    }
+    CLog::Log(LOGDEBUG, "Waiting {} milliseconds for PHY toggling", phy_delay);
+    usleep(phy_delay * 1000);
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/phy", enable ? "1" : "0");
+}
+
+bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name, const int stereo_mode)
+{
+  bool result = false;
+
+  aml_enable_PHY(false);
+
+  aml_handle_display_stereo_mode(stereo_mode);
+  result = aml_set_display_resolution(res, framebuffer_name);
+  aml_handle_scale(res);
+
+  aml_enable_PHY(true);
+
+
+  return result;
+}
+
+static void aml_add_resolution(const std::string &mode, std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+
+  if (((StringUtils::StartsWith(mode, "4k2k")) && (aml_support_h264_4k2k() > AML_NO_H264_4K2K)) || !(StringUtils::StartsWith(mode, "4k2k")))
+  {
+    if (aml_mode_to_resolution(mode.c_str(), &res))
+      resolutions.push_back(res);
+
+    if (aml_has_frac_rate_policy())
+    {
+      // Add fractional frame rates: 23.976, 29.97 and 59.94 Hz
+      switch ((int)res.fRefreshRate)
+      {
+        case 24:
+        case 30:
+        case 60:
+        res.fRefreshRate /= 1.001;
+        res.strMode       = StringUtils::Format("{}x{} @ {:.2f}{} - Full Screen", res.iScreenWidth, res.iScreenHeight, res.fRefreshRate,
+            res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+        resolutions.push_back(res);
+      }
+    }
+  }
+}
+
+static bool aml_modes_to_resolutions(const std::vector<std::string> &probe_str, std::vector<RESOLUTION_INFO> &resolutions)
+{
+  resolutions.clear();
+
+  for (std::vector<std::string>::const_iterator i = probe_str.begin(); i != probe_str.end(); ++i)
+  {
+    std::vector<std::string> elem_str = StringUtils::Split(*i, " ");
+    if (elem_str.size() == 1)
+      aml_add_resolution(elem_str[0], resolutions);
+    else
+      for (size_t j = 1; j < elem_str.size(); j++)
+        aml_add_resolution(elem_str[0] + " " + elem_str[j], resolutions);
+  }
+
+  return resolutions.size() > 0;
+}
+
+bool aml_probe_3d_resolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  std::string valstr, dcap3dfile;
+
+  dcap3dfile = CSpecialProtocol::TranslatePath("special://home/userdata/disp_cap_3d");
+
+  if (!SysfsUtils::Has(dcap3dfile))
+    CLog::Log(LOGINFO, "No {} to read", dcap3dfile);
+
+  if ((SysfsUtils::Has(dcap3dfile) && SysfsUtils::GetString(dcap3dfile, valstr) >= 0) ||
+      SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap_3d", valstr) >= 0)
+  {
+    std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+    return aml_modes_to_resolutions(probe_str, resolutions);
+  }
+
+  return false;
+}
+
+
+bool aml_probe_resolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  std::string valstr, vesastr, dcapfile;
+  dcapfile = CSpecialProtocol::TranslatePath("special://home/userdata/disp_cap");
+
+  if (!SysfsUtils::Has(dcapfile))
+    CLog::Log(LOGINFO, "No {} to read", dcapfile);
+
+  if (!SysfsUtils::Has(dcapfile) || SysfsUtils::GetString(dcapfile, valstr) < 0)
+  {
+    if (SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", valstr) < 0 || valstr.empty())
+    {
+      CLog::Log(LOGDEBUG, "Cannot read EDID - falling back to current display mode");
+      if (SysfsUtils::GetString("/sys/class/display/mode", valstr) < 0)
+      {
+        CLog::Log(LOGDEBUG, "Cannot get current display mode");
+        return false;
+      }
+    }
+  }
+
+  if (SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/vesa_cap", vesastr) == 0 && !vesastr.empty())
+  {
+    // If EDID returns VESA modes then check if we should override them
+    std::string vesacapfile = CSpecialProtocol::TranslatePath("special://home/userdata/vesa_cap");
+
+    if (SysfsUtils::Has(vesacapfile))
+    {
+      if (SysfsUtils::GetString(vesacapfile, vesastr) == 0)
+        CLog::Log(LOGINFO, "Using {} to override VESA modes reported by EDID", vesacapfile);
+      else
+      {
+        CLog::Log(LOGERROR, "Error reading {}", vesacapfile);
+        vesastr.clear();
+      }
+    }
+    else
+      CLog::Log(LOGINFO, "No {} to read", vesacapfile);
+
+    if (!vesastr.empty())
+      valstr += "\n" + vesastr;
+  }
+
+  std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+
+  return aml_modes_to_resolutions(probe_str, resolutions);
+}
+
+bool aml_set_display_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name)
+{
+  std::string mode = res.strId.c_str();
+
+  // switch display resolution
+  SysfsUtils::SetString("/sys/class/display/mode", "null");
+
+  int fractional_rate = (res.fRefreshRate == floor(res.fRefreshRate)) ? 0 : 1;
+  CLog::Log(LOGDEBUG, "AMLUtils::aml_set_display_resolution setting frac_rate_policy to {}", fractional_rate);
+  SysfsUtils::SetInt("/sys/class/amhdmitx/amhdmitx0/frac_rate_policy", fractional_rate);
+
+  CLog::Log(LOGDEBUG, "AMLUtils::aml_set_display_resolution new video mode is {}", mode);
+
+  SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
+
+  aml_set_framebuffer_resolution(res, framebuffer_name);
+
+  return true;
+}
+
+void aml_handle_scale(const RESOLUTION_INFO &res)
+{
+  if (res.iScreenWidth > res.iWidth && res.iScreenHeight > res.iHeight)
+    aml_enable_freeScale(res);
+  else
+    aml_disable_freeScale();
+}
+
+void aml_handle_display_stereo_mode(const int stereo_mode)
+{
+  static std::string lastHdmiTxConfig = "3doff";
+
+  std::string command = "3doff";
+  switch (stereo_mode)
+  {
+    case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+      command = "3dlr";
+      break;
+    case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+      command = "3dtb";
+      break;
+    case RENDER_STEREO_MODE_HARDWAREBASED:
+      command = "3dfp";
+      break;
+    default:
+      // nothing - command is already initialised to "3doff"
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode old mode {} new mode {}", lastHdmiTxConfig.c_str(), command.c_str());
+  // there is no way to read back current mode from sysfs
+  // so we track state internal. Because even
+  // when setting the same mode again - kernel driver
+  // will initiate a new hdmi handshake which is not
+  // what we want of course.
+  // for 3d mode we are called 2 times and need to allow both calls
+  // to succeed. Because the first call doesn't switch mode (i guessi its
+  // timing issue between switching the refreshrate and switching to 3d mode
+  // which needs to occure in the correct order, else switching refresh rate
+  // might reset 3dmode).
+  // So we set the 3d mode - if the last command is different from the current
+  // command - or in case they are the same - we ensure that its not the 3doff
+  // command that gets repeated here.
+  if (lastHdmiTxConfig != command || command != "3doff")
+  {
+    CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode setting new mode");
+    lastHdmiTxConfig = command;
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/config", command);
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "AMLUtils::aml_handle_display_stereo_mode - no change needed");
+  }
+}
+
+void aml_enable_freeScale(const RESOLUTION_INFO &res)
+{
+  char fsaxis_str[256] = {0};
+  sprintf(fsaxis_str, "0 0 %d %d", res.iWidth-1, res.iHeight-1);
+  char waxis_str[256] = {0};
+  sprintf(waxis_str, "0 0 %d %d", res.iScreenWidth-1, res.iScreenHeight-1);
+
+  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
+  SysfsUtils::SetString("/sys/class/graphics/fb0/free_scale_axis", fsaxis_str);
+  SysfsUtils::SetString("/sys/class/graphics/fb0/window_axis", waxis_str);
+  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0x10001);
+}
+
+void aml_disable_freeScale()
+{
+  // turn off frame buffer freescale
+  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
+  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
+}
+
+static bool isMaliBug()
+{
+  std::string model;
+
+  SysfsUtils::GetString("/proc/device-tree/model", model);
+  if (model.rfind("Vero4K", 0) == 0)
+  {
+    std::string buggyMali;
+
+    SysfsUtils::GetString("/sys/firmware/devicetree/base/buggymali", buggyMali);
+    return buggyMali.rfind("true", 0) == 0;
+  }
+
+  return false;
+}
+
+void aml_calc_framebuffer_resolution(const RESOLUTION_INFO &res, int &width, int &height)
+{
+  width = res.iWidth;
+  height = res.iHeight;
+
+  if (res.dwFlags & (D3DPRESENTFLAG_MODE3DTB | D3DPRESENTFLAG_MODE3DFP))
+    height = res.iHeight * 2 + res.iBlanking;
+  else if (res.dwFlags & (D3DPRESENTFLAG_MODE3DSBS))
+    width = res.iWidth * 2 + res.iBlanking;
+}
+
+void aml_set_framebuffer_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name)
+{
+  int fbWidth, fbHeight;
+
+  aml_calc_framebuffer_resolution(res, fbWidth, fbHeight);
+  aml_set_framebuffer_resolution(fbWidth, fbHeight, framebuffer_name);
+}
+
+void aml_set_framebuffer_resolution(int width, int height, std::string framebuffer_name)
+{
+  int fd0;
+  std::string framebuffer = "/dev/" + framebuffer_name;
+
+  if ((fd0 = open(framebuffer.c_str(), O_RDWR)) >= 0)
+  {
+    struct fb_var_screeninfo vinfo;
+    if (ioctl(fd0, FBIOGET_VSCREENINFO, &vinfo) == 0)
+    {
+      vinfo.xres = width;
+      vinfo.yres = height;
+      vinfo.xres_virtual = width;
+      vinfo.yres_virtual = height*2;
+
+      if (isMaliBug())
+      {
+        // There seems to be a bug in libMali or the Mali driver which can't handle
+        // virtual resolutions other than those originally set when libMali was
+        // initialized.
+        vinfo.xres_virtual = 1920;
+        vinfo.yres_virtual = 4410;
+      }
+
+      vinfo.bits_per_pixel = 32;
+      vinfo.activate = FB_ACTIVATE_ALL;
+      ioctl(fd0, FBIOPUT_VSCREENINFO, &vinfo);
+    }
+    close(fd0);
+  }
+}
+
+bool aml_read_reg(const std::string &reg, uint32_t &reg_val)
+{
+  std::string path = "/sys/kernel/debug/aml_reg/paddr";
+  if (SysfsUtils::Has(path))
+  {
+    if (SysfsUtils::SetString(path, reg) == 0)
+    {
+      std::string val;
+      if (SysfsUtils::GetString(path, val) == 0)
+      {
+        CRegExp regexp;
+        regexp.RegComp("\\[0x(?<reg>.+)\\][\\s]+=[\\s]+(?<val>.+)");
+        if (regexp.RegFind(val) == 0)
+        {
+          std::string match;
+          if (regexp.GetNamedSubPattern("reg", match))
+          {
+            if (match == reg)
+            {
+              if (regexp.GetNamedSubPattern("val", match))
+              {
+                try
+                {
+                  reg_val = std::stoul(match, 0, 16);
+                  return true;
+                }
+                catch (...) {}
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  return false;
+}
+
+bool aml_has_capability_ignore_alpha()
+{
+  // AML is at least GXBB
+  uint32_t reg_val;
+  if (aml_read_reg("c8100220", reg_val))
+  {
+    if ((reg_val >> 24) >= 0x1f)
+      return true;
+  }
+  return false;
+}
+
+bool aml_set_reg_ignore_alpha()
+{
+  if (aml_has_capability_ignore_alpha())
+  {
+    std::string path = "/sys/kernel/debug/aml_reg/paddr";
+    if (SysfsUtils::SetString(path, "d01068b4 0x7fc0") == 0)
+      return true;
+  }
+  return false;
+}
+
+bool aml_unset_reg_ignore_alpha()
+{
+  if (aml_has_capability_ignore_alpha())
+  {
+    std::string path = "/sys/kernel/debug/aml_reg/paddr";
+    if (SysfsUtils::SetString(path, "d01068b4 0x3fc0") == 0)
+      return true;
+  }
+  return false;
+}
+
diff --git a/xbmc/utils/AMLUtils.h b/xbmc/utils/AMLUtils.h
new file mode 100644
index 0000000000..83ca38c3d5
--- /dev/null
+++ b/xbmc/utils/AMLUtils.h
@@ -0,0 +1,70 @@
+/*
+ *  Copyright (C) 2011-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "windowing/Resolution.h"
+
+#include <string>
+#include <vector>
+
+enum AML_DEVICE_TYPE
+{
+  AML_DEVICE_TYPE_UNINIT   = -2,
+  AML_DEVICE_TYPE_UNKNOWN  = -1,
+  AML_DEVICE_TYPE_M1,
+  AML_DEVICE_TYPE_M3,
+  AML_DEVICE_TYPE_M6,
+  AML_DEVICE_TYPE_M8,   // S802
+  AML_DEVICE_TYPE_M8B,  // S805
+  AML_DEVICE_TYPE_M8M2  // S812
+};
+
+enum AML_DISPLAY_AXIS_PARAM
+{
+  AML_DISPLAY_AXIS_PARAM_X = 0,
+  AML_DISPLAY_AXIS_PARAM_Y,
+  AML_DISPLAY_AXIS_PARAM_WIDTH,
+  AML_DISPLAY_AXIS_PARAM_HEIGHT
+};
+
+enum AML_SUPPORT_H264_4K2K
+{
+  AML_SUPPORT_H264_4K2K_UNINIT = -1,
+  AML_NO_H264_4K2K,
+  AML_HAS_H264_4K2K,
+  AML_HAS_H264_4K2K_SAME_PROFILE
+};
+
+bool aml_present();
+bool aml_permissions();
+bool aml_support_hevc();
+bool aml_support_hevc_4k2k();
+bool aml_support_hevc_10bit();
+AML_SUPPORT_H264_4K2K aml_support_h264_4k2k();
+bool aml_support_vp9();
+bool aml_support_av1();
+bool aml_has_frac_rate_policy();
+void aml_set_audio_passthrough(bool passthrough);
+bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res);
+bool aml_get_native_resolution(RESOLUTION_INFO *res);
+bool aml_set_native_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name, const int stereo_mode);
+bool aml_probe_resolutions(std::vector<RESOLUTION_INFO> &resolutions);
+bool aml_probe_3d_resolutions(std::vector<RESOLUTION_INFO> &resolutions);
+bool aml_set_display_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name);
+void aml_handle_scale(const RESOLUTION_INFO &res);
+void aml_handle_display_stereo_mode(const int stereo_mode);
+void aml_enable_freeScale(const RESOLUTION_INFO &res);
+void aml_disable_freeScale();
+void aml_set_framebuffer_resolution(const RESOLUTION_INFO &res, std::string framebuffer_name);
+void aml_set_framebuffer_resolution(int width, int height, std::string framebuffer_name);
+void aml_calc_framebuffer_resolution(const RESOLUTION_INFO &res, int &width, int &height);
+bool aml_read_reg(const std::string &reg, uint32_t &reg_val);
+bool aml_has_capability_ignore_alpha();
+bool aml_set_reg_ignore_alpha();
+bool aml_unset_reg_ignore_alpha();
diff --git a/xbmc/utils/BitstreamConverter.cpp b/xbmc/utils/BitstreamConverter.cpp
index f2224a5457..e284efc0ff 100644
--- a/xbmc/utils/BitstreamConverter.cpp
+++ b/xbmc/utils/BitstreamConverter.cpp
@@ -427,7 +427,7 @@ bool CBitstreamConverter::Open(enum AVCodecID codec, uint8_t *in_extradata, int
       // valid hvcC data (bitstream) always starts with the value 1 (version)
       if(m_to_annexb)
       {
-       /**
+       /** @todo from Amlogic
         * It seems the extradata is encoded as hvcC format.
         * Temporarily, we support configurationVersion==0 until 14496-15 3rd
         * is finalized. When finalized, configurationVersion will be 1 and we
@@ -535,7 +535,7 @@ bool CBitstreamConverter::Convert(uint8_t *pData, int iSize)
         if (m_convert_bitstream)
         {
           // convert demuxer packet from bitstream to bytestream (AnnexB)
-          int bytestream_size = 0;
+          uint32_t bytestream_size = 0;
           uint8_t *bytestream_buff = NULL;
 
           BitstreamConvert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
@@ -678,6 +678,7 @@ bool CBitstreamConverter::BitstreamConvertInitAVC(void *in_extradata, int in_ext
   uint16_t unit_size;
   uint32_t total_size = 0;
   uint8_t *out = NULL, unit_nb, sps_done = 0, sps_seen = 0, pps_seen = 0;
+  uint8_t mvc_done = 0;
   const uint8_t *extradata = (uint8_t*)in_extradata + 4;
   static const uint8_t nalu_header[4] = {0, 0, 0, 1};
 
@@ -726,6 +727,18 @@ pps:
       if (unit_nb)
         pps_seen = 1;
     }
+
+    if (!unit_nb && !mvc_done++)
+    {
+      if (in_extrasize - total_size > 14 && memcmp(extradata + 8, "mvcC", 4) == 0)
+      {
+        // start over; take SPS and PPS from the mvcC atom
+        extradata += 12 + 5; // skip over mvcC atom header
+        unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
+        sps_done = 0;
+        pps_seen = 0;
+      }
+    }
   }
 
   if (out)
@@ -868,7 +881,7 @@ bool CBitstreamConverter::IsSlice(uint8_t unit_type)
   }
 }
 
-bool CBitstreamConverter::BitstreamConvert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+bool CBitstreamConverter::BitstreamConvert(uint8_t* pData, int iSize, uint8_t **poutbuf, uint32_t *poutbuf_size)
 {
   // based on h264_mp4toannexb_bsf.c (ffmpeg)
   // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
@@ -878,7 +891,7 @@ bool CBitstreamConverter::BitstreamConvert(uint8_t* pData, int iSize, uint8_t **
   uint8_t *buf = pData;
   uint32_t buf_size = iSize;
   uint8_t  unit_type, nal_sps, nal_pps, nal_sei;
-  int32_t  nal_size;
+  uint32_t  nal_size;
   uint32_t cumul_size = 0;
   const uint8_t *buf_end = buf + buf_size;
 
@@ -916,7 +929,7 @@ bool CBitstreamConverter::BitstreamConvert(uint8_t* pData, int iSize, uint8_t **
         unit_type = (*buf >> 1) & 0x3f;
     }
 
-    if (buf + nal_size > buf_end || nal_size <= 0)
+    if (nal_size > (buf_end - buf) || nal_size == 0)
       goto fail;
 
     // Don't add sps/pps if the unit already contain them
@@ -956,7 +969,7 @@ fail:
 }
 
 void CBitstreamConverter::BitstreamAllocAndCopy(uint8_t** poutbuf,
-                                                int* poutbuf_size,
+                                                uint32_t* poutbuf_size,
                                                 const uint8_t* sps_pps,
                                                 uint32_t sps_pps_size,
                                                 const uint8_t* in,
diff --git a/xbmc/utils/BitstreamConverter.h b/xbmc/utils/BitstreamConverter.h
index 3c57e14057..91b7864a9f 100644
--- a/xbmc/utils/BitstreamConverter.h
+++ b/xbmc/utils/BitstreamConverter.h
@@ -108,9 +108,9 @@ protected:
   bool              IsSlice(uint8_t unit_type);
   bool              BitstreamConvertInitAVC(void *in_extradata, int in_extrasize);
   bool              BitstreamConvertInitHEVC(void *in_extradata, int in_extrasize);
-  bool              BitstreamConvert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
+  bool              BitstreamConvert(uint8_t* pData, int iSize, uint8_t **poutbuf, uint32_t *poutbuf_size);
   static void BitstreamAllocAndCopy(uint8_t** poutbuf,
-                                    int* poutbuf_size,
+                                    uint32_t* poutbuf_size,
                                     const uint8_t* sps_pps,
                                     uint32_t sps_pps_size,
                                     const uint8_t* in,
diff --git a/xbmc/utils/CMakeLists.txt b/xbmc/utils/CMakeLists.txt
index 8e1328999f..3a2b962ea4 100644
--- a/xbmc/utils/CMakeLists.txt
+++ b/xbmc/utils/CMakeLists.txt
@@ -239,6 +239,15 @@ if("gbm" IN_LIST CORE_PLATFORM_NAME_LC OR "wayland" IN_LIST CORE_PLATFORM_NAME_L
   endif()
 endif()
 
+if(AML_FOUND)
+  list(APPEND SOURCES AMLUtils.cpp
+                      ScreenshotAML.cpp
+                      SysfsUtils.cpp)
+  list(APPEND HEADERS AMLUtils.h
+                      ScreenshotAML.h
+                      SysfsUtils.h)
+endif()
+
 core_add_library(utils)
 
 if(NOT CORE_SYSTEM_NAME STREQUAL windows AND NOT CORE_SYSTEM_NAME STREQUAL windowsstore)
diff --git a/xbmc/utils/EGLUtils.cpp b/xbmc/utils/EGLUtils.cpp
index 7c5e70938f..72aaf282b8 100644
--- a/xbmc/utils/EGLUtils.cpp
+++ b/xbmc/utils/EGLUtils.cpp
@@ -84,40 +84,11 @@ std::map<EGLenum, const char*> eglErrors =
 
 std::map<EGLint, const char*> eglErrorType =
 {
-  X(EGL_DEBUG_MSG_CRITICAL_KHR),
-  X(EGL_DEBUG_MSG_ERROR_KHR),
-  X(EGL_DEBUG_MSG_WARN_KHR),
-  X(EGL_DEBUG_MSG_INFO_KHR),
 };
 #undef X
 
 } // namespace
 
-void EglErrorCallback(EGLenum error,
-                      const char* command,
-                      EGLint messageType,
-                      EGLLabelKHR threadLabel,
-                      EGLLabelKHR objectLabel,
-                      const char* message)
-{
-  std::string errorStr;
-  std::string typeStr;
-
-  auto eglError = eglErrors.find(error);
-  if (eglError != eglErrors.end())
-  {
-    errorStr = eglError->second;
-  }
-
-  auto eglType = eglErrorType.find(messageType);
-  if (eglType != eglErrorType.end())
-  {
-    typeStr = eglType->second;
-  }
-
-  CLog::Log(LOGDEBUG, "EGL Debugging:\nError: {}\nCommand: {}\nType: {}\nMessage: {}", errorStr, command, typeStr, message);
-}
-
 std::set<std::string> CEGLUtils::GetClientExtensions()
 {
   const char* extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
@@ -171,19 +142,6 @@ void CEGLUtils::Log(int logLevel, const std::string& what)
 CEGLContextUtils::CEGLContextUtils(EGLenum platform, std::string const& platformExtension)
 : m_platform{platform}
 {
-  if (CEGLUtils::HasClientExtension("EGL_KHR_debug"))
-  {
-    auto eglDebugMessageControl = CEGLUtils::GetRequiredProcAddress<PFNEGLDEBUGMESSAGECONTROLKHRPROC>("eglDebugMessageControlKHR");
-
-    EGLAttrib eglDebugAttribs[] = {EGL_DEBUG_MSG_CRITICAL_KHR, EGL_TRUE,
-                                   EGL_DEBUG_MSG_ERROR_KHR, EGL_TRUE,
-                                   EGL_DEBUG_MSG_WARN_KHR, EGL_TRUE,
-                                   EGL_DEBUG_MSG_INFO_KHR, EGL_TRUE,
-                                   EGL_NONE};
-
-    eglDebugMessageControl(EglErrorCallback, eglDebugAttribs);
-  }
-
   m_platformSupported = CEGLUtils::HasClientExtension("EGL_EXT_platform_base") && CEGLUtils::HasClientExtension(platformExtension);
 }
 
@@ -394,18 +352,9 @@ bool CEGLContextUtils::CreateContext(CEGLAttributesVec contextAttribs)
 
   EGLConfig eglConfig{m_eglConfig};
 
-  if (CEGLUtils::HasExtension(m_eglDisplay, "EGL_KHR_no_config_context"))
-    eglConfig = EGL_NO_CONFIG_KHR;
-
   if (CEGLUtils::HasExtension(m_eglDisplay, "EGL_IMG_context_priority"))
     contextAttribs.Add({{EGL_CONTEXT_PRIORITY_LEVEL_IMG, EGL_CONTEXT_PRIORITY_HIGH_IMG}});
 
-  if (CEGLUtils::HasExtension(m_eglDisplay, "EGL_KHR_create_context") &&
-      CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_openGlDebugging)
-  {
-    contextAttribs.Add({{EGL_CONTEXT_FLAGS_KHR, EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR}});
-  }
-
   m_eglContext = eglCreateContext(m_eglDisplay, eglConfig,
                                   EGL_NO_CONTEXT, contextAttribs.Get());
 
diff --git a/xbmc/utils/GLUtils.cpp b/xbmc/utils/GLUtils.cpp
index df8921e2b0..31555998ef 100644
--- a/xbmc/utils/GLUtils.cpp
+++ b/xbmc/utils/GLUtils.cpp
@@ -41,35 +41,12 @@ std::map<GLenum, const char*> glErrors =
 };
 
 std::map<GLenum, const char*> glErrorSource = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
-    X(GL_DEBUG_SOURCE_API_KHR),
-    X(GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR),
-    X(GL_DEBUG_SOURCE_SHADER_COMPILER_KHR),
-    X(GL_DEBUG_SOURCE_THIRD_PARTY_KHR),
-    X(GL_DEBUG_SOURCE_APPLICATION_KHR),
-    X(GL_DEBUG_SOURCE_OTHER_KHR),
-#endif
 };
 
 std::map<GLenum, const char*> glErrorType = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
-    X(GL_DEBUG_TYPE_ERROR_KHR),
-    X(GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR),
-    X(GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR),
-    X(GL_DEBUG_TYPE_PORTABILITY_KHR),
-    X(GL_DEBUG_TYPE_PERFORMANCE_KHR),
-    X(GL_DEBUG_TYPE_OTHER_KHR),
-    X(GL_DEBUG_TYPE_MARKER_KHR),
-#endif
 };
 
 std::map<GLenum, const char*> glErrorSeverity = {
-#if defined(HAS_GLES) && defined(TARGET_LINUX)
-    X(GL_DEBUG_SEVERITY_HIGH_KHR),
-    X(GL_DEBUG_SEVERITY_MEDIUM_KHR),
-    X(GL_DEBUG_SEVERITY_LOW_KHR),
-    X(GL_DEBUG_SEVERITY_NOTIFICATION_KHR),
-#endif
 };
 #undef X
 
diff --git a/xbmc/utils/GLUtils.h b/xbmc/utils/GLUtils.h
index 5c360300dd..ede094c649 100644
--- a/xbmc/utils/GLUtils.h
+++ b/xbmc/utils/GLUtils.h
@@ -20,6 +20,7 @@
 // and will be optimized out.
 
 #include "system_gl.h"
+#include <stdint.h>
 
 namespace KODI
 {
diff --git a/xbmc/utils/ScreenshotAML.cpp b/xbmc/utils/ScreenshotAML.cpp
new file mode 100644
index 0000000000..a46e01aead
--- /dev/null
+++ b/xbmc/utils/ScreenshotAML.cpp
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (C) 2015-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "utils/ScreenshotAML.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/ioctl.h>
+
+// taken from linux/amlogic/amports/amvideocap.h - needs to be synced - no changes expected though
+#define AMVIDEOCAP_IOC_MAGIC  'V'
+#define AMVIDEOCAP_IOW_SET_WANTFRAME_WIDTH      _IOW(AMVIDEOCAP_IOC_MAGIC, 0x02, int)
+#define AMVIDEOCAP_IOW_SET_WANTFRAME_HEIGHT     _IOW(AMVIDEOCAP_IOC_MAGIC, 0x03, int)
+#define AMVIDEOCAP_IOW_SET_CANCEL_CAPTURE       _IOW(AMVIDEOCAP_IOC_MAGIC, 0x33, int)
+
+// capture format already defaults to GE2D_FORMAT_S24_RGB - no need to pull in all the ge2d headers :)
+
+#define CAPTURE_DEVICEPATH "/dev/amvideocap0"
+
+//the buffer format is BGRA (4 byte)
+void CScreenshotAML::CaptureVideoFrame(unsigned char *buffer, int iWidth, int iHeight, bool bBlendToBuffer)
+{
+  int captureFd = open(CAPTURE_DEVICEPATH, O_RDWR, 0);
+  if (captureFd >= 0)
+  {
+    int stride = ((iWidth + 31) & ~31) * 3;
+    int buffSize = stride * iHeight;
+    int readSize = 0;
+    // videobuffer should be rgb according to docu - but it is bgr ...
+    unsigned char *videoBuffer = new unsigned char[buffSize];
+
+    if (videoBuffer != NULL)
+    {
+      // configure destination
+      ioctl(captureFd, AMVIDEOCAP_IOW_SET_WANTFRAME_WIDTH, stride / 3);
+      ioctl(captureFd, AMVIDEOCAP_IOW_SET_WANTFRAME_HEIGHT, iHeight);
+      readSize = pread(captureFd, videoBuffer, buffSize, 0);
+    }
+
+    close(captureFd);
+
+    if (readSize == buffSize)
+    {
+      if (!bBlendToBuffer)
+      {
+        memset(buffer, 0xff, iHeight * iWidth * 4);
+      }
+
+      for (int y = 0; y < iHeight; ++y)
+      {
+        unsigned char *videoPtr = videoBuffer + y * stride;
+
+        for (int x = 0; x < iWidth; ++x, buffer += 4, videoPtr += 3)
+        {
+          float alpha = buffer[3] / (float)255;
+
+          if (bBlendToBuffer)
+          {
+            //B
+            buffer[0] = alpha * (float)buffer[0] + (1 - alpha) * (float)videoPtr[0];
+            //G
+            buffer[1] = alpha * (float)buffer[1] + (1 - alpha) * (float)videoPtr[1];
+            //R
+            buffer[2] = alpha * (float)buffer[2] + (1 - alpha) * (float)videoPtr[2];
+            //A
+            buffer[3] = 0xff;// we are solid now
+          }
+          else
+          {
+            memcpy(buffer, videoPtr, 3);
+          }
+        }
+      }
+    }
+    delete [] videoBuffer;
+  }
+}
diff --git a/xbmc/utils/ScreenshotAML.h b/xbmc/utils/ScreenshotAML.h
new file mode 100644
index 0000000000..26176182a0
--- /dev/null
+++ b/xbmc/utils/ScreenshotAML.h
@@ -0,0 +1,17 @@
+/*
+ *  Copyright (C) 2015-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+class CScreenshotAML
+{
+  public:
+    // Captures the current visible video framebuffer and blends it into
+    // the passed overlay. The buffer format is BGRA (4 byte)
+    static void CaptureVideoFrame(unsigned char *buffer, int iWidth, int iHeight, bool bBlendToBuffer = true);
+};
diff --git a/xbmc/utils/SysfsUtils.cpp b/xbmc/utils/SysfsUtils.cpp
new file mode 100644
index 0000000000..29990a64da
--- /dev/null
+++ b/xbmc/utils/SysfsUtils.cpp
@@ -0,0 +1,116 @@
+/*
+ *  Copyright (C) 2011-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "SysfsUtils.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <string.h>
+
+int SysfsUtils::SetString(const std::string& path, const std::string& valstr)
+{
+  int fd = open(path.c_str(), O_RDWR, 0644);
+  int ret = 0;
+  if (fd >= 0)
+  {
+    if (write(fd, valstr.c_str(), valstr.size()) < 0)
+      ret = -1;
+    close(fd);
+  }
+  if (ret)
+    CLog::Log(LOGERROR, "{}: error writing {}",__FUNCTION__, path.c_str());
+
+  return ret;
+}
+
+int SysfsUtils::GetString(const std::string& path, std::string& valstr)
+{
+  int len;
+  char buf[256] = {0};
+
+  int fd = open(path.c_str(), O_RDONLY);
+  if (fd >= 0)
+  {
+    valstr.clear();
+    while ((len = read(fd, buf, 256)) > 0)
+      valstr.append(buf, len);
+    close(fd);
+
+    StringUtils::Trim(valstr);
+
+    return 0;
+  }
+
+  CLog::Log(LOGERROR, "{}: error reading {}",__FUNCTION__, path.c_str());
+  valstr = "fail";
+  return -1;
+}
+
+int SysfsUtils::SetInt(const std::string& path, const int val)
+{
+  int fd = open(path.c_str(), O_RDWR, 0644);
+  int ret = 0;
+  if (fd >= 0)
+  {
+    char bcmd[16];
+    sprintf(bcmd, "%d", val);
+    if (write(fd, bcmd, strlen(bcmd)) < 0)
+      ret = -1;
+    close(fd);
+  }
+  if (ret)
+    CLog::Log(LOGERROR, "{}: error writing {}",__FUNCTION__, path.c_str());
+
+  return ret;
+}
+
+int SysfsUtils::GetInt(const std::string& path, int& val)
+{
+  int fd = open(path.c_str(), O_RDONLY);
+  int ret = 0;
+  if (fd >= 0)
+  {
+    char bcmd[16];
+    if (read(fd, bcmd, sizeof(bcmd)) < 0)
+      ret = -1;
+    else
+      val = strtol(bcmd, NULL, 16);
+
+    close(fd);
+  }
+  if (ret)
+    CLog::Log(LOGERROR, "{}: error reading {}",__FUNCTION__, path.c_str());
+
+  return ret;
+}
+
+bool SysfsUtils::Has(const std::string &path)
+{
+  int fd = open(path.c_str(), O_RDONLY);
+  if (fd >= 0)
+  {
+    close(fd);
+    return true;
+  }
+  return false;
+}
+
+bool SysfsUtils::HasRW(const std::string &path)
+{
+  int fd = open(path.c_str(), O_RDWR);
+  if (fd >= 0)
+  {
+    close(fd);
+    return true;
+  }
+  return false;
+}
diff --git a/xbmc/utils/SysfsUtils.h b/xbmc/utils/SysfsUtils.h
new file mode 100644
index 0000000000..b173a456bc
--- /dev/null
+++ b/xbmc/utils/SysfsUtils.h
@@ -0,0 +1,22 @@
+/*
+ *  Copyright (C) 2011-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <string>
+
+class SysfsUtils
+{
+public:
+  static int SetString(const std::string& path, const std::string& valstr);
+  static int GetString(const std::string& path, std::string& valstr);
+  static int SetInt(const std::string& path, const int val);
+  static int GetInt(const std::string& path, int& val);
+  static bool Has(const std::string& path);
+  static bool HasRW(const std::string &path);
+};
diff --git a/xbmc/utils/SystemInfo.cpp b/xbmc/utils/SystemInfo.cpp
index bcdcd03dbf..7d11584baf 100644
--- a/xbmc/utils/SystemInfo.cpp
+++ b/xbmc/utils/SystemInfo.cpp
@@ -55,6 +55,9 @@ using namespace winrt::Windows::System::Profile;
 #include <androidjni/Build.h>
 #include <androidjni/Context.h>
 #include <androidjni/PackageManager.h>
+#if defined(HAS_LIBAMCODEC)
+#include "utils/AMLUtils.h"
+#endif
 #endif
 
 /* Platform identification */
diff --git a/xbmc/video/PlayerController.cpp b/xbmc/video/PlayerController.cpp
index 036fbaed12..254d572cd5 100644
--- a/xbmc/video/PlayerController.cpp
+++ b/xbmc/video/PlayerController.cpp
@@ -500,8 +500,7 @@ bool CPlayerController::OnAction(const CAction &action)
           for (const CVariant &mode : indexList)
           {
             auto res = CDisplaySettings::GetInstance().GetResFromString(mode.asString());
-            const RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(res);
-            dialog->Add(info.strMode);
+            dialog->Add(CDisplaySettings::GetInstance().GetDisplayStringFromRes(res));
             if (res == currentRes)
               current = idx;
             idx++;
diff --git a/xbmc/windowing/GraphicContext.cpp b/xbmc/windowing/GraphicContext.cpp
index 423148c043..a2cb3f4e6c 100644
--- a/xbmc/windowing/GraphicContext.cpp
+++ b/xbmc/windowing/GraphicContext.cpp
@@ -14,6 +14,7 @@
 #include "application/ApplicationPlayer.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
+#include "guilib/StereoscopicsManager.h"
 #include "guilib/TextureManager.h"
 #include "guilib/gui3d.h"
 #include "input/InputManager.h"
@@ -258,6 +259,13 @@ CPoint CGraphicContext::StereoCorrection(const CPoint &point) const
     if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
       res.y += info.iHeight + info.iBlanking;
   }
+  if (m_stereoMode == RENDER_STEREO_MODE_HARDWAREBASED)
+  {
+    const RESOLUTION_INFO info = GetResInfo();
+
+    if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      res.y += info.iHeight + info.iBlanking;
+  }
   if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
   {
     const RESOLUTION_INFO info = GetResInfo();
@@ -354,7 +362,7 @@ void CGraphicContext::SetFullScreenVideo(bool bOnOff)
     }
   }
   else
-    SetVideoResolution(RES_WINDOW, false);
+    SetVideoResolution(RES_DESKTOP, false);
 }
 
 bool CGraphicContext::IsFullScreenVideo() const
@@ -382,6 +390,36 @@ bool CGraphicContext::IsValidResolution(RESOLUTION res)
   return false;
 }
 
+uint32_t CGraphicContext::ConvertRenderStereoModeToMode3dFlags(RENDER_STEREO_MODE stereo_mode) const
+{
+  if (stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    return D3DPRESENTFLAG_MODE3DTB;
+  else if (stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    return D3DPRESENTFLAG_MODE3DSBS;
+  else if (stereo_mode == RENDER_STEREO_MODE_HARDWAREBASED)
+    return D3DPRESENTFLAG_MODE3DFP;
+
+  return 0;
+}
+
+RENDER_STEREO_MODE CGraphicContext::ConvertMode3dFlagsToRenderStereoMode(uint32_t mode3dFlags) const
+{
+  if (mode3dFlags & D3DPRESENTFLAG_MODE3DTB)
+    return RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
+  else if (mode3dFlags & D3DPRESENTFLAG_MODE3DSBS)
+    return RENDER_STEREO_MODE_SPLIT_VERTICAL;
+  else if (mode3dFlags & D3DPRESENTFLAG_MODE3DFP)
+    return RENDER_STEREO_MODE_HARDWAREBASED;
+
+  return RENDER_STEREO_MODE_OFF;
+}
+
+RENDER_STEREO_MODE CGraphicContext::GetRenderStereoModeFromResolution(RESOLUTION resolution) const
+{
+  RESOLUTION_INFO info = GetResInfo(resolution);
+  return ConvertMode3dFlagsToRenderStereoMode(info.dwFlags);
+}
+
 // call SetVideoResolutionInternal and ensure its done from mainthread
 void CGraphicContext::SetVideoResolution(RESOLUTION res, bool forceUpdate)
 {
@@ -405,6 +443,12 @@ void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdat
     res = RES_DESKTOP;
   }
 
+  if (CServiceBroker::GetGUI() != nullptr && CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode() != m_stereoMode)
+  {
+    // stereo mode has changed, so we do need to update now
+    forceUpdate = 1;
+  }
+
   // If we are switching to the same resolution and same window/full-screen, no need to do anything
   if (!forceUpdate && res == lastRes && m_bFullScreenRoot == CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen)
   {
@@ -433,10 +477,19 @@ void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdat
   int origScreenWidth = m_iScreenWidth;
   int origScreenHeight = m_iScreenHeight;
   float origFPSOverride = m_fFPSOverride;
+  RENDER_STEREO_MODE origStereoMode = m_stereoMode;
 
   UpdateInternalStateWithResolution(res);
   RESOLUTION_INFO info_org  = CDisplaySettings::GetInstance().GetResolutionInfo(res);
 
+  // Get render stereo mode from flags
+  m_stereoMode = ConvertMode3dFlagsToRenderStereoMode(info_org.dwFlags);
+  if (m_stereoMode == RENDER_STEREO_MODE_OFF
+	  && CServiceBroker::GetGUI() != nullptr && CServiceBroker::GetGUI()->GetStereoscopicsManager().GetStereoMode() != RENDER_STEREO_MODE_OFF) {
+    // Stereoscopics manager has asked for a 3D mode but we've got a 2D resolution => switch to mono
+    m_stereoMode = RENDER_STEREO_MODE_MONO;
+  }
+
   bool switched = false;
   if (CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen)
   {
@@ -460,7 +513,7 @@ void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdat
     SetStereoView(RENDER_STEREO_VIEW_OFF);
 
     // update anyone that relies on sizing information
-    CServiceBroker::GetInputManager().SetMouseResolution(info_org.iWidth, info_org.iHeight, 1, 1);
+    CServiceBroker::GetInputManager().SetMouseResolution(info_org.iScreenWidth, info_org.iScreenHeight, 1, 1);
 
     CGUIComponent *gui = CServiceBroker::GetGUI();
     if (gui)
@@ -472,6 +525,8 @@ void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdat
     m_iScreenWidth = origScreenWidth;
     m_iScreenHeight = origScreenHeight;
     m_fFPSOverride = origFPSOverride;
+    m_stereoMode = origStereoMode;
+
     if (IsValidResolution(lastRes))
     {
       m_Resolution = lastRes;
@@ -573,10 +628,18 @@ void CGraphicContext::ResetScreenParameters(RESOLUTION res)
 {
   RESOLUTION_INFO& info = CDisplaySettings::GetInstance().GetResolutionInfo(res);
 
-  info.iSubtitles = info.iHeight;
-  info.fPixelRatio = 1.0f;
-  info.iScreenWidth = info.iWidth;
-  info.iScreenHeight = info.iHeight;
+  switch (res)
+  {
+  case RES_WINDOW:
+    info.iSubtitles = (int)(0.965 * info.iHeight);
+    info.fPixelRatio = 1.0;
+    break;
+  default:
+    break;
+  }
+
+  CLog::Log(LOGWARNING, "CGraphicContext::ResetScreenParameters: Should reset resolutions? {}/{} vs. {}/{}",
+		  info.iWidth, info.iHeight, info.iScreenWidth, info.iScreenHeight);
   ResetOverscan(res, info.Overscan);
 }
 
@@ -599,33 +662,6 @@ const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
 {
   RESOLUTION_INFO info = CDisplaySettings::GetInstance().GetResolutionInfo(res);
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-  {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-    {
-      info.fPixelRatio     /= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
-    }
-    info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
-    info.Overscan.top    /= 2;
-    info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
-    info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
-  }
-
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-  {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-    {
-      info.fPixelRatio     *= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
-    }
-    info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
-    info.Overscan.left   /= 2;
-    info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
-  }
-
   if (res == m_Resolution && m_fFPSOverride != 0)
   {
     info.fRefreshRate = m_fFPSOverride;
@@ -984,13 +1020,6 @@ const std::string& CGraphicContext::GetMediaDir() const
 void CGraphicContext::Flip(bool rendered, bool videoLayer)
 {
   CServiceBroker::GetRenderSystem()->PresentRender(rendered, videoLayer);
-
-  if(m_stereoMode != m_nextStereoMode)
-  {
-    m_stereoMode = m_nextStereoMode;
-    SetVideoResolution(GetVideoResolution(), true);
-    CServiceBroker::GetGUI()->GetWindowManager().SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
-  }
 }
 
 void CGraphicContext::GetAllowedResolutions(std::vector<RESOLUTION> &res)
diff --git a/xbmc/windowing/GraphicContext.h b/xbmc/windowing/GraphicContext.h
index 9cd4f32718..c81dd55596 100644
--- a/xbmc/windowing/GraphicContext.h
+++ b/xbmc/windowing/GraphicContext.h
@@ -29,11 +29,17 @@
 #define D3DPRESENTFLAG_PROGRESSIVE  4
 #define D3DPRESENTFLAG_MODE3DSBS    8
 #define D3DPRESENTFLAG_MODE3DTB    16
+#define D3DPRESENTFLAG_MODE3DFP    32
 
 /* what types are important for mode setting */
 #define D3DPRESENTFLAG_MODEMASK ( D3DPRESENTFLAG_INTERLACED \
                                   | D3DPRESENTFLAG_MODE3DSBS  \
-                                  | D3DPRESENTFLAG_MODE3DTB   )
+                                  | D3DPRESENTFLAG_MODE3DTB   \
+                                  | D3DPRESENTFLAG_MODE3DFP   )
+/* 3D modes only */
+#define D3DPRESENTFLAG_MODE3DMASK (D3DPRESENTFLAG_MODE3DSBS \
+                                   | D3DPRESENTFLAG_MODE3DTB \
+                                   | D3DPRESENTFLAG_MODE3DFP)
 
 enum VIEW_TYPE { VIEW_TYPE_NONE = 0,
                  VIEW_TYPE_LIST,
@@ -82,7 +88,6 @@ public:
 
   void Flip(bool rendered, bool videoLayer);
 
-  // gfx context interface
   int GetWidth() const;
   int GetHeight() const;
   bool SetViewPort(float fx, float fy , float fwidth, float fheight, bool intersectPrevious = false);
@@ -101,6 +106,9 @@ public:
   void ApplyStateBlock();
   void Clear(UTILS::COLOR::Color color = 0);
   void GetAllowedResolutions(std::vector<RESOLUTION> &res);
+  uint32_t ConvertRenderStereoModeToMode3dFlags(RENDER_STEREO_MODE stereo_mode) const;
+  RENDER_STEREO_MODE ConvertMode3dFlagsToRenderStereoMode(uint32_t mode3dFlags) const;
+  RENDER_STEREO_MODE GetRenderStereoModeFromResolution(RESOLUTION resolution) const;
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
    Takes account of overscan and UI zooming.
diff --git a/xbmc/windowing/Resolution.cpp b/xbmc/windowing/Resolution.cpp
index 91d8a39ec0..b6e35681cc 100644
--- a/xbmc/windowing/Resolution.cpp
+++ b/xbmc/windowing/Resolution.cpp
@@ -68,16 +68,16 @@ float RESOLUTION_INFO::DisplayRatio() const
   return iWidth * fPixelRatio / iHeight;
 }
 
-RESOLUTION CResolutionUtils::ChooseBestResolution(float fps, int width, int height, bool is3D)
+RESOLUTION CResolutionUtils::ChooseBestResolution(float fps, int width, int height, const uint32_t modeflag3d)
 {
   RESOLUTION res = CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution();
   float weight = 0.0f;
 
-  if (!FindResolutionFromOverride(fps, width, is3D, res, weight, false)) //find a refreshrate from overrides
+  if (!FindResolutionFromOverride(fps, width, modeflag3d, res, weight, false)) //find a refreshrate from overrides
   {
-    if (!FindResolutionFromOverride(fps, width, is3D, res, weight, true)) //if that fails find it from a fallback
+    if (!FindResolutionFromOverride(fps, width, modeflag3d, res, weight, true)) //if that fails find it from a fallback
     {
-      FindResolutionFromWhitelist(fps, width, height, is3D, res); //find a refreshrate from whitelist
+      FindResolutionFromWhitelist(fps, width, height, modeflag3d, res); //find a refreshrate from whitelist
     }
   }
 
@@ -91,12 +91,12 @@ static inline bool ModeSort(CVariant i, CVariant j)
   return (i < j);
 }
 
-void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int height, bool is3D, RESOLUTION &resolution)
+void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int height, uint32_t modeflag3d, RESOLUTION &resolution)
 {
   RESOLUTION_INFO curr = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(resolution);
   CLog::Log(LOGINFO,
             "[WHITELIST] Searching the whitelist for: width: {}, height: {}, fps: {:0.3f}, 3D: {}",
-            width, height, fps, is3D ? "true" : "false");
+            width, height, fps, modeflag3d ? "true" : "false");
 
   std::vector<CVariant> indexList = CServiceBroker::GetSettingsComponent()->GetSettings()->GetList(CSettings::SETTING_VIDEOSCREEN_WHITELIST);
 
@@ -115,7 +115,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
       info = CDisplaySettings::GetInstance().GetResolutionInfo(c);
       /* add all progressive 2D modes >= desktop */
       if (info.iScreenHeight >= curr.iScreenHeight && info.iScreenWidth >= curr.iScreenWidth &&
-          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (curr.dwFlags & D3DPRESENTFLAG_MODEMASK))
+          (!(info.dwFlags & D3DPRESENTFLAG_MODEMASK) || (info.dwFlags & modeflag3d)))
       {
         // do not add half refreshrates (25, 29.97 by default) as kodi cannot cope with
         // them on playback start. Especially interlaced content is not properly detected
@@ -132,6 +132,13 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
 
   std::sort(indexList.begin(), indexList.end(), ModeSort);
 
+  if (modeflag3d)
+  {
+    if (Find3dResolution(fps, width, height, modeflag3d, indexList, resolution))
+      return;
+	CLog::Log(LOGDEBUG, "[WHITELIST 3D] No match for a 3D resolution");
+  }
+
   CLog::Log(LOGDEBUG, "[WHITELIST] Searching for an exact resolution with an exact refresh rate");
 
   unsigned int penalty = std::numeric_limits<unsigned int>::max();
@@ -146,7 +153,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
     // allow macroblock alignment / padding errors (e.g. 1080 mod16 == 8)
     if (((height == info.iScreenHeight && width <= info.iScreenWidth + 8) ||
          (width == info.iScreenWidth && height <= info.iScreenHeight + 8)) &&
-        (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
         MathUtils::FloatEquals(info.fRefreshRate, fps, 0.01f))
     {
       CLog::Log(LOGDEBUG,
@@ -180,7 +187,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
       // allow macroblock alignment / padding errors (e.g. 1080 mod16 == 8)
       if (((height == info.iScreenHeight && width <= info.iScreenWidth + 8) ||
            (width == info.iScreenWidth && height <= info.iScreenHeight + 8)) &&
-          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
           MathUtils::FloatEquals(info.fRefreshRate, fps * 2, 0.01f))
       {
         CLog::Log(LOGDEBUG,
@@ -219,7 +226,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
       // allow macroblock alignment / padding errors (e.g. 1080 mod16 == 8)
       if (((height == info.iScreenHeight && width <= info.iScreenWidth + 8) ||
            (width == info.iScreenWidth && height <= info.iScreenHeight + 8)) &&
-          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+          ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
           MathUtils::FloatEquals(info.fRefreshRate, fps * 2.5f, 0.01f))
       {
         CLog::Log(
@@ -254,8 +261,8 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
       const RESOLUTION_INFO info = CDisplaySettings::GetInstance().GetResolutionInfo(i);
 
       // pick the lowest resolution that has a matching refresh rate
-      if ((info.iScreenHeight >= height || info.iScreenWidth >= width) &&
-        (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (curr.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+      if ((info.iScreenHeight >= height && info.iScreenWidth >= width) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
           MathUtils::FloatEquals(info.fRefreshRate, fps, 0.01f))
       {
         resolution = i;
@@ -278,7 +285,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
 
     // allow resolutions that are desktop resolution but have the correct refresh rate
     if (info.iScreenWidth == desktop_info.iScreenWidth &&
-        (info.dwFlags & D3DPRESENTFLAG_MODEMASK) == (desktop_info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
         MathUtils::FloatEquals(info.fRefreshRate, fps, 0.01f))
     {
       CLog::Log(LOGDEBUG,
@@ -305,8 +312,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
 
       // allow resolutions that are desktop resolution but have double the refresh rate
       if (info.iScreenWidth == desktop_info.iScreenWidth &&
-          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) ==
-              (desktop_info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
           MathUtils::FloatEquals(info.fRefreshRate, fps * 2, 0.01f))
       {
         CLog::Log(LOGDEBUG,
@@ -334,8 +340,7 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
 
       // allow resolutions that are desktop resolution but have 2.5 times the refresh rate
       if (info.iScreenWidth == desktop_info.iScreenWidth &&
-          (info.dwFlags & D3DPRESENTFLAG_MODEMASK) ==
-              (desktop_info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+        ! (info.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
           MathUtils::FloatEquals(info.fRefreshRate, fps * 2.5f, 0.01f))
       {
         CLog::Log(
@@ -351,10 +356,19 @@ void CResolutionUtils::FindResolutionFromWhitelist(float fps, int width, int hei
               "[WHITELIST] No match for a desktop resolution with a 3:2 pulldown refresh rate");
   }
 
+  if (!(modeflag3d & D3DPRESENTFLAG_MODE3DMASK) && (curr.dwFlags & D3DPRESENTFLAG_MODE3DMASK))
+  {
+    CLog::Log(LOGDEBUG, "[WHITELIST] No resolution matched, use RES_DESKTOP as 2D resolution fallback");
+    // we're searching for a 2D resolution but the current one is 3D, so we need to use a 2D
+    // fallback now
+    resolution = RES_DESKTOP;
+    return;
+  }
+
   CLog::Log(LOGDEBUG, "[WHITELIST] No resolution matched");
 }
 
-bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight, bool fallback)
+bool CResolutionUtils::FindResolutionFromOverride(float fps, int width, uint32_t modeflag3d, RESOLUTION &resolution, float& weight, bool fallback)
 {
   RESOLUTION_INFO curr = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(resolution);
 
@@ -506,3 +520,84 @@ void CResolutionUtils::GetMaxAllowedResolution(unsigned int& width, unsigned int
   width = maxWidth;
   height = maxHeight;
 }
+
+bool CResolutionUtils::Find3dResolution(float fps, int width, int height, uint32_t modeflag3d, std::vector<CVariant> &indexList, RESOLUTION &resolution)
+{
+  CLog::Log(LOGDEBUG, "[WHITELIST 3D] Searching for an exact 3D resolution with an exact refresh rate");
+
+  for (const auto &mode : indexList)
+  {
+	RESOLUTION i = CDisplaySettings::GetInstance().GetResFromString(mode.asString());
+	const RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(i);
+
+	// allow resolutions that are exact and have the correct refresh rate
+	// allow macroblock alignement / padding errors (e.g. 1080 mod16 == 8)
+	if (((height == info.iScreenHeight && width <= info.iScreenWidth + 8) ||
+		 (width == info.iScreenWidth && height <= info.iScreenHeight + 8)) &&
+		 (info.dwFlags & modeflag3d) &&
+		MathUtils::FloatEquals(info.fRefreshRate, fps, 0.01f))
+	{
+	  CLog::Log(LOGDEBUG, "[WHITELIST 3D] Matched an exact 3D resolution with an exact refresh rate {} ({})", info.strMode, i);
+	  resolution = i;
+	  return true;
+	}
+  }
+
+  CLog::Log(LOGDEBUG, "[WHITELIST 3D] No match for an exact 3D resolution with an exact refresh rate, searching for double refresh rate now");
+
+  for (const auto &mode : indexList)
+  {
+	RESOLUTION i = CDisplaySettings::GetInstance().GetResFromString(mode.asString());
+	const RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(i);
+
+	// allow resolutions that are exact and have the double refresh rate
+	// allow macroblock alignement / padding errors (e.g. 1080 mod16 == 8)
+	if (((height == info.iScreenHeight && width <= info.iScreenWidth + 8) ||
+		 (width == info.iScreenWidth && height <= info.iScreenHeight + 8)) &&
+		 (info.dwFlags & modeflag3d) &&
+		MathUtils::FloatEquals(info.fRefreshRate, fps * 2, 0.01f))
+	{
+	  CLog::Log(LOGDEBUG, "[WHITELIST 3D] Matched an exact 3D resolution with double refresh rate {} ({})", info.strMode, i);
+	  resolution = i;
+	  return true;
+	}
+  }
+
+  CLog::Log(LOGDEBUG, "[WHITELIST 3D] No match for an exact 3D resolution with double refresh rate, searching for higher resolution with exact refresh rate now");
+
+  for (const auto &mode : indexList)
+  {
+	RESOLUTION i = CDisplaySettings::GetInstance().GetResFromString(mode.asString());
+	const RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(i);
+
+	// allow resolutions that are higher and have the correct refresh rate
+	if ((height <= info.iScreenHeight || width <= info.iScreenWidth) &&
+		 (info.dwFlags & modeflag3d) &&
+		MathUtils::FloatEquals(info.fRefreshRate, fps, 0.01f))
+	{
+	  CLog::Log(LOGDEBUG, "[WHITELIST 3D] Matched a higher 3D resolution with exact refresh rate {} ({})", info.strMode, i);
+	  resolution = i;
+	  return true;
+	}
+  }
+
+  CLog::Log(LOGDEBUG, "[WHITELIST 3D] No match for a higher 3D resolution with exact refresh rate, searching for higher resolution with double refresh rate now");
+
+  for (const auto &mode : indexList)
+  {
+	RESOLUTION i = CDisplaySettings::GetInstance().GetResFromString(mode.asString());
+	const RESOLUTION_INFO info = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(i);
+
+	// allow resolutions that are higher and have the double refresh rate
+	if ((height <= info.iScreenHeight || width <= info.iScreenWidth) &&
+		 (info.dwFlags & modeflag3d) &&
+		MathUtils::FloatEquals(info.fRefreshRate, fps * 2, 0.01f))
+	{
+	  CLog::Log(LOGDEBUG, "[WHITELIST 3D] Matched a higher 3D resolution with double refresh rate {} ({})", info.strMode, i);
+	  resolution = i;
+	  return true;
+	}
+  }
+
+  return false;
+}
diff --git a/xbmc/windowing/Resolution.h b/xbmc/windowing/Resolution.h
index 768d459238..80af3d126d 100644
--- a/xbmc/windowing/Resolution.h
+++ b/xbmc/windowing/Resolution.h
@@ -10,6 +10,9 @@
 
 #include <stdint.h>
 #include <string>
+#include <vector>
+
+class CVariant;
 
 typedef int DisplayMode;
 #define DM_WINDOWED     -1
@@ -89,7 +92,7 @@ public:
 class CResolutionUtils
 {
 public:
-  static RESOLUTION ChooseBestResolution(float fps, int width, int height, bool is3D);
+  static RESOLUTION ChooseBestResolution(float fps, int width, int height, const uint32_t modeflag3d);
   static bool HasWhitelist();
   static void PrintWhitelist();
 
@@ -101,7 +104,8 @@ public:
   static void GetMaxAllowedResolution(unsigned int& width, unsigned int& height);
 
 protected:
-  static void FindResolutionFromWhitelist(float fps, int width, int height, bool is3D, RESOLUTION &resolution);
-  static bool FindResolutionFromOverride(float fps, int width, bool is3D, RESOLUTION &resolution, float& weight, bool fallback);
+  static void FindResolutionFromWhitelist(float fps, int width, int height, uint32_t modeflag3d, RESOLUTION &resolution);
+  static bool FindResolutionFromOverride(float fps, int width, uint32_t modeflag3d, RESOLUTION &resolution, float& weight, bool fallback);
+  static bool Find3dResolution(float fps, int width, int height, uint32_t modeflag3d, std::vector<CVariant> &indexList, RESOLUTION &resolution);
   static float RefreshWeight(float refresh, float fps);
 };
diff --git a/xbmc/windowing/WinSystem.cpp b/xbmc/windowing/WinSystem.cpp
index cef6940576..fe7c481202 100644
--- a/xbmc/windowing/WinSystem.cpp
+++ b/xbmc/windowing/WinSystem.cpp
@@ -70,6 +70,8 @@ void CWinSystemBase::UpdateDesktopResolution(RESOLUTION_INFO& newRes, const std:
     newRes.strMode += "i";
   if (dwFlags & D3DPRESENTFLAG_MODE3DTB)
     newRes.strMode += "tab";
+  if (dwFlags & D3DPRESENTFLAG_MODE3DFP)
+    newRes.strMode += "fp";
   if (dwFlags & D3DPRESENTFLAG_MODE3DSBS)
     newRes.strMode += "sbs";
   newRes.strOutput = output;
diff --git a/xbmc/windowing/amlogic/CMakeLists.txt b/xbmc/windowing/amlogic/CMakeLists.txt
new file mode 100644
index 0000000000..5df7176c70
--- /dev/null
+++ b/xbmc/windowing/amlogic/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(SOURCES WinSystemAmlogic.cpp
+            VideoSyncAML.cpp)
+
+set(HEADERS WinSystemAmlogic.h
+            VideoSyncAML.h)
+
+if(OPENGLES_FOUND)
+  list(APPEND SOURCES WinSystemAmlogicGLESContext.cpp)
+  list(APPEND HEADERS WinSystemAmlogicGLESContext.h)
+endif()
+
+core_add_library(windowing_Amlogic)
diff --git a/xbmc/windowing/amlogic/VideoSyncAML.cpp b/xbmc/windowing/amlogic/VideoSyncAML.cpp
new file mode 100644
index 0000000000..391c9f3a4e
--- /dev/null
+++ b/xbmc/windowing/amlogic/VideoSyncAML.cpp
@@ -0,0 +1,96 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoSyncAML.h"
+#include "ServiceBroker.h"
+#include "windowing/GraphicContext.h"
+#include "utils/TimeUtils.h"
+#include "utils/log.h"
+#include "threads/Thread.h"
+#include "windowing/WinSystem.h"
+#include <sys/poll.h>
+
+#include <chrono>
+#include <thread>
+
+extern CEvent g_aml_codec_sync_event;
+
+CVideoSyncAML::CVideoSyncAML(void *clock)
+: CVideoSync(clock)
+, m_abort(false)
+{
+}
+
+CVideoSyncAML::~CVideoSyncAML()
+{
+}
+
+bool CVideoSyncAML::Setup(PUPDATECLOCK func)
+{
+  UpdateClock = func;
+
+  m_abort = false;
+
+  CServiceBroker::GetWinSystem()->Register(this);
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: setting up AML");
+
+  return true;
+}
+
+void CVideoSyncAML::Run(CEvent& stopEvent)
+{
+  // We use the wall clock for timout handling (no AML h/w, startup)
+  std::chrono::time_point<std::chrono::system_clock> now(std::chrono::system_clock::now());
+  unsigned int waittime (3000 / m_fps);
+  uint64_t numVBlanks (0);
+
+  /* This shouldn't be very busy and timing is important so increase priority */
+  CThread::GetCurrentThread()->SetPriority(ThreadPriority::ABOVE_NORMAL);
+
+  while (!stopEvent.Signaled() && !m_abort)
+  {
+    int countVSyncs(1);
+    if( !g_aml_codec_sync_event.Wait(std::chrono::milliseconds(waittime)))
+    {
+      std::chrono::milliseconds elapsed(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count());
+      uint64_t curVBlanks = (m_fps * elapsed.count()) / 1000;
+      int64_t lastVBlankTime((curVBlanks * 1000) / m_fps);
+      if (elapsed.count() > lastVBlankTime)
+      {
+        lastVBlankTime = (++curVBlanks * 1000) / m_fps;
+        std::this_thread::sleep_for(std::chrono::milliseconds(lastVBlankTime - elapsed.count()));
+      }
+      countVSyncs = curVBlanks - numVBlanks;
+      numVBlanks = curVBlanks;
+    }
+    else
+      ++numVBlanks;
+
+    uint64_t now = CurrentHostCounter();
+
+    UpdateClock(countVSyncs, now, m_refClock);
+  }
+}
+
+void CVideoSyncAML::Cleanup()
+{
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: cleaning up AML");
+  CServiceBroker::GetWinSystem()->Unregister(this);
+}
+
+float CVideoSyncAML::GetFps()
+{
+  m_fps = CServiceBroker::GetWinSystem()->GetGfxContext().GetFPS();
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: fps: {:.3f}", m_fps);
+  return m_fps;
+}
+
+void CVideoSyncAML::OnResetDisplay()
+{
+  m_abort = true;
+}
diff --git a/xbmc/windowing/amlogic/VideoSyncAML.h b/xbmc/windowing/amlogic/VideoSyncAML.h
new file mode 100644
index 0000000000..961c520493
--- /dev/null
+++ b/xbmc/windowing/amlogic/VideoSyncAML.h
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "windowing/VideoSync.h"
+#include "guilib/DispResource.h"
+
+class CVideoSyncAML : public CVideoSync, IDispResource
+{
+public:
+  CVideoSyncAML(void *clock);
+  virtual ~CVideoSyncAML();
+  virtual bool Setup(PUPDATECLOCK func)override;
+  virtual void Run(CEvent& stopEvent)override;
+  virtual void Cleanup()override;
+  virtual float GetFps()override;
+  virtual void OnResetDisplay()override;
+private:
+  volatile bool m_abort;
+};
diff --git a/xbmc/windowing/amlogic/WinSystemAmlogic.cpp b/xbmc/windowing/amlogic/WinSystemAmlogic.cpp
new file mode 100755
index 0000000000..c95233de44
--- /dev/null
+++ b/xbmc/windowing/amlogic/WinSystemAmlogic.cpp
@@ -0,0 +1,535 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemAmlogic.h"
+
+#include <string.h>
+#include <float.h>
+
+#include "ServiceBroker.h"
+#include "cores/RetroPlayer/process/amlogic/RPProcessInfoAmlogic.h"
+#include "cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h"
+#include "cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.h"
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
+#include "cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.h"
+#include "cores/AudioEngine/AESinkFactory.h"
+#include "cores/AudioEngine/Sinks/AESinkALSA.h"
+#include "windowing/GraphicContext.h"
+#include "windowing/Resolution.h"
+#include "platform/linux/powermanagement/LinuxPowerSyscall.h"
+#include "platform/linux/ScreenshotSurfaceAML.h"
+#include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/SettingPath.h"
+#include "settings/windows/GUIControlSettings.h"
+#include "guilib/DispResource.h"
+#include "utils/AMLUtils.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "utils/StringUtils.h"
+#include "threads/SingleLock.h"
+#include "messaging/ApplicationMessenger.h"
+#include <libudev.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <locale.h>
+#include <unistd.h>
+
+using namespace KODI::MESSAGING;
+
+#include <linux/fb.h>
+
+#include "system_egl.h"
+
+using namespace KODI;
+
+CWinSystemAmlogic::CWinSystemAmlogic() :
+  m_libinput(new CLibInputHandler)
+{
+  const char *env_framebuffer = getenv("FRAMEBUFFER");
+
+  // default to framebuffer 0
+  m_framebuffer_name = "fb0";
+  if (env_framebuffer)
+  {
+    std::string framebuffer(env_framebuffer);
+    std::string::size_type start = framebuffer.find("fb");
+    m_framebuffer_name = framebuffer.substr(start);
+  }
+
+  m_nativeDisplay = EGL_NO_DISPLAY;
+  m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+
+  m_displayWidth = 0;
+  m_displayHeight = 0;
+
+  m_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_delayDispReset = false;
+
+  aml_permissions();
+  aml_disable_freeScale();
+
+ /* Take in to account custom OSMC parameters */
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_FORCERGB)) {
+    CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::Initialize -- forcing RGB");
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/output_rgb", "1");
+ }
+
+  int range_control;
+  SysfsUtils::GetInt("/sys/module/am_vecm/parameters/range_control", range_control);
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_LIMITEDRANGEAML))
+    range_control &= 1;
+  else
+    range_control |= 2;
+  CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::Initialize -- setting quantization range to {}",
+      range_control & 2 ? "full" : "limited");
+  SysfsUtils::SetInt("/sys/module/am_vecm/parameters/range_control", range_control);
+
+ if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_LOCKHPD)) {
+    CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::Initialize -- forcing HPD to be locked");
+    SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/debug", "hpd_lock1");
+ }
+
+ std::string attr = "";
+ SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/attr", attr);
+
+ if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_FORCE422)) {
+   if (attr.find("444") != std::string::npos ||
+       attr.find("422") != std::string::npos ||
+       attr.find("420") != std::string::npos)
+     attr.replace(attr.find("4"),3,"422").append("now");
+   else
+     attr.append("422now");
+ }
+ else {
+   if (attr.find("422") != std::string::npos)
+     attr.erase(attr.find("4"),3);
+   attr.append("now");
+ }
+ CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::Initialize -- setting 422 output, attr = {}", attr);
+ SysfsUtils::SetString("/sys/class/amhdmitx/amhdmitx0/attr", attr.c_str());
+
+ int maxlum = 100;
+ maxlum = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOSCREEN_MAXLUM);
+ CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::Initialize -- setting max lum to {}", maxlum);
+ SysfsUtils::SetInt("/sys/module/am_vecm/parameters/customer_panel_lumin", maxlum);
+
+ SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/rawedid", m_lastEdid);
+ StartMonitorHWEvent();
+
+  // Register sink
+  AE::CAESinkFactory::ClearSinks();
+  CAESinkALSA::Register();
+  m_libinput->Start();
+}
+
+CWinSystemAmlogic::~CWinSystemAmlogic()
+{
+  StopMonitorHWEvent();
+
+  if(m_nativeWindow)
+  {
+    m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+  }
+}
+
+void hwMon(CWinSystemAmlogic *instance) {
+
+        struct udev *udev;
+        struct udev_device *dev;
+
+        struct udev_monitor *mon;
+        int fd;
+
+        /* Create the udev object */
+        udev = udev_new();
+        if (!udev) {
+                return;
+        }
+
+        mon = udev_monitor_new_from_netlink(udev, "udev");
+        udev_monitor_filter_add_match_subsystem_devtype(mon, "extcon", NULL);
+	udev_monitor_filter_add_match_subsystem_devtype(mon, "switch", NULL);
+
+        udev_monitor_enable_receiving(mon);
+        fd = udev_monitor_get_fd(mon);
+
+        /* Poll for events */
+
+        while (1 && instance->m_monitorEvents) {
+
+                fd_set fds;
+                struct timeval tv;
+                int ret;
+
+                FD_ZERO(&fds);
+                FD_SET(fd, &fds);
+                tv.tv_sec = 0;
+                tv.tv_usec = 0;
+
+                ret = select(fd+1, &fds, NULL, NULL, &tv);
+
+                /* Check if FD has received data */
+
+                if (ret > 0 && FD_ISSET(fd, &fds)) {
+
+                        dev = udev_monitor_receive_device(mon);
+                        if (dev) {
+                                CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic: Detected HDMI switch");
+                                int state;
+                                SysfsUtils::GetInt("/sys/class/amhdmitx/amhdmitx0/hpd_state", state);
+				std::string newEdid;
+				SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/rawedid", newEdid);
+
+                                if (state && newEdid != instance->m_lastEdid) {
+                                    CServiceBroker::GetAppMessenger()->PostMsg(TMSG_AML_RESIZE);
+				    instance->m_lastEdid = newEdid;
+				}
+                                udev_device_unref(dev);
+                        }
+                        else {
+                                CLog::Log(LOGERROR, "CEGLNativeTypeAmlogic: can't get device from receive_device");
+                        }
+                }
+                usleep(250*1000);
+        }
+}
+
+void CWinSystemAmlogic::StartMonitorHWEvent() {
+    CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::StartMonitorHWEvent -- starting event monitor for HDMI hotplug events");
+    m_monitorEvents = true;
+    m_monitorThread = std::thread(hwMon, this);
+    return;
+}
+
+void CWinSystemAmlogic::StopMonitorHWEvent() {
+    CLog::Log(LOGDEBUG, "CEGLNativeTypeAmlogic::StopMonitorHWEvent -- stopping event monitor for HDMI hotplug events");
+    m_monitorEvents = false;
+    m_monitorThread.join();
+    return;
+}
+
+bool CWinSystemAmlogic::InitWindowSystem()
+{
+
+const std::shared_ptr<CSettings> settings = CServiceBroker::GetSettingsComponent()->GetSettings();
+
+  if (!aml_support_av1()) {
+	auto setting = settings->GetSetting(CSettings::SETTING_VIDEOPLAYER_USEAMCODECAV1);
+	if (setting)
+	{
+		setting->SetVisible(false);
+		settings->SetBool(CSettings::SETTING_VIDEOPLAYER_USEAMCODECAV1, false);
+	}
+  }
+
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+
+  CDVDVideoCodecAmlogic::Register();
+  CLinuxRendererGLES::Register();
+  RETRO::CRPProcessInfoAmlogic::Register();
+  RETRO::CRPProcessInfoAmlogic::RegisterRendererFactory(new RETRO::CRendererFactoryOpenGLES);
+  CRendererAML::Register();
+  CScreenshotSurfaceAML::Register();
+
+  aml_set_framebuffer_resolution(1920, 2205, m_framebuffer_name);
+
+  return CWinSystemBase::InitWindowSystem();
+}
+
+bool CWinSystemAmlogic::DestroyWindowSystem()
+{
+  return true;
+}
+
+void CWinSystemAmlogic::CalculateFrameBufferResolution(const RESOLUTION_INFO &res, int &width, int &height)
+{
+	aml_calc_framebuffer_resolution(res, width, height);
+}
+
+bool CWinSystemAmlogic::CreateNewWindow(const std::string& name,
+                                    bool fullScreen,
+                                    RESOLUTION_INFO& res)
+{
+  RESOLUTION_INFO current_resolution;
+  current_resolution.iWidth = current_resolution.iHeight = 0;
+  RENDER_STEREO_MODE stereo_mode = CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
+
+  m_nWidth        = res.iWidth;
+  m_nHeight       = res.iHeight;
+  m_displayWidth  = res.iScreenWidth;
+  m_displayHeight = res.iScreenHeight;
+  m_fRefreshRate  = res.fRefreshRate;
+
+  if ((m_bWindowCreated && aml_get_native_resolution(&current_resolution)) &&
+    current_resolution.iWidth == res.iWidth && current_resolution.iHeight == res.iHeight &&
+    current_resolution.iScreenWidth == res.iScreenWidth && current_resolution.iScreenHeight == res.iScreenHeight &&
+    m_bFullScreen == fullScreen && current_resolution.fRefreshRate == res.fRefreshRate &&
+    (current_resolution.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+    m_stereo_mode == stereo_mode)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemEGL::CreateNewWindow: No need to create a new window");
+    return true;
+  }
+
+  int delay = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt("videoscreen.delayrefreshchange");
+  if (delay > 0)
+  {
+    m_delayDispReset = true;
+    m_dispResetTimer.Set(std::chrono::milliseconds(static_cast<unsigned int>(delay * 100)));
+  }
+
+  {
+    std::unique_lock<CCriticalSection> lock(m_resourceSection);
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+    {
+      (*i)->OnLostDisplay();
+    }
+  }
+
+  m_stereo_mode = stereo_mode;
+  m_bFullScreen = fullScreen;
+
+#ifdef _FBDEV_WINDOW_H_
+  int fbWidth, fbHeight;
+  CalculateFrameBufferResolution(res, fbWidth, fbHeight);
+
+  fbdev_window *nativeWindow = new fbdev_window;
+  nativeWindow->width = (ushort) fbWidth;
+  nativeWindow->height = (ushort) fbHeight;
+  m_nativeWindow = static_cast<EGLNativeWindowType>(nativeWindow);
+#endif
+
+  aml_set_native_resolution(res, m_framebuffer_name, stereo_mode);
+
+  if (!m_delayDispReset)
+  {
+    std::unique_lock<CCriticalSection> lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+    {
+      (*i)->OnResetDisplay();
+    }
+  }
+
+  return true;
+}
+
+bool CWinSystemAmlogic::DestroyWindow()
+{
+  m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+
+  return true;
+}
+
+static std::string ModeFlagsToString(unsigned int flags, bool identifier)
+{
+  std::string res;
+  if(flags & D3DPRESENTFLAG_INTERLACED)
+    res += "i";
+  else
+    res += "p";
+
+  if(!identifier)
+    res += " ";
+
+  if(flags & D3DPRESENTFLAG_MODE3DSBS)
+    res += "sbs";
+  else if(flags & D3DPRESENTFLAG_MODE3DTB)
+    res += "tab";
+  else if(flags & D3DPRESENTFLAG_MODE3DFP)
+    res += "fp";
+  else if(identifier)
+    res += "std";
+  return res;
+}
+
+void CWinSystemAmlogic::Update3dResolutions()
+{
+  if (!aml_probe_3d_resolutions(resolutions3d) || resolutions3d.empty())
+  {
+    CLog::Log(LOGWARNING, "{}: No valid 3D resolutions found.",__FUNCTION__);
+    return;
+  }
+
+  for (size_t i = 0; i < resolutions3d.size(); i++)
+  {
+	if (resolutions3d[i].dwFlags & D3DPRESENTFLAG_INTERLACED) // ignore interlaced 3D resolutions
+	  continue;
+
+    std::string m3d = "<unknown>";
+    if (resolutions3d[i].dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+      m3d = "SBS";
+    else if (resolutions3d[i].dwFlags & D3DPRESENTFLAG_MODE3DTB)
+      m3d = "TAB";
+    else if (resolutions3d[i].dwFlags & D3DPRESENTFLAG_MODE3DFP)
+      m3d = "FP";
+
+    CServiceBroker::GetWinSystem()->GetGfxContext().ResetOverscan(resolutions3d[i]);
+    CDisplaySettings::GetInstance().AddResolutionInfo(resolutions3d[i]);
+
+    CLog::Log(LOGINFO, "Found 3D resolution {} x {} with {} x {}{} @ {:f} ({})",
+      resolutions3d[i].iWidth,
+      resolutions3d[i].iHeight,
+      resolutions3d[i].iScreenWidth,
+      resolutions3d[i].iScreenHeight,
+      resolutions3d[i].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resolutions3d[i].fRefreshRate,
+      m3d);
+  }
+}
+
+void CWinSystemAmlogic::UpdateResolutions()
+{
+  CWinSystemBase::UpdateResolutions();
+
+  RESOLUTION_INFO resDesktop, curDisplay;
+  std::string curDesktopSetting, curResolution, newRes;
+  std::vector<RESOLUTION_INFO> resolutions;
+
+  if (!aml_probe_resolutions(resolutions) || resolutions.empty())
+  {
+    CLog::Log(LOGWARNING, "{}: ProbeResolutions failed.",__FUNCTION__);
+  }
+
+  /* ProbeResolutions includes already all resolutions.
+   * Only get desktop resolution so we can replace xbmc's desktop res
+   */
+  if (aml_get_native_resolution(&curDisplay))
+  {
+    resDesktop = curDisplay;
+  }
+
+  curDesktopSetting = CServiceBroker::GetSettingsComponent()->GetSettings()->GetString(CSettings::SETTING_VIDEOSCREEN_SCREENMODE);
+
+  curResolution = StringUtils::Format("{:05}{:05}{:09.5f}{}",
+      resDesktop.iScreenWidth, resDesktop.iScreenHeight, resDesktop.fRefreshRate,
+      ModeFlagsToString(resDesktop.dwFlags, true));
+
+  if (curDesktopSetting == "DESKTOP")
+    curDesktopSetting = curResolution;
+  else if (curDesktopSetting.length() == 24)
+    curDesktopSetting = StringUtils::Right(curDesktopSetting, 23);
+
+  CLog::Log(LOGINFO, "Current display setting is {}", curDesktopSetting);
+  CLog::Log(LOGINFO, "Current output resolution is {}", curResolution);
+
+  RESOLUTION ResDesktop = RES_INVALID;
+  RESOLUTION res_index  = RES_DESKTOP;
+  bool resExactMatch = false;
+  std::string ResString;
+  std::string ResFallback = "00480024.00000istd";
+
+  for (size_t i = 0; i < resolutions.size(); i++)
+  {
+    // if this is a new setting,
+    // create a new empty setting to fill in.
+    if ((int)CDisplaySettings::GetInstance().ResolutionInfoSize() <= res_index)
+    {
+      RESOLUTION_INFO res;
+      CDisplaySettings::GetInstance().AddResolutionInfo(res);
+    }
+
+    CServiceBroker::GetWinSystem()->GetGfxContext().ResetOverscan(resolutions[i]);
+    CDisplaySettings::GetInstance().GetResolutionInfo(res_index) = resolutions[i];
+
+    CLog::Log(LOGINFO, "Found resolution {:d} x {:d} with {:d} x {:d}{} @ {:f} Hz\n",
+      resolutions[i].iWidth,
+      resolutions[i].iHeight,
+      resolutions[i].iScreenWidth,
+      resolutions[i].iScreenHeight,
+      resolutions[i].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resolutions[i].fRefreshRate);
+
+    ResString = StringUtils::Format("{:05}{:05}{:09.5f}{}",
+          resolutions[i].iScreenWidth, resolutions[i].iScreenHeight, resolutions[i].fRefreshRate,
+          ModeFlagsToString(resolutions[i].dwFlags, true));
+    if (curDesktopSetting == ResString){
+      ResDesktop = res_index;
+      resExactMatch = true;
+      newRes = ResString;
+      CLog::Log(LOGINFO, "Current resolution setting found at 16 + {}", i);
+    }
+
+    /* fall back to the highest resolution available but not more than current desktop */
+    if(curDesktopSetting.substr(5,18).compare(ResString.substr(5,18)) >= 0 &&
+        ResString.substr(5,18).compare(ResFallback) > 0 && ! resExactMatch)
+    {
+      ResDesktop = res_index;
+      ResFallback = ResString.substr(5,18);
+      newRes = ResString;
+      CLog::Log(LOGINFO, "Fallback resolution at 16 + {} {}", i, ResFallback);
+    }
+
+    res_index = (RESOLUTION)((int)res_index + 1);
+  }
+
+  // set RES_DESKTOP
+  if (ResDesktop != RES_INVALID)
+  {
+    CLog::Log(LOGINFO, "Found {} at {:d}, setting to RES_DESKTOP at {:d}", newRes, (int) ResDesktop, (int) RES_DESKTOP);
+
+    CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop);
+  }
+  Update3dResolutions();
+  CDisplaySettings::GetInstance().ApplyCalibrations();
+}
+
+bool CWinSystemAmlogic::Hide()
+{
+  return false;
+}
+
+bool CWinSystemAmlogic::Show(bool show)
+{
+  std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
+  SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
+  return true;
+}
+
+void CWinSystemAmlogic::Register(IDispResource *resource)
+{
+  std::unique_lock<CCriticalSection> lock(m_resourceSection);
+  m_resources.push_back(resource);
+}
+
+void CWinSystemAmlogic::Unregister(IDispResource *resource)
+{
+  std::unique_lock<CCriticalSection> lock(m_resourceSection);
+  std::vector<IDispResource*>::iterator i = find(m_resources.begin(), m_resources.end(), resource);
+  if (i != m_resources.end())
+    m_resources.erase(i);
+}
+
+CHDRCapabilities CWinSystemAmlogic::GetDisplayHDRCapabilities() const
+{
+  std::string hdr_caps;
+  CHDRCapabilities HDRcaps;
+  if (SysfsUtils::GetString("/sys/class/amvecm/hdr_support", hdr_caps) == 0)
+  {
+    if (hdr_caps.find("HDR10") != std::string::npos)
+      HDRcaps.SetHDR10();
+    if (hdr_caps.find("HDR10+") != std::string::npos)
+      HDRcaps.SetHDR10Plus();
+    if (hdr_caps.find("HLG") != std::string::npos)
+      HDRcaps.SetHLG();
+    if (hdr_caps.find("DV") != std::string::npos)
+      HDRcaps.SetDolbyVision();
+  }
+  return HDRcaps;
+}
+
+bool CWinSystemAmlogic::IsHDRDisplay()
+{
+  CHDRCapabilities HDRcaps;
+  HDRcaps = CWinSystemAmlogic::GetDisplayHDRCapabilities();
+  return HDRcaps.SupportsHDR10();
+}
+
diff --git a/xbmc/windowing/amlogic/WinSystemAmlogic.h b/xbmc/windowing/amlogic/WinSystemAmlogic.h
new file mode 100644
index 0000000000..528e82f911
--- /dev/null
+++ b/xbmc/windowing/amlogic/WinSystemAmlogic.h
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "platform/linux/input/LibInputHandler.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "threads/CriticalSection.h"
+#include "windowing/WinSystem.h"
+#include "threads/SystemClock.h"
+#include "EGL/egl.h"
+#include <thread>
+
+class IDispResource;
+
+class CWinSystemAmlogic : public CWinSystemBase
+{
+public:
+  CWinSystemAmlogic();
+  virtual ~CWinSystemAmlogic();
+
+  bool InitWindowSystem() override;
+  bool DestroyWindowSystem() override;
+
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool DestroyWindow() override;
+  void UpdateResolutions() override;
+
+  bool Hide() override;
+  bool Show(bool show = true) override;
+  virtual void Register(IDispResource *resource);
+  virtual void Unregister(IDispResource *resource);
+  CHDRCapabilities GetDisplayHDRCapabilities() const override;
+  bool IsHDRDisplay() override;
+  bool m_monitorEvents;
+  std::string m_lastEdid;
+  
+protected:
+  std::string m_framebuffer_name;
+  EGLDisplay m_nativeDisplay;
+  EGLNativeWindowType m_nativeWindow;
+
+  int m_displayWidth;
+  int m_displayHeight;
+
+  RENDER_STEREO_MODE m_stereo_mode;
+
+  bool m_delayDispReset;
+  XbmcThreads::EndTime<> m_dispResetTimer;
+
+  CCriticalSection m_resourceSection;
+  std::vector<IDispResource*> m_resources;
+  std::unique_ptr<CLibInputHandler> m_libinput;
+  void StartMonitorHWEvent();
+  void StopMonitorHWEvent();
+  std::thread m_monitorThread;
+  void CalculateFrameBufferResolution(const RESOLUTION_INFO &res, int &width, int &height);
+
+private:
+  std::vector<RESOLUTION_INFO> resolutions3d;
+
+  void Update3dResolutions();
+};
diff --git a/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.cpp b/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.cpp
new file mode 100644
index 0000000000..25926a3e6e
--- /dev/null
+++ b/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.cpp
@@ -0,0 +1,177 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "VideoSyncAML.h"
+#include "WinSystemAmlogicGLESContext.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+#include "windowing/WindowSystemFactory.h"
+#include "windowing/GraphicContext.h"
+
+using namespace KODI;
+using namespace KODI::WINDOWING::AML;
+
+void CWinSystemAmlogicGLESContext::Register()
+{
+  KODI::WINDOWING::CWindowSystemFactory::RegisterWindowSystem(CreateWinSystem, "aml");
+}
+
+std::unique_ptr<CWinSystemBase> CWinSystemAmlogicGLESContext::CreateWinSystem()
+{
+  return std::make_unique<CWinSystemAmlogicGLESContext>();
+}
+
+bool CWinSystemAmlogicGLESContext::InitWindowSystem()
+{
+  if (!CWinSystemAmlogic::InitWindowSystem())
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.CreateDisplay(m_nativeDisplay))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.InitializeDisplay(EGL_OPENGL_ES_API))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.ChooseConfig(EGL_OPENGL_ES2_BIT))
+  {
+    return false;
+  }
+
+  CEGLAttributesVec contextAttribs;
+  contextAttribs.Add({{EGL_CONTEXT_CLIENT_VERSION, 2}});
+
+  if (!m_pGLContext.CreateContext(contextAttribs))
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CWinSystemAmlogicGLESContext::CreateNewWindow(const std::string& name,
+                                               bool fullScreen,
+                                               RESOLUTION_INFO& res)
+{
+  m_pGLContext.DestroySurface();
+
+  if (!CWinSystemAmlogic::DestroyWindow())
+  {
+    return false;
+  }
+
+  if (!CWinSystemAmlogic::CreateNewWindow(name, fullScreen, res))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.CreateSurface(m_nativeWindow))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.BindContext())
+  {
+    return false;
+  }
+
+  if (!m_delayDispReset)
+  {
+    std::unique_lock<CCriticalSection> lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+
+  return true;
+}
+
+bool CWinSystemAmlogicGLESContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight);
+  return true;
+}
+
+bool CWinSystemAmlogicGLESContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  CreateNewWindow("", fullScreen, res);
+
+  int fbWidth, fbHeight;
+  CalculateFrameBufferResolution(res, fbWidth, fbHeight);
+
+  CRenderSystemGLES::ResetRenderSystem(fbWidth, fbHeight);
+
+  return true;
+}
+
+void CWinSystemAmlogicGLESContext::SetVSyncImpl(bool enable)
+{
+  if (!m_pGLContext.SetVSync(enable))
+  {
+    CLog::Log(LOGERROR, "{},Could not set egl vsync", __FUNCTION__);
+  }
+}
+
+void CWinSystemAmlogicGLESContext::PresentRenderImpl(bool rendered)
+{
+  if (m_delayDispReset && m_dispResetTimer.IsTimePast())
+  {
+    m_delayDispReset = false;
+    std::unique_lock<CCriticalSection> lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+  if (!rendered)
+    return;
+
+  // Ignore errors - eglSwapBuffers() sometimes fails during modeswaps on AML,
+  // there is probably nothing we can do about it
+  m_pGLContext.TrySwapBuffers();
+}
+
+EGLDisplay CWinSystemAmlogicGLESContext::GetEGLDisplay() const
+{
+  return m_pGLContext.GetEGLDisplay();
+}
+
+EGLSurface CWinSystemAmlogicGLESContext::GetEGLSurface() const
+{
+  return m_pGLContext.GetEGLSurface();
+}
+
+EGLContext CWinSystemAmlogicGLESContext::GetEGLContext() const
+{
+  return m_pGLContext.GetEGLContext();
+}
+
+EGLConfig  CWinSystemAmlogicGLESContext::GetEGLConfig() const
+{
+  return m_pGLContext.GetEGLConfig();
+}
+
+std::unique_ptr<CVideoSync> CWinSystemAmlogicGLESContext::GetVideoSync(void *clock)
+{
+  std::unique_ptr<CVideoSync> pVSync(new CVideoSyncAML(clock));
+  return pVSync;
+}
+
+bool CWinSystemAmlogicGLESContext::SupportsStereo(RENDER_STEREO_MODE mode) const
+{
+  if (mode == RENDER_STEREO_MODE_HARDWAREBASED) {
+    // yes, we support hardware based MVC decoding
+    return true;
+  }
+
+  return CRenderSystemGLES::SupportsStereo(mode);
+}
diff --git a/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.h b/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.h
new file mode 100644
index 0000000000..0c24698b79
--- /dev/null
+++ b/xbmc/windowing/amlogic/WinSystemAmlogicGLESContext.h
@@ -0,0 +1,61 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "utils/EGLUtils.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "utils/GlobalsHandling.h"
+#include "WinSystemAmlogic.h"
+
+namespace KODI
+{
+namespace WINDOWING
+{
+namespace AML
+{
+
+class CWinSystemAmlogicGLESContext : public CWinSystemAmlogic, public CRenderSystemGLES
+{
+public:
+  CWinSystemAmlogicGLESContext() = default;
+  virtual ~CWinSystemAmlogicGLESContext() = default;
+
+  static void Register();
+  static std::unique_ptr<CWinSystemBase> CreateWinSystem();
+
+  // Implementation of CWinSystemBase via CWinSystemAmlogic
+  CRenderSystemBase *GetRenderSystem() override { return this; }
+  bool InitWindowSystem() override;
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+
+  virtual std::unique_ptr<CVideoSync> GetVideoSync(void *clock) override;
+
+  bool SupportsStereo(RENDER_STEREO_MODE mode) const override;
+
+  EGLDisplay GetEGLDisplay() const;
+  EGLSurface GetEGLSurface() const;
+  EGLContext GetEGLContext() const;
+  EGLConfig  GetEGLConfig() const;
+protected:
+  void SetVSyncImpl(bool enable) override;
+  void PresentRenderImpl(bool rendered) override;
+
+private:
+  CEGLContextUtils m_pGLContext;
+
+};
+
+}
+}
+}
