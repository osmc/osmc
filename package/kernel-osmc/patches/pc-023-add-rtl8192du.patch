diff --git a/README.md b/README.md
new file mode 100644
index 0000000..e23e42f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+rtl8192du
+=========
diff --git a/drivers/net/wireless/rtl8192du/Makefile b/drivers/net/wireless/rtl8192du/Makefile
new file mode 100644
index 0000000..e866458
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/Makefile
@@ -0,0 +1,184 @@
+EXTRA_CFLAGS += $(USER_EXTRA_CFLAGS)
+EXTRA_CFLAGS += -O3
+
+EXTRA_CFLAGS += -Wno-unused-variable
+EXTRA_CFLAGS += -Wno-unused-value
+EXTRA_CFLAGS += -Wno-unused-label
+EXTRA_CFLAGS += -Wno-unused-parameter
+EXTRA_CFLAGS += -Wno-unused-function
+EXTRA_CFLAGS += -Wno-unused
+
+EXTRA_CFLAGS += -Wno-uninitialized
+
+EXTRA_CFLAGS += -I$(src)/include
+
+CONFIG_AUTOCFG_CP = n
+
+CONFIG_POWER_SAVING = n
+CONFIG_USB_AUTOSUSPEND = n
+CONFIG_HW_PWRP_DETECTION = y
+CONFIG_WIFI_TEST = n
+CONFIG_BT_COEXISTENCE = n
+CONFIG_WAKE_ON_WLAN = n
+
+CONFIG_DRVEXT_MODULE = n
+
+export TopDIR ?= $(shell pwd)
+
+ccflags-y += -D__CHECK_ENDIAN__
+
+RTL871X = rtl8192d
+
+MODULE_NAME = 8192du
+
+CHIP_FILES := \
+	hal/$(RTL871X)_xmit.o
+
+HCI_NAME = usb
+
+_OS_INTFS_FILES :=	os_dep/osdep_service.o \
+			os_dep/os_intfs.o \
+			os_dep/$(HCI_NAME)_intf.o \
+			os_dep/$(HCI_NAME)_ops_linux.o \
+			os_dep/ioctl_linux.o \
+			os_dep/xmit_linux.o \
+			os_dep/mlme_linux.o \
+			os_dep/recv_linux.o \
+			os_dep/ioctl_cfg80211.o \
+			os_dep/rtw_android.o
+
+
+_HAL_INTFS_FILES :=	hal/hal_intf.o \
+			hal/hal_com.o \
+			hal/$(RTL871X)_hal_init.o \
+			hal/$(RTL871X)_phycfg.o \
+			hal/$(RTL871X)_rf6052.o \
+			hal/$(RTL871X)_dm.o \
+			hal/$(RTL871X)_rxdesc.o \
+			hal/$(RTL871X)_cmd.o \
+			hal/$(HCI_NAME)_halinit.o \
+			hal/rtl$(MODULE_NAME)_led.o \
+			hal/rtl$(MODULE_NAME)_xmit.o \
+			hal/rtl$(MODULE_NAME)_recv.o \
+			hal/hal8192duhwimg.o
+
+_HAL_INTFS_FILES += hal/$(HCI_NAME)_ops_linux.o
+
+_HAL_INTFS_FILES += $(CHIP_FILES)
+
+
+ifeq ($(CONFIG_AUTOCFG_CP), y)
+$(shell cp $(TopDIR)/autoconf_$(RTL871X)_$(HCI_NAME)_linux.h $(TopDIR)/include/autoconf.h)
+endif
+
+
+ifeq ($(CONFIG_USB_AUTOSUSPEND), y)
+EXTRA_CFLAGS += -DCONFIG_USB_AUTOSUSPEND
+endif
+
+ifeq ($(CONFIG_POWER_SAVING), y)
+EXTRA_CFLAGS += -DCONFIG_POWER_SAVING
+endif
+
+ifeq ($(CONFIG_HW_PWRP_DETECTION), y)
+EXTRA_CFLAGS += -DCONFIG_HW_PWRP_DETECTION
+endif
+
+ifeq ($(CONFIG_WIFI_TEST), y)
+EXTRA_CFLAGS += -DCONFIG_WIFI_TEST
+endif
+
+ifeq ($(CONFIG_BT_COEXISTENCE), y)
+EXTRA_CFLAGS += -DCONFIG_BT_COEXISTENCE
+endif
+
+ifeq ($(CONFIG_WAKE_ON_WLAN), y)
+EXTRA_CFLAGS += -DCONFIG_WAKE_ON_WLAN
+endif
+
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ | sed -e s/ppc/powerpc/)
+ARCH ?= $(SUBARCH)
+CROSS_COMPILE ?=
+KVER  := $(shell uname -r)
+KSRC := /lib/modules/$(KVER)/build
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
+INSTALL_PREFIX :=
+
+KSRC := $(shell pwd)/../../../../
+
+ifneq ($(USER_MODULE_NAME),)
+MODULE_NAME := $(USER_MODULE_NAME)
+endif
+
+ifneq ($(KERNELRELEASE),)
+
+
+rtk_core :=	core/rtw_cmd.o \
+		core/rtw_security.o \
+		core/rtw_debug.o \
+		core/rtw_io.o \
+		core/rtw_ioctl_set.o \
+		core/rtw_ieee80211.o \
+		core/rtw_mlme.o \
+		core/rtw_mlme_ext.o \
+		core/rtw_wlan_util.o \
+		core/rtw_pwrctrl.o \
+		core/rtw_rf.o \
+		core/rtw_recv.o \
+		core/rtw_sta_mgt.o \
+		core/rtw_ap.o \
+		core/rtw_xmit.o	\
+		core/rtw_p2p.o \
+		core/rtw_sreset.o
+
+$(MODULE_NAME)-y += $(rtk_core)
+
+$(MODULE_NAME)-y += core/rtw_efuse.o
+
+$(MODULE_NAME)-y += $(_HAL_INTFS_FILES)
+
+$(MODULE_NAME)-y += $(_OS_INTFS_FILES)
+
+obj-$(CONFIG_RTL8192DU) := $(MODULE_NAME).o
+
+else
+
+export CONFIG_RTL8192DU = m
+
+all: modules
+
+modules:
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(shell pwd)  modules
+
+strip:
+	$(CROSS_COMPILE)strip $(MODULE_NAME).ko --strip-unneeded
+
+install:
+	install -d $(DESTDIR)$(INSTALL_PREFIX)$(MODDESTDIR)
+	install -m644 $(MODULE_NAME).ko  $(DESTDIR)$(INSTALL_PREFIX)$(MODDESTDIR)
+	install -d $(DESTDIR)$(INSTALL_PREFIX)/lib/firmware/rtlwifi
+	install -m644 rtl8192dufw.bin $(DESTDIR)$(INSTALL_PREFIX)/lib/firmware/rtlwifi
+	install -m644 rtl8192dufw_wol.bin $(DESTDIR)$(INSTALL_PREFIX)/lib/firmware/rtlwifi
+	depmod -a
+
+uninstall:
+	rm -f $(DESTDIR)$(INSTALL_PREFIX)$(MODDESTDIR)/$(MODULE_NAME).ko
+	rm -f $(DESTDIR)$(INSTALL_PREFIX)/lib/firmware/rtlwifi/rtl8192dufw.bin
+	rm -f $(DESTDIR)$(INSTALL_PREFIX)/lib/firmware/rtlwifi/rtl8192dufw_wol.bin
+	depmod -a
+
+config_r:
+	@echo "make config"
+	/bin/bash script/Configure script/config.in
+
+.PHONY: modules clean
+
+clean:
+	rm -fr *.mod.c *.mod *.o .*.cmd *.ko *~
+	rm .tmp_versions -fr ; rm Module.symvers -fr
+	rm -fr Module.markers ; rm -fr modules.order
+	cd core ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
+	cd hal ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
+	cd os_dep ; rm -fr *.mod.c *.mod *.o .*.cmd *.ko
+endif
+
diff --git a/drivers/net/wireless/rtl8192du/README.md b/drivers/net/wireless/rtl8192du/README.md
new file mode 100644
index 0000000..2563cbf
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/README.md
@@ -0,0 +1,4 @@
+rtl8192du
+=========
+
+Source code for RTL8192DU device
\ No newline at end of file
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_ap.c b/drivers/net/wireless/rtl8192du/core/rtw_ap.c
new file mode 100644
index 0000000..b03023e
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_ap.c
@@ -0,0 +1,2068 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_AP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+#ifdef CONFIG_92D_AP_MODE
+
+void init_mlme_ap_info(struct rtw_adapter *padapter)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+	_rtw_spinlock_init(&pmlmepriv->bcn_update_lock);
+
+	/* for ACL */
+	_rtw_init_queue(&pacl_list->acl_node_q);
+
+	start_ap_mode(padapter);
+}
+
+void free_mlme_ap_info(struct rtw_adapter *padapter)
+{
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
+
+	rtw_sta_flush(padapter);
+
+	pmlmeinfo->state = _HW_STATE_NOLINK_;
+
+	/* free_assoc_sta_resources */
+	rtw_free_all_stainfo(padapter);
+
+	/* free bc/mc sta_info */
+	psta = rtw_get_bcmc_stainfo(padapter);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(padapter, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+	_rtw_spinlock_free(&pmlmepriv->bcn_update_lock);
+}
+
+static void update_BCNTIM(struct rtw_adapter *padapter)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);
+	unsigned char *pie = pnetwork_mlmeext->IEs;
+
+	/* update TIM IE */
+	if (true) {
+		u8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+		__le16 tim_bitmap_le;
+		uint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;
+
+		tim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);
+
+		p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, _TIM_IE_, &tim_ielen, pnetwork_mlmeext->IELength - _FIXED_IE_LENGTH_);
+		if (p != NULL && tim_ielen > 0) {
+			tim_ielen += 2;
+
+			premainder_ie = p+tim_ielen;
+
+			tim_ie_offset = (int)(p - pie);
+
+			remainder_ielen = pnetwork_mlmeext->IELength - tim_ie_offset - tim_ielen;
+
+			/* append TIM IE from dst_ie offset */
+			dst_ie = p;
+		} else {
+			tim_ielen = 0;
+
+			/* calucate head_len */
+			offset = _FIXED_IE_LENGTH_;
+
+			/* get ssid_ie len */
+			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SSID_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));
+			if (p !=  NULL)
+				offset += tmp_len+2;
+
+			/*  get supported rates len */
+			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));
+			if (p !=  NULL)
+				offset += tmp_len+2;
+
+			/* DS Parameter Set IE, len = 3 */
+			offset += 3;
+
+			premainder_ie = pie + offset;
+
+			remainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;
+
+			/* append TIM IE from offset */
+			dst_ie = pie + offset;
+		}
+
+		if (remainder_ielen > 0) {
+			pbackup_remainder_ie = kmalloc(remainder_ielen, GFP_ATOMIC);
+			if (pbackup_remainder_ie && premainder_ie)
+				memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+		}
+
+		*dst_ie++ = _TIM_IE_;
+
+		if ((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fc))
+			tim_ielen = 5;
+		else
+			tim_ielen = 4;
+
+		*dst_ie++ = tim_ielen;
+
+		*dst_ie++ = 0;/* DTIM count */
+		*dst_ie++ = 1;/* DTIM peroid */
+
+		if (pstapriv->tim_bitmap&BIT(0))/* for bc/mc frames */
+			*dst_ie++ = BIT(0);/* bitmap ctrl */
+		else
+			*dst_ie++ = 0;
+
+		if (tim_ielen == 4) {
+			*dst_ie++ = *(u8 *)&tim_bitmap_le;
+		} else if (tim_ielen == 5) {
+			memcpy(dst_ie, &tim_bitmap_le, 2);
+			dst_ie += 2;
+		}
+
+		/* copy remainder IE */
+		if (pbackup_remainder_ie) {
+			memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+			kfree(pbackup_remainder_ie);
+		}
+
+		offset =  (uint)(dst_ie - pie);
+		pnetwork_mlmeext->IELength = offset + remainder_ielen;
+	}
+
+#ifndef CONFIG_INTERRUPT_BASED_TXBCN
+	set_tx_beacon_cmd(padapter);
+#endif /* CONFIG_INTERRUPT_BASED_TXBCN */
+}
+
+void rtw_add_bcn_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork, u8 index, u8 *data, u8 len)
+{
+	struct ndis_802_11_variable_ies *pIE;
+	u8	bmatch = false;
+	u8	*pie = pnetwork->IEs;
+	u8	*p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	u32	i, offset, ielen, ie_offset, remainder_ielen = 0;
+
+	for (i = sizeof(struct ndis_802_11_fixed_ies); i < pnetwork->IELength;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pnetwork->IEs + i);
+
+		if (pIE->ElementID > index) {
+			break;
+		} else if (pIE->ElementID == index) { /*  already exist the same IE */
+			p = (u8 *)pIE;
+			ielen = pIE->Length;
+			bmatch = true;
+			break;
+		}
+
+		p = (u8 *)pIE;
+		ielen = pIE->Length;
+		i += (pIE->Length + 2);
+	}
+
+	if (p != NULL && ielen > 0) {
+		ielen += 2;
+
+		premainder_ie = p+ielen;
+
+		ie_offset = (int)(p - pie);
+
+		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
+
+		if (bmatch)
+			dst_ie = p;
+		else
+			dst_ie = (p+ielen);
+	}
+
+	if (remainder_ielen > 0) {
+		pbackup_remainder_ie = kmalloc(remainder_ielen, GFP_KERNEL);
+		if (pbackup_remainder_ie && premainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+	*dst_ie++ = index;
+	*dst_ie++ = len;
+
+	memcpy(dst_ie, data, len);
+	dst_ie += len;
+
+	/* copy remainder IE */
+	if (pbackup_remainder_ie) {
+		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+		kfree(pbackup_remainder_ie);
+	}
+
+	offset =  (uint)(dst_ie - pie);
+	pnetwork->IELength = offset + remainder_ielen;
+}
+
+void rtw_remove_bcn_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork, u8 index)
+{
+	u8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	uint offset, ielen, ie_offset, remainder_ielen = 0;
+	u8	*pie = pnetwork->IEs;
+
+	p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, index, &ielen, pnetwork->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL && ielen > 0) {
+		ielen += 2;
+
+		premainder_ie = p+ielen;
+
+		ie_offset = (int)(p - pie);
+
+		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
+
+		dst_ie = p;
+	}
+
+	if (remainder_ielen > 0) {
+		pbackup_remainder_ie = kmalloc(remainder_ielen, GFP_KERNEL);
+		if (pbackup_remainder_ie && premainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+	/* copy remainder IE */
+	if (pbackup_remainder_ie) {
+		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+		kfree(pbackup_remainder_ie);
+	}
+
+	offset =  (uint)(dst_ie - pie);
+	pnetwork->IELength = offset + remainder_ielen;
+}
+
+static u8 chk_sta_is_alive(struct sta_info *psta)
+{
+	u8 ret = false;
+
+	if ((psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts) == (psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts))
+		;
+	else
+		ret = true;
+
+	sta_update_last_rx_pkts(psta);
+
+	return ret;
+}
+
+void	expire_timeout_chk(struct rtw_adapter *padapter)
+{
+	struct list_head *phead, *plist;
+	u8 updated;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 chk_alive_num = 0;
+	char chk_alive_list[NUM_STA];
+	int i;
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+
+	phead = &pstapriv->auth_list;
+	plist = phead->next;
+
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		psta = container_of(plist, struct sta_info, auth_list);
+		plist = plist->next;
+
+		if (psta->expire_to > 0) {
+			psta->expire_to--;
+			if (psta->expire_to == 0) {
+				list_del_init(&psta->auth_list);
+				pstapriv->auth_list_cnt--;
+
+				DBG_8192D("auth expire %02X%02X%02X%02X%02X%02X\n",
+					  psta->hwaddr[0], psta->hwaddr[1],
+					  psta->hwaddr[2], psta->hwaddr[3],
+					  psta->hwaddr[4], psta->hwaddr[5]);
+
+				spin_unlock_bh(&pstapriv->auth_list_lock);
+
+				spin_lock_bh(&(pstapriv->sta_hash_lock));
+				rtw_free_stainfo(padapter, psta);
+				spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+				spin_lock_bh(&pstapriv->auth_list_lock);
+			}
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	psta = NULL;
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+
+	/* check asoc_queue */
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = plist->next;
+
+		if (chk_sta_is_alive(psta) || !psta->expire_to) {
+			psta->expire_to = pstapriv->expire_to;
+			psta->keep_alive_trycnt = 0;
+			psta->under_exist_checking = 0;
+		} else {
+			psta->expire_to--;
+		}
+
+		if (psta->expire_to <= 0) {
+			struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+			if (padapter->registrypriv.wifi_spec == 1) {
+				psta->expire_to = pstapriv->expire_to;
+				continue;
+			}
+
+			if (psta->state & WIFI_SLEEP_STATE) {
+				if (!(psta->state & WIFI_STA_ALIVE_CHK_STATE)) {
+					/* to check if alive by another methods if staion is at ps mode. */
+					psta->expire_to = pstapriv->expire_to;
+					psta->state |= WIFI_STA_ALIVE_CHK_STATE;
+
+					/* to update bcn with tim_bitmap for this station */
+					pstapriv->tim_bitmap |= BIT(psta->aid);
+					update_beacon(padapter, _TIM_IE_, NULL, false);
+
+					if (!pmlmeext->active_keep_alive_check)
+						continue;
+				}
+			}
+
+			if (pmlmeext->active_keep_alive_check) {
+				int stainfo_offset;
+
+				stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+				if (stainfo_offset_valid(stainfo_offset))
+					chk_alive_list[chk_alive_num++] = stainfo_offset;
+
+				continue;
+			}
+
+			list_del_init(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+
+			DBG_8192D("asoc expire %pM, state = 0x%x\n", psta->hwaddr, psta->state);
+			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+		} else {
+			/* TODO: Aging mechanism to digest frames in sleep_q to avoid running out of xmitframe */
+			if (psta->sleepq_len > (NR_XMITFRAME/pstapriv->asoc_list_cnt) &&
+			    padapter->xmitpriv.free_xmitframe_cnt < (NR_XMITFRAME/pstapriv->asoc_list_cnt/2)) {
+				DBG_8192D("%s sta:%pM, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n", __func__,
+					  psta->hwaddr, psta->sleepq_len,
+					  padapter->xmitpriv.free_xmitframe_cnt,
+					  pstapriv->asoc_list_cnt);
+				wakeup_sta_to_xmit(padapter, psta);
+			}
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	if (chk_alive_num) {
+		u8 backup_oper_channel = 0;
+		struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+		/* switch to correct channel of current network  before issue keep-alive frames */
+		if (rtw_get_oper_ch(padapter) != pmlmeext->cur_channel) {
+			backup_oper_channel = rtw_get_oper_ch(padapter);
+			SelectChannel(padapter, pmlmeext->cur_channel);
+		}
+
+		/* issue null data to check sta alive*/
+		for (i = 0; i < chk_alive_num; i++) {
+			int ret = _FAIL;
+
+			psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
+
+			if (psta->state & WIFI_SLEEP_STATE)
+				ret = issue_nulldata(padapter, psta->hwaddr, 0, 1, 50);
+			else
+				ret = issue_nulldata(padapter, psta->hwaddr, 0, 3, 50);
+
+			psta->keep_alive_trycnt++;
+			if (ret == _SUCCESS) {
+				DBG_8192D("asoc check, sta(%pM) is alive\n", psta->hwaddr);
+				psta->expire_to = pstapriv->expire_to;
+				psta->keep_alive_trycnt = 0;
+				continue;
+			} else if (psta->keep_alive_trycnt <= 3) {
+				DBG_8192D("ack check for asoc expire, keep_alive_trycnt =%d\n",
+					  psta->keep_alive_trycnt);
+				psta->expire_to = 1;
+				continue;
+			}
+
+			psta->keep_alive_trycnt = 0;
+
+			DBG_8192D("asoc expire %pM, state = 0x%x\n", psta->hwaddr, psta->state);
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			list_del_init(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+		}
+
+		if (backup_oper_channel > 0) /* back to the original operation channel */
+			SelectChannel(padapter, backup_oper_channel);
+	}
+
+	associated_clients_update(padapter, updated);
+}
+
+static void add_RATid(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	int i;
+	u8 rf_type;
+	u32 init_rate = 0;
+	unsigned char sta_band = 0, raid, shortGIrate = false;
+	unsigned char limit;
+	unsigned int tx_ra_bitmap = 0;
+	struct ht_priv	*psta_ht = NULL;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
+
+	if (psta)
+		psta_ht = &psta->htpriv;
+	else
+		return;
+
+	/* b/g mode ra_bitmap */
+	for (i = 0; i < sizeof(psta->bssrateset); i++) {
+		if (psta->bssrateset[i])
+			tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+	}
+
+	/* n mode ra_bitmap */
+	if (psta_ht->ht_option) {
+		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+		if (rf_type == RF_2T2R)
+			limit = 16;/*  2R */
+		else
+			limit = 8;/*   1R */
+
+		for (i = 0; i < limit; i++) {
+			if (psta_ht->ht_cap.supp_mcs_set[i/8] & BIT(i%8))
+				tx_ra_bitmap |= BIT(i+12);
+		}
+
+		/* max short GI rate */
+		shortGIrate = psta_ht->sgi;
+	}
+
+	if (pcur_network->Configuration.DSConfig > 14) {
+		/*  5G band */
+		if (tx_ra_bitmap & 0xffff000)
+			sta_band |= WIRELESS_11_5N | WIRELESS_11A;
+		else
+			sta_band |= WIRELESS_11A;
+	} else {
+		if (tx_ra_bitmap & 0xffff000)
+			sta_band |= WIRELESS_11_24N | WIRELESS_11G | WIRELESS_11B;
+		else if (tx_ra_bitmap & 0xff0)
+			sta_band |= WIRELESS_11G | WIRELESS_11B;
+		else
+			sta_band |= WIRELESS_11B;
+	}
+
+	raid = networktype_to_raid(sta_band);
+	init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
+
+	if (psta->aid < NUM_STA) {
+		u8 arg = 0;
+
+		arg = psta->mac_id&0x1f;
+
+		arg |= BIT(7);/* support entry 2~31 */
+
+		if (shortGIrate)
+			arg |= BIT(5);
+
+		tx_ra_bitmap |= ((raid<<28)&0xf0000000);
+
+		DBG_8192D("%s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = 0x%x\n",
+			  __func__ , psta->mac_id, raid , tx_ra_bitmap, arg);
+
+		rtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg);
+
+		if (shortGIrate)
+			init_rate |= BIT(6);
+
+		/* set ra_id, init_rate */
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+
+	} else {
+		DBG_8192D("station aid %d exceed the max number\n", psta->aid);
+	}
+}
+
+static void update_bmc_sta(struct rtw_adapter *padapter)
+{
+	u32 init_rate = 0;
+	unsigned char	network_type, raid;
+	int i, supportRateNum = 0;
+	unsigned int tx_ra_bitmap = 0;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
+	struct sta_info *psta = rtw_get_bcmc_stainfo(padapter);
+
+	if (psta) {
+		psta->aid = 0;/* default set to 0 */
+		psta->mac_id = psta->aid + 1;
+
+		psta->qos_option = 0;
+		psta->htpriv.ht_option = false;
+
+		psta->ieee8021x_blocked = 0;
+
+		memset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+		/* prepare for add_RATid */
+		supportRateNum = rtw_get_rateset_len((u8 *)&pcur_network->SupportedRates);
+		network_type = rtw_check_network_type((u8 *)&pcur_network->SupportedRates, supportRateNum, 1);
+
+		memcpy(psta->bssrateset, &pcur_network->SupportedRates, supportRateNum);
+		psta->bssratelen = supportRateNum;
+
+		/* b/g mode ra_bitmap */
+		for (i = 0; i < supportRateNum; i++) {
+			if (psta->bssrateset[i])
+				tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+		}
+
+		if (pcur_network->Configuration.DSConfig > 14) {
+			/* force to A mode. 5G doesn't support CCK rates */
+			network_type = WIRELESS_11A;
+			tx_ra_bitmap = 0x150; /*  6, 12, 24 Mbps */
+		} else {
+			/* force to b mode */
+			network_type = WIRELESS_11B;
+			tx_ra_bitmap = 0xf;
+		}
+
+		raid = networktype_to_raid(network_type);
+		init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
+
+		{
+			u8 arg = 0;
+
+			arg = psta->mac_id&0x1f;
+
+			arg |= BIT(7);
+
+			tx_ra_bitmap |= ((raid<<28)&0xf0000000);
+
+			DBG_8192D("update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap, arg);
+
+			rtw_hal_add_ra_tid(padapter, tx_ra_bitmap, arg);
+		}
+
+		/* set ra_id, init_rate */
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+
+		spin_lock_bh(&psta->lock);
+		psta->state = _FW_LINKED;
+		spin_unlock_bh(&psta->lock);
+
+	} else {
+		DBG_8192D("add_RATid_bmc_sta error!\n");
+	}
+}
+
+/* notes: */
+/* AID: 1~MAX for sta and 0 for bc/mc in ap/adhoc mode */
+/* MAC_ID = AID+1 for sta in ap/adhoc mode */
+/* MAC_ID = 1 for bc/mc for sta/ap/adhoc */
+/* MAC_ID = 0 for bssid for sta/ap/adhoc */
+/* CAM_ID = 0~3 for default key, cmd_id = macid + 3, macid = aid+1; */
+
+void update_sta_info_apmode(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
+	struct ht_priv	*phtpriv_sta = &psta->htpriv;
+
+	/* set intf_tag to if1 */
+
+	psta->mac_id = psta->aid+1;
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
+		psta->ieee8021x_blocked = true;
+	else
+		psta->ieee8021x_blocked = false;
+
+	/* update sta's cap */
+
+	/* ERP */
+	VCS_update(padapter, psta);
+
+	/* HT related cap */
+	if (phtpriv_sta->ht_option) {
+		/* check if sta supports rx ampdu */
+		phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
+
+		/* check if sta support s Short GI */
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & (IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
+			phtpriv_sta->sgi = true;
+
+		/*  bwmode */
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & IEEE80211_HT_CAP_SUP_WIDTH) {
+			phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+		}
+
+		psta->qos_option = true;
+	} else {
+		phtpriv_sta->ampdu_enable = false;
+
+		phtpriv_sta->sgi = false;
+		phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
+		phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+	/* Rx AMPDU */
+	send_delba(padapter, 0, psta->hwaddr);/*  recipient */
+
+	/* TX AMPDU */
+	send_delba(padapter, 1, psta->hwaddr);/* originator */
+	phtpriv_sta->agg_enable_bitmap = 0x0;/* reset */
+	phtpriv_sta->candidate_tid_bitmap = 0x0;/* reset */
+
+	/* todo: init other variables */
+
+	memset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+	/* add ratid */
+
+	spin_lock_bh(&psta->lock);
+	psta->state |= _FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+}
+
+static void update_hw_ht_param(struct rtw_adapter *padapter)
+{
+	unsigned char		max_AMPDU_len;
+	unsigned char		min_MPDU_spacing;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_8192D("%s\n", __func__);
+
+	/* handle A-MPDU parameter field */
+	/*
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing
+	*/
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));
+
+	/*  */
+	/*  Config SM Power Save setting */
+	/*  */
+	pmlmeinfo->SM_PS = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & 0x0C) >> 2;
+	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
+		DBG_8192D("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);
+}
+
+static void start_bss_network(struct rtw_adapter *padapter, u8 *pbuf)
+{
+	u8 *p;
+	u8 val8, cur_channel, cur_bwmode, cur_ch_offset;
+	u16 bcn_interval;
+	u32	acparm;
+	int	ie_len;
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct security_priv *psecuritypriv = &(padapter->securitypriv);
+	struct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork_mlmeext = &(pmlmeinfo->network);
+	struct HT_info_element *pht_info = NULL;
+	u8 cbw40_enable = 0;
+	u8 change_band = false;
+
+	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;
+	cur_channel = pnetwork->Configuration.DSConfig;
+	cur_bwmode = HT_CHANNEL_WIDTH_20;;
+	cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	/* check if there is wps ie, */
+	/* if there is wpsie in beacon, the hostapd will update beacon twice when stating hostapd, */
+	/* and at first time the security ie (RSN/WPA IE) will not include in beacon. */
+	if (NULL == rtw_get_wps_ie(pnetwork->IEs+_FIXED_IE_LENGTH_, pnetwork->IELength-_FIXED_IE_LENGTH_, NULL, NULL))
+		pmlmeext->bstart_bss = true;
+
+	/* todo: update wmm, ht cap */
+	/* pmlmeinfo->WMM_enable; */
+	/* pmlmeinfo->HT_enable; */
+	if (pmlmepriv->qospriv.qos_option)
+		pmlmeinfo->WMM_enable = true;
+
+	if (pmlmepriv->htpriv.ht_option) {
+		pmlmeinfo->WMM_enable = true;
+		pmlmeinfo->HT_enable = true;
+
+		update_hw_ht_param(padapter);
+	}
+
+	if (pmlmepriv->cur_network.join_res != true) { /* setting only at  first time */
+		/* WEP Key will be set before this function, do not clear CAM. */
+		if ((psecuritypriv->dot11PrivacyAlgrthm != _WEP40_) && (psecuritypriv->dot11PrivacyAlgrthm != _WEP104_))
+			flush_all_cam_entry(padapter);	/* clear CAM */
+	}
+
+	/* set MSR to AP_Mode */
+	Set_MSR(padapter, _HW_STATE_AP_);
+
+	/* Set BSSID REG */
+	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, pnetwork->MacAddress);
+
+	/* Set EDCA param reg */
+#ifdef CONFIG_CONCURRENT_MODE
+	acparm = 0x005ea42b;
+#else
+	acparm = 0x002F3217; /*  VO */
+#endif
+	rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acparm));
+	acparm = 0x005E4317; /*  VI */
+	rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acparm));
+	acparm = 0x005ea42b;
+	rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acparm));
+	acparm = 0x0000A444; /*  BK */
+	rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acparm));
+
+	/* Set Security */
+	val8 = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) ? 0xcc : 0xcf;
+	rtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));
+
+	/* Beacon Control related register */
+	rtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&bcn_interval));
+
+	if (pmlmepriv->cur_network.join_res != true) { /* setting only at  first time */
+		u32 initialgain;
+
+		initialgain = 0x1e;
+
+		/* disable dynamic functions, such as high power, DIG */
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (padapter->adapter_type > PRIMARY_ADAPTER) {
+			if (rtw_buddy_adapter_up(padapter)) {
+				struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+
+				/* turn on dynamic functions on PRIMARY_ADAPTER, dynamic functions only runs at PRIMARY_ADAPTER */
+				Switch_DM_Func(pbuddy_adapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
+
+				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
+			}
+		} else
+#endif
+		{
+			/* turn on dynamic functions */
+			Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
+
+			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
+		}
+	}
+
+	/* set channel, bwmode */
+	p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)),
+		       _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength -
+		       sizeof(struct ndis_802_11_fixed_ies)));
+	if (p && ie_len) {
+		pht_info = (struct HT_info_element *)(p+2);
+
+		if (pmlmeext->cur_channel > 14) {
+			if (pregpriv->cbw40_enable & BIT(1))
+				cbw40_enable = 1;
+		} else {
+			if (pregpriv->cbw40_enable & BIT(0))
+				cbw40_enable = 1;
+		}
+
+		if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2))) {
+			/* switch to the 40M Hz mode */
+			cur_bwmode = HT_CHANNEL_WIDTH_40;
+			switch (pht_info->infos[0] & 0x3) {
+			case 1:
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+			case 3:
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+			default:
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+			}
+		}
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	dc_set_ap_channel_bandwidth(padapter, cur_channel, cur_ch_offset, cur_bwmode);
+#else
+	/* TODO: need to judge the phy parameters on concurrent mode for single phy */
+#ifdef CONFIG_CONCURRENT_MODE
+	if (!check_buddy_fwstate(padapter, _FW_LINKED|_FW_UNDER_LINKING|_FW_UNDER_SURVEY)) {
+		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
+	} else if (check_buddy_fwstate(padapter, _FW_LINKED)) {/* only second adapter can enter AP Mode */
+		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+
+		/* To sync cur_channel/cur_bwmode/cur_ch_offset with primary adapter */
+		DBG_8192D("primary iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
+		DBG_8192D("primary adapter, CH =%d, BW =%d, offset =%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
+		DBG_8192D("second adapter, CH =%d, BW =%d, offset =%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+
+		if ((cur_channel <= 14 && pbuddy_mlmeext->cur_channel >= 36) ||
+		    (cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
+			change_band = true;
+
+		cur_channel = pbuddy_mlmeext->cur_channel;
+		if (cur_bwmode == HT_CHANNEL_WIDTH_40) {
+			if (pht_info)
+				pht_info->infos[0] &= ~(BIT(0)|BIT(1));
+
+			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) {
+				cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
+
+				/* to update cur_ch_offset value in beacon */
+				if (pht_info) {
+					switch (cur_ch_offset) {
+					case HAL_PRIME_CHNL_OFFSET_LOWER:
+						pht_info->infos[0] |= 0x1;
+						break;
+					case HAL_PRIME_CHNL_OFFSET_UPPER:
+						pht_info->infos[0] |= 0x3;
+						break;
+					case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
+					default:
+						break;
+					}
+				}
+			} else if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20) {
+				cur_bwmode = HT_CHANNEL_WIDTH_20;
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+				if (cur_channel > 0 && cur_channel < 5) {
+					if (pht_info)
+						pht_info->infos[0] |= 0x1;
+
+					cur_bwmode = HT_CHANNEL_WIDTH_40;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				}
+
+				if (cur_channel > 7 && cur_channel < (14+1)) {
+					if (pht_info)
+						pht_info->infos[0] |= 0x3;
+
+					cur_bwmode = HT_CHANNEL_WIDTH_40;
+					cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				}
+
+				set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
+			}
+		}
+
+		/*  to update channel value in beacon */
+		pnetwork->Configuration.DSConfig = cur_channel;
+		p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pnetwork->IELength - sizeof(struct ndis_802_11_fixed_ies)));
+		if (p && ie_len > 0)
+			*(p + 2) = cur_channel;
+
+		if (pht_info)
+			pht_info->primary_channel = cur_channel;
+
+		/* set buddy adapter channel, bandwidth, offeset to current adapter */
+		pmlmeext->cur_channel = cur_channel;
+		pmlmeext->cur_bwmode = cur_bwmode;
+		pmlmeext->cur_ch_offset = cur_ch_offset;
+
+		/* buddy interface band is different from current interface, update ERP, support rate, ext support rate IE */
+		if (change_band)
+			change_band_update_ie(padapter, pnetwork);
+	}
+#else
+	set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	DBG_8192D("CH =%d, BW =%d, offset =%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+
+	/*  */
+	pmlmeext->cur_channel = cur_channel;
+	pmlmeext->cur_bwmode = cur_bwmode;
+	pmlmeext->cur_ch_offset = cur_ch_offset;
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+	pmlmeext->cur_wireless_mode = pmlmepriv->cur_network.network_type;
+
+	/* update cur_wireless_mode */
+	update_wireless_mode(padapter);
+
+	/* update RRSR after set channel and bandwidth */
+	UpdateBrateTbl(padapter, pnetwork->SupportedRates);
+	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);
+
+	/* udpate capability after cur_wireless_mode updated */
+	update_capinfo(padapter, rtw_get_capability((struct wlan_bssid_ex *)pnetwork));
+
+	/* let pnetwork_mlmeext == pnetwork_mlme. */
+	memcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);
+
+	if (pmlmeext->bstart_bss) {
+		update_beacon(padapter, _TIM_IE_, NULL, false);
+
+#ifndef CONFIG_INTERRUPT_BASED_TXBCN /* other case will  tx beacon when bcn interrupt coming in. */
+		/* issue beacon frame */
+		if (send_beacon(padapter) == _FAIL)
+			DBG_8192D("issue_beacon, fail!\n");
+#endif /* CONFIG_INTERRUPT_BASED_TXBCN */
+	}
+
+	/* update bc/mc sta_info */
+	update_bmc_sta(padapter);
+}
+
+int rtw_check_beacon_data(struct rtw_adapter *padapter, u8 *pbuf,  int len)
+{
+	int ret = _SUCCESS;
+	u8 *p;
+	u8 *pHT_caps_ie = NULL;
+	u8 *pHT_info_ie = NULL;
+	struct sta_info *psta = NULL;
+	u16 cap, ht_cap = false;
+	uint ie_len = 0;
+	int group_cipher, pairwise_cipher;
+	u8	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
+	int supportRateNum = 0;
+	u8 OUI1[] = {0x00, 0x50, 0xf2, 0x01};
+	u8 wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+	u8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pbss_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 *ie = pbss_network->IEs;
+
+	/* SSID */
+	/* Supported rates */
+	/* DS Params */
+	/* WLAN_EID_COUNTRY */
+	/* ERP Information element */
+	/* Extended supported rates */
+	/* WPA/WPA2 */
+	/* Wi-Fi Wireless Multimedia Extensions */
+	/* ht_capab, ht_oper */
+	/* WPS IE */
+
+	DBG_8192D("%s, len =%d\n", __func__, len);
+
+	if (!check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		return _FAIL;
+
+	if (len > MAX_IE_SZ)
+		return _FAIL;
+
+	pbss_network->IELength = len;
+
+	memset(ie, 0, MAX_IE_SZ);
+
+	memcpy(ie, pbuf, pbss_network->IELength);
+
+	if (pbss_network->InfrastructureMode != NDIS802_11APMODE)
+		return _FAIL;
+
+	pbss_network->Rssi = 0;
+
+	memcpy(pbss_network->MacAddress, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	/* beacon interval */
+	p = rtw_get_beacon_interval_from_ie(ie);/* ie + 8;  8: TimeStamp, 2: Beacon Interval 2:Capability */
+	pbss_network->Configuration.BeaconPeriod = RTW_GET_LE16(p);
+
+	/* capability */
+	cap = RTW_GET_LE16(ie);
+
+	/* SSID */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SSID_IE_, &ie_len,
+		       (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0) {
+		memset(&pbss_network->Ssid, 0, sizeof(struct ndis_802_11_ssid));
+		memcpy(pbss_network->Ssid.Ssid, (p + 2), ie_len);
+		pbss_network->Ssid.SsidLength = ie_len;
+	}
+
+	/* chnnel */
+	channel = 0;
+	pbss_network->Configuration.Length = 0;
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _DSSET_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0)
+		channel = *(p + 2);
+
+	pbss_network->Configuration.DSConfig = channel;
+
+	memset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);
+	/*  get supported rates */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p !=  NULL) {
+		memcpy(supportRate, p+2, ie_len);
+		supportRateNum = ie_len;
+	}
+
+	/* get ext_supported rates */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ie_len, pbss_network->IELength - _BEACON_IE_OFFSET_);
+	if (p !=  NULL) {
+		memcpy(supportRate+supportRateNum, p+2, ie_len);
+		supportRateNum += ie_len;
+	}
+
+	network_type = rtw_check_network_type(supportRate, supportRateNum, channel);
+
+	rtw_set_supported_rate(pbss_network->SupportedRates, network_type);
+
+	/* parsing ERP_IE */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0)
+		ERP_IE_handler(padapter, (struct ndis_802_11_variable_ies *)p);
+
+	/* update privacy/security */
+	if (cap & BIT(4))
+		pbss_network->Privacy = 1;
+	else
+		pbss_network->Privacy = 0;
+
+	psecuritypriv->wpa_psk = 0;
+
+	/* wpa2 */
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa2_group_cipher = _NO_PRIVACY_;
+	psecuritypriv->wpa2_pairwise_cipher = _NO_PRIVACY_;
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0) {
+		if (rtw_parse_wpa2_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+
+			psecuritypriv->dot8021xalg = 1;/* psk,  todo:802.1x */
+			psecuritypriv->wpa_psk |= BIT(1);
+			psecuritypriv->wpa2_group_cipher = group_cipher;
+			psecuritypriv->wpa2_pairwise_cipher = pairwise_cipher;
+		}
+	}
+
+	/* wpa */
+	ie_len = 0;
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa_group_cipher = _NO_PRIVACY_;
+	psecuritypriv->wpa_pairwise_cipher = _NO_PRIVACY_;
+	for (p = ie + _BEACON_IE_OFFSET_;; p += (ie_len + 2)) {
+		p = rtw_get_ie(p, _SSN_IE_1_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+		if ((p) && (_rtw_memcmp(p+2, OUI1, 4))) {
+			if (rtw_parse_wpa_ie(p, ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+				psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+
+				psecuritypriv->dot8021xalg = 1;/* psk,  todo:802.1x */
+
+				psecuritypriv->wpa_psk |= BIT(0);
+
+				psecuritypriv->wpa_group_cipher = group_cipher;
+				psecuritypriv->wpa_pairwise_cipher = pairwise_cipher;
+			}
+			break;
+		}
+
+		if ((p == NULL) || (ie_len == 0))
+				break;
+	}
+
+	/* wmm */
+	ie_len = 0;
+	pmlmepriv->qospriv.qos_option = 0;
+	if (pregistrypriv->wmm_enable) {
+		for (p = ie + _BEACON_IE_OFFSET_;; p += (ie_len + 2)) {
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+			if ((p) && _rtw_memcmp(p+2, WMM_PARA_IE, 6)) {
+				pmlmepriv->qospriv.qos_option = 1;
+
+				*(p+8) |= BIT(7);/* QoS Info, support U-APSD */
+
+				/* disable all ACM bits since the WMM admission control is not supported */
+				*(p + 10) &= ~BIT(4); /* BE */
+				*(p + 14) &= ~BIT(4); /* BK */
+				*(p + 18) &= ~BIT(4); /* VI */
+				*(p + 22) &= ~BIT(4); /* VO */
+
+				break;
+			}
+
+			if ((p == NULL) || (ie_len == 0))
+				break;
+		}
+	}
+
+	/* parsing HT_CAP_IE */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0) {
+		u8 rf_type;
+
+		struct rtw_ieee80211_ht_cap *pht_cap = (struct rtw_ieee80211_ht_cap *)(p+2);
+
+		pHT_caps_ie = p;
+
+		ht_cap = true;
+		network_type |= WIRELESS_11_24N;
+
+		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+		if ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||
+		    (psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP))
+			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
+		else
+			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
+
+		pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_FACTOR & 0x03); /* set  Max Rx AMPDU size  to 64K */
+
+		if (rf_type == RF_1T1R) {
+			pht_cap->supp_mcs_set[0] = 0xff;
+			pht_cap->supp_mcs_set[1] = 0x0;
+		}
+
+		memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);
+	}
+
+	/* parsing HT_INFO_IE */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len > 0)
+		pHT_info_ie = p;
+
+	switch (network_type) {
+	case WIRELESS_11B:
+		pbss_network->NetworkTypeInUse = NDIS802_11DS;
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+	case WIRELESS_11G_24N:
+	case WIRELESS_11BG_24N:
+		pbss_network->NetworkTypeInUse = NDIS802_11OFDM24;
+		break;
+	case WIRELESS_11A:
+		pbss_network->NetworkTypeInUse = NDIS802_11OFDM5;
+		break;
+	default:
+		pbss_network->NetworkTypeInUse = NDIS802_11OFDM24;
+		break;
+	}
+
+	pmlmepriv->cur_network.network_type = network_type;
+
+	pmlmepriv->htpriv.ht_option = false;
+#ifdef CONFIG_80211N_HT
+	/* ht_cap */
+	if (pregistrypriv->ht_enable && ht_cap) {
+		pmlmepriv->htpriv.ht_option = true;
+		pmlmepriv->qospriv.qos_option = 1;
+
+		if (pregistrypriv->ampdu_enable == 1)
+			pmlmepriv->htpriv.ampdu_enable = true;
+
+		HT_caps_handler(padapter, (struct ndis_802_11_variable_ies *)pHT_caps_ie);
+
+		HT_info_handler(padapter, (struct ndis_802_11_variable_ies *)pHT_info_ie);
+	}
+#endif
+
+	pbss_network->Length = get_wlan_bssid_ex_sz((struct wlan_bssid_ex  *)pbss_network);
+
+	/* issue beacon to start bss network */
+	start_bss_network(padapter, (u8 *)pbss_network);
+
+	/* alloc sta_info for ap itself */
+	psta = rtw_get_stainfo(&padapter->stapriv, pbss_network->MacAddress);
+	if (!psta) {
+		psta = rtw_alloc_stainfo(&padapter->stapriv, pbss_network->MacAddress);
+		if (psta == NULL)
+			return _FAIL;
+	}
+	psta->state |= WIFI_AP_STATE;		/* Aries, add, fix bug of flush_cam_entry at STOP AP mode , 0724 */
+	rtw_indicate_connect(padapter);
+
+	pmlmepriv->cur_network.join_res = true;/* for check if already set beacon */
+
+	/* update bc/mc sta_info */
+
+	return ret;
+}
+
+void rtw_set_macaddr_acl(struct rtw_adapter *padapter, int mode)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+	DBG_8192D("%s, mode =%d\n", __func__, mode);
+
+	pacl_list->mode = mode;
+}
+
+int rtw_acl_add_sta(struct rtw_adapter *padapter, u8 *addr)
+{
+	struct list_head *plist, *phead;
+	u8 added = false;
+	int i, ret = 0;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue *pacl_node_q = &pacl_list->acl_node_q;
+
+	DBG_8192D("%s(acl_num =%d) =%pM\n", __func__, pacl_list->num, addr);
+
+	if ((NUM_ACL-1) < pacl_list->num)
+		return -1;
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	phead = get_list_head(pacl_node_q);
+	plist = phead->next;
+
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = plist->next;
+
+		if (_rtw_memcmp(paclnode->addr, addr, ETH_ALEN)) {
+			if (paclnode->valid) {
+				added = true;
+				DBG_8192D("%s, sta has been added\n", __func__);
+				break;
+			}
+		}
+	}
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	if (added)
+		return ret;
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	for (i = 0; i < NUM_ACL; i++) {
+		paclnode = &pacl_list->aclnode[i];
+
+		if (!paclnode->valid) {
+			INIT_LIST_HEAD(&paclnode->list);
+
+			memcpy(paclnode->addr, addr, ETH_ALEN);
+
+			paclnode->valid = true;
+
+			rtw_list_insert_tail(&paclnode->list, get_list_head(pacl_node_q));
+
+			pacl_list->num++;
+
+			break;
+		}
+	}
+
+	DBG_8192D("%s, acl_num =%d\n", __func__, pacl_list->num);
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	return ret;
+}
+
+int rtw_acl_remove_sta(struct rtw_adapter *padapter, u8 *addr)
+{
+	struct list_head *plist, *phead;
+	int i, ret = 0;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue *pacl_node_q = &pacl_list->acl_node_q;
+
+	DBG_8192D("%s(acl_num =%d) =%pM\n", __func__, pacl_list->num, addr);
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	phead = get_list_head(pacl_node_q);
+	plist = phead->next;
+
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = plist->next;
+
+		if (_rtw_memcmp(paclnode->addr, addr, ETH_ALEN)) {
+			if (paclnode->valid) {
+				paclnode->valid = false;
+
+				list_del_init(&paclnode->list);
+
+				pacl_list->num--;
+			}
+		}
+	}
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	DBG_8192D("%s, acl_num =%d\n", __func__, pacl_list->num);
+
+	return ret;
+}
+
+#ifdef CONFIG_NATIVEAP_MLME
+
+static void update_bcn_erpinfo_ie(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);
+	unsigned char *p, *ie = pnetwork->IEs;
+	u32 len = 0;
+
+	DBG_8192D("%s, ERP_enable =%d\n", __func__, pmlmeinfo->ERP_enable);
+
+	if (!pmlmeinfo->ERP_enable)
+		return;
+
+	/* parsing ERP_IE */
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+	if (p && len > 0) {
+		struct ndis_802_11_variable_ies *pIE = (struct ndis_802_11_variable_ies *)p;
+
+		if (pmlmepriv->num_sta_non_erp == 1)
+			pIE->data[0] |= RTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION;
+		else
+			pIE->data[0] &= ~(RTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION);
+
+		if (pmlmepriv->num_sta_no_short_preamble > 0)
+			pIE->data[0] |= RTW_ERP_INFO_BARKER_PREAMBLE_MODE;
+		else
+			pIE->data[0] &= ~(RTW_ERP_INFO_BARKER_PREAMBLE_MODE);
+
+		ERP_IE_handler(padapter, pIE);
+	}
+}
+
+static void update_bcn_wps_ie(struct rtw_adapter *padapter)
+{
+	u8 *pwps_ie = NULL, *pwps_ie_src, *premainder_ie, *pbackup_remainder_ie = NULL;
+	uint wps_ielen = 0, wps_offset, remainder_ielen;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);
+	unsigned char *ie = pnetwork->IEs;
+	u32 ielen = pnetwork->IELength;
+
+	DBG_8192D("%s\n", __func__);
+
+	pwps_ie = rtw_get_wps_ie(ie+_FIXED_IE_LENGTH_, ielen-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
+
+	if (pwps_ie == NULL || wps_ielen == 0)
+		return;
+
+	wps_offset = (uint)(pwps_ie-ie);
+
+	premainder_ie = pwps_ie + wps_ielen;
+
+	remainder_ielen = ielen - wps_offset - wps_ielen;
+
+	if (remainder_ielen > 0) {
+		pbackup_remainder_ie = kmalloc(remainder_ielen, GFP_KERNEL);
+		if (pbackup_remainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+	pwps_ie_src = pmlmepriv->wps_beacon_ie;
+	if (pwps_ie_src == NULL)
+		return;
+
+	wps_ielen = (uint)pwps_ie_src[1];/* to get ie data len */
+	if ((wps_offset+wps_ielen+2+remainder_ielen) <= MAX_IE_SZ) {
+		memcpy(pwps_ie, pwps_ie_src, wps_ielen+2);
+		pwps_ie += (wps_ielen+2);
+
+		if (pbackup_remainder_ie)
+			memcpy(pwps_ie, pbackup_remainder_ie, remainder_ielen);
+
+		/* update IELength */
+		pnetwork->IELength = wps_offset + (wps_ielen+2) + remainder_ielen;
+	}
+
+	kfree(pbackup_remainder_ie);
+}
+
+static void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter, u8 *oui)
+{
+	DBG_8192D("%s\n", __func__);
+
+	if (_rtw_memcmp(WPS_OUI, oui, 4))
+		update_bcn_wps_ie(padapter);
+	else if ((_rtw_memcmp(RTW_WPA_OUI, oui, 4)) ||
+		 (_rtw_memcmp(WMM_OUI, oui, 4)) ||
+		 (_rtw_memcmp(P2P_OUI, oui, 4)))
+		return;
+	else
+		DBG_8192D("unknown OUI type!\n");
+}
+
+void update_beacon(struct rtw_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)
+{
+	struct mlme_priv *pmlmepriv;
+	struct mlme_ext_priv	*pmlmeext;
+	/* struct mlme_ext_info	*pmlmeinfo; */
+
+	if (!padapter)
+		return;
+
+	pmlmepriv = &(padapter->mlmepriv);
+	pmlmeext = &(padapter->mlmeextpriv);
+
+	if (!pmlmeext->bstart_bss)
+		return;
+
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
+
+	switch (ie_id) {
+	case _TIM_IE_:
+		update_BCNTIM(padapter);
+		break;
+	case _ERPINFO_IE_:
+		update_bcn_erpinfo_ie(padapter);
+		break;
+	case _VENDOR_SPECIFIC_IE_:
+		update_bcn_vendor_spec_ie(padapter, oui);
+		break;
+	default:
+		break;
+	}
+
+	pmlmepriv->update_bcn = true;
+
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
+
+#ifndef CONFIG_INTERRUPT_BASED_TXBCN
+	if (tx)
+		set_tx_beacon_cmd(padapter);
+#endif /* CONFIG_INTERRUPT_BASED_TXBCN */
+}
+
+#ifdef CONFIG_80211N_HT
+
+/*
+op_mode
+Set to 0 (HT pure) under the followign conditions
+	- all STAs in the BSS are 20/40 MHz HT in 20/40 MHz BSS or
+	- all STAs in the BSS are 20 MHz HT in 20 MHz BSS
+Set to 1 (HT non-member protection) if there may be non-HT STAs
+	in both the primary and the secondary channel
+Set to 2 if only HT STAs are associated in BSS,
+	however and at least one 20 MHz HT STA is associated
+Set to 3 (HT mixed mode) when one or more non-HT STAs are associated
+	(currently non-GF HT station is considered as non-HT STA also)
+*/
+static int rtw_ht_operation_update(struct rtw_adapter *padapter)
+{
+	u16 cur_op_mode, new_op_mode;
+	int op_mode_changes = 0;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
+
+	if (pmlmepriv->htpriv.ht_option)
+		return 0;
+
+	DBG_8192D("%s current operation mode = 0x%X\n",
+		  __func__, pmlmepriv->ht_op_mode);
+
+	if (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT) &&
+	    pmlmepriv->num_sta_ht_no_gf) {
+		pmlmepriv->ht_op_mode |=
+			HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;
+		op_mode_changes++;
+	} else if ((pmlmepriv->ht_op_mode &
+		    HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT) &&
+		   pmlmepriv->num_sta_ht_no_gf == 0) {
+		pmlmepriv->ht_op_mode &=
+			~HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;
+		op_mode_changes++;
+	}
+
+	if (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&
+	    (pmlmepriv->num_sta_no_ht || pmlmepriv->olbc_ht)) {
+		pmlmepriv->ht_op_mode |= HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;
+		op_mode_changes++;
+	} else if ((pmlmepriv->ht_op_mode &
+		    HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&
+		   (pmlmepriv->num_sta_no_ht == 0 && !pmlmepriv->olbc_ht)) {
+		pmlmepriv->ht_op_mode &=
+			~HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;
+		op_mode_changes++;
+	}
+
+	/* Note: currently we switch to the MIXED op mode if HT non-greenfield
+	 * station is associated. Probably it's a theoretical case, since
+	 * it looks like all known HT STAs support greenfield.
+	 */
+	new_op_mode = 0;
+	if (pmlmepriv->num_sta_no_ht ||
+	    (pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT))
+		new_op_mode = OP_MODE_MIXED;
+	else if ((phtpriv_ap->ht_cap.cap_info & IEEE80211_HT_CAP_SUP_WIDTH) &&
+		 pmlmepriv->num_sta_ht_20mhz)
+		new_op_mode = OP_MODE_20MHZ_HT_STA_ASSOCED;
+	else if (pmlmepriv->olbc_ht)
+		new_op_mode = OP_MODE_MAY_BE_LEGACY_STAS;
+	else
+		new_op_mode = OP_MODE_PURE;
+
+	cur_op_mode = pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_OP_MODE_MASK;
+	if (cur_op_mode != new_op_mode) {
+		pmlmepriv->ht_op_mode &= ~HT_INFO_OPERATION_MODE_OP_MODE_MASK;
+		pmlmepriv->ht_op_mode |= new_op_mode;
+		op_mode_changes++;
+	}
+
+	DBG_8192D("%s new operation mode = 0x%X changes =%d\n",
+		  __func__, pmlmepriv->ht_op_mode, op_mode_changes);
+
+	return op_mode_changes;
+}
+
+#endif /* CONFIG_80211N_HT */
+
+void associated_clients_update(struct rtw_adapter *padapter, u8 updated)
+{
+	/* update associcated stations cap. */
+	if (updated) {
+		struct list_head *phead, *plist;
+		struct sta_info *psta = NULL;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+
+		phead = &pstapriv->asoc_list;
+		plist = phead->next;
+
+		/* check asoc_queue */
+		while (!rtw_end_of_queue_search(phead, plist)) {
+			psta = container_of(plist, struct sta_info, asoc_list);
+
+			plist = plist->next;
+
+			VCS_update(padapter, psta);
+		}
+
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+	}
+}
+
+/* called > TSR LEVEL for USB or SDIO Interface*/
+void bss_cap_update_on_sta_join(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	u8 beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+
+	if (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {
+		if (!psta->no_short_preamble_set) {
+			psta->no_short_preamble_set = 1;
+
+			pmlmepriv->num_sta_no_short_preamble++;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+			    (pmlmepriv->num_sta_no_short_preamble == 1)) {
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
+			}
+		}
+	} else {
+		if (psta->no_short_preamble_set) {
+			psta->no_short_preamble_set = 0;
+
+			pmlmepriv->num_sta_no_short_preamble--;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+			    (pmlmepriv->num_sta_no_short_preamble == 0)) {
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
+			}
+		}
+	}
+
+	if (psta->flags & WLAN_STA_NONERP) {
+		if (!psta->nonerp_set) {
+			psta->nonerp_set = 1;
+
+			pmlmepriv->num_sta_non_erp++;
+
+			if (pmlmepriv->num_sta_non_erp == 1) {
+				beacon_updated = true;
+				update_beacon(padapter, _ERPINFO_IE_, NULL, true);
+			}
+		}
+
+	} else {
+		if (psta->nonerp_set) {
+			psta->nonerp_set = 0;
+
+			pmlmepriv->num_sta_non_erp--;
+
+			if (pmlmepriv->num_sta_non_erp == 0) {
+				beacon_updated = true;
+				update_beacon(padapter, _ERPINFO_IE_, NULL, true);
+			}
+		}
+	}
+
+	if (!(psta->capability & WLAN_CAPABILITY_SHORT_SLOT)) {
+		if (!psta->no_short_slot_time_set) {
+			psta->no_short_slot_time_set = 1;
+
+			pmlmepriv->num_sta_no_short_slot_time++;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+			    (pmlmepriv->num_sta_no_short_slot_time == 1)) {
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
+			}
+		}
+	} else {
+		if (psta->no_short_slot_time_set) {
+			psta->no_short_slot_time_set = 0;
+
+			pmlmepriv->num_sta_no_short_slot_time--;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+			    (pmlmepriv->num_sta_no_short_slot_time == 0)) {
+				beacon_updated = true;
+				update_beacon(padapter, 0xFF, NULL, true);
+			}
+		}
+	}
+
+#ifdef CONFIG_80211N_HT
+
+	if (psta->flags & WLAN_STA_HT) {
+		u16 ht_capab = psta->htpriv.ht_cap.cap_info;
+
+		DBG_8192D("HT: STA %pM HT Capabilities Info: 0x%04x\n",
+			  psta->hwaddr, ht_capab);
+
+		if (psta->no_ht_set) {
+			psta->no_ht_set = 0;
+			pmlmepriv->num_sta_no_ht--;
+		}
+
+		if ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {
+			if (!psta->no_ht_gf_set) {
+				psta->no_ht_gf_set = 1;
+				pmlmepriv->num_sta_ht_no_gf++;
+			}
+			DBG_8192D("%s STA %pM - no greenfield, num of non-gf stations %d\n",
+				  __func__, psta->hwaddr,
+				  pmlmepriv->num_sta_ht_no_gf);
+		}
+
+		if ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH) == 0) {
+			if (!psta->ht_20mhz_set) {
+				psta->ht_20mhz_set = 1;
+				pmlmepriv->num_sta_ht_20mhz++;
+			}
+			DBG_8192D("%s STA %pM - 20 MHz HT, num of 20MHz HT STAs %d\n",
+				  __func__, psta->hwaddr,
+				  pmlmepriv->num_sta_ht_20mhz);
+		}
+
+	} else {
+		if (!psta->no_ht_set) {
+			psta->no_ht_set = 1;
+			pmlmepriv->num_sta_no_ht++;
+		}
+		if (pmlmepriv->htpriv.ht_option) {
+			DBG_8192D("%s STA %pM - no HT, num of non-HT stations %d\n",
+				  __func__, psta->hwaddr,
+				  pmlmepriv->num_sta_no_ht);
+		}
+	}
+
+	if (rtw_ht_operation_update(padapter) > 0) {
+		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);
+	}
+
+#endif /* CONFIG_80211N_HT */
+
+	/* update associcated stations cap. */
+	associated_clients_update(padapter,  beacon_updated);
+
+	DBG_8192D("%s, updated =%d\n", __func__, beacon_updated);
+}
+
+u8 bss_cap_update_on_sta_leave(struct rtw_adapter *padapter,
+			       struct sta_info *psta)
+{
+	u8 beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+
+	if (!psta)
+		return beacon_updated;
+
+	if (psta->no_short_preamble_set) {
+		psta->no_short_preamble_set = 0;
+		pmlmepriv->num_sta_no_short_preamble--;
+		if (pmlmeext->cur_wireless_mode > WIRELESS_11B &&
+		    pmlmepriv->num_sta_no_short_preamble == 0) {
+			beacon_updated = true;
+			update_beacon(padapter, 0xFF, NULL, true);
+		}
+	}
+
+	if (psta->nonerp_set) {
+		psta->nonerp_set = 0;
+		pmlmepriv->num_sta_non_erp--;
+		if (pmlmepriv->num_sta_non_erp == 0) {
+			beacon_updated = true;
+			update_beacon(padapter, _ERPINFO_IE_, NULL, true);
+		}
+	}
+
+	if (psta->no_short_slot_time_set) {
+		psta->no_short_slot_time_set = 0;
+		pmlmepriv->num_sta_no_short_slot_time--;
+		if (pmlmeext->cur_wireless_mode > WIRELESS_11B &&
+		    pmlmepriv->num_sta_no_short_slot_time == 0) {
+			beacon_updated = true;
+			update_beacon(padapter, 0xFF, NULL, true);
+		}
+	}
+
+#ifdef CONFIG_80211N_HT
+
+	if (psta->no_ht_gf_set) {
+		psta->no_ht_gf_set = 0;
+		pmlmepriv->num_sta_ht_no_gf--;
+	}
+
+	if (psta->no_ht_set) {
+		psta->no_ht_set = 0;
+		pmlmepriv->num_sta_no_ht--;
+	}
+
+	if (psta->ht_20mhz_set) {
+		psta->ht_20mhz_set = 0;
+		pmlmepriv->num_sta_ht_20mhz--;
+	}
+
+	if (rtw_ht_operation_update(padapter) > 0) {
+		update_beacon(padapter, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(padapter, _HT_ADD_INFO_IE_, NULL, true);
+	}
+
+#endif /* CONFIG_80211N_HT */
+
+	/* update associcated stations cap. */
+
+	DBG_8192D("%s, updated =%d\n", __func__, beacon_updated);
+
+	return beacon_updated;
+}
+
+u8 ap_free_sta(struct rtw_adapter *padapter, struct sta_info *psta,
+	       bool active, u16 reason)
+{
+	u8 beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	if (!psta)
+		return beacon_updated;
+
+	/* tear down Rx AMPDU */
+	send_delba(padapter, 0, psta->hwaddr);/*  recipient */
+
+	/* tear down TX AMPDU */
+	send_delba(padapter, 1, psta->hwaddr);/* originator */
+	psta->htpriv.agg_enable_bitmap = 0x0;/* reset */
+	psta->htpriv.candidate_tid_bitmap = 0x0;/* reset */
+
+	if (active)
+		issue_deauth(padapter, psta->hwaddr, reason);
+
+	/* clear cam entry / key */
+	rtw_clearstakey_cmd(padapter, (u8 *)psta, (u8)(psta->mac_id + 3), true);
+
+	spin_lock_bh(&psta->lock);
+	psta->state &= ~_FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+
+	report_del_sta_event(padapter, psta->hwaddr, reason);
+
+	beacon_updated = bss_cap_update_on_sta_leave(padapter, psta);
+
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(padapter, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+	return beacon_updated;
+}
+
+int rtw_ap_inform_ch_switch(struct rtw_adapter *padapter, u8 new_ch,
+			    u8 ch_offset)
+{
+	struct list_head *phead, *plist;
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return ret;
+
+	DBG_8192D(FUNC_NDEV_FMT" with ch:%u, offset:%u\n",
+		  FUNC_NDEV_ARG(padapter->pnetdev), new_ch, ch_offset);
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+
+	/* for each sta in asoc_queue */
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = plist->next;
+
+		issue_action_spct_ch_switch(padapter, psta->hwaddr, new_ch,
+					    ch_offset);
+		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 :
+				  (pstapriv->expire_to * 2);
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	issue_action_spct_ch_switch(padapter, bc_addr, new_ch, ch_offset);
+
+	return ret;
+}
+
+int rtw_sta_flush(struct rtw_adapter *padapter)
+{
+	struct list_head *phead, *plist;
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(padapter->pnetdev));
+
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return ret;
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+
+	/* free sta asoc_queue */
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+
+		plist = plist->next;
+
+		list_del_init(&psta->asoc_list);
+		pstapriv->asoc_list_cnt--;
+
+		ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	issue_deauth(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);
+
+	associated_clients_update(padapter, true);
+
+	return ret;
+}
+
+/* called > TSR LEVEL for USB or SDIO Interface*/
+void sta_info_update(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	int flags = psta->flags;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	/* update wmm cap. */
+	if (WLAN_STA_WME&flags)
+		psta->qos_option = 1;
+	else
+		psta->qos_option = 0;
+
+	if (pmlmepriv->qospriv.qos_option == 0)
+		psta->qos_option = 0;
+
+#ifdef CONFIG_80211N_HT
+	/* update 802.11n ht cap. */
+	if (WLAN_STA_HT&flags) {
+		psta->htpriv.ht_option = true;
+		psta->qos_option = 1;
+	} else {
+		psta->htpriv.ht_option = false;
+	}
+
+	if (pmlmepriv->htpriv.ht_option)
+		psta->htpriv.ht_option = false;
+#endif
+
+	update_sta_info_apmode(padapter, psta);
+}
+
+/* called >= TSR LEVEL for USB or SDIO Interface*/
+void ap_sta_info_defer_update(struct rtw_adapter *padapter,
+			      struct sta_info *psta)
+{
+	if (psta->state & _FW_LINKED) {
+		/* add ratid */
+		add_RATid(padapter, psta);
+	}
+}
+
+void start_ap_mode(struct rtw_adapter *padapter)
+{
+	int i;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
+	pmlmepriv->num_sta_non_erp = 0;
+	pmlmepriv->num_sta_no_short_slot_time = 0;
+	pmlmepriv->num_sta_no_short_preamble = 0;
+	pmlmepriv->num_sta_ht_no_gf = 0;
+	pmlmepriv->num_sta_no_ht = 0;
+	pmlmepriv->num_sta_ht_20mhz = 0;
+	pmlmepriv->olbc = false;
+	pmlmepriv->olbc_ht = false;
+
+#ifdef CONFIG_80211N_HT
+	pmlmepriv->ht_op_mode = 0;
+#endif
+
+	for (i = 0; i < NUM_STA; i++)
+		pstapriv->sta_aid[i] = NULL;
+
+	pmlmepriv->wps_beacon_ie = NULL;
+	pmlmepriv->wps_probe_resp_ie = NULL;
+	pmlmepriv->wps_assoc_resp_ie = NULL;
+
+	pmlmepriv->p2p_beacon_ie = NULL;
+	pmlmepriv->p2p_probe_resp_ie = NULL;
+
+	/* for ACL */
+	INIT_LIST_HEAD(&(pacl_list->acl_node_q.queue));
+	pacl_list->num = 0;
+	pacl_list->mode = 0;
+	for (i = 0; i < NUM_ACL; i++) {
+		INIT_LIST_HEAD(&pacl_list->aclnode[i].list);
+		pacl_list->aclnode[i].valid = false;
+	}
+}
+
+void stop_ap_mode(struct rtw_adapter *padapter)
+{
+	struct list_head *phead, *plist;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue *pacl_node_q = &pacl_list->acl_node_q;
+
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
+
+	/* reset and init security priv , this can refine with
+	 * rtw_reset_securitypriv */
+	memset((unsigned char *)&padapter->securitypriv, 0,
+	       sizeof(struct security_priv));
+	padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
+	padapter->securitypriv.ndisencryptstatus = NDIS802_11WEPDISABLED;
+
+	/* for ACL */
+	spin_lock_bh(&(pacl_node_q->lock));
+	phead = get_list_head(pacl_node_q);
+	plist = phead->next;
+	while (!rtw_end_of_queue_search(phead, plist)) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node,
+					  list);
+		plist = plist->next;
+
+		if (paclnode->valid) {
+			paclnode->valid = false;
+
+			list_del_init(&paclnode->list);
+
+			pacl_list->num--;
+		}
+	}
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	DBG_8192D("%s, free acl_node_queue, num =%d\n", __func__,
+		  pacl_list->num);
+
+	rtw_sta_flush(padapter);
+
+	/* free_assoc_sta_resources */
+	rtw_free_all_stainfo(padapter);
+
+	psta = rtw_get_bcmc_stainfo(padapter);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(padapter, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+	rtw_init_bcmc_stainfo(padapter);
+
+	rtw_free_mlme_priv_ie_data(pmlmepriv);
+}
+
+#endif /* CONFIG_NATIVEAP_MLME */
+#endif /* CONFIG_92D_AP_MODE */
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_cmd.c b/drivers/net/wireless/rtl8192du/core/rtw_cmd.c
new file mode 100644
index 0000000..9b3cdaf
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_cmd.c
@@ -0,0 +1,2252 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtw_cmd.h>
+#include <usb_osintf.h>
+/*
+Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+int _rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	int res = _SUCCESS;
+
+	_rtw_init_sema(&(pcmdpriv->cmd_queue_sema), 0);
+	_rtw_init_sema(&(pcmdpriv->terminate_cmdthread_sema), 0);
+
+	_rtw_init_queue(&(pcmdpriv->cmd_queue));
+
+	pcmdpriv->cmd_seq = 1;
+
+	pcmdpriv->cmd_allocated_buf = kzalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ, GFP_ATOMIC);
+
+	if (pcmdpriv->cmd_allocated_buf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ((SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+
+	pcmdpriv->rsp_allocated_buf = kzalloc(MAX_RSPSZ + 4, GFP_ATOMIC);
+
+	if (pcmdpriv->rsp_allocated_buf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 -
+			    ((SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
+
+	pcmdpriv->cmd_issued_cnt = 0;
+	pcmdpriv->cmd_done_cnt = 0;
+	pcmdpriv->rsp_cnt = 0;
+
+exit:
+	return res;
+}
+
+#ifdef CONFIG_C2H_WK
+static void c2h_wk_callback(_workitem *work);
+#endif
+int _rtw_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	int res = _SUCCESS;
+
+#ifdef CONFIG_H2CLBK
+	_rtw_init_sema(&(pevtpriv->lbkevt_done), 0);
+	pevtpriv->lbkevt_limit = 0;
+	pevtpriv->lbkevt_num = 0;
+	pevtpriv->cmdevt_parm = NULL;
+#endif
+
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+	ATOMIC_SET(&pevtpriv->event_seq, 0);
+	pevtpriv->evt_done_cnt = 0;
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+
+	_rtw_init_sema(&(pevtpriv->evt_notify), 0);
+	_rtw_init_sema(&(pevtpriv->terminate_evtthread_sema), 0);
+
+	pevtpriv->evt_allocated_buf = kzalloc(MAX_EVTSZ + 4, GFP_ATOMIC);
+	if (pevtpriv->evt_allocated_buf == NULL) {
+		res = _FAIL;
+		goto exit;
+		}
+	pevtpriv->evt_buf = pevtpriv->evt_allocated_buf  +  4 - ((unsigned int)(pevtpriv->evt_allocated_buf) & 3);
+
+	_rtw_init_queue(&(pevtpriv->evt_queue));
+
+exit:
+
+#endif /* end of CONFIG_EVENT_THREAD_MODE */
+
+#ifdef CONFIG_C2H_WK
+	_init_workitem(&pevtpriv->c2h_wk, c2h_wk_callback, NULL);
+	pevtpriv->c2h_wk_alive = false;
+	pevtpriv->c2h_queue = rtw_cbuf_alloc(C2H_QUEUE_MAX_LEN+1);
+#endif
+	return res;
+}
+
+void _rtw_free_evt_priv(struct evt_priv *pevtpriv)
+{
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+_rtw_free_evt_priv\n"));
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	_rtw_free_sema(&(pevtpriv->evt_notify));
+	_rtw_free_sema(&(pevtpriv->terminate_evtthread_sema));
+
+	kfree(pevtpriv->evt_allocated_buf);
+#endif
+
+#ifdef CONFIG_C2H_WK
+	_cancel_workitem_sync(&pevtpriv->c2h_wk);
+	while (pevtpriv->c2h_wk_alive)
+		rtw_msleep_os(10);
+
+	while (!rtw_cbuf_empty(pevtpriv->c2h_queue)) {
+		void *c2h = rtw_cbuf_pop(pevtpriv->c2h_queue);
+		if (c2h != NULL && c2h != (void *)pevtpriv)
+			kfree(c2h);
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("-_rtw_free_evt_priv\n"));
+
+}
+
+void _rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+
+	if (pcmdpriv) {
+		_rtw_spinlock_free(&(pcmdpriv->cmd_queue.lock));
+		_rtw_free_sema(&(pcmdpriv->cmd_queue_sema));
+		_rtw_free_sema(&(pcmdpriv->terminate_cmdthread_sema));
+		kfree(pcmdpriv->cmd_allocated_buf);
+		kfree(pcmdpriv->rsp_allocated_buf);
+	}
+
+}
+
+/*
+Calling Context:
+
+rtw_enqueue_cmd can only be called between kernel thread,
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+int	_rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj)
+{
+	long unsigned int flags;
+
+	if (obj == NULL)
+		goto exit;
+
+	spin_lock_irqsave(&queue->lock, flags);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+exit:
+	return _SUCCESS;
+}
+
+struct cmd_obj *_rtw_dequeue_cmd(struct __queue *queue)
+{
+	long unsigned int flags;
+	struct cmd_obj *obj;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	if (rtw_is_list_empty(&(queue->queue))) {
+		obj = NULL;
+	} else {
+		obj = container_of((&queue->queue)->next, struct cmd_obj, list);
+		list_del_init(&obj->list);
+	}
+
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return obj;
+}
+
+u32	rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	u32	res;
+
+	res = _rtw_init_cmd_priv(pcmdpriv);
+
+	return res;
+}
+
+u32	rtw_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	int	res;
+
+	res = _rtw_init_evt_priv(pevtpriv);
+
+	return res;
+}
+
+void rtw_free_evt_priv(struct evt_priv *pevtpriv)
+{
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_evt_priv\n"));
+	_rtw_free_evt_priv(pevtpriv);
+
+}
+
+void rtw_free_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("rtw_free_cmd_priv\n"));
+	_rtw_free_cmd_priv(pcmdpriv);
+
+}
+
+static int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
+{
+	u8 allow = false; /* set to true to allow enqueuing cmd when hw_init_completed is false */
+
+	if (cmd_obj->cmdcode == GEN_CMD_CODE(_SETCHANNELPLAN))
+		allow = true;
+
+	if ((pcmdpriv->padapter->hw_init_completed == false && allow == false) ||
+	    pcmdpriv->cmdthd_running == false)	/* com_thread not running */
+		return _FAIL;
+	return _SUCCESS;
+}
+
+u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
+{
+	int res = _FAIL;
+	struct rtw_adapter *padapter = pcmdpriv->padapter;
+
+	if (cmd_obj == NULL) {
+		goto exit;
+	}
+
+	cmd_obj->padapter = padapter;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	/* change pcmdpriv to primary's pcmdpriv */
+	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
+		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
+#endif
+
+	res = rtw_cmd_filter(pcmdpriv, cmd_obj);
+	if (_FAIL == res) {
+		rtw_free_cmd_obj(cmd_obj);
+		goto exit;
+	}
+
+	res = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);
+
+	if (res == _SUCCESS)
+		_rtw_up_sema(&pcmdpriv->cmd_queue_sema);
+
+exit:
+	return res;
+}
+
+struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
+{
+	struct cmd_obj *cmd_obj;
+
+	cmd_obj = _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);
+
+	return cmd_obj;
+}
+
+void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv)
+{
+
+	pcmdpriv->cmd_done_cnt++;
+
+}
+
+void rtw_free_cmd_obj(struct cmd_obj *pcmd)
+{
+
+	if ((pcmd->cmdcode != _JOINBSS_CMD_) &&
+	    (pcmd->cmdcode != _CREATEBSS_CMD_)) {
+		/* free parmbuf in cmd_obj */
+		kfree(pcmd->parmbuf);
+	}
+
+	if (pcmd->rsp != NULL) {
+		if (pcmd->rspsz != 0) {
+			/* free rsp in cmd_obj */
+			kfree(pcmd->rsp);
+		}
+	}
+
+	/* free cmd_obj */
+	kfree(pcmd);
+
+}
+
+int rtw_cmd_thread(void *context)
+{
+	u8 ret;
+	struct cmd_obj *pcmd;
+	u8 *pcmdbuf;
+	u8 (*cmd_hdl)(struct rtw_adapter *padapter, u8 *pbuf);
+	void (*pcmd_callback)(struct rtw_adapter *dev, struct cmd_obj *pcmd);
+	struct rtw_adapter *padapter = (struct rtw_adapter *)context;
+	struct cmd_priv *pcmdpriv = &(padapter->cmdpriv);
+
+	thread_enter("RTW_CMD_THREAD");
+
+	pcmdbuf = pcmdpriv->cmd_buf;
+
+	pcmdpriv->cmdthd_running = true;
+	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("start r871x rtw_cmd_thread !!!!\n"));
+
+	while (1) {
+		if ((_rtw_down_sema(&(pcmdpriv->cmd_queue_sema))) == _FAIL)
+			break;
+
+#ifdef CONFIG_LPS_LCLK
+		if (rtw_register_cmd_alive(padapter) != _SUCCESS)
+			continue;
+#endif
+
+_next:
+		if ((padapter->bDriverStopped == true) ||
+		    (padapter->bSurpriseRemoved == true)) {
+			DBG_8192D("###> rtw_cmd_thread break.................\n");
+			RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+				 ("rtw_cmd_thread:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+				 padapter->bDriverStopped,
+				 padapter->bSurpriseRemoved));
+			break;
+		}
+
+		pcmd = rtw_dequeue_cmd(pcmdpriv);
+		if (!pcmd) {
+#ifdef CONFIG_LPS_LCLK
+			rtw_unregister_cmd_alive(padapter);
+#endif
+			continue;
+		}
+
+		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
+			pcmd->res = H2C_DROPPED;
+			goto post_process;
+		}
+
+		if (_FAIL == rtw_cmd_filter(pcmdpriv, pcmd)) {
+			rtw_free_cmd_obj(pcmd);
+			continue;
+		}
+
+		pcmdpriv->cmd_issued_cnt++;
+
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));/* _RND4 */
+
+		memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+		if (pcmd->cmdcode < (sizeof(wlancmds) / sizeof(struct cmd_hdl))) {
+			cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
+
+			if (cmd_hdl) {
+				ret = cmd_hdl(pcmd->padapter, pcmdbuf);
+				pcmd->res = ret;
+			}
+
+			pcmdpriv->cmd_seq++;
+		} else {
+			pcmd->res = H2C_PARAMETERS_ERROR;
+		}
+
+		cmd_hdl = NULL;
+
+post_process:
+
+		/* call callback function for post-processed */
+		if (pcmd->cmdcode < (sizeof(rtw_cmd_callback) / sizeof(struct _cmd_callback))) {
+			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
+			if (pcmd_callback == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("mlme_cmd_hdl(): pcmd_callback = 0x%p, cmdcode = 0x%x\n", pcmd_callback, pcmd->cmdcode));
+				rtw_free_cmd_obj(pcmd);
+			} else {
+				/* todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!= NULL) */
+				pcmd_callback(pcmd->padapter, pcmd);/* need conider that free cmd_obj in rtw_cmd_callback */
+			}
+		}
+
+		flush_signals_thread();
+
+		goto _next;
+	}
+	pcmdpriv->cmdthd_running = false;
+
+	/*  free all cmd_obj resources */
+	do {
+		pcmd = rtw_dequeue_cmd(pcmdpriv);
+		if (pcmd == NULL)
+			break;
+
+		rtw_free_cmd_obj(pcmd);
+	} while (1);
+
+	_rtw_up_sema(&pcmdpriv->terminate_cmdthread_sema);
+
+	thread_exit();
+}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj)
+{
+	int	res;
+	struct __queue *queue = &pevtpriv->evt_queue;
+
+	res = _SUCCESS;
+
+	if (obj == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	spin_lock_bh(&queue->lock);
+
+	rtw_list_insert_tail(&obj->list, &queue->queue);
+
+	spin_unlock_bh(&queue->lock);
+
+exit:
+	return res;
+}
+
+struct evt_obj *rtw_dequeue_evt(_queue *queue)
+{
+	struct evt_obj *pevtobj;
+
+	spin_lock_bh(&queue->lock);
+
+	if (rtw_is_list_empty(&(queue->queue))) {
+		pevtobj = NULL;
+	} else {
+		pevtobj = container_of(&(queue->queue->next; struct evt_obj, list);
+		list_del_init(&pevtobj->list);
+	}
+
+	spin_unlock_bh(&queue->lock);
+
+	return pevtobj;
+}
+
+void rtw_free_evt_obj(struct evt_obj *pevtobj)
+{
+
+	kfree(pevtobj->parmbuf);
+	kfree(pevtobj);
+
+}
+
+void rtw_evt_notify_isr(struct evt_priv *pevtpriv)
+{
+
+	pevtpriv->evt_done_cnt++;
+	_rtw_up_sema(&(pevtpriv->evt_notify));
+
+}
+#endif
+
+u8 rtw_setstandby_cmd(struct rtw_adapter *padapter, uint action)
+{
+	struct cmd_obj *ph2c;
+	struct usb_suspend_parm *psetusbsuspend;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	u8 ret = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetusbsuspend = (struct usb_suspend_parm *)kzalloc(sizeof(struct usb_suspend_parm), GFP_ATOMIC);
+	if (psetusbsuspend == NULL) {
+		kfree(ph2c);
+		ret = _FAIL;
+		goto exit;
+	}
+
+	psetusbsuspend->action = action;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetusbsuspend, GEN_CMD_CODE(_SETUSBSUSPEND));
+
+	ret = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+	return ret;
+}
+
+/*
+rtw_sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+u8 rtw_sitesurvey_cmd(struct rtw_adapter *padapter, struct ndis_802_11_ssid *ssid, int ssid_num,
+	struct rtw_ieee80211_channel *ch, int ch_num)
+{
+	u8 res = _FAIL;
+	struct cmd_obj *ph2c;
+	struct sitesurvey_parm *psurveyPara;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+#ifdef CONFIG_LPS
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SCAN, 1);
+	}
+#endif
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL)
+		return _FAIL;
+
+	psurveyPara = (struct sitesurvey_parm *)kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);
+	if (psurveyPara == NULL) {
+		kfree(ph2c);
+		return _FAIL;
+	}
+
+	rtw_free_network_queue(padapter, false);
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("\nflush  network queue\n\n"));
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SITESURVEY));
+
+	/* psurveyPara->bsslimit = 48; */
+	psurveyPara->scan_mode = pmlmepriv->scan_mode;
+
+	/* prepare ssid list */
+	if (ssid) {
+		int i;
+		for (i = 0; i < ssid_num && i < RTW_SSID_SCAN_AMOUNT; i++) {
+			if (ssid[i].SsidLength) {
+				memcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(struct ndis_802_11_ssid));
+				psurveyPara->ssid_num++;
+			}
+		}
+	}
+
+	/* prepare channel list */
+	if (ch) {
+		int i;
+		for (i = 0; i < ch_num && i < RTW_CHANNEL_SCAN_AMOUNT; i++) {
+			if (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {
+				memcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));
+				psurveyPara->ch_num++;
+			}
+		}
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+	if (res == _SUCCESS) {
+		pmlmepriv->scan_start_time = rtw_get_current_time();
+
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
+			_set_timer(&pmlmepriv->scan_to_timer, SURVEY_TO * (38 + (38 / RTW_SCAN_NUM_OF_CH) * RTW_STAY_AP_CH_MILLISECOND) + 1000);
+		else
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+			_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+
+		rtw_led_control(padapter, LED_CTL_SITE_SURVEY);
+
+		pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
+	} else {
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	}
+
+	return res;
+}
+
+u8 rtw_setdatarate_cmd(struct rtw_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj *ph2c;
+	struct setdatarate_parm *pbsetdataratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pbsetdataratepara = (struct setdatarate_parm *)kzalloc(sizeof(struct setdatarate_parm), GFP_ATOMIC);
+	if (pbsetdataratepara == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pbsetdataratepara, GEN_CMD_CODE(_SETDATARATE));
+#ifdef MP_FIRMWARE_OFFLOAD
+	pbsetdataratepara->curr_rateidx = *(u32 *)rateset;
+#else
+	pbsetdataratepara->mac_id = 5;
+	memcpy(pbsetdataratepara->datarates, rateset, NUMRATES);
+#endif
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+	return res;
+}
+
+u8 rtw_setbasicrate_cmd(struct rtw_adapter *padapter, u8 *rateset)
+{
+	struct cmd_obj *ph2c;
+	struct setbasicrate_parm *pssetbasicratepara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pssetbasicratepara = (struct setbasicrate_parm *)kzalloc(sizeof(struct setbasicrate_parm), GFP_ATOMIC);
+
+	if (pssetbasicratepara == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pssetbasicratepara, _SETBASICRATE_CMD_);
+
+	memcpy(pssetbasicratepara->basicrates, rateset, NUMRATES);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+	return res;
+}
+
+/*
+unsigned char rtw_setphy_cmd(unsigned char  *adapter)
+
+1.  be called only after rtw_update_registrypriv_dev_network(~) or mp testing program
+2.  for AdHoc/Ap mode or mp mode?
+
+*/
+u8 rtw_setphy_cmd(struct rtw_adapter *padapter, u8 modem, u8 ch)
+{
+	struct cmd_obj *ph2c;
+	struct setphy_parm *psetphypara;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	psetphypara = (struct setphy_parm *)kzalloc(sizeof(struct setphy_parm), GFP_ATOMIC);
+
+	if (psetphypara == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetphypara, _SETPHY_CMD_);
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("CH =%d, modem =%d", ch, modem));
+
+	psetphypara->modem = modem;
+	psetphypara->rfchannel = ch;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_setbbreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 val)
+{
+	struct cmd_obj *ph2c;
+	struct writeBB_parm *pwritebbparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+		}
+	pwritebbparm = (struct writeBB_parm *)kzalloc(sizeof(struct writeBB_parm), GFP_ATOMIC);
+
+	if (pwritebbparm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwritebbparm, GEN_CMD_CODE(_SETBBREG));
+
+	pwritebbparm->offset = offset;
+	pwritebbparm->value = val;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_getbbreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj *ph2c;
+	struct readBB_parm *prdbbparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	prdbbparm = (struct readBB_parm *)kzalloc(sizeof(struct readBB_parm), GFP_ATOMIC);
+
+	if (prdbbparm == NULL) {
+		kfree(ph2c);
+		return _FAIL;
+	}
+
+	INIT_LIST_HEAD(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_GETBBREG);
+	ph2c->parmbuf = (unsigned char *)prdbbparm;
+	ph2c->cmdsz =  sizeof(struct readBB_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readBB_rsp);
+
+	prdbbparm->offset = offset;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_setrfreg_cmd(struct rtw_adapter *padapter, u8 offset, u32 val)
+{
+	struct cmd_obj *ph2c;
+	struct writeRF_parm *pwriterfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pwriterfparm = (struct writeRF_parm *)kzalloc(sizeof(struct writeRF_parm), GFP_ATOMIC);
+
+	if (pwriterfparm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pwriterfparm, GEN_CMD_CODE(_SETRFREG));
+
+	pwriterfparm->offset = offset;
+	pwriterfparm->value = val;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_getrfreg_cmd(struct rtw_adapter *padapter, u8 offset, u8 *pval)
+{
+	struct cmd_obj *ph2c;
+	struct readRF_parm *prdrfparm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	prdrfparm = (struct readRF_parm *)kzalloc(sizeof(struct readRF_parm), GFP_ATOMIC);
+	if (prdrfparm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_GETRFREG);
+	ph2c->parmbuf = (unsigned char *)prdrfparm;
+	ph2c->cmdsz =  sizeof(struct readRF_parm);
+	ph2c->rsp = pval;
+	ph2c->rspsz = sizeof(struct readRF_rsp);
+
+	prdrfparm->offset = offset;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+
+}
+
+void rtw_readtssi_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+
+	kfree(pcmd->parmbuf);
+	kfree(pcmd);
+
+}
+
+u8 rtw_createbss_cmd(struct rtw_adapter *padapter)
+{
+	struct cmd_obj *pcmd;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_bssid_ex *pdev_network = &padapter->registrypriv.dev_network;
+	u8 res = _SUCCESS;
+
+	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for Any SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, (" createbss for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = _CREATEBSS_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	pdev_network->Length = pcmd->cmdsz;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+exit:
+
+	return res;
+}
+
+u8 rtw_createbss_cmd_ex(struct rtw_adapter *padapter, unsigned char *pbss, unsigned int sz)
+{
+	struct cmd_obj *pcmd;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = GEN_CMD_CODE(_CREATEBSS);
+	pcmd->parmbuf = pbss;
+	pcmd->cmdsz =  sz;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_joinbss_cmd(struct rtw_adapter *padapter, struct wlan_network *pnetwork)
+{
+	u8 res = _SUCCESS;
+	uint	t_len = 0;
+	struct wlan_bssid_ex	*psecnetwork;
+	struct cmd_obj *pcmd;
+	struct cmd_priv		*pcmdpriv = &padapter->cmdpriv;
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	rtw_led_control(padapter, LED_CTL_START_TO_LINK);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_, ("+Join cmd: Any SSid\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+Join cmd: SSid =[%s]\n", pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd: memory allocate for cmd_obj fail!!!\n"));
+		goto exit;
+	}
+	/* for IEs is fix buf size */
+	t_len = sizeof(struct wlan_bssid_ex);
+
+	/* for hidden ap to set fw_state here */
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true) {
+		switch (ndis_network_mode) {
+		case NDIS802_11IBSS:
+			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			break;
+		case NDIS802_11INFRA:
+			set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+			break;
+		case NDIS802_11APMODE:
+		case NDIS802_11AUTOUNK:
+		case NDIS802_11INFRA_MAX:
+			break;
+		}
+	}
+
+	psecnetwork = (struct wlan_bssid_ex *)&psecuritypriv->sec_bss;
+	if (psecnetwork == NULL) {
+		kfree(pcmd);
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("rtw_joinbss_cmd :psecnetwork == NULL!!!\n"));
+		goto exit;
+	}
+
+	memset(psecnetwork, 0, t_len);
+
+	memcpy(psecnetwork, &pnetwork->network, get_wlan_bssid_ex_sz(&pnetwork->network));
+
+	psecuritypriv->authenticator_ie[0] = (unsigned char)psecnetwork->IELength;
+
+	if ((psecnetwork->IELength-12) < (256-1)) {
+		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
+	} else {
+		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
+	}
+
+	psecnetwork->IELength = 0;
+	/*  Added by Albert 2009/02/18 */
+	/*  If the the driver wants to use the bssid to create the connection. */
+	/*  If not,  we have to copy the connecting AP's MAC address to it so that */
+	/*  the driver just has the bssid information for PMKIDList searching. */
+
+	if (pmlmepriv->assoc_by_bssid == false)
+		memcpy(&pmlmepriv->assoc_bssid[0], &pnetwork->network.MacAddress[0], ETH_ALEN);
+
+	psecnetwork->IELength = rtw_restruct_sec_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
+
+	pqospriv->qos_option = 0;
+
+	if (pregistrypriv->wmm_enable) {
+		u32 tmp_len;
+
+		tmp_len = rtw_restruct_wmm_ie(padapter, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
+
+		if (psecnetwork->IELength != tmp_len) {
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; /* There is WMM IE in this corresp. beacon */
+		} else {
+			pqospriv->qos_option = 0;/* There is no WMM IE in this corresp. beacon */
+		}
+	}
+
+#ifdef CONFIG_80211N_HT
+	phtpriv->ht_option = false;
+	if (pregistrypriv->ht_enable) {
+		/*	Added by Albert 2010/06/23 */
+		/*	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue. */
+		/*	Especially for Realtek 8192u SoftAP. */
+		if ((padapter->securitypriv.dot11PrivacyAlgrthm != _WEP40_) &&
+		    (padapter->securitypriv.dot11PrivacyAlgrthm != _WEP104_) &&
+		    (padapter->securitypriv.dot11PrivacyAlgrthm != _TKIP_)) {
+			/* rtw_restructure_ht_ie */
+			rtw_restructure_ht_ie(padapter, &pnetwork->network.IEs[0],
+					      &psecnetwork->IEs[0],
+					      pnetwork->network.IELength,
+					      &psecnetwork->IELength,
+					      (u8)psecnetwork->Configuration.DSConfig);
+		}
+	}
+
+#endif
+
+	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
+
+	pcmd->cmdsz = get_wlan_bssid_ex_sz(psecnetwork);/* get cmdsz before endian conversion */
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = _JOINBSS_CMD_;/* GEN_CMD_CODE(_JoinBss) */
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_disassoc_cmd(struct rtw_adapter *padapter, u32 deauth_timeout_ms, bool enqueue) /* for sta_mode */
+{
+	struct cmd_obj *cmdobj = NULL;
+	struct disconnect_parm *param = NULL;
+	struct cmd_priv *cmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_disassoc_cmd\n"));
+
+	/* prepare cmd parameter */
+	param = (struct disconnect_parm *)kzalloc(sizeof(*param), GFP_ATOMIC);
+	if (param == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	param->deauth_timeout_ms = deauth_timeout_ms;
+
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		cmdobj = (struct cmd_obj *)kzalloc(sizeof(*cmdobj), GFP_ATOMIC);
+		if (cmdobj == NULL) {
+			res = _FAIL;
+			kfree(param);
+			goto exit;
+		}
+		init_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DISCONNECT_CMD_);
+		res = rtw_enqueue_cmd(cmdpriv, cmdobj);
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if (H2C_SUCCESS != disconnect_hdl(padapter, (u8 *)param))
+			res = _FAIL;
+		kfree(param);
+	}
+
+exit:
+
+	return res;
+}
+
+u8 rtw_setopmode_cmd(struct rtw_adapter *padapter, enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct cmd_obj *ph2c;
+	struct setopmode_parm *psetop;
+
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = false;
+		goto exit;
+	}
+	psetop = (struct setopmode_parm *)kzalloc(sizeof(struct setopmode_parm), GFP_ATOMIC);
+	if (psetop == NULL) {
+		kfree(ph2c);
+		res = false;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SETOPMODE_CMD_);
+	psetop->mode = (u8)networktype;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_setstakey_cmd(struct rtw_adapter *padapter, u8 *psta, u8 unicast_key)
+{
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+
+	struct mlme_priv			*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv		*psecuritypriv = &padapter->securitypriv;
+	struct sta_info *sta = (struct sta_info *)psta;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm *)kzalloc(sizeof(struct set_stakey_parm), GFP_ATOMIC);
+	if (psetstakey_para == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetstakey_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_stakey_rsp), GFP_ATOMIC);
+	if (psetstakey_rsp == NULL) {
+		kfree(ph2c);
+		kfree(psetstakey_para);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
+	ph2c->rsp = (u8 *)psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+	memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		psetstakey_para->algorithm = (unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+	} else {
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
+	}
+
+	if (unicast_key == true) {
+		memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
+	} else {
+		memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
+	}
+
+	/* jeff: set this becasue at least sw key is ready */
+	padapter->securitypriv.busetkipkey = true;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_clearstakey_cmd(struct rtw_adapter *padapter, u8 *psta, u8 entry, u8 enqueue)
+{
+	struct cmd_obj *ph2c;
+	struct set_stakey_parm *psetstakey_para;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	struct set_stakey_rsp *psetstakey_rsp = NULL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct sta_info *sta = (struct sta_info *)psta;
+	u8 res = _SUCCESS;
+
+	if (!enqueue) {
+		clear_cam_entry(padapter, entry);
+	} else {
+		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		if (ph2c == NULL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+		psetstakey_para = (struct set_stakey_parm *)kzalloc(sizeof(struct set_stakey_parm), GFP_ATOMIC);
+		if (psetstakey_para == NULL) {
+			kfree(ph2c);
+			res = _FAIL;
+			goto exit;
+		}
+
+		psetstakey_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_stakey_rsp), GFP_ATOMIC);
+		if (psetstakey_rsp == NULL) {
+			kfree(ph2c);
+			kfree(psetstakey_para);
+			res = _FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
+		ph2c->rsp = (u8 *)psetstakey_rsp;
+		ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+		memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+
+		psetstakey_para->algorithm = _NO_PRIVACY_;
+
+		psetstakey_para->id = entry;
+
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	}
+exit:
+
+	return res;
+}
+
+u8 rtw_setrttbl_cmd(struct rtw_adapter *padapter, struct setratable_parm *prate_table)
+{
+	struct cmd_obj *ph2c;
+	struct setratable_parm *psetrttblparm;
+	struct cmd_priv				*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+		}
+	psetrttblparm = (struct setratable_parm *)kzalloc(sizeof(struct setratable_parm), GFP_ATOMIC);
+
+	if (psetrttblparm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetrttblparm, GEN_CMD_CODE(_SETRATABLE));
+
+	memcpy(psetrttblparm, prate_table, sizeof(struct setratable_parm));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_getrttbl_cmd(struct rtw_adapter *padapter, struct getratable_rsp *pval)
+{
+	struct cmd_obj *ph2c;
+	struct getratable_parm *pgetrttblparm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pgetrttblparm = (struct getratable_parm *)kzalloc(sizeof(struct getratable_parm), GFP_ATOMIC);
+
+	if (pgetrttblparm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&ph2c->list);
+	ph2c->cmdcode = GEN_CMD_CODE(_GETRATABLE);
+	ph2c->parmbuf = (unsigned char *)pgetrttblparm;
+	ph2c->cmdsz =  sizeof(struct getratable_parm);
+	ph2c->rsp = (u8 *)pval;
+	ph2c->rspsz = sizeof(struct getratable_rsp);
+
+	pgetrttblparm->rsvd = 0x0;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_setassocsta_cmd(struct rtw_adapter *padapter, u8 *mac_addr)
+{
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct set_assocsta_parm *psetassocsta_para;
+	struct set_stakey_rsp		*psetassocsta_rsp = NULL;
+
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetassocsta_para = (struct set_assocsta_parm *)kzalloc(sizeof(struct set_assocsta_parm), GFP_ATOMIC);
+	if (psetassocsta_para == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetassocsta_rsp = (struct set_stakey_rsp *)kzalloc(sizeof(struct set_assocsta_rsp), GFP_ATOMIC);
+	if (psetassocsta_rsp == NULL) {
+		kfree(ph2c);
+		kfree(psetassocsta_para);
+		return _FAIL;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetassocsta_para, _SETASSOCSTA_CMD_);
+	ph2c->rsp = (u8 *)psetassocsta_rsp;
+	ph2c->rspsz = sizeof(struct set_assocsta_rsp);
+
+	memcpy(psetassocsta_para->addr, mac_addr, ETH_ALEN);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+ }
+
+u8 rtw_addbareq_cmd(struct rtw_adapter *padapter, u8 tid, u8 *addr)
+{
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	struct cmd_obj *ph2c;
+	struct addBaReq_parm *paddbareq_parm;
+
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm = (struct addBaReq_parm *)kzalloc(sizeof(struct addBaReq_parm), GFP_ATOMIC);
+	if (paddbareq_parm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm->tid = tid;
+	memcpy(paddbareq_parm->addr, addr, ETH_ALEN);
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_ADDBAREQ));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_dynamic_chk_wk_cmd(struct rtw_adapter *padapter)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
+		goto exit;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type != PRIMARY_ADAPTER && padapter->pbuddy_adapter)
+		pcmdpriv = &(padapter->pbuddy_adapter->cmdpriv);
+#endif
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	if (pdrvextra_cmd_parm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = DYNAMIC_CHK_WK_CID;
+	pdrvextra_cmd_parm->type_size = 0;
+	pdrvextra_cmd_parm->pbuf = (u8 *)padapter;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+	return res;
+}
+
+u8 rtw_set_ch_cmd(struct rtw_adapter *padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue)
+{
+	struct cmd_obj *pcmdobj;
+	struct set_ch_parm *set_ch_parm;
+	struct cmd_priv *pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+	DBG_8192D(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
+		  FUNC_NDEV_ARG(padapter->pnetdev), ch, bw, ch_offset);
+
+	/* check input parameter */
+
+	/* prepare cmd parameter */
+	set_ch_parm = (struct set_ch_parm *)kzalloc(sizeof(*set_ch_parm), GFP_ATOMIC);
+	if (set_ch_parm == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	set_ch_parm->ch = ch;
+	set_ch_parm->bw = bw;
+	set_ch_parm->ch_offset = ch_offset;
+
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		if (pcmdobj == NULL) {
+			kfree(set_ch_parm);
+			res = _FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(pcmdobj, set_ch_parm, GEN_CMD_CODE(_SETCHANNEL));
+		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if (H2C_SUCCESS != set_ch_hdl(padapter, (u8 *)set_ch_parm))
+			res = _FAIL;
+
+		kfree(set_ch_parm);
+	}
+
+	/* do something based on res... */
+
+exit:
+
+	DBG_8192D(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(padapter->pnetdev), res);
+
+	return res;
+}
+
+u8 rtw_set_chplan_cmd(struct rtw_adapter *padapter, u8 chplan, u8 enqueue)
+{
+	struct cmd_obj *pcmdobj;
+	struct setchannelplan_param *setchannelplan_param;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_chplan_cmd\n"));
+
+	/* check input parameter */
+	if (!rtw_is_channel_plan_valid(chplan)) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	/* prepare cmd parameter */
+	setchannelplan_param = (struct setchannelplan_param *)kzalloc(sizeof(struct setchannelplan_param), GFP_ATOMIC);
+	if (setchannelplan_param == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	setchannelplan_param->channel_plan = chplan;
+
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct	cmd_obj), GFP_ATOMIC);
+		if (pcmdobj == NULL) {
+			kfree(setchannelplan_param);
+			res = _FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelplan_param, GEN_CMD_CODE(_SETCHANNELPLAN));
+		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if (H2C_SUCCESS != set_chplan_hdl(padapter, (unsigned char *)setchannelplan_param))
+			res = _FAIL;
+
+		kfree(setchannelplan_param);
+	}
+
+	/* do something based on res... */
+	if (res == _SUCCESS)
+		padapter->mlmepriv.ChannelPlan = chplan;
+
+exit:
+
+	return res;
+}
+
+u8 rtw_led_blink_cmd(struct rtw_adapter *padapter, struct LED_871X *pLed)
+{
+	struct cmd_obj *pcmdobj;
+	struct ledblink_param *ledBlink_param;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_led_blink_cmd\n"));
+
+	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct	cmd_obj), GFP_ATOMIC);
+	if (pcmdobj == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	ledBlink_param = (struct ledblink_param *)kzalloc(sizeof(struct	ledblink_param), GFP_ATOMIC);
+	if (ledBlink_param == NULL) {
+		kfree(pcmdobj);
+		res = _FAIL;
+		goto exit;
+	}
+
+	ledBlink_param->pLed = pLed;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmdobj, ledBlink_param, GEN_CMD_CODE(_LEDBLINK));
+	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_set_csa_cmd(struct rtw_adapter *padapter, u8 new_ch_no)
+{
+	struct cmd_obj *pcmdobj;
+	struct setchannelswitch_param *setchannelswitch_param;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+	RT_TRACE(_module_rtl871x_cmd_c_, _drv_notice_, ("+rtw_set_csa_cmd\n"));
+
+	pcmdobj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmdobj == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	setchannelswitch_param = (struct setchannelswitch_param *)kzalloc(sizeof(struct setchannelswitch_param), GFP_ATOMIC);
+	if (setchannelswitch_param == NULL) {
+		kfree(pcmdobj);
+		res = _FAIL;
+		goto exit;
+	}
+
+	setchannelswitch_param->new_ch_no = new_ch_no;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setchannelswitch_param, GEN_CMD_CODE(_SETCHANNELSWITCH));
+	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+
+exit:
+
+	return res;
+}
+
+u8 rtw_tdls_cmd(struct rtw_adapter *padapter, u8 *addr, u8 option)
+{
+	struct cmd_obj *pcmdobj;
+	struct TDLSoption_param	*TDLSoption;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct cmd_priv   *pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+	return res;
+}
+
+static void traffic_status_watchdog(struct rtw_adapter *padapter)
+{
+#ifdef CONFIG_LPS
+	u8 enterps;
+#endif
+	u8 bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
+	u8 bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+
+	/*  Determine if our traffic is busy now */
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100 ||
+		    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100) {
+			bBusyTraffic = true;
+
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 100)
+				bRxBusyTraffic = true;
+
+			if (pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 100)
+				bTxBusyTraffic = true;
+		}
+
+		/*  Higher Tx/Rx data. */
+		if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
+		    pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000) {
+			bHigherBusyTraffic = true;
+
+			/*  Extremely high Rx data. */
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 5000)
+				bHigherBusyRxTraffic = true;
+
+			/*  Extremely high Tx data. */
+			if (pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 5000)
+				bHigherBusyTxTraffic = true;
+		}
+
+#ifdef CONFIG_LPS
+		/*  check traffic for  powersaving. */
+		if (((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8) ||
+		    (pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))
+			enterps = false;
+		else
+			enterps = true;
+
+		/*  LeisurePS only work in infra mode. */
+		if (enterps)
+			rtw_lps_enter(padapter);
+		else
+			rtw_lps_leave(padapter);
+#endif
+	} else {
+#ifdef CONFIG_LPS
+		rtw_lps_leave(padapter);
+#endif
+	}
+
+	pmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = bBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bTxBusyTraffic = bTxBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bRxBusyTraffic = bRxBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;
+}
+
+static void dynamic_chk_wk_hdl(struct rtw_adapter *padapter, u8 *pbuf, int sz)
+{
+	struct mlme_priv *pmlmepriv;
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
+		return;
+
+	if ((void *)padapter != (void *)pbuf && padapter->pbuddy_adapter == NULL)
+		return;
+
+	padapter = (struct rtw_adapter *)pbuf;
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true))
+		return;
+
+	pmlmepriv = &(padapter->mlmepriv);
+
+#ifdef CONFIG_92D_AP_MODE
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		expire_timeout_chk(padapter);
+#endif
+
+	#ifdef DBG_CONFIG_ERROR_DETECT
+	rtw_hal_sreset_xmit_status_check(padapter);
+	#endif
+
+	linked_status_chk(padapter);
+	traffic_status_watchdog(padapter);
+
+	rtw_hal_dm_watchdog(padapter);
+}
+
+#ifdef CONFIG_LPS
+
+static void lps_ctrl_wk_hdl(struct rtw_adapter *padapter, u8 lps_ctrl_type)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 mstatus;
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		return;
+
+	switch (lps_ctrl_type) {
+	case LPS_CTRL_SCAN:
+		LeaveAllPowerSaveMode(padapter);
+		break;
+	case LPS_CTRL_JOINBSS:
+		rtw_lps_leave(padapter);
+		break;
+	case LPS_CTRL_CONNECT:
+		mstatus = 1;
+		/*  Reset LPS Setting */
+		padapter->pwrctrlpriv.LpsIdleCount = 0;
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		break;
+	case LPS_CTRL_DISCONNECT:
+		mstatus = 0;
+		rtw_lps_leave(padapter);
+		rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_JOINBSSRPT, (u8 *)(&mstatus));
+		break;
+	case LPS_CTRL_SPECIAL_PACKET:
+		pwrpriv->DelayLPSLastTimeStamp = rtw_get_current_time();
+		rtw_lps_leave(padapter);
+		break;
+
+	default:
+		break;
+	}
+
+}
+
+u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter *padapter, u8 lps_ctrl_type, u8 enqueue)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type != IFACE_PORT0)
+		return res;
+#endif
+
+	if (enqueue) {
+		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		if (ph2c == NULL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+		if (pdrvextra_cmd_parm == NULL) {
+			kfree(ph2c);
+			res = _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm->ec_id = LPS_CTRL_WK_CID;
+		pdrvextra_cmd_parm->type_size = lps_ctrl_type;
+		pdrvextra_cmd_parm->pbuf = NULL;
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	} else {
+		lps_ctrl_wk_hdl(padapter, lps_ctrl_type);
+	}
+
+exit:
+
+	return res;
+}
+
+#endif
+#ifdef CONFIG_ANTENNA_DIVERSITY
+
+void antenna_select_wk_hdl(struct rtw_adapter *padapter, u8 antenna)
+{
+	rtw_hal_set_hwreg(padapter, HW_VAR_ANTENNA_DIVERSITY_SELECT, (u8 *)(&antenna));
+}
+
+u8 rtw_antenna_select_cmd(struct rtw_adapter *padapter, u8 antenna, u8 enqueue)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 support_ant_div = false;
+	u8 res = _SUCCESS;
+
+	rtw_hal_get_def_var(padapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(support_ant_div));
+	if (false == support_ant_div)
+		return res;
+
+	if (true == enqueue) {
+		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		if (ph2c == NULL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+		if (pdrvextra_cmd_parm == NULL) {
+			kfree(ph2c);
+			res = _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm->ec_id = ANT_SELECT_WK_CID;
+		pdrvextra_cmd_parm->type_size = antenna;
+		pdrvextra_cmd_parm->pbuf = NULL;
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	} else {
+		antenna_select_wk_hdl(padapter, antenna);
+	}
+exit:
+
+	return res;
+}
+#endif
+
+static void power_saving_wk_hdl(struct rtw_adapter *padapter, u8 *pbuf, int sz)
+{
+	 rtw_ps_processor(padapter);
+}
+
+u8 rtw_ps_cmd(struct rtw_adapter *padapter)
+{
+	struct cmd_obj *ppscmd;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+
+	u8 res = _SUCCESS;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type != PRIMARY_ADAPTER)
+		goto exit;
+#endif
+
+	ppscmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ppscmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	if (pdrvextra_cmd_parm == NULL) {
+		kfree(ppscmd);
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;
+	pdrvextra_cmd_parm->pbuf = NULL;
+	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ppscmd);
+
+exit:
+
+	return res;
+}
+
+#ifdef CONFIG_92D_AP_MODE
+
+static void rtw_chk_hi_queue_hdl(struct rtw_adapter *padapter)
+{
+	int cnt = 0;
+	struct sta_info *psta_bmc;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	psta_bmc = rtw_get_bcmc_stainfo(padapter);
+	if (!psta_bmc)
+		return;
+
+	if (psta_bmc->sleepq_len == 0) {
+		while ((rtw_read32(padapter, 0x414)&0x00ffff00) != 0) {
+			rtw_msleep_os(100);
+			cnt++;
+			if (cnt > 10)
+				break;
+		}
+
+		if (cnt <= 10) {
+			pstapriv->tim_bitmap &= ~BIT(0);
+			pstapriv->sta_dz_bitmap &= ~BIT(0);
+			update_beacon(padapter, _TIM_IE_, NULL, false);
+		}
+	}
+}
+
+u8 rtw_chk_hi_queue_cmd(struct rtw_adapter *padapter)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	if (pdrvextra_cmd_parm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+	pdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;
+	pdrvextra_cmd_parm->type_size = 0;
+	pdrvextra_cmd_parm->pbuf = NULL;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+	return res;
+}
+#endif
+
+u8 rtw_c2h_wk_cmd(struct rtw_adapter *padapter, u8 *c2h_evt)
+{
+	struct cmd_obj *ph2c;
+	struct drvextra_cmd_parm *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &padapter->cmdpriv;
+	u8 res = _SUCCESS;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm *)kzalloc(sizeof(struct drvextra_cmd_parm), GFP_ATOMIC);
+	if (pdrvextra_cmd_parm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = C2H_WK_CID;
+	pdrvextra_cmd_parm->type_size = c2h_evt ? 16 : 0;
+	pdrvextra_cmd_parm->pbuf = c2h_evt;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_SET_DRV_EXTRA));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+s32 c2h_evt_hdl(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt, c2h_id_filter filter)
+{
+	s32 ret = _FAIL;
+	u8 buf[16];
+
+	if (!c2h_evt) {
+		/* No c2h event in cmd_obj, read c2h event before handling*/
+		if (c2h_evt_read(adapter, buf) == _SUCCESS) {
+			c2h_evt = (struct c2h_evt_hdr *)buf;
+
+			if (filter && filter(c2h_evt->id) == false)
+				goto exit;
+
+			ret = rtw_hal_c2h_handler(adapter, c2h_evt);
+		}
+	} else {
+		if (filter && filter(c2h_evt->id) == false)
+			goto exit;
+		ret = rtw_hal_c2h_handler(adapter, c2h_evt);
+	}
+exit:
+	return ret;
+}
+
+#ifdef CONFIG_C2H_WK
+static void c2h_wk_callback(_workitem *work)
+{
+	struct evt_priv *evtpriv = container_of(work, struct evt_priv, c2h_wk);
+	struct rtw_adapter *adapter = container_of(evtpriv, struct rtw_adapter, evtpriv);
+	struct c2h_evt_hdr *c2h_evt;
+	c2h_id_filter ccx_id_filter = rtw_hal_c2h_id_filter_ccx(adapter);
+
+	evtpriv->c2h_wk_alive = true;
+
+	while (!rtw_cbuf_empty(evtpriv->c2h_queue)) {
+		c2h_evt = (struct c2h_evt_hdr *)rtw_cbuf_pop(evtpriv->c2h_queue);
+		if (c2h_evt != NULL) {
+			/* This C2H event is read, clear it */
+			c2h_evt_clear(adapter);
+		} else if ((c2h_evt = (struct c2h_evt_hdr *)kmalloc(16, GFP_ATOMIC)) != NULL) {
+			/* This C2H event is not read, read & clear now */
+			if (c2h_evt_read(adapter, (u8 *)c2h_evt) != _SUCCESS)
+				continue;
+		}
+
+		/* Special pointer to trigger c2h_evt_clear only */
+		if ((void *)c2h_evt == (void *)evtpriv)
+			continue;
+
+		if (!c2h_evt_exist(c2h_evt)) {
+			kfree(c2h_evt);
+			continue;
+		}
+
+		if (ccx_id_filter(c2h_evt->id) == true) {
+			/* Handle CCX report here */
+			rtw_hal_c2h_handler(adapter, c2h_evt);
+			kfree(c2h_evt);
+		} else {
+			/* Enqueue into cmd_thread for others */
+			rtw_c2h_wk_cmd(adapter, (u8 *)c2h_evt);
+		}
+	}
+
+	evtpriv->c2h_wk_alive = false;
+}
+#endif
+
+u8 rtw_drvextra_cmd_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
+{
+	struct drvextra_cmd_parm *pdrvextra_cmd;
+
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	pdrvextra_cmd = (struct drvextra_cmd_parm *)pbuf;
+
+	switch (pdrvextra_cmd->ec_id) {
+	case DYNAMIC_CHK_WK_CID:
+		dynamic_chk_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		break;
+	case POWER_SAVING_CTRL_WK_CID:
+		power_saving_wk_hdl(padapter, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+		break;
+#ifdef CONFIG_LPS
+	case LPS_CTRL_WK_CID:
+		lps_ctrl_wk_hdl(padapter, (u8)pdrvextra_cmd->type_size);
+		break;
+#endif
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	case ANT_SELECT_WK_CID:
+		antenna_select_wk_hdl(padapter, pdrvextra_cmd->type_size);
+		break;
+#endif
+	case P2P_PROTO_WK_CID:
+		/*	Commented by Albert 2011/07/01 */
+		/*	I used the type_size as the type command */
+		p2p_protocol_wk_hdl(padapter, pdrvextra_cmd->type_size);
+		break;
+#ifdef CONFIG_92D_AP_MODE
+	case CHECK_HIQ_WK_CID:
+		rtw_chk_hi_queue_hdl(padapter);
+		break;
+#endif /* CONFIG_92D_AP_MODE */
+	case C2H_WK_CID:
+		c2h_evt_hdl(padapter, (struct c2h_evt_hdr *)pdrvextra_cmd->pbuf, NULL);
+		break;
+	default:
+		break;
+	}
+
+	if (pdrvextra_cmd->pbuf && pdrvextra_cmd->type_size > 0)
+		kfree(pdrvextra_cmd->pbuf);
+
+	return H2C_SUCCESS;
+}
+
+void rtw_survey_cmd_callback(struct rtw_adapter *padapter ,  struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res == H2C_DROPPED) {
+		/* TODO: cancel timer and do timeout handler directly... */
+		/* need to make timeout handlerOS independent */
+		_set_timer(&pmlmepriv->scan_to_timer, 1);
+	} else if (pcmd->res != H2C_SUCCESS) {
+		_set_timer(&pmlmepriv->scan_to_timer, 1);
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: MgntActrtw_set_802_11_bssid_LIST_SCAN Fail ************\n\n."));
+	}
+
+	/*  free cmd */
+	rtw_free_cmd_obj(pcmd);
+
+}
+
+void rtw_disassoc_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res != H2C_SUCCESS) {
+		spin_lock_bh(&pmlmepriv->lock);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		spin_unlock_bh(&pmlmepriv->lock);
+
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ***Error: disconnect_cmd_callback Fail ***\n."));
+		return;
+	}
+	/*  free cmd */
+	rtw_free_cmd_obj(pcmd);
+}
+
+void rtw_joinbss_cmd_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	if (pcmd->res == H2C_DROPPED) {
+		/* TODO: cancel timer and do timeout handler directly... */
+		/* need to make timeout handlerOS independent */
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	} else if (pcmd->res != H2C_SUCCESS) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("********Error:rtw_select_and_join_from_scanned_queue Wait Sema  Fail ************\n"));
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	}
+
+	rtw_free_cmd_obj(pcmd);
+
+}
+
+void rtw_createbss_cmd_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
+{
+	u8 timer_cancelled;
+	struct sta_info *psta = NULL;
+	struct wlan_network *pwlan = NULL;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_bssid_ex *pnetwork = (struct wlan_bssid_ex *)pcmd->parmbuf;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+	if ((pcmd->res != H2C_SUCCESS)) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n ********Error: rtw_createbss_cmd_callback  Fail ************\n\n."));
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	}
+	_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
+
+#ifdef CONFIG_FW_MLMLE
+       /* endian_convert */
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	pnetwork->Configuration.DSConfig = le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime = le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern = le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet = le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length = le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+	spin_lock_bh(&pmlmepriv->lock);
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		psta = rtw_get_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+		if (!psta) {
+			psta = rtw_alloc_stainfo(&padapter->stapriv, pnetwork->MacAddress);
+			if (psta == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nCan't alloc sta_info when createbss_cmd_callback\n"));
+				goto createbss_cmd_fail;
+			}
+		}
+		rtw_indicate_connect(padapter);
+	} else {
+		pwlan = _rtw_alloc_network(pmlmepriv);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+		if (pwlan == NULL) {
+			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
+			if (pwlan == NULL) {
+				RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\n Error:  can't get pwlan in rtw_joinbss_event_callback\n"));
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+				goto createbss_cmd_fail;
+			}
+			pwlan->last_scanned = rtw_get_current_time();
+		} else {
+			rtw_list_insert_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+		}
+
+		pnetwork->Length = get_wlan_bssid_ex_sz(pnetwork);
+		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+
+		/*  copy pdev_network information to	pmlmepriv->cur_network */
+		memcpy(&tgt_network->network, pnetwork, (get_wlan_bssid_ex_sz(pnetwork)));
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		/*  we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback) */
+	}
+
+createbss_cmd_fail:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_free_cmd_obj(pcmd);
+
+}
+
+void rtw_setstakey_cmdrsp_callback(struct rtw_adapter *padapter, struct cmd_obj *pcmd)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct set_stakey_rsp *psetstakey_rsp = (struct set_stakey_rsp *)(pcmd->rsp);
+	struct sta_info *psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
+
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: rtw_setstaKey_cmdrsp_callback => can't get sta_info\n\n"));
+		goto exit;
+	}
+exit:
+	rtw_free_cmd_obj(pcmd);
+
+}
+
+void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct set_assocsta_parm *passocsta_parm = (struct set_assocsta_parm *)(pcmd->parmbuf);
+	struct set_assocsta_rsp *passocsta_rsp = (struct set_assocsta_rsp *)(pcmd->rsp);
+	struct sta_info *psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
+
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_, ("\nERROR: setassocsta_cmdrsp_callbac => can't get sta_info\n\n"));
+		goto exit;
+	}
+
+	psta->aid = passocsta_rsp->cam_id;
+	psta->mac_id = passocsta_rsp->cam_id;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+	rtw_free_cmd_obj(pcmd);
+
+}
+
+static void rtw_getrttbl_cmd_cmdrsp_callback(struct rtw_adapter *padapter,  struct cmd_obj *pcmd)
+{
+
+	rtw_free_cmd_obj(pcmd);
+
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_debug.c b/drivers/net/wireless/rtl8192du/core/rtw_debug.c
new file mode 100644
index 0000000..f4c4519
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_debug.c
@@ -0,0 +1,1080 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_DEBUG_C_
+
+#include <rtw_debug.h>
+
+u32 GlobalDebugLevel = _drv_err_;
+
+u64 GlobalDebugComponents =
+	_module_rtl871x_xmit_c_ |
+	_module_xmit_osdep_c_ |
+	_module_rtl871x_recv_c_ |
+	_module_recv_osdep_c_ |
+	_module_rtl871x_mlme_c_ |
+	_module_mlme_osdep_c_ |
+	_module_rtl871x_sta_mgt_c_ |
+	_module_rtl871x_cmd_c_ |
+	_module_cmd_osdep_c_ |
+	_module_rtl871x_io_c_ |
+	_module_io_osdep_c_ |
+	_module_os_intfs_c_|
+	_module_rtl871x_security_c_|
+	_module_rtl871x_eeprom_c_|
+	_module_hal_init_c_|
+	_module_hci_hal_init_c_|
+	_module_rtl871x_ioctl_c_|
+	_module_rtl871x_ioctl_set_c_|
+	_module_rtl871x_ioctl_query_c_|
+	_module_rtl871x_pwrctrl_c_|
+	_module_hci_intfs_c_|
+	_module_hci_ops_c_|
+	_module_hci_ops_os_c_|
+	_module_rtl871x_ioctl_os_c|
+	_module_rtl8712_cmd_c_|
+	_module_hal_xmit_c_|
+	_module_rtl8712_recv_c_ |
+	_module_mp_ |
+	_module_efuse_;
+
+/* endif */
+
+#ifdef CONFIG_PROC_DEBUG
+
+int proc_get_drv_version(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "%s\n", DRIVERVERSION);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_log_level(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+		"log_level:%d\n",
+		GlobalDebugLevel
+		);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_log_level(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	s32 is_signal_dbg;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%d ", &is_signal_dbg);
+
+		if (is_signal_dbg >= 0 && is_signal_dbg < 10) {
+			GlobalDebugLevel = is_signal_dbg;
+			pr_info("%d\n", GlobalDebugLevel);
+		}
+	}
+	return count;
+}
+
+int proc_get_write_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	*eof = 1;
+	return 0;
+}
+
+int proc_set_write_reg(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 addr, val, len;
+
+	if (count < 3) {
+		DBG_8192D("argument size is less than 3\n");
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%x %x %x", &addr, &val, &len);
+
+		if (num !=  3) {
+			DBG_8192D("invalid write_reg parameter!\n");
+			return count;
+		}
+		switch (len) {
+		case 1:
+			rtw_write8(padapter, addr, (u8)val);
+			break;
+		case 2:
+			rtw_write16(padapter, addr, (u16)val);
+			break;
+		case 4:
+			rtw_write32(padapter, addr, val);
+			break;
+		default:
+			DBG_8192D("error write length=%d", len);
+			break;
+		}
+	}
+	return count;
+}
+
+static u32 proc_get_read_addr = 0xeeeeeeee;
+static u32 proc_get_read_len = 0x4;
+
+int proc_get_read_reg(char *page, char **start,
+		      off_t offset, int count,
+		      int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	int len = 0;
+
+	if (proc_get_read_addr == 0xeeeeeeee) {
+		*eof = 1;
+		return len;
+	}
+
+	switch (proc_get_read_len) {
+	case 1:
+		len += snprintf(page + len, count - len, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
+		break;
+	case 2:
+		len += snprintf(page + len, count - len, "rtw_read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
+		break;
+	case 4:
+		len += snprintf(page + len, count - len, "rtw_read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
+		break;
+	default:
+		len += snprintf(page + len, count - len, "error read length=%d\n", proc_get_read_len);
+		break;
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_set_read_reg(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	char tmp[16];
+	u32 addr, len;
+
+	if (count < 2) {
+		DBG_8192D("argument size is less than 2\n");
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%x %x", &addr, &len);
+
+		if (num !=  2) {
+			DBG_8192D("invalid read_reg parameter!\n");
+			return count;
+		}
+		proc_get_read_addr = addr;
+		proc_get_read_len = len;
+	}
+	return count;
+}
+
+int proc_get_fwstate(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "fwstate=0x%x\n", get_fwstate(pmlmepriv));
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_sec_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_mlmext_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_qos_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+	*eof = 1;
+	return len;
+}
+
+int proc_get_ht_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n"
+		"oper_ch =%d, oper_bw=%d, oper_ch_offet=%d\n",
+		pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset,
+		rtw_get_oper_ch(padapter), rtw_get_oper_bw(padapter), rtw_get_oper_choffset(padapter));
+	*eof = 1;
+
+	return len;
+}
+
+int proc_get_ap_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct sta_info *psta;
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int len = 0;
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+	if (psta) {
+		int i;
+		struct recv_reorder_ctrl *preorder_ctrl;
+
+		len += snprintf(page + len, count - len, "SSID=%s\n", cur_network->network.Ssid.Ssid);
+		len += snprintf(page + len, count - len, "sta's macaddr:%pM\n", psta->hwaddr);
+		len += snprintf(page + len, count - len, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+		len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+		len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+		len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+		len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+		len += snprintf(page + len, count - len, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+		len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+
+		for (i = 0; i < 16; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			if (preorder_ctrl->enable)
+				len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+		}
+
+	} else {
+		len += snprintf(page + len, count - len, "can't get sta's macaddr, cur_network's macaddr:%pM\n", cur_network->network.MacAddress);
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_adapter_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "bSurpriseRemoved=%d, bDriverStopped=%d\n",
+						padapter->bSurpriseRemoved, padapter->bDriverStopped);
+	*eof = 1;
+	return len;
+}
+
+int proc_get_trx_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv  *precvpriv = &padapter->recvpriv;
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d, free_ext_xmitbuf_cnt=%d, free_recvframe_cnt=%d\n",
+				pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmit_extbuf_cnt, precvpriv->free_recvframe_cnt);
+	len += snprintf(page + len, count - len, "rx_urb_pending_cnt=%d\n", precvpriv->rx_pending_cnt);
+
+	len += snprintf(page + len, count - len, "recvbuf_skb_alloc_fail_cnt=%d\n", precvpriv->recvbuf_skb_alloc_fail_cnt);
+	len += snprintf(page + len, count - len, "recvbuf_null_cnt=%d\n", precvpriv->recvbuf_null_cnt);
+	len += snprintf(page + len, count - len, "read_port_complete_EINPROGRESS_cnt=%d\n", precvpriv->read_port_complete_EINPROGRESS_cnt);
+	len += snprintf(page + len, count - len, "read_port_complete_other_urb_err_cnt=%d\n", precvpriv->read_port_complete_other_urb_err_cnt);
+	len += snprintf(page + len, count - len, "hw_init_completed=%d\n", padapter->hw_init_completed);
+	len += snprintf(page + len, count - len, "continual_urb_error=%d\n", atomic_read(&pdvobj->continual_urb_error));
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_mac_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
+
+	for (i = 0x0; i < 0x300; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_mac_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
+	memset(page, 0, count);
+	for (i = 0x300; i < 0x600; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_mac_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= MAC REG =======\n");
+
+	for (i = 0x600; i < 0x800; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_bb_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	for (i = 0x800; i < 0xB00; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_bb_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	for (i = 0xB00; i < 0xE00; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_bb_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1;
+
+	len += snprintf(page + len, count - len, "\n======= BB REG =======\n");
+	for (i = 0xE00; i < 0x1000; i += 4) {
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1, path;
+	u32 value;
+
+	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
+	path = 1;
+	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n", path);
+	for (i = 0; i < 0xC0; i++) {
+		value = rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x ", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", value);
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1, path;
+	u32 value;
+
+	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
+	path = 1;
+	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n", path);
+	for (i = 0xC0; i < 0x100; i++) {
+		value = rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x ", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", value);
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1, path;
+	u32 value;
+
+	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
+	path = 2;
+	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n", path);
+	for (i = 0; i < 0xC0; i++) {
+		value = rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x ", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", value);
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rf_reg_dump4(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	int len = 0;
+	int i, j = 1, path;
+	u32 value;
+
+	len += snprintf(page + len, count - len, "\n======= RF REG =======\n");
+	path = 2;
+	len += snprintf(page + len, count - len, "\nRF_Path(%x)\n", path);
+	for (i = 0xC0; i < 0x100; i++) {
+		value = rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
+		if (j%4 == 1)
+			len += snprintf(page + len, count - len, "0x%02x ", i);
+		len += snprintf(page + len, count - len, " 0x%08x ", value);
+		if ((j++)%4 == 0)
+			len += snprintf(page + len, count - len, "\n");
+	}
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rx_signal(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+		"rssi:%d\n"
+		"rxpwdb:%d\n"
+		"signal_strength:%u\n"
+		"signal_qual:%u\n"
+		"noise:%u\n",
+		padapter->recvpriv.rssi,
+		padapter->recvpriv.rxpwdb,
+		padapter->recvpriv.signal_strength,
+		padapter->recvpriv.signal_qual,
+		padapter->recvpriv.noise
+		);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_rx_signal(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 is_signal_dbg;
+	s32 signal_strength;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%u %u", &is_signal_dbg, &signal_strength);
+
+		is_signal_dbg = is_signal_dbg == 0 ? 0 : 1;
+
+		if (is_signal_dbg && num != 2)
+			return count;
+
+		signal_strength = signal_strength > 100 ? 100 : signal_strength;
+		signal_strength = signal_strength < 0 ? 0 : signal_strength;
+
+		padapter->recvpriv.is_signal_dbg = is_signal_dbg;
+		padapter->recvpriv.signal_strength_dbg = signal_strength;
+
+		if (is_signal_dbg)
+			DBG_8192D("set %s %u\n", "DBG_SIGNAL_STRENGTH", signal_strength);
+		else
+			DBG_8192D("set %s\n", "HW_SIGNAL_STRENGTH");
+	}
+	return count;
+}
+
+int proc_get_ht_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+
+	int len = 0;
+
+	if (pregpriv)
+		len += snprintf(page + len, count - len,
+			"%d\n",
+			pregpriv->ht_enable
+			);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_ht_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	s32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if (pregpriv && mode >= 0 && mode < 2) {
+			pregpriv->ht_enable = mode;
+			pr_info("ht_enable=%d\n", pregpriv->ht_enable);
+		}
+	}
+	return count;
+}
+
+int proc_get_cbw40_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+
+	int len = 0;
+
+	if (pregpriv)
+		len += snprintf(page + len, count - len,
+			"%d\n",
+			pregpriv->cbw40_enable
+			);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_cbw40_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	s32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if (pregpriv && mode >= 0 && mode < 2) {
+			pregpriv->cbw40_enable = mode;
+			pr_info("cbw40_enable=%d\n", mode);
+		}
+	}
+	return count;
+}
+
+int proc_get_ampdu_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+
+	int len = 0;
+
+	if (pregpriv)
+		len += snprintf(page + len, count - len,
+			"%d\n",
+			pregpriv->ampdu_enable
+			);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_ampdu_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	s32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if (pregpriv && mode >= 0 && mode < 3) {
+			pregpriv->ampdu_enable = mode;
+			pr_info("ampdu_enable=%d\n", mode);
+		}
+	}
+	return count;
+}
+
+int proc_get_two_path_rssi(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	int len = 0;
+
+	if (padapter)
+		len += snprintf(page + len, count - len,
+			"%d %d\n",
+			padapter->recvpriv.RxRssi[0],
+			padapter->recvpriv.RxRssi[1]
+			);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rx_stbc(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+
+	int len = 0;
+
+	if (pregpriv)
+		len += snprintf(page + len, count - len,
+			"%d\n",
+			pregpriv->rx_stbc
+			);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_set_rx_stbc(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	u32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if (pregpriv && (mode == 0 || mode == 1 || mode == 2 || mode == 3)) {
+			pregpriv->rx_stbc = mode;
+			pr_info("rx_stbc=%d\n", mode);
+		}
+	}
+	return count;
+}
+
+int proc_get_vid(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u16 VID = 0;
+	int len = 0;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_VID, (u8 *)&VID);
+	len += snprintf(page + len, count - len,
+		"%04x\n",
+		VID
+		);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_pid(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u16 PID = 0;
+	int len = 0;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_PID, (u8 *)&PID);
+	len += snprintf(page + len, count - len,
+		"%04x\n",
+		PID
+		);
+
+	*eof = 1;
+	return len;
+}
+
+int proc_get_rssi_disp(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	*eof = 1;
+	return 0;
+}
+
+int proc_set_rssi_disp(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 enable = 0;
+
+	if (count < 1) {
+		DBG_8192D("argument size is less than 1\n");
+		return -EFAULT;
+	}
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+		int num = sscanf(tmp, "%x", &enable);
+
+		if (num !=  1) {
+			DBG_8192D("invalid set_rssi_disp parameter!\n");
+			return count;
+		}
+
+		if (enable) {
+			DBG_8192D("Turn On Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = enable;
+		} else {
+			DBG_8192D("Turn Off Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = 0;
+		}
+	}
+	return count;
+}
+
+#ifdef CONFIG_92D_AP_MODE
+
+int proc_get_all_sta_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct sta_info *psta;
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int i, j;
+	struct list_head *plist, *phead;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int len = 0;
+
+	len += snprintf(page + len, count - len, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	for (i = 0; i < NUM_STA; i++) {
+		phead = &(pstapriv->sta_hash[i]);
+		plist = phead->next;
+
+		while ((rtw_end_of_queue_search(phead, plist)) == false) {
+			psta = container_of(plist, struct sta_info, hash_list);
+
+			plist = plist->next;
+
+			len += snprintf(page + len, count - len, "sta's macaddr:%pM\n", psta->hwaddr);
+			len += snprintf(page + len, count - len, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+			len += snprintf(page + len, count - len, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+			len += snprintf(page + len, count - len, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+			len += snprintf(page + len, count - len, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+			len += snprintf(page + len, count - len, "ampdu_enable=%d\n", psta->htpriv.ampdu_enable);
+			len += snprintf(page + len, count - len, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+			len += snprintf(page + len, count - len, "sleepq_len=%d\n", psta->sleepq_len);
+			len += snprintf(page + len, count - len, "capability=0x%x\n", psta->capability);
+			len += snprintf(page + len, count - len, "flags=0x%x\n", psta->flags);
+			len += snprintf(page + len, count - len, "wpa_psk=0x%x\n", psta->wpa_psk);
+			len += snprintf(page + len, count - len, "wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
+			len += snprintf(page + len, count - len, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
+			len += snprintf(page + len, count - len, "qos_info=0x%x\n", psta->qos_info);
+			len += snprintf(page + len, count - len, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
+
+			for (j = 0; j < 16; j++) {
+				preorder_ctrl = &psta->recvreorder_ctrl[j];
+				if (preorder_ctrl->enable)
+					len += snprintf(page + len, count - len, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+			}
+		}
+	}
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+	*eof = 1;
+	return len;
+}
+
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+int proc_get_best_channel(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	int len = 0;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i = 0; pmlmeext->channel_set[i].ChannelNum != 0; i++) {
+		if (pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if (pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}
+
+	for (i = 0; pmlmeext->channel_set[i].ChannelNum != 0; i++) {
+		/*  2.4G */
+		if (pmlmeext->channel_set[i].ChannelNum == 6) {
+			if (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		/*  5G */
+		if (pmlmeext->channel_set[i].ChannelNum >= 36 &&
+		    pmlmeext->channel_set[i].ChannelNum < 140) {
+			 /*  Find primary channel */
+			if (((pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0) &&
+			    (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count)) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if (pmlmeext->channel_set[i].ChannelNum >= 149 &&
+		    pmlmeext->channel_set[i].ChannelNum < 165) {
+			 /*  find primary channel */
+			if (((pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0) &&
+			    (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count)) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+		len += snprintf(page + len, count - len, "The rx cnt of channel %3d=%d\n",
+					pmlmeext->channel_set[i].ChannelNum, pmlmeext->channel_set[i].rx_count);
+	}
+
+	len += snprintf(page + len, count - len, "best_channel_5G=%d\n", best_channel_5G);
+	len += snprintf(page + len, count - len, "best_channel_24G=%d\n", best_channel_24G);
+
+	*eof = 1;
+	return len;
+}
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_efuse.c b/drivers/net/wireless/rtl8192du/core/rtw_efuse.c
new file mode 100644
index 0000000..e617fdf
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_efuse.c
@@ -0,0 +1,763 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_EFUSE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_efuse.h>
+
+/*------------------------Define local variable------------------------------*/
+u8 fakeEfuseBank;
+u32 fakeEfuseUsedBytes;
+u8 fakeEfuseContent[EFUSE_MAX_HW_SIZE] = {0};
+u8 fakeEfuseInitMap[EFUSE_MAX_MAP_LEN] = {0};
+u8 fakeEfuseModifiedMap[EFUSE_MAX_MAP_LEN] = {0};
+
+u32 BTEfuseUsedBytes;
+u8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+u8 BTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN] = {0};
+u8 BTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN] = {0};
+
+u32 fakeBTEfuseUsedBytes;
+u8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+u8 fakeBTEfuseInitMap[EFUSE_BT_MAX_MAP_LEN] = {0};
+u8 fakeBTEfuseModifiedMap[EFUSE_BT_MAX_MAP_LEN] = {0};
+/*------------------------Define local variable------------------------------*/
+
+/*  */
+#define REG_EFUSE_CTRL		0x0030
+#define EFUSE_CTRL			REG_EFUSE_CTRL		/*  E-Fuse Control. */
+/*  */
+
+static bool Efuse_Read1ByteFromFakeContent(struct rtw_adapter *adapter, u16 Offset, u8 *value)
+{
+	if (Offset >= EFUSE_MAX_HW_SIZE)
+		return false;
+	if (fakeEfuseBank == 0)
+		*value = fakeEfuseContent[Offset];
+	else
+		*value = fakeBTEfuseContent[fakeEfuseBank-1][Offset];
+	return true;
+}
+
+static bool Efuse_Write1ByteToFakeContent(struct rtw_adapter *adapter, u16 Offset, u8 value)
+{
+	if (Offset >= EFUSE_MAX_HW_SIZE)
+		return false;
+	if (fakeEfuseBank == 0)
+		fakeEfuseContent[Offset] = value;
+	else
+		fakeBTEfuseContent[fakeEfuseBank-1][Offset] = value;
+	return true;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	Efuse_PowerSwitch
+ *
+ * Overview:	When we want to enable write operation, we should change to
+ *				pwr on state. When we stop write, we should switch to 500k mode
+ *				and disable LDO 2.5V.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/17/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+void Efuse_PowerSwitch(struct rtw_adapter *adapter, u8 write, u8 pwrstate)
+{
+	adapter->HalFunc.EfusePowerSwitch(adapter, write, pwrstate);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	efuse_GetCurrentSize
+ *
+ * Overview:	Get current efuse size!!!
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/16/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+u16 Efuse_GetCurrentSize(struct rtw_adapter *adapter, u8 efusetype, bool test)
+{
+	u16 ret = 0;
+
+	ret = adapter->HalFunc.EfuseGetCurrentSize(adapter, efusetype, test);
+
+	return ret;
+}
+
+/*  11/16/2008 MH Add description. Get current efuse area enabled word!!. */
+u8
+Efuse_CalculateWordCnts(u8 word_en)
+{
+	u8 word_cnts = 0;
+	if (!(word_en & BIT(0)))
+		word_cnts++; /*  0 : write enable */
+	if (!(word_en & BIT(1)))
+		word_cnts++;
+	if (!(word_en & BIT(2)))
+		word_cnts++;
+	if (!(word_en & BIT(3)))
+		word_cnts++;
+	return word_cnts;
+}
+
+/*  */
+/*	Description: */
+/*		Execute E-Fuse read byte operation. */
+/*		Refered from SD1 Richard. */
+/*  */
+/*	Assumption: */
+/*		1. Boot from E-Fuse and successfully auto-load. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*  */
+/*	Created by Roger, 2008.10.21. */
+/*  */
+void ReadEFuseByte(struct rtw_adapter *adapter, u16 _offset, u8 *pbuf, bool test)
+{
+	u32 value32;
+	u8 readbyte;
+	u16 retry;
+
+	if (test) {
+		Efuse_Read1ByteFromFakeContent(adapter, _offset, pbuf);
+		return;
+	}
+
+	/* Write Address */
+	rtw_write8(adapter, EFUSE_CTRL+1, (_offset & 0xff));
+	readbyte = rtw_read8(adapter, EFUSE_CTRL+2);
+	rtw_write8(adapter, EFUSE_CTRL+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
+
+	/* Write bit 32 0 */
+	readbyte = rtw_read8(adapter, EFUSE_CTRL+3);
+	rtw_write8(adapter, EFUSE_CTRL+3, (readbyte & 0x7f));
+
+	/* Check bit 32 read-ready */
+	retry = 0;
+	value32 = rtw_read32(adapter, EFUSE_CTRL);
+	while (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {
+		value32 = rtw_read32(adapter, EFUSE_CTRL);
+		retry++;
+	}
+
+	/*  20100205 Joseph: Add delay suggested by SD1 Victor. */
+	/*  This fix the problem that Efuse read error in high temperature condition. */
+	/*  Designer says that there shall be some delay after ready bit is set, or the */
+	/*  result will always stay on last data we read. */
+	rtw_udelay_os(50);
+	value32 = rtw_read32(adapter, EFUSE_CTRL);
+
+	*pbuf = (u8)(value32 & 0xff);
+}
+
+/*	Description: */
+/*		1. Execute E-Fuse read byte operation according as map offset and */
+/*		    save to E-Fuse table. */
+/*		2. Refered from SD1 Richard. */
+/*	Assumption: */
+/*		1. Boot from E-Fuse and successfully auto-load. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*	Created by Roger, 2008.10.21. */
+/*	2008/12/12 MH	1. Reorganize code flow and reserve bytes. and add description. */
+/*					2. Add efuse utilization collect. */
+/*	2008/12/22 MH	Read Efuse must check if we write section 1 data again!!! Sec1 */
+/*					write addr must be after sec5. */
+
+static void efuse_ReadEFuse(struct rtw_adapter *adapter, u8 efusetype, u16 _offset, u16 _size_byte, u8 *pbuf, bool test)
+{
+	adapter->HalFunc.ReadEFuse(adapter, efusetype, _offset, _size_byte, pbuf, test);
+}
+
+void EFUSE_GetEfuseDefinition(struct rtw_adapter *adapter, u8 efusetype, u8 type, void *out, bool test)
+{
+	adapter->HalFunc.EFUSEGetEfuseDefinition(adapter, efusetype, type, out, test);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	EFUSE_Read1Byte
+ *
+ * Overview:	Copy from WMAC fot EFUSE read 1 byte.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 09/23/2008	MHC		Copy from WMAC.
+ *
+ *---------------------------------------------------------------------------*/
+u8 EFUSE_Read1Byte(struct rtw_adapter *adapter, u16 address)
+{
+	u8 data;
+	u8 bytetemp = {0x00};
+	u8 temp = {0x00};
+	u32 k = 0;
+	u16 contentlen = 0;
+
+	EFUSE_GetEfuseDefinition(adapter, EFUSE_WIFI , TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&contentlen, false);
+
+	if (address < contentlen) {	/* E-fuse 512Byte */
+		/* Write E-fuse Register address bit0~7 */
+		temp = address & 0xFF;
+		rtw_write8(adapter, EFUSE_CTRL+1, temp);
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+2);
+		/* Write E-fuse Register address bit8~9 */
+		temp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);
+		rtw_write8(adapter, EFUSE_CTRL+2, temp);
+
+		/* Write 0x30[31]= 0 */
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
+		temp = bytetemp & 0x7F;
+		rtw_write8(adapter, EFUSE_CTRL+3, temp);
+
+		/* Wait Write-ready (0x30[31]= 1) */
+		bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
+		while (!(bytetemp & 0x80)) {
+			bytetemp = rtw_read8(adapter, EFUSE_CTRL+3);
+			k++;
+			if (k == 1000) {
+				k = 0;
+				break;
+			}
+		}
+		data = rtw_read8(adapter, EFUSE_CTRL);
+		return data;
+	} else {
+		return 0xFF;
+	}
+} /* EFUSE_Read1Byte */
+
+/*  11/16/2008 MH Read one byte from real Efuse. */
+u8 efuse_OneByteRead(struct rtw_adapter *adapter, u16 addr, u8 *data, bool test)
+{
+	u8 tmpidx = 0;
+	u8 result;
+
+	if (test) {
+		result = Efuse_Read1ByteFromFakeContent(adapter, addr, data);
+		return result;
+	}
+	/*  -----------------e-fuse reg ctrl -------------------------------- */
+	/* address */
+	rtw_write8(adapter, EFUSE_CTRL+1, (u8)(addr&0xff));
+	rtw_write8(adapter, EFUSE_CTRL+2, ((u8)((addr >> 8) & 0x03)) |
+	(rtw_read8(adapter, EFUSE_CTRL+2)&0xFC));
+
+	rtw_write8(adapter, EFUSE_CTRL+3,  0x72);/* read cmd */
+
+	while (!(0x80 & rtw_read8(adapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+	if (tmpidx < 100) {
+		*data = rtw_read8(adapter, EFUSE_CTRL);
+		result = true;
+	} else {
+		*data = 0xff;
+		result = false;
+	}
+	return result;
+}
+
+/*  11/16/2008 MH Write one byte to reald Efuse. */
+u8 efuse_OneByteWrite(struct rtw_adapter *adapter, u16 addr, u8 data, bool test)
+{
+	u8 tmpidx = 0;
+	u8 result;
+
+	if (test) {
+		result = Efuse_Write1ByteToFakeContent(adapter, addr, data);
+		return result;
+	}
+
+	/*  -----------------e-fuse reg ctrl ---------------------------- */
+	/* address */
+	rtw_write8(adapter, EFUSE_CTRL+1, (u8)(addr&0xff));
+	rtw_write8(adapter, EFUSE_CTRL+2,
+		   (rtw_read8(adapter, EFUSE_CTRL+2)&0xFC) | (u8)((addr>>8)&0x03));
+	rtw_write8(adapter, EFUSE_CTRL, data);/* data */
+
+	rtw_write8(adapter, EFUSE_CTRL+3, 0xF2);/* write cmd */
+
+	while ((0x80 & rtw_read8(adapter, EFUSE_CTRL+3)) && (tmpidx < 100))
+		tmpidx++;
+
+	if (tmpidx < 100)
+		result = true;
+	else
+		result = false;
+	return result;
+}
+
+int Efuse_PgPacketRead(struct rtw_adapter *adapter, u8 offset, u8 *data, bool test)
+{
+	int	ret = 0;
+
+	ret =  adapter->HalFunc.Efuse_PgPacketRead(adapter, offset, data, test);
+	return ret;
+}
+
+int Efuse_PgPacketWrite(struct rtw_adapter *adapter, u8 offset, u8 word_en,
+			u8 *data, bool test)
+{
+	int ret;
+
+	ret =  adapter->HalFunc.Efuse_PgPacketWrite(adapter, offset, word_en, data, test);
+
+	return ret;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	efuse_WordEnableDataRead
+ *
+ * Overview:	Read allowed word in current efuse section data.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/16/2008	MHC		Create Version 0.
+ * 11/21/2008	MHC		Fix Write bug when we only enable late word.
+ *
+ *---------------------------------------------------------------------------*/
+void efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata)
+{
+	if (!(word_en&BIT(0))) {
+		targetdata[0] = sourdata[0];
+		targetdata[1] = sourdata[1];
+	}
+	if (!(word_en&BIT(1))) {
+		targetdata[2] = sourdata[2];
+		targetdata[3] = sourdata[3];
+	}
+	if (!(word_en&BIT(2))) {
+		targetdata[4] = sourdata[4];
+		targetdata[5] = sourdata[5];
+	}
+	if (!(word_en&BIT(3))) {
+		targetdata[6] = sourdata[6];
+		targetdata[7] = sourdata[7];
+	}
+}
+
+u8 Efuse_WordEnableDataWrite(struct rtw_adapter *adapter, u16 efuse_addr,
+			     u8 word_en, u8 *data, bool test)
+{
+	u8 ret = 0;
+
+	ret =  adapter->HalFunc.Efuse_WordEnableDataWrite(adapter, efuse_addr, word_en, data, test);
+
+	return ret;
+}
+
+static u8 efuse_read8(struct rtw_adapter *padapter, u16 address, u8 *value)
+{
+	return efuse_OneByteRead(padapter, address, value, false);
+}
+
+static u8 efuse_write8(struct rtw_adapter *padapter, u16 address, u8 *value)
+{
+	return efuse_OneByteWrite(padapter, address, *value, false);
+}
+
+/*
+ * read/wirte raw efuse data
+ */
+u8 rtw_efuse_access(struct rtw_adapter *padapter, u8 write, u16 start_addr, u16 cnts, u8 *data)
+{
+	int i = 0;
+	u16 real_content_len = 0, max_available_size = 0;
+	u8 res = _FAIL;
+	u8 (*rw8)(struct rtw_adapter *, u16, u8*);
+
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_REAL_CONTENT_LEN, (void *)&real_content_len, false);
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+
+	if (start_addr > real_content_len)
+		return _FAIL;
+
+	if (true == write) {
+		if ((start_addr + cnts) > max_available_size)
+			return _FAIL;
+		rw8 = &efuse_write8;
+	} else {
+		rw8 = &efuse_read8;
+	}
+
+	Efuse_PowerSwitch(padapter, write, true);
+
+	/*  e-fuse one byte read / write */
+	for (i = 0; i < cnts; i++) {
+		if (start_addr >= real_content_len) {
+			res = _FAIL;
+			break;
+		}
+
+		res = rw8(padapter, start_addr++, data++);
+		if (_FAIL == res)
+			break;
+	}
+
+	Efuse_PowerSwitch(padapter, write, false);
+
+	return res;
+}
+/*  */
+u16 efuse_GetMaxSize(struct rtw_adapter *padapter)
+{
+	u16 max_size;
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI , TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_size, false);
+	return max_size;
+}
+/*  */
+u8 efuse_GetCurrentSize(struct rtw_adapter *padapter, u16 *size)
+{
+	Efuse_PowerSwitch(padapter, false, true);
+	*size = Efuse_GetCurrentSize(padapter, EFUSE_WIFI, false);
+	Efuse_PowerSwitch(padapter, false, false);
+
+	return _SUCCESS;
+}
+
+u8 rtw_efuse_map_read(struct rtw_adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u16 maplen = 0;
+
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&maplen, false);
+
+	if ((addr + cnts) > maplen)
+		return _FAIL;
+
+	Efuse_PowerSwitch(padapter, false, true);
+
+	efuse_ReadEFuse(padapter, EFUSE_WIFI, addr, cnts, data, false);
+
+	Efuse_PowerSwitch(padapter, false, false);
+
+	return _SUCCESS;
+}
+
+u8 rtw_efuse_map_write(struct rtw_adapter *padapter, u16 addr, u16 cnts, u8 *data)
+{
+	u8 offset, word_en;
+	u8 *map;
+	u8 newdata[PGPKT_DATA_SIZE + 1];
+	s32	i, idx;
+	u8 ret = _SUCCESS;
+	u16 maplen = 0;
+
+	EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_EFUSE_MAP_LEN, (void *)&maplen, false);
+
+	if ((addr + cnts) > maplen)
+		return _FAIL;
+
+	map = kzalloc(maplen, GFP_KERNEL);
+	if (map == NULL)
+		return _FAIL;
+
+	ret = rtw_efuse_map_read(padapter, 0, maplen, map);
+	if (ret == _FAIL)
+		goto exit;
+
+	Efuse_PowerSwitch(padapter, true, true);
+
+	offset = (addr >> 3);
+	word_en = 0xF;
+	memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	i = addr & 0x7;	/*  index of one package */
+	idx = 0;	/*  data index */
+
+	if (i & 0x1) {
+		/*  odd start */
+		if (data[idx] != map[addr+idx]) {
+			word_en &= ~BIT(i >> 1);
+			newdata[i-1] = map[addr+idx-1];
+			newdata[i] = data[idx];
+		}
+		i++;
+		idx++;
+	}
+	do {
+		for (; i < PGPKT_DATA_SIZE; i += 2) {
+			if (cnts == idx)
+				 break;
+			if ((cnts - idx) == 1) {
+				if (data[idx] != map[addr+idx]) {
+					word_en &= ~BIT(i >> 1);
+					newdata[i] = data[idx];
+					newdata[i+1] = map[addr+idx+1];
+				}
+				idx++;
+				break;
+			} else {
+				if ((data[idx] != map[addr+idx]) ||
+				    (data[idx+1] != map[addr+idx+1])) {
+					word_en &= ~BIT(i >> 1);
+					newdata[i] = data[idx];
+					newdata[i+1] = data[idx + 1];
+				}
+				idx += 2;
+			}
+			if (idx == cnts)
+				break;
+		}
+
+		if (word_en != 0xF) {
+			ret = Efuse_PgPacketWrite(padapter, offset, word_en, newdata, false);
+			DBG_8192D("offset =%x\n", offset);
+			DBG_8192D("word_en =%x\n", word_en);
+
+			for (i = 0; i < PGPKT_DATA_SIZE; i++)
+				DBG_8192D("data =%x \t", newdata[i]);
+			if (ret == _FAIL)
+				break;
+		}
+
+		if (idx == cnts)
+			break;
+
+		offset++;
+		i = 0;
+		word_en = 0xF;
+		memset(newdata, 0xFF, PGPKT_DATA_SIZE);
+	} while (1);
+
+	Efuse_PowerSwitch(padapter, true, false);
+
+exit:
+
+	kfree(map);
+
+	return ret;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	Efuse_ReadAllMap
+ *
+ * Overview:	Read All Efuse content
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/11/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+static void Efuse_ReadAllMap(struct rtw_adapter *adapter, u8 efusetype, u8 *efuse, bool test)
+{
+	u16 maplen = 0;
+
+	Efuse_PowerSwitch(adapter, false, true);
+	EFUSE_GetEfuseDefinition(adapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
+	efuse_ReadEFuse(adapter, efusetype, 0, maplen, efuse, test);
+	Efuse_PowerSwitch(adapter, false, false);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	efuse_ShadowRead1Byte
+ *			efuse_ShadowRead2Byte
+ *			efuse_ShadowRead4Byte
+ *
+ * Overview:	Read from efuse init map by one/two/four bytes !!!!!
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/12/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+static void efuse_ShadowRead1Byte(struct rtw_adapter *adapter, u16 Offset, u8 *value)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	*value = pEEPROM->efuse_eeprom_data[Offset];
+}	/*  EFUSE_ShadowRead1Byte */
+
+/* Read Two Bytes */
+static void efuse_ShadowRead2Byte(struct rtw_adapter *adapter, u16 Offset, u16 *value)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	*value = pEEPROM->efuse_eeprom_data[Offset];
+	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
+}	/*  EFUSE_ShadowRead2Byte */
+
+/* Read Four Bytes */
+static void efuse_ShadowRead4Byte(struct rtw_adapter *adapter, u16 Offset, u32 *value)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	*value = pEEPROM->efuse_eeprom_data[Offset];
+	*value |= pEEPROM->efuse_eeprom_data[Offset+1]<<8;
+	*value |= pEEPROM->efuse_eeprom_data[Offset+2]<<16;
+	*value |= pEEPROM->efuse_eeprom_data[Offset+3]<<24;
+}	/*  efuse_ShadowRead4Byte */
+
+/*-----------------------------------------------------------------------------
+ * Function:	efuse_ShadowWrite1Byte
+ *			efuse_ShadowWrite2Byte
+ *			efuse_ShadowWrite4Byte
+ *
+ * Overview:	Write efuse modify map by one/two/four byte.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/12/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+static void efuse_ShadowWrite1Byte(struct rtw_adapter *adapter, u16 Offset, u8 value)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	pEEPROM->efuse_eeprom_data[Offset] = value;
+}	/*  efuse_ShadowWrite1Byte */
+
+/* Write Two Bytes */
+static void efuse_ShadowWrite2Byte(struct rtw_adapter *adapter, u16 Offset, u16 value)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	pEEPROM->efuse_eeprom_data[Offset] = value&0x00FF;
+	pEEPROM->efuse_eeprom_data[Offset+1] = value>>8;
+}	/*  efuse_ShadowWrite1Byte */
+
+/* Write Four Bytes */
+static void efuse_ShadowWrite4Byte(struct rtw_adapter *adapter, u16 Offset, u32 value)
+{
+	struct eeprom_priv *EEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	EEPROM->efuse_eeprom_data[Offset] = (u8)(value&0x000000FF);
+	EEPROM->efuse_eeprom_data[Offset+1] = (u8)((value>>8)&0x0000FF);
+	EEPROM->efuse_eeprom_data[Offset+2] = (u8)((value>>16)&0x00FF);
+	EEPROM->efuse_eeprom_data[Offset+3] = (u8)((value>>24)&0xFF);
+}	/*  efuse_ShadowWrite1Byte */
+
+/*-----------------------------------------------------------------------------
+ * Function:	EFUSE_ShadowMapUpdate
+ *
+ * Overview:	Transfer current EFUSE content to shadow init and modify map.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/13/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+void EFUSE_ShadowMapUpdate(struct rtw_adapter *adapter, u8 efusetype, bool test)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+	u16 maplen = 0;
+
+	EFUSE_GetEfuseDefinition(adapter, efusetype, TYPE_EFUSE_MAP_LEN, (void *)&maplen, test);
+
+	if (pEEPROM->bautoload_fail_flag == true) {
+		memset(pEEPROM->efuse_eeprom_data, 0xFF, maplen);
+	} else {
+		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+		if (_SUCCESS != retriveAdaptorInfoFile(adapter->registrypriv.adaptor_info_caching_file_path, pEEPROM)) {
+		#endif
+
+			Efuse_ReadAllMap(adapter, efusetype, pEEPROM->efuse_eeprom_data, test);
+
+		#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+			storeAdaptorInfoFile(adapter->registrypriv.adaptor_info_caching_file_path, pEEPROM);
+		}
+		#endif
+	}
+} /*  EFUSE_ShadowMapUpdate */
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+
+int storeAdaptorInfoFile(char *path, struct eeprom_priv *eeprom_priv)
+{
+	int ret = _SUCCESS;
+
+	if (path && eeprom_priv) {
+		ret = rtw_store_to_file(path, eeprom_priv->efuse_eeprom_data,
+					EEPROM_MAX_SIZE);
+		if (ret == EEPROM_MAX_SIZE)
+			ret = _SUCCESS;
+		else
+			ret = _FAIL;
+	} else {
+		DBG_8192D("%s NULL pointer\n", __func__);
+		ret =  _FAIL;
+	}
+	return ret;
+}
+
+int retriveAdaptorInfoFile(char *path, struct eeprom_priv *eeprom_priv)
+{
+	int ret = _SUCCESS;
+	mm_segment_t oldfs;
+	struct file *fp;
+
+	if (path && eeprom_priv) {
+		ret = rtw_retrive_from_file(path,
+					    eeprom_priv->efuse_eeprom_data,
+					    EEPROM_MAX_SIZE);
+
+		if (ret == EEPROM_MAX_SIZE)
+			ret = _SUCCESS;
+		else
+			ret = _FAIL;
+	} else {
+		DBG_8192D("%s NULL pointer\n", __func__);
+		ret = _FAIL;
+	}
+	return ret;
+}
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_ieee80211.c b/drivers/net/wireless/rtl8192du/core/rtw_ieee80211.c
new file mode 100644
index 0000000..1c40aad
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_ieee80211.c
@@ -0,0 +1,1310 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _IEEE80211_C
+
+#include <drv_types.h>
+#include <ieee80211.h>
+#include <wifi.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+#include <usb_osintf.h>
+
+u8 RTW_WPA_OUI_TYPE[] = { 0x00, 0x50, 0xf2, 1 };
+u16 RTW_WPA_VERSION = 1;
+u8 WPA_AUTH_KEY_MGMT_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x50, 0xf2, 1 };
+u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x50, 0xf2, 2 };
+u8 WPA_CIPHER_SUITE_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+u8 WPA_CIPHER_SUITE_WEP40[] = { 0x00, 0x50, 0xf2, 1 };
+u8 WPA_CIPHER_SUITE_TKIP[] = { 0x00, 0x50, 0xf2, 2 };
+u8 WPA_CIPHER_SUITE_WRAP[] = { 0x00, 0x50, 0xf2, 3 };
+u8 WPA_CIPHER_SUITE_CCMP[] = { 0x00, 0x50, 0xf2, 4 };
+u8 WPA_CIPHER_SUITE_WEP104[] = { 0x00, 0x50, 0xf2, 5 };
+
+u16 RSN_VERSION_BSD = 1;
+u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x0f, 0xac, 1 };
+u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x0f, 0xac, 2 };
+u8 RSN_CIPHER_SUITE_NONE[] = { 0x00, 0x0f, 0xac, 0 };
+u8 RSN_CIPHER_SUITE_WEP40[] = { 0x00, 0x0f, 0xac, 1 };
+u8 RSN_CIPHER_SUITE_TKIP[] = { 0x00, 0x0f, 0xac, 2 };
+u8 RSN_CIPHER_SUITE_WRAP[] = { 0x00, 0x0f, 0xac, 3 };
+u8 RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
+u8 RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };
+/*  */
+/*  for adhoc-master to generate ie and provide supported-rate to fw */
+/*  */
+
+static u8	WIFI_CCKRATES[] = {
+	(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+	(IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)
+};
+
+static u8	WIFI_OFDMRATES[] = {
+	(IEEE80211_OFDM_RATE_6MB),
+	(IEEE80211_OFDM_RATE_9MB),
+	(IEEE80211_OFDM_RATE_12MB),
+	(IEEE80211_OFDM_RATE_18MB),
+	(IEEE80211_OFDM_RATE_24MB),
+	IEEE80211_OFDM_RATE_36MB,
+	IEEE80211_OFDM_RATE_48MB,
+	IEEE80211_OFDM_RATE_54MB
+};
+
+int rtw_get_bit_value_from_ieee_value(u8 val)
+{
+	unsigned char dot11_rate_table[] = {
+		2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108, 0
+	}; /*  last element must be zero!! */
+
+	int i = 0;
+	while (dot11_rate_table[i] != 0) {
+		if (dot11_rate_table[i] == val)
+			return BIT(i);
+		i++;
+	}
+	return 0;
+}
+
+uint	rtw_is_cckrates_included(u8 *rate)
+{
+	u32	i = 0;
+
+	while (rate[i] != 0) {
+		if  ((((rate[i]) & 0x7f) == 2) || (((rate[i]) & 0x7f) == 4) ||
+		     (((rate[i]) & 0x7f) == 11) || (((rate[i]) & 0x7f) == 22))
+			return true;
+		i++;
+	}
+
+	return false;
+}
+
+uint	rtw_is_cckratesonly_included(u8 *rate)
+{
+	u32 i = 0;
+
+	while (rate[i] != 0) {
+		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
+			return false;
+		i++;
+	}
+	return true;
+}
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel)
+{
+	if (channel > 14) {
+		if ((rtw_is_cckrates_included(rate)) == true)
+			return WIRELESS_INVALID;
+		else
+			return WIRELESS_11A;
+	} else {  /*  could be pure B, pure G, or B/G */
+		if ((rtw_is_cckratesonly_included(rate)) == true)
+			return WIRELESS_11B;
+		else if ((rtw_is_cckrates_included(rate)) == true)
+			return	WIRELESS_11BG;
+		else
+			return WIRELESS_11G;
+	}
+}
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source,
+				unsigned int *frlen)
+{
+	memcpy((void *)pbuf, (void *)source, len);
+	*frlen = *frlen + len;
+	return pbuf + len;
+}
+
+/*  rtw_set_ie will update frame length */
+u8 *rtw_set_ie(u8 *pbuf, int index, uint len, u8 *source, uint *frlen)
+{
+
+	*pbuf = (u8)index;
+
+	*(pbuf + 1) = (u8)len;
+
+	if (len > 0)
+		memcpy((void *)(pbuf + 2), (void *)source, len);
+
+	*frlen = *frlen + (len + 2);
+
+	return pbuf + len + 2;
+}
+
+inline u8 *rtw_set_ie_ch_switch (u8 *buf, u32 *buf_len, u8 ch_switch_mode,
+				u8 new_ch, u8 ch_switch_cnt)
+{
+	u8 ie_data[3];
+
+	ie_data[0] = ch_switch_mode;
+	ie_data[1] = new_ch;
+	ie_data[2] = ch_switch_cnt;
+	return rtw_set_ie(buf, WLAN_EID_CHANNEL_SWITCH,  3, ie_data, buf_len);
+}
+
+inline u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset)
+{
+	if (ch_offset == SCN)
+		return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	else if (ch_offset == SCA)
+		return HAL_PRIME_CHNL_OFFSET_UPPER;
+	else if (ch_offset == SCB)
+		return HAL_PRIME_CHNL_OFFSET_LOWER;
+
+	return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+}
+
+inline u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset)
+{
+	if (ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+		return SCN;
+	else if (ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+		return SCB;
+	else if (ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+		return SCA;
+
+	return SCN;
+}
+
+inline u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset)
+{
+	return rtw_set_ie(buf, WLAN_EID_SECONDARY_CHANNEL_OFFSET,  1, &secondary_ch_offset, buf_len);
+}
+
+inline u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl,
+	u8 flags, u16 reason, u16 precedence)
+{
+	u8 ie_data[6];
+
+	ie_data[0] = ttl;
+	ie_data[1] = flags;
+	RTW_PUT_LE16((u8 *)&ie_data[2], reason);
+	RTW_PUT_LE16((u8 *)&ie_data[4], precedence);
+
+	return rtw_set_ie(buf, 0x118,  6, ie_data, buf_len);
+}
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+u8 *rtw_get_ie(u8 *pbuf, int index, int *len, int limit)
+{
+	int tmp, i;
+	u8 *p;
+
+	if (limit < 1) {
+
+		return NULL;
+	}
+
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while (1) {
+		if (*p == index) {
+			*len = *(p + 1);
+			return p;
+		} else {
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+
+	return NULL;
+}
+
+/**
+ * rtw_get_ie_ex - Search specific IE from a series of IEs
+ * @in_ie: Address of IEs to search
+ * @in_len: Length limit from in_ie
+ * @eid: Element ID to match
+ * @oui: OUI to match
+ * @oui_len: OUI length
+ * @ie: If not NULL and the specific IE is found, the IE will be copied to the buf starting from the specific IE
+ * @ielen: If not NULL and the specific IE is found, will set to the length of the entire IE
+ *
+ * Returns: The address of the specific IE found, or NULL
+ */
+u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len,
+		  u8 *ie, uint *ielen)
+{
+	uint cnt;
+	u8 *target_ie = NULL;
+
+	if (ielen)
+		*ielen = 0;
+	if (!in_ie || in_len <= 0)
+		return target_ie;
+	cnt = 0;
+	while (cnt < in_len) {
+		if (eid == in_ie[cnt] &&
+		    (!oui || _rtw_memcmp(&in_ie[cnt+2], oui, oui_len) == true)) {
+			target_ie = &in_ie[cnt];
+			if (ie)
+				memcpy(ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			if (ielen)
+				*ielen = in_ie[cnt+1]+2;
+			break;
+		} else {
+			cnt += in_ie[cnt+1]+2; /* goto next */
+		}
+	}
+	return target_ie;
+}
+
+/**
+ * rtw_ies_remove_ie - Find matching IEs and remove
+ * @ies: Address of IEs to search
+ * @ies_len: Pointer of length of ies, will update to new length
+ * @offset: The offset to start scarch
+ * @eid: Element ID to match
+ * @oui: OUI to match
+ * @oui_len: OUI length
+ *
+ * Returns: _SUCCESS: ies is updated, _FAIL: not updated
+ */
+int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len)
+{
+	int ret = _FAIL;
+	u8 *target_ie;
+	u32 target_ielen;
+	u8 *start;
+	uint search_len;
+
+	if (!ies || !ies_len || *ies_len <= offset)
+		goto exit;
+
+	start = ies + offset;
+	search_len = *ies_len - offset;
+
+	while (1) {
+		target_ie = rtw_get_ie_ex(start, search_len, eid, oui, oui_len, NULL, &target_ielen);
+		if (target_ie && target_ielen) {
+			u8 buf[MAX_IE_SZ] = {0};
+			u8 *remain_ies = target_ie + target_ielen;
+			uint remain_len = search_len - (remain_ies - start);
+
+			memcpy(buf, remain_ies, remain_len);
+			memcpy(target_ie, buf, remain_len);
+			*ies_len = *ies_len - target_ielen;
+			ret = _SUCCESS;
+
+			start = target_ie;
+			search_len = remain_len;
+		} else {
+			break;
+		}
+	}
+exit:
+	return ret;
+}
+
+void rtw_set_supported_rate(u8 *SupportedRates, uint mode)
+{
+
+	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	switch (mode) {
+	case WIRELESS_11B:
+		memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11A:
+	case WIRELESS_11_5N:
+	case WIRELESS_11A_5N:/* Todo: no basic rate for ofdm ? */
+		memcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	case WIRELESS_11BG:
+	case WIRELESS_11G_24N:
+	case WIRELESS_11_24N:
+	case WIRELESS_11BG_24N:
+		memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+		memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+		break;
+	}
+
+}
+
+uint	rtw_get_rateset_len(u8	*rateset)
+{
+	uint i = 0;
+
+	while (1) {
+		if ((rateset[i]) == 0)
+			break;
+
+		if (i > 12)
+			break;
+
+		i++;
+	}
+
+	return i;
+}
+
+int rtw_generate_ie(struct registry_priv *pregistrypriv)
+{
+	u8	wireless_mode;
+	int	sz = 0, rate_len;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *ie = pdev_network->IEs;
+
+	/* timestamp will be inserted by hardware */
+	sz += 8;
+	ie += sz;
+
+	/* beacon interval : 2bytes */
+	*(__le16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);/* BCN_INTERVAL; */
+	sz += 2;
+	ie += 2;
+
+	/* capability info */
+	*(u16 *)ie = 0;
+
+	*(__le16 *)ie |= cpu_to_le16(cap_IBSS);
+
+	if (pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(__le16 *)ie |= cpu_to_le16(cap_ShortPremble);
+
+	if (pdev_network->Privacy)
+		*(__le16 *)ie |= cpu_to_le16(cap_Privacy);
+
+	sz += 2;
+	ie += 2;
+
+	/* SSID */
+	ie = rtw_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);
+
+	/* supported rates */
+	if (pregistrypriv->wireless_mode == WIRELESS_11ABGN) {
+		if (pdev_network->Configuration.DSConfig > 14)
+			wireless_mode = WIRELESS_11A_5N;
+		else
+			wireless_mode = WIRELESS_11BG_24N;
+	} else {
+		wireless_mode = pregistrypriv->wireless_mode;
+	}
+
+	rtw_set_supported_rate(pdev_network->SupportedRates, wireless_mode) ;
+
+	rate_len = rtw_get_rateset_len(pdev_network->SupportedRates);
+
+	if (rate_len > 8)
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, 8, pdev_network->SupportedRates, &sz);
+	else
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, rate_len, pdev_network->SupportedRates, &sz);
+
+	/* DS parameter set */
+	ie = rtw_set_ie(ie, _DSSET_IE_, 1, (u8 *)&(pdev_network->Configuration.DSConfig), &sz);
+
+	/* IBSS Parameter Set */
+
+	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (u8 *)&(pdev_network->Configuration.ATIMWindow), &sz);
+
+	if (rate_len > 8)
+		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (pdev_network->SupportedRates + 8), &sz);
+
+	/* return _SUCCESS; */
+	return sz;
+}
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{
+	int len;
+	u16 val16;
+	__le16 le_tmp;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
+	u8 *pbuf = pie;
+
+	while (1) {
+		pbuf = rtw_get_ie(pbuf, _WPA_IE_ID_, &len, limit);
+
+		if (pbuf) {
+			/* check if oui matches... */
+			if (_rtw_memcmp((pbuf + 2), wpa_oui_type, sizeof(wpa_oui_type)) == false)
+				goto check_next_ie;
+
+			/* check version... */
+			memcpy((u8 *)&le_tmp, (pbuf + 6), sizeof(val16));
+
+			val16 = le16_to_cpu(le_tmp);
+			if (val16 != 0x0001)
+				goto check_next_ie;
+
+			*wpa_ie_len = *(pbuf + 1);
+
+			return pbuf;
+		} else {
+			*wpa_ie_len = 0;
+			return NULL;
+		}
+
+check_next_ie:
+
+		limit -= (2 + len);
+
+		if (limit <= 0)
+			break;
+
+		pbuf += (2 + len);
+	}
+
+	*wpa_ie_len = 0;
+
+	return NULL;
+}
+
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{
+	return rtw_get_ie(pie, _WPA2_IE_ID_, rsn_ie_len, limit);
+}
+
+int rtw_get_wpa_cipher_suite(u8 *s)
+{
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+int rtw_get_wpa2_cipher_suite(u8 *s)
+{
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (u8)(wpa_ie_len - 2)) ||
+	    (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != true))
+		return _FAIL;
+
+	pos = wpa_ie;
+
+	pos += 8;
+	left = wpa_ie_len - 8;
+
+	/* group_cipher */
+	if (left >= WPA_SELECTOR_LEN) {
+		*group_cipher = rtw_get_wpa_cipher_suite(pos);
+
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+
+	} else if (left > 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));
+
+		return _FAIL;
+	}
+
+	/* pairwise_cipher */
+	if (left >= 2) {
+		/* count = le16_to_cpu(*(u16 *)pos); */
+		count = RTW_GET_LE16(pos);
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("%s: ie count botch (pairwise), count %u left %u",
+				 __func__, count, left));
+			return _FAIL;
+		}
+
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= rtw_get_wpa_cipher_suite(pos);
+
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+
+	} else if (left == 1) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)",   __func__));
+		return _FAIL;
+	}
+
+	return ret;
+}
+
+int rtw_parse_wpa2_ie(u8 *rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher)
+{
+	int i, ret = _SUCCESS;
+	int left, count;
+	u8 *pos;
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+
+	if ((*rsn_ie != _WPA2_IE_ID_) ||
+	    (*(rsn_ie+1) != (u8)(rsn_ie_len - 2)))
+		return _FAIL;
+
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;
+
+	/* group_cipher */
+	if (left >= RSN_SELECTOR_LEN) {
+		*group_cipher = rtw_get_wpa2_cipher_suite(pos);
+
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+
+	} else if (left > 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie length mismatch, %u too much", __func__, left));
+		return _FAIL;
+	}
+
+	/* pairwise_cipher */
+	if (left >= 2) {
+		count = RTW_GET_LE16(pos);
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie count botch (pairwise), "
+						 "count %u left %u", __func__, count, left));
+			return _FAIL;
+		}
+
+		for (i = 0; i < count; i++) {
+			*pairwise_cipher |= rtw_get_wpa2_cipher_suite(pos);
+
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+
+	} else if (left == 1) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s: ie too short (for key mgmt)",  __func__));
+
+		return _FAIL;
+	}
+
+	return ret;
+}
+
+int rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len)
+{
+	u8 authmode, i;
+	u8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};
+	uint	cnt;
+
+	/* Search required WPA or WPA2 IE and copy to sec_ie[] */
+
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+
+	while (cnt < in_len) {
+		authmode = in_ie[cnt];
+
+		if ((authmode == _WPA_IE_ID_) &&
+		    (_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0], 4) == true)) {
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+					 ("\n rtw_get_wpa_ie: in_ie[cnt+1]+2 =%d\n",
+					 in_ie[cnt+1]+2));
+
+				memcpy(wpa_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+
+				for (i = 0; i < (in_ie[cnt+1]+2); i = i+8) {
+					RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+						 ("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",
+						 wpa_ie[i], wpa_ie[i+1],
+						 wpa_ie[i+2], wpa_ie[i+3],
+						 wpa_ie[i+4], wpa_ie[i+5],
+						 wpa_ie[i+6], wpa_ie[i+7]));
+				}
+
+				*wpa_len = in_ie[cnt+1]+2;
+				cnt += in_ie[cnt+1]+2;  /* get next */
+		} else {
+			if (authmode == _WPA2_IE_ID_) {
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+					 ("\n get_rsn_ie: sec_idx =%d in_ie[cnt+1]+2 =%d\n",
+					 sec_idx, in_ie[cnt+1]+2));
+
+				memcpy(rsn_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+
+				for (i = 0; i < (in_ie[cnt+1]+2); i = i+8) {
+					RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+						 ("\n %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x\n",
+						 rsn_ie[i], rsn_ie[i+1],
+						 rsn_ie[i+2], rsn_ie[i+3],
+						 rsn_ie[i+4], rsn_ie[i+5],
+						 rsn_ie[i+6], rsn_ie[i+7]));
+				}
+
+				*rsn_len = in_ie[cnt+1]+2;
+				cnt += in_ie[cnt+1]+2;  /* get next */
+			} else {
+				cnt += in_ie[cnt+1]+2;   /* get next */
+			}
+		}
+	}
+
+	return *rsn_len + *wpa_len;
+}
+
+u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen)
+{
+	u8 match = false;
+	u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+	if (ie_ptr == NULL)
+		return match;
+
+	eid = ie_ptr[0];
+
+	if ((eid == _WPA_IE_ID_) && (_rtw_memcmp(&ie_ptr[2], wps_oui, 4) == true)) {
+		*wps_ielen = ie_ptr[1]+2;
+		match = true;
+	}
+	return match;
+}
+
+/**
+ * rtw_get_wps_ie - Search WPS IE from a series of IEs
+ * @in_ie: Address of IEs to search
+ * @in_len: Length limit from in_ie
+ * @wps_ie: If not NULL and WPS IE is found, WPS IE will be copied to the buf starting from wps_ie
+ * @wps_ielen: If not NULL and WPS IE is found, will set to the length of the entire WPS IE
+ *
+ * Returns: The address of the WPS IE found, or NULL
+ */
+u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen)
+{
+	uint cnt;
+	u8 *wpsie_ptr = NULL;
+	u8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};
+
+	if (wps_ielen)
+		*wps_ielen = 0;
+
+	if (!in_ie || in_len <= 0)
+		return wpsie_ptr;
+
+	cnt = 0;
+
+	while (cnt < in_len) {
+		eid = in_ie[cnt];
+
+		if ((eid == _WPA_IE_ID_) &&
+		    (_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4) == true)) {
+			wpsie_ptr = &in_ie[cnt];
+			if (wps_ie)
+				memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+			if (wps_ielen)
+				*wps_ielen = in_ie[cnt+1]+2;
+			cnt += in_ie[cnt+1]+2;
+			break;
+		} else {
+			cnt += in_ie[cnt+1]+2; /* goto next */
+		}
+	}
+	return wpsie_ptr;
+}
+
+/**
+ * rtw_get_wps_attr - Search a specific WPS attribute from a given WPS IE
+ * @wps_ie: Address of WPS IE to search
+ * @wps_ielen: Length limit from wps_ie
+ * @target_attr_id: The attribute ID of WPS attribute to search
+ * @buf_attr: If not NULL and the WPS attribute is found, WPS attribute will be copied to the buf starting from buf_attr
+ * @len_attr: If not NULL and the WPS attribute is found, will set to the length of the entire WPS attribute
+ *
+ * Returns: the address of the specific WPS attribute found, or NULL
+ */
+u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_attr, u32 *len_attr)
+{
+	u8 *attr_ptr = NULL;
+	u8 *target_attr_ptr = NULL;
+	u8 wps_oui[4] = {0x00, 0x50, 0xF2, 0x04};
+
+	if (len_attr)
+		*len_attr = 0;
+
+	if ((wps_ie[0] != _VENDOR_SPECIFIC_IE_) ||
+	    (_rtw_memcmp(wps_ie + 2, wps_oui, 4) != true))
+		return attr_ptr;
+
+	/*  6 = 1(Element ID) + 1(Length) + 4(WPS OUI) */
+	attr_ptr = wps_ie + 6; /* goto first attr */
+
+	while (attr_ptr - wps_ie < wps_ielen) {
+		/*  4 = 2(Attribute ID) + 2(Length) */
+		u16 attr_id = RTW_GET_BE16(attr_ptr);
+		u16 attr_data_len = RTW_GET_BE16(attr_ptr + 2);
+		u16 attr_len = attr_data_len + 4;
+
+		if (attr_id == target_attr_id) {
+			target_attr_ptr = attr_ptr;
+
+			if (buf_attr)
+				memcpy(buf_attr, attr_ptr, attr_len);
+
+			if (len_attr)
+				*len_attr = attr_len;
+
+			break;
+		} else {
+			attr_ptr += attr_len; /* goto next */
+		}
+	}
+	return target_attr_ptr;
+}
+
+/**
+ * rtw_get_wps_attr_content - Search a specific WPS attribute content from a given WPS IE
+ * @wps_ie: Address of WPS IE to search
+ * @wps_ielen: Length limit from wps_ie
+ * @target_attr_id: The attribute ID of WPS attribute to search
+ * @buf_content: If not NULL and the WPS attribute is found, WPS attribute content will be copied to the buf starting from buf_content
+ * @len_content: If not NULL and the WPS attribute is found, will set to the length of the WPS attribute content
+ *
+ * Returns: the address of the specific WPS attribute content found, or NULL
+ */
+u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_content, uint *len_content)
+{
+	u8 *attr_ptr;
+	u32 attr_len;
+
+	if (len_content)
+		*len_content = 0;
+
+	attr_ptr = rtw_get_wps_attr(wps_ie, wps_ielen, target_attr_id, NULL, &attr_len);
+
+	if (attr_ptr && attr_len) {
+		if (buf_content)
+			memcpy(buf_content, attr_ptr+4, attr_len-4);
+
+		if (len_content)
+			*len_content = attr_len-4;
+
+		return attr_ptr+4;
+	}
+
+	return NULL;
+}
+
+static int rtw_802_11_parse_ven(u8 *pos, uint elen,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors)
+{
+	unsigned int oui;
+
+	/* first 3 bytes in vendor specific information element are the IEEE
+	 * OUI of the vendor. The following byte is used a vendor specific
+	 * sub-type. */
+	if (elen < 4) {
+		if (show_errors) {
+			DBG_8192D("short vendor specific information element ignored (len =%lu)\n",
+				  (unsigned long) elen);
+		}
+		return -1;
+	}
+
+	oui = RTW_GET_BE24(pos);
+	switch (oui) {
+	case OUI_MICROSOFT:
+		/* Microsoft/Wi-Fi information elements are further typed and
+		 * subtyped */
+		switch (pos[3]) {
+		case 1:
+			/* Microsoft OUI (00:50:F2) with OUI Type 1:
+			 * real WPA information element */
+			elems->wpa_ie = pos;
+			elems->wpa_ie_len = elen;
+			break;
+		case WME_OUI_TYPE: /* this is a Wi-Fi WME info. element */
+			if (elen < 5) {
+				DBG_8192D("short WME information element ignored (len =%lu)\n",
+					  (unsigned long) elen);
+				return -1;
+			}
+			switch (pos[4]) {
+			case WME_OUI_SUBTYPE_INFORMATION_ELEMENT:
+			case WME_OUI_SUBTYPE_PARAMETER_ELEMENT:
+				elems->wme = pos;
+				elems->wme_len = elen;
+				break;
+			case WME_OUI_SUBTYPE_TSPEC_ELEMENT:
+				elems->wme_tspec = pos;
+				elems->wme_tspec_len = elen;
+				break;
+			default:
+				DBG_8192D("unknown WME information element ignored (subtype =%d len =%lu)\n",
+					  pos[4], (unsigned long) elen);
+				return -1;
+			}
+			break;
+		case 4:
+			/* Wi-Fi Protected Setup (WPS) IE */
+			elems->wps_ie = pos;
+			elems->wps_ie_len = elen;
+			break;
+		default:
+			DBG_8192D("Unknown Microsoft information element ignored (type =%d len =%lu)\n",
+				  pos[3], (unsigned long) elen);
+			return -1;
+		}
+		break;
+
+	case OUI_BROADCOM:
+		switch (pos[3]) {
+		case VENDOR_HT_CAPAB_OUI_TYPE:
+			elems->vendor_ht_cap = pos;
+			elems->vendor_ht_cap_len = elen;
+			break;
+		default:
+			DBG_8192D("Unknown Broadcom information element ignored (type =%d len =%lu)\n",
+				  pos[3], (unsigned long) elen);
+			return -1;
+		}
+		break;
+
+	default:
+		DBG_8192D("unknown vendor specific information element ignored (vendor OUI %02x:%02x:%02x len =%lu)\n",
+			  pos[0], pos[1], pos[2], (unsigned long) elen);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * ieee802_11_parse_elems - Parse information elements in management frames
+ * @start: Pointer to the start of IEs
+ * @len: Length of IE buffer in octets
+ * @elems: Data structure for parsed elements
+ * @show_errors: Whether to show parsing errors in debug log
+ * Returns: Parsing result
+ */
+enum parse_res rtw_ieee802_11_parse_elems(u8 *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors)
+{
+	uint left = len;
+	u8 *pos = start;
+	int unknown = 0;
+
+	memset(elems, 0, sizeof(*elems));
+
+	while (left >= 2) {
+		u8 id, elen;
+
+		id = *pos++;
+		elen = *pos++;
+		left -= 2;
+
+		if (elen > left) {
+			if (show_errors) {
+				DBG_8192D("IEEE 802.11 element parse failed (id =%d elen =%d left =%lu)\n",
+					  id, elen, (unsigned long) left);
+			}
+			return PARSE_FAIL;
+		}
+
+		switch (id) {
+		case WLAN_EID_SSID:
+			elems->ssid = pos;
+			elems->ssid_len = elen;
+			break;
+		case WLAN_EID_SUPP_RATES:
+			elems->supp_rates = pos;
+			elems->supp_rates_len = elen;
+			break;
+		case WLAN_EID_FH_PARAMS:
+			elems->fh_params = pos;
+			elems->fh_params_len = elen;
+			break;
+		case WLAN_EID_DS_PARAMS:
+			elems->ds_params = pos;
+			elems->ds_params_len = elen;
+			break;
+		case WLAN_EID_CF_PARAMS:
+			elems->cf_params = pos;
+			elems->cf_params_len = elen;
+			break;
+		case WLAN_EID_TIM:
+			elems->tim = pos;
+			elems->tim_len = elen;
+			break;
+		case WLAN_EID_IBSS_PARAMS:
+			elems->ibss_params = pos;
+			elems->ibss_params_len = elen;
+			break;
+		case WLAN_EID_CHALLENGE:
+			elems->challenge = pos;
+			elems->challenge_len = elen;
+			break;
+		case WLAN_EID_ERP_INFO:
+			elems->erp_info = pos;
+			elems->erp_info_len = elen;
+			break;
+		case WLAN_EID_EXT_SUPP_RATES:
+			elems->ext_supp_rates = pos;
+			elems->ext_supp_rates_len = elen;
+			break;
+		case WLAN_EID_VENDOR_SPECIFIC:
+			if (rtw_802_11_parse_ven(pos, elen, elems, show_errors))
+				unknown++;
+			break;
+		case WLAN_EID_RSN:
+			elems->rsn_ie = pos;
+			elems->rsn_ie_len = elen;
+			break;
+		case WLAN_EID_PWR_CAPABILITY:
+			elems->power_cap = pos;
+			elems->power_cap_len = elen;
+			break;
+		case WLAN_EID_SUPPORTED_CHANNELS:
+			elems->supp_channels = pos;
+			elems->supp_channels_len = elen;
+			break;
+		case WLAN_EID_MOBILITY_DOMAIN:
+			elems->mdie = pos;
+			elems->mdie_len = elen;
+			break;
+		case WLAN_EID_FAST_BSS_TRANSITION:
+			elems->ftie = pos;
+			elems->ftie_len = elen;
+			break;
+		case WLAN_EID_TIMEOUT_INTERVAL:
+			elems->timeout_int = pos;
+			elems->timeout_int_len = elen;
+			break;
+		case WLAN_EID_HT_CAP:
+			elems->ht_capabilities = pos;
+			elems->ht_capabilities_len = elen;
+			break;
+		case WLAN_EID_HT_OPERATION:
+			elems->ht_operation = pos;
+			elems->ht_operation_len = elen;
+			break;
+		default:
+			unknown++;
+			if (!show_errors)
+				break;
+			DBG_8192D("IEEE 802.11 element parse ignored unknown element (id =%d elen =%d)\n",
+				  id, elen);
+			break;
+		}
+
+		left -= elen;
+		pos += elen;
+	}
+
+	if (left)
+		return PARSE_FAIL;
+
+	return unknown ? PARSE_UNK : PARSE_OK;
+}
+
+static u8 key_char2num(u8 ch)
+{
+	if ((ch >= '0') && (ch <= '9'))
+		return ch - '0';
+	else if ((ch >= 'a') && (ch <= 'f'))
+		return ch - 'a' + 10;
+	else if ((ch >= 'A') && (ch <= 'F'))
+		return ch - 'A' + 10;
+	else
+		return 0xff;
+}
+
+u8 str_2char2num(u8 hch, u8 lch)
+{
+	return (key_char2num(hch) * 10) + key_char2num(lch);
+}
+
+u8 key_2char2num(u8 hch, u8 lch)
+{
+	return (key_char2num(hch) << 4) | key_char2num(lch);
+}
+
+u8 convert_ip_addr(u8 hch, u8 mch, u8 lch)
+{
+	return (key_char2num(hch) * 100) + (key_char2num(mch) * 10) + key_char2num(lch);
+}
+
+void rtw_macaddr_cfg(u8 *mac_addr)
+{
+	u8 mac[ETH_ALEN];
+	if (mac_addr == NULL)
+		return;
+
+	if (rtw_initmac) {	/*	Users specify the mac address */
+		int jj, kk;
+
+		for (jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3)
+			mac[jj] = key_2char2num(rtw_initmac[kk], rtw_initmac[kk+1]);
+		memcpy(mac_addr, mac, ETH_ALEN);
+	} else {	/*	Use the mac address stored in the Efuse */
+		memcpy(mac, mac_addr, ETH_ALEN);
+	}
+
+	if (((mac[0] == 0xff) && (mac[1] == 0xff) && (mac[2] == 0xff) &&
+	     (mac[3] == 0xff) && (mac[4] == 0xff) && (mac[5] == 0xff)) ||
+	    ((mac[0] == 0x0) && (mac[1] == 0x0) && (mac[2] == 0x0) &&
+	     (mac[3] == 0x0) && (mac[4] == 0x0) && (mac[5] == 0x0))) {
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x00;
+		mac[5] = 0x00;
+		/*  use default mac addresss */
+		memcpy(mac_addr, mac, ETH_ALEN);
+		DBG_8192D("MAC Address from efuse error, assign default one !!!\n");
+	}
+
+	DBG_8192D("rtw_macaddr_cfg MAC Address  = %pM\n", mac_addr);
+}
+
+void dump_ies(u8 *buf, u32 buf_len)
+{
+	u8 *pos = (u8 *)buf;
+	u8 id, len;
+
+	while (pos-buf <= buf_len) {
+		id = *pos;
+		len = *(pos+1);
+
+		DBG_8192D("%s ID:%u, LEN:%u\n", __func__, id, len);
+		dump_wps_ie(pos, len);
+
+		pos += (2+len);
+	}
+}
+
+void dump_wps_ie(u8 *ie, u32 ie_len)
+{
+	u8 *pos = (u8 *)ie;
+	u16 id;
+	u16 len;
+
+	u8 *wps_ie;
+	uint wps_ielen;
+
+	wps_ie = rtw_get_wps_ie(ie, ie_len, NULL, &wps_ielen);
+	if (wps_ie != ie || wps_ielen == 0)
+		return;
+
+	pos += 6;
+	while (pos-ie < ie_len) {
+		id = RTW_GET_BE16(pos);
+		len = RTW_GET_BE16(pos + 2);
+
+		DBG_8192D("%s ID:0x%04x, LEN:%u\n", __func__, id, len);
+
+		pos += (4+len);
+	}
+}
+
+/* Baron adds to avoid FreeBSD warning */
+int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+
+	return 1;
+}
+
+int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case RTW_IEEE80211_FTYPE_DATA:
+		if (fc & RTW_IEEE80211_STYPE_QOS_DATA)
+			hdrlen += 2;
+		if ((fc & RTW_IEEE80211_FCTL_FROMDS) && (fc & RTW_IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case RTW_IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case RTW_IEEE80211_STYPE_CTS:
+		case RTW_IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+/* show MCS rate, unit: 100Kbps */
+u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI_20, u8 short_GI_40, unsigned char *mcs_rate)
+{
+	u16 max_rate = 0;
+
+	if (rf_type == RF_1T1R) {
+		if (mcs_rate[0] & BIT(7))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 1500 : 1350) : ((short_GI_20) ? 722 : 650);
+		else if (mcs_rate[0] & BIT(6))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 1350 : 1215) : ((short_GI_20) ? 650 : 585);
+		else if (mcs_rate[0] & BIT(5))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);
+		else if (mcs_rate[0] & BIT(4))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);
+		else if (mcs_rate[0] & BIT(3))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);
+		else if (mcs_rate[0] & BIT(2))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 450 : 405) : ((short_GI_20) ? 217 : 195);
+		else if (mcs_rate[0] & BIT(1))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);
+		else if (mcs_rate[0] & BIT(0))
+			max_rate = (bw_40MHz) ? ((short_GI_40) ? 150 : 135) : ((short_GI_20) ? 72 : 65);
+	} else {
+		if (mcs_rate[1]) {
+			if (mcs_rate[1] & BIT(7))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 3000 : 2700) : ((short_GI_20) ? 1444 : 1300);
+			else if (mcs_rate[1] & BIT(6))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 2700 : 2430) : ((short_GI_20) ? 1300 : 1170);
+			else if (mcs_rate[1] & BIT(5))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 2400 : 2160) : ((short_GI_20) ? 1156 : 1040);
+			else if (mcs_rate[1] & BIT(4))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 1800 : 1620) : ((short_GI_20) ? 867 : 780);
+			else if (mcs_rate[1] & BIT(3))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);
+			else if (mcs_rate[1] & BIT(2))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);
+			else if (mcs_rate[1] & BIT(1))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);
+			else if (mcs_rate[1] & BIT(0))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);
+		} else {
+			if (mcs_rate[0] & BIT(7))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 1500 : 1350) : ((short_GI_20) ? 722 : 650);
+			else if (mcs_rate[0] & BIT(6))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 1350 : 1215) : ((short_GI_20) ? 650 : 585);
+			else if (mcs_rate[0] & BIT(5))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 1200 : 1080) : ((short_GI_20) ? 578 : 520);
+			else if (mcs_rate[0] & BIT(4))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 900 : 810) : ((short_GI_20) ? 433 : 390);
+			else if (mcs_rate[0] & BIT(3))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 600 : 540) : ((short_GI_20) ? 289 : 260);
+			else if (mcs_rate[0] & BIT(2))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 450 : 405) : ((short_GI_20) ? 217 : 195);
+			else if (mcs_rate[0] & BIT(1))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 300 : 270) : ((short_GI_20) ? 144 : 130);
+			else if (mcs_rate[0] & BIT(0))
+				max_rate = (bw_40MHz) ? ((short_GI_40) ? 150 : 135) : ((short_GI_20) ? 72 : 65);
+		}
+	}
+	return max_rate;
+}
+
+int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8 *category, u8 *action)
+{
+	const u8 *frame_body = frame + sizeof(struct rtw_ieee80211_hdr_3addr);
+	u16 fc;
+	u8 c, a;
+
+	fc = le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)frame)->frame_ctl);
+
+	if ((fc & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE)) !=
+	    (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION))
+		return false;
+
+	c = frame_body[0];
+
+	switch (c) {
+	case RTW_WLAN_CATEGORY_P2P: /* vendor-specific */
+		break;
+	default:
+		a = frame_body[1];
+	}
+
+	if (category)
+		*category = c;
+	if (action)
+		*action = a;
+
+	return true;
+}
+
+static const char *_action_public_str[] = {
+	"ACT_PUB_BSSCOEXIST",
+	"ACT_PUB_DSE_ENABLE",
+	"ACT_PUB_DSE_DEENABLE",
+	"ACT_PUB_DSE_REG_LOCATION",
+	"ACT_PUB_EXT_CHL_SWITCH",
+	"ACT_PUB_DSE_MSR_REQ",
+	"ACT_PUB_DSE_MSR_RPRT",
+	"ACT_PUB_MP",
+	"ACT_PUB_DSE_PWR_CONSTRAINT",
+	"ACT_PUB_VENDOR",
+	"ACT_PUB_GAS_INITIAL_REQ",
+	"ACT_PUB_GAS_INITIAL_RSP",
+	"ACT_PUB_GAS_COMEBACK_REQ",
+	"ACT_PUB_GAS_COMEBACK_RSP",
+	"ACT_PUB_TDLS_DISCOVERY_RSP",
+	"ACT_PUB_LOCATION_TRACK",
+	"ACT_PUB_RSVD",
+};
+
+const char *action_public_str(u8 action)
+{
+	action = (action >= ACT_PUBLIC_MAX) ? ACT_PUBLIC_MAX : action;
+	return _action_public_str[action];
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_io.c b/drivers/net/wireless/rtl8192du/core/rtw_io.c
new file mode 100644
index 0000000..205ac92
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_io.c
@@ -0,0 +1,425 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*
+
+The purpose of rtw_io.c
+
+a. provides the API
+
+b. provides the protocol engine
+
+c. provides the software interface between caller and the hardware interface
+
+Compiler Flag Option:
+
+1. default USB configuration
+   a. USE_ASYNC_IRP: Both sync/async operations are provided.
+
+Only sync read/rtw_write_mem operations are provided.
+
+jackson@realtek.com.tw
+
+*/
+
+#define _RTW_IO_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_io.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+
+u8 _rtw_read8(struct rtw_adapter *adapter, u32 addr)
+{
+	u8 r_val;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+
+	_read8 = pintfhdl->io_ops._read8;
+
+	r_val = _read8(pintfhdl, addr);
+
+	return r_val;
+}
+
+u16 _rtw_read16(struct rtw_adapter *adapter, u32 addr)
+{
+	u16 r_val;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u16	(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+
+	_read16 = pintfhdl->io_ops._read16;
+
+	r_val = _read16(pintfhdl, addr);
+
+	return r_val;
+}
+
+u32 _rtw_read32(struct rtw_adapter *adapter, u32 addr)
+{
+	u32 r_val;
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u32	(*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+	_read32 = pintfhdl->io_ops._read32;
+
+	r_val = _read32(pintfhdl, addr);
+
+	return r_val;
+}
+
+int _rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
+	int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	int ret;
+
+	_write8 = pintfhdl->io_ops._write8;
+
+	ret = _write8(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+
+int _rtw_write16(struct rtw_adapter *adapter, u32 addr, u16 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	int ret;
+
+	_write16 = pintfhdl->io_ops._write16;
+
+	ret = _write16(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+int _rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	int ret;
+
+	_write32 = pintfhdl->io_ops._write32;
+
+	ret = _write32(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+
+int _rtw_writeN(struct rtw_adapter *adapter, u32 addr, u32 length, u8 *pdata)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct intf_hdl *pintfhdl = (struct intf_hdl *)(&(pio_priv->intf));
+	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr,
+		       u32 length, u8 *pdata);
+	int ret;
+
+	_writeN = pintfhdl->io_ops._writeN;
+
+	ret = _writeN(pintfhdl, addr, length, pdata);
+
+	return RTW_STATUS_CODE(ret);
+}
+int _rtw_write8_async(struct rtw_adapter *adapter, u32 addr, u8 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+	int ret;
+
+	_write8_async = pintfhdl->io_ops._write8_async;
+
+	ret = _write8_async(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+int _rtw_write16_async(struct rtw_adapter *adapter, u32 addr, u16 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
+	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+	int ret;
+
+	_write16_async = pintfhdl->io_ops._write16_async;
+
+	ret = _write16_async(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+int _rtw_write32_async(struct rtw_adapter *adapter, u32 addr, u32 val)
+{
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
+	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+	int ret;
+
+	_write32_async = pintfhdl->io_ops._write32_async;
+
+	ret = _write32_async(pintfhdl, addr, val);
+
+	return RTW_STATUS_CODE(ret);
+}
+
+void _rtw_read_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr,
+			  u32 cnt, u8 *pmem);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true)) {
+		RT_TRACE(_module_rtl871x_io_c_, _drv_info_,
+			 ("rtw_read_mem:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+			 adapter->bDriverStopped, adapter->bSurpriseRemoved));
+	     return;
+	}
+
+	_read_mem = pintfhdl->io_ops._read_mem;
+
+	_read_mem(pintfhdl, addr, cnt, pmem);
+
+}
+
+void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr,
+			   u32 cnt, u8 *pmem);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
+
+	_write_mem = pintfhdl->io_ops._write_mem;
+
+	_write_mem(pintfhdl, addr, cnt, pmem);
+
+}
+
+void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr,
+			  u32 cnt, u8 *pmem);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl *pintfhdl = &(pio_priv->intf);
+
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true)) {
+		RT_TRACE(_module_rtl871x_io_c_, _drv_info_,
+			 ("rtw_read_port:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+			 adapter->bDriverStopped, adapter->bSurpriseRemoved));
+	     return;
+	}
+
+	_read_port = pintfhdl->io_ops._read_port;
+
+	_read_port(pintfhdl, addr, cnt, pmem);
+
+}
+
+void _rtw_read_port_cancel(struct rtw_adapter *adapter)
+{
+	void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct intf_hdl *pintfhdl = &(pio_priv->intf);
+
+	_read_port_cancel = pintfhdl->io_ops._read_port_cancel;
+
+	if (_read_port_cancel)
+		_read_port_cancel(pintfhdl);
+}
+
+u32 _rtw_write_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
+{
+	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr,
+			   u32 cnt, u8 *pmem);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
+	u32 ret = _SUCCESS;
+
+	_write_port = pintfhdl->io_ops._write_port;
+
+	ret = _write_port(pintfhdl, addr, cnt, pmem);
+
+	return ret;
+}
+
+u32 _rtw_write_port_and_wait(struct rtw_adapter *adapter, u32 addr, u32 cnt,
+			     u8 *pmem, int timeout_ms)
+{
+	int ret = _SUCCESS;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pmem;
+	struct submit_ctx sctx;
+
+	rtw_sctx_init(&sctx, timeout_ms);
+	pxmitbuf->sctx = &sctx;
+
+	ret = _rtw_write_port(adapter, addr, cnt, pmem);
+
+	if (ret == _SUCCESS)
+		ret = rtw_sctx_wait(&sctx);
+
+	 return ret;
+}
+
+void _rtw_write_port_cancel(struct rtw_adapter *adapter)
+{
+	void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+	struct io_priv *pio_priv = &adapter->iopriv;
+	struct intf_hdl *pintfhdl = &(pio_priv->intf);
+
+	_write_port_cancel = pintfhdl->io_ops._write_port_cancel;
+
+	if (_write_port_cancel)
+		_write_port_cancel(pintfhdl);
+}
+
+int rtw_init_io_priv(struct rtw_adapter *padapter,
+		     void (*set_intf_ops)(struct _io_ops *pops))
+{
+	struct io_priv	*piopriv = &padapter->iopriv;
+	struct intf_hdl *pintf = &piopriv->intf;
+
+	if (set_intf_ops == NULL)
+		return _FAIL;
+
+	piopriv->padapter = padapter;
+	pintf->padapter = padapter;
+	pintf->pintf_dev = adapter_to_dvobj(padapter);
+
+	set_intf_ops(&pintf->io_ops);
+
+	return _SUCCESS;
+}
+
+#ifdef DBG_IO
+
+u16 read_sniff_ranges[][2] = {
+	/* 0x550, 0x551}, */
+};
+
+u16 write_sniff_ranges[][2] = {
+	/* 0x550, 0x551}, */
+	/* 0x4c, 0x4c}, */
+};
+
+int read_sniff_num = sizeof(read_sniff_ranges)/sizeof(u16)/2;
+int write_sniff_num = sizeof(write_sniff_ranges)/sizeof(u16)/2;
+
+bool match_read_sniff_ranges(u16 addr, u16 len)
+{
+	int i;
+	for (i = 0; i < read_sniff_num; i++) {
+		if (addr + len > read_sniff_ranges[i][0] &&
+		    addr <= read_sniff_ranges[i][1])
+			return true;
+	}
+
+	return false;
+}
+
+bool match_write_sniff_ranges(u16 addr, u16 len)
+{
+	int i;
+	for (i = 0; i < write_sniff_num; i++) {
+		if (addr + len > write_sniff_ranges[i][0] &&
+		    addr <= write_sniff_ranges[i][1])
+			return true;
+	}
+
+	return false;
+}
+
+u8 dbg_rtw_read8(struct rtw_adapter *adapter, u32 addr,
+		 const char *caller, const int line)
+{
+	u8 val = _rtw_read8(adapter, addr);
+
+	if (match_read_sniff_ranges(addr, 1))
+		DBG_871X("DBG_IO %s:%d rtw_read8(0x%04x) return 0x%02x\n",
+			 caller, line, addr, val);
+
+	return val;
+}
+
+u16 dbg_rtw_read16(struct rtw_adapter *adapter, u32 addr,
+		   const char *caller, const int line)
+{
+	u16 val = _rtw_read16(adapter, addr);
+
+	if (match_read_sniff_ranges(addr, 2))
+		DBG_871X("DBG_IO %s:%d rtw_read16(0x%04x) return 0x%04x\n",
+			 caller, line, addr, val);
+
+	return val;
+}
+
+u32 dbg_rtw_read32(struct rtw_adapter *adapter, u32 addr,
+		   const char *caller, const int line)
+{
+	u32 val = _rtw_read32(adapter, addr);
+
+	if (match_read_sniff_ranges(addr, 4))
+		DBG_871X("DBG_IO %s:%d rtw_read32(0x%04x) return 0x%08x\n",
+			 caller, line, addr, val);
+
+	return val;
+}
+
+int dbg_rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val,
+		   const char *caller, const int line)
+{
+	if (match_write_sniff_ranges(addr, 1))
+		DBG_871X("DBG_IO %s:%d rtw_write8(0x%04x, 0x%02x)\n", caller,
+			 line, addr, val);
+
+	return _rtw_write8(adapter, addr, val);
+}
+
+int dbg_rtw_write16(struct rtw_adapter *adapter, u32 addr, u16 val,
+		    const char *caller, const int line)
+{
+	if (match_write_sniff_ranges(addr, 2))
+		DBG_871X("DBG_IO %s:%d rtw_write16(0x%04x, 0x%04x)\n", caller,
+			 line, addr, val);
+
+	return _rtw_write16(adapter, addr, val);
+}
+
+int dbg_rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val,
+		    const char *caller, const int line)
+{
+	if (match_write_sniff_ranges(addr, 4))
+		DBG_871X("DBG_IO %s:%d rtw_write32(0x%04x, 0x%08x)\n", caller,
+			 line, addr, val);
+
+	return _rtw_write32(adapter, addr, val);
+}
+
+int dbg_rtw_writeN(struct rtw_adapter *adapter, u32 addr, u32 length, u8 *data,
+		   const char *caller, const int line)
+{
+	if (match_write_sniff_ranges(addr, length))
+		DBG_871X("DBG_IO %s:%d rtw_writeN(0x%04x, %u)\n", caller,
+			 line, addr, length);
+
+	return _rtw_writeN(adapter, addr, length, data);
+}
+#endif
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_ioctl_set.c b/drivers/net/wireless/rtl8192du/core/rtw_ioctl_set.c
new file mode 100644
index 0000000..cf32d53
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_ioctl_set.c
@@ -0,0 +1,1106 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_IOCTL_SET_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_ioctl_set.h>
+#include <hal_intf.h>
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#include <mlme_osdep.h>
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+(\
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
+	 (addr[2] == 0xff) && (addr[3] == 0xff) && \
+	 (addr[4] == 0xff) && (addr[5] == 0xff))  ? true : false \
+)
+
+u8 rtw_validate_ssid(struct ndis_802_11_ssid *ssid)
+{
+	u8	 i;
+	u8	ret = true;
+
+	if (ssid->SsidLength > 32) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));
+		ret = false;
+		goto exit;
+	}
+
+	for (i = 0; i < ssid->SsidLength; i++) {
+		/* wifi, printable ascii code must be supported */
+		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
+			ret = false;
+			break;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+u8 rtw_do_join(struct rtw_adapter *padapter)
+{
+	struct list_head *plist, *phead;
+	u8 *pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	u8 ret = _SUCCESS;
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("\n rtw_do_join: phead = %p; plist = %p\n\n\n", phead, plist));
+
+	pmlmepriv->cur_network.join_res = -2;
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+	pmlmepriv->pscanned = plist;
+
+	pmlmepriv->to_join = true;
+
+	if (_rtw_queue_empty(queue) == true) {
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+		/* when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty */
+		/* we try to issue sitesurvey firstly */
+
+		if (pmlmepriv->LinkDetectInfo.bBusyTraffic == false || rtw_to_roaming(padapter) > 0) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+				 ("rtw_do_join(): site survey if scanned_queue is empty\n."));
+			/*  submit site_survey_cmd */
+			ret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
+			if (_SUCCESS != ret) {
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,
+					 _drv_err_,
+					 ("rtw_do_join(): site survey return error\n."));
+			}
+		}
+
+		goto exit;
+	} else {
+		int select_ret;
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		select_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);
+		if (select_ret == _SUCCESS) {
+			pmlmepriv->to_join = false;
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+		} else if (ret == 2) { /* there is no need to wait for join */
+			ret = _SUCCESS;
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+			rtw_indicate_connect(padapter);
+		} else {
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {
+				/*  submit createbss_cmd to change to a ADHOC_MASTER */
+
+				/* pmlmepriv->lock has been acquired by caller... */
+				struct wlan_bssid_ex    *pdev_network = &(padapter->registrypriv.dev_network);
+
+				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+
+				pibss = padapter->registrypriv.dev_network.MacAddress;
+
+				memset(&pdev_network->Ssid, 0, sizeof(struct ndis_802_11_ssid));
+				memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));
+
+				rtw_update_registrypriv_dev_network(padapter);
+
+				rtw_generate_random_ibss(pibss);
+
+				if (rtw_createbss_cmd(padapter) != _SUCCESS) {
+					RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error=>do_goin: rtw_createbss_cmd status FAIL***\n "));
+					ret =  false;
+					goto exit;
+				}
+
+				pmlmepriv->to_join = false;
+
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n "));
+
+			} else {
+				/*  can't associate; reset under-linking */
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+				/* when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue */
+				/* we try to issue sitesurvey firstly */
+				if (pmlmepriv->LinkDetectInfo.bBusyTraffic == false ||
+				    rtw_to_roaming(padapter) > 0) {
+					ret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);
+					if (_SUCCESS != ret)
+						RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+							 ("do_join(): site survey return error\n."));
+				}
+			}
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+u8 rtw_set_802_11_bssid(struct rtw_adapter *padapter, u8 *bssid)
+{
+	u8 status = _SUCCESS;
+	u32 cur_time = 0;
+
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+rtw_set_802_11_bssid: bssid =%pM\n", bssid));
+
+	if ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 && bssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||
+	    (bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF && bssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {
+		status = _FAIL;
+		goto exit;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	DBG_8192D("Set BSSID under fw_state= 0x%08x\n", get_fwstate(pmlmepriv));
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		goto handle_tkip_countermeasure;
+	else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		goto release_mlme_lock;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == true) {
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)
+				goto release_mlme_lock;/* it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. */
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set BSSID not the same bssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid =%pM\n", bssid));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("cur_bssid =%pM\n", pmlmepriv->cur_network.network.MacAddress));
+
+			rtw_disassoc_cmd(padapter, 0, true);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				rtw_indicate_disconnect(padapter);
+
+			rtw_free_assoc_resources(padapter, 1);
+
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+handle_tkip_countermeasure:
+	/* should we add something here...? */
+
+	if (padapter->securitypriv.btkip_countermeasure == true) {
+		cur_time = rtw_get_current_time();
+
+		if ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {
+			padapter->securitypriv.btkip_countermeasure = false;
+			padapter->securitypriv.btkip_countermeasure_time = 0;
+		} else {
+			status = _FAIL;
+			goto release_mlme_lock;
+		}
+	}
+
+	memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+	pmlmepriv->assoc_by_bssid = true;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		pmlmepriv->to_join = true;
+	else
+		status = rtw_do_join(padapter);
+
+release_mlme_lock:
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+		 ("rtw_set_802_11_bssid: status=%d\n", status));
+
+	return status;
+}
+
+u8 rtw_set_802_11_ssid(struct rtw_adapter *padapter, struct ndis_802_11_ssid *ssid)
+{
+	u8 status = _SUCCESS;
+	u32 cur_time = 0;
+
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+rtw_set_802_11_ssid: ssid =[%s] fw_state= 0x%08x\n",
+		  ssid->Ssid, get_fwstate(pmlmepriv)));
+
+	if (padapter->hw_init_completed == false) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("set_ssid: hw_init_completed== false=>exit!!!\n"));
+		status = _FAIL;
+		goto exit;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	DBG_8192D("Set SSID under fw_state= 0x%08x\n", get_fwstate(pmlmepriv));
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		goto handle_tkip_countermeasure;
+	else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)
+		goto release_mlme_lock;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+			 ("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));
+
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == true)) {
+			if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)) {
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("Set SSID is the same ssid, fw_state= 0x%08x\n",
+					  get_fwstate(pmlmepriv)));
+
+				if (rtw_is_same_ibss(padapter, pnetwork) == false) {
+					/* if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again */
+					rtw_disassoc_cmd(padapter, 0, true);
+
+					if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+						rtw_indicate_disconnect(padapter);
+
+					rtw_free_assoc_resources(padapter, 1);
+
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+						_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+					}
+				} else {
+					goto release_mlme_lock;/* it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. */
+				}
+			}
+#ifdef CONFIG_LPS
+			else {
+				rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_JOINBSS, 1);
+			}
+#endif
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set SSID not the same ssid\n"));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_ssid =[%s] len= 0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("assoc_ssid =[%s] len= 0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));
+
+			rtw_disassoc_cmd(padapter, 0, true);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				rtw_indicate_disconnect(padapter);
+
+			rtw_free_assoc_resources(padapter, 1);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+handle_tkip_countermeasure:
+
+	if (padapter->securitypriv.btkip_countermeasure == true) {
+		cur_time = rtw_get_current_time();
+
+		if ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {
+			padapter->securitypriv.btkip_countermeasure = false;
+			padapter->securitypriv.btkip_countermeasure_time = 0;
+		} else {
+			status = _FAIL;
+			goto release_mlme_lock;
+		}
+	}
+
+	#ifdef CONFIG_VALIDATE_SSID
+	if (rtw_validate_ssid(ssid) == false) {
+		status = _FAIL;
+		goto release_mlme_lock;
+	}
+	#endif
+
+	memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));
+	pmlmepriv->assoc_by_bssid = false;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)
+		pmlmepriv->to_join = true;
+	else
+		status = rtw_do_join(padapter);
+
+release_mlme_lock:
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+		 ("-rtw_set_802_11_ssid: status=%d\n", status));
+
+	return status;
+}
+
+u8 rtw_set_802_11_infrastructure_mode(struct rtw_adapter *padapter,
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE *pold_state = &(cur_network->network.InfrastructureMode);
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,
+		 ("+rtw_set_802_11_infrastructure_mode: old=%d new=%d fw_state= 0x%08x\n",
+		  *pold_state, networktype, get_fwstate(pmlmepriv)));
+
+	if (*pold_state != networktype) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, (" change mode!"));
+
+		if (*pold_state == NDIS802_11APMODE) {
+			/* change to other mode from Ndis802_11APMode */
+			cur_network->join_res = -1;
+
+#ifdef CONFIG_92D_AP_MODE
+			stop_ap_mode(padapter);
+#endif
+		}
+
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) || (*pold_state == NDIS802_11IBSS))
+			rtw_disassoc_cmd(padapter, 0, true);
+
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
+			rtw_free_assoc_resources(padapter, 0);
+
+		if ((*pold_state == NDIS802_11INFRA) || (*pold_state == NDIS802_11IBSS)) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				rtw_indicate_disconnect(padapter); /* will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not */
+	       }
+
+		*pold_state = networktype;
+
+		_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);
+
+		switch (networktype) {
+		case NDIS802_11IBSS:
+			set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			break;
+		case NDIS802_11INFRA:
+			set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+			break;
+		case NDIS802_11APMODE:
+			set_fwstate(pmlmepriv, WIFI_AP_STATE);
+#ifdef CONFIG_92D_AP_MODE
+			start_ap_mode(padapter);
+#endif
+			break;
+		case NDIS802_11AUTOUNK:
+		case NDIS802_11INFRA_MAX:
+			break;
+		}
+	}
+
+	return true;
+}
+
+u8 rtw_set_802_11_disassociate(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_disassociate: rtw_indicate_disconnect\n"));
+
+		rtw_disassoc_cmd(padapter, 0, true);
+		rtw_indicate_disconnect(padapter);
+		rtw_free_assoc_resources(padapter, 1);
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	return true;
+}
+
+u8 rtw_set_802_11_bssid_list_scan(struct rtw_adapter *padapter, struct ndis_802_11_ssid *pssid, int ssid_max_num)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	u8	res = true;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("+rtw_set_802_11_bssid_list_scan(), fw_state=%x\n", get_fwstate(pmlmepriv)));
+
+	if (padapter == NULL) {
+		res = false;
+		goto exit;
+	}
+	if (padapter->hw_init_completed == false) {
+		res = false;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n=== rtw_set_802_11_bssid_list_scan:hw_init_completed== false===\n"));
+		goto exit;
+	}
+
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||
+	    (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)) {
+		/*  Scan or linking is in progress, do nothing. */
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));
+		res = true;
+
+		if (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING)) == true)
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));
+		else
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###pmlmepriv->sitesurveyctrl.traffic_busy== true\n\n"));
+	} else {
+		if (rtw_is_scan_deny(padapter)) {
+			DBG_8192D(FUNC_ADPT_FMT": scan deny\n", FUNC_ADPT_ARG(padapter));
+			indicate_wx_scan_complete_event(padapter);
+			return _SUCCESS;
+		}
+
+		spin_lock_bh(&pmlmepriv->lock);
+
+		res = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);
+
+		spin_unlock_bh(&pmlmepriv->lock);
+	}
+exit:
+
+	return res;
+}
+
+u8 rtw_set_802_11_authentication_mode(struct rtw_adapter *padapter, enum NDIS_802_11_AUTHENTICATION_MODE authmode)
+{
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	int res;
+	u8 ret;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_802_11_auth.mode(): mode=%x\n", authmode));
+
+	psecuritypriv->ndisauthtype = authmode;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+		 ("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype =%d",
+		 psecuritypriv->ndisauthtype));
+
+	if (psecuritypriv->ndisauthtype > 3)
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+
+	res = rtw_set_auth(padapter, psecuritypriv);
+
+	if (res == _SUCCESS)
+		ret = true;
+	else
+		ret = false;
+
+	return ret;
+}
+
+u8 rtw_set_802_11_add_wep(struct rtw_adapter *padapter, struct ndis_802_11_wep *wep)
+{
+	int		keyid, res;
+	struct security_priv *psecuritypriv = &(padapter->securitypriv);
+	u8		ret = _SUCCESS;
+
+	keyid = wep->KeyIndex & 0x3fffffff;
+
+	if (keyid >= 4) {
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MgntActrtw_set_802_11_add_wep:keyid>4=>fail\n"));
+		ret = false;
+		goto exit;
+	}
+
+	switch (wep->KeyLength) {
+	case 5:
+		psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength= 5\n"));
+		break;
+	case 13:
+		psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength= 13\n"));
+		break;
+	default:
+		psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength!= 5 or 13\n"));
+		break;
+	}
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_wep:befor memcpy, wep->KeyLength= 0x%x wep->KeyIndex = 0x%x  keyid =%x\n", wep->KeyLength, wep->KeyIndex, keyid));
+
+	memcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]), &(wep->KeyMaterial), wep->KeyLength);
+
+	psecuritypriv->dot11DefKeylen[keyid] = wep->KeyLength;
+
+	psecuritypriv->dot11PrivacyKeyIndex = keyid;
+
+	RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,
+		 ("rtw_set_802_11_add_wep:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",
+		 psecuritypriv->dot11DefKey[keyid].skey[0], psecuritypriv->dot11DefKey[keyid].skey[1], psecuritypriv->dot11DefKey[keyid].skey[2],
+		 psecuritypriv->dot11DefKey[keyid].skey[3], psecuritypriv->dot11DefKey[keyid].skey[4], psecuritypriv->dot11DefKey[keyid].skey[5],
+		 psecuritypriv->dot11DefKey[keyid].skey[6], psecuritypriv->dot11DefKey[keyid].skey[7], psecuritypriv->dot11DefKey[keyid].skey[8],
+		 psecuritypriv->dot11DefKey[keyid].skey[9], psecuritypriv->dot11DefKey[keyid].skey[10], psecuritypriv->dot11DefKey[keyid].skey[11],
+		 psecuritypriv->dot11DefKey[keyid].skey[12]));
+
+	res = rtw_set_key(padapter, psecuritypriv, keyid, 1);
+
+	if (res == _FAIL)
+		ret = false;
+exit:
+
+	return ret;
+}
+
+u8 rtw_set_802_11_remove_wep(struct rtw_adapter *padapter, u32 keyindex)
+{
+	u8 ret = _SUCCESS;
+
+	if (keyindex >= 0x80000000 || padapter == NULL) {
+		ret = false;
+		goto exit;
+	} else {
+		int res;
+		struct security_priv *psecuritypriv = &(padapter->securitypriv);
+		if (keyindex < 4) {
+			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
+
+			res = rtw_set_key(padapter, psecuritypriv, keyindex, 0);
+
+			psecuritypriv->dot11DefKeylen[keyindex] = 0;
+
+			if (res == _FAIL)
+				ret = _FAIL;
+		} else {
+			ret = _FAIL;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+u8 rtw_set_802_11_add_key(struct rtw_adapter *padapter, struct ndis_802_11_key *key)
+{
+	uint	encryptionalgo;
+	u8 *pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = false;
+	u8	bgrouptkey = false;/* can be remove later */
+	u8	ret = _SUCCESS;
+
+	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
+		/*  It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, */
+		/*  it must fail the request and return NDIS_STATUS_INVALID_DATA. */
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ", (int)(key->KeyIndex & 0x80000000) == 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000) > 0)[=%d]", (int)(key->KeyIndex & 0x40000000) > 0));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_set_802_11_add_key: key->KeyIndex =%d\n", (int)key->KeyIndex));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	if (key->KeyIndex & 0x40000000) {
+		/*  Pairwise key */
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
+
+		pbssid = get_bssid(&padapter->mlmepriv);
+		stainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);
+
+		if ((stainfo != NULL) && (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY:(stainfo != NULL) && (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\n"));
+			encryptionalgo = stainfo->dot118021XPrivacy;
+		} else {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: stainfo == NULL)||(adapter->securitypriv.dot11AuthAlgrthm!= dot11AuthAlgrthm_8021X)\n"));
+			encryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("rtw_set_802_11_add_key: (encryptionalgo ==%d)!\n", encryptionalgo));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("rtw_set_802_11_add_key: (adapter->securitypriv.dot11PrivacyAlgrthm ==%d)!\n",
+			 padapter->securitypriv.dot11PrivacyAlgrthm));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+			 ("rtw_set_802_11_add_key: (adapter->securitypriv.dot11AuthAlgrthm ==%d)!\n",
+			 padapter->securitypriv.dot11AuthAlgrthm));
+
+		if ((stainfo != NULL))
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 ("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy ==%d)!\n",
+				 stainfo->dot118021XPrivacy));
+
+		if (key->KeyIndex & 0x000000FF) {
+			/*  The key index is specified in the lower 8 bits by values of zero to 255. */
+			/*  The key index should be set to zero for a Pairwise key, and the driver should fail with */
+			/*  NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero */
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" key->KeyIndex & 0x000000FF.\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  check BSSID */
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MacAddr_isBcst(key->BSSID)\n"));
+			ret = false;
+			goto exit;
+		}
+
+		/*  Check key length for TKIP. */
+		/* if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32) */
+		if ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  Check key length for AES. */
+		if ((encryptionalgo == _AES_) && (key->KeyLength != 16)) {
+			/*  For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case. */
+			if (key->KeyLength == 32) {
+				key->KeyLength = 16;
+			} else {
+				ret = _FAIL;
+				goto exit;
+			}
+		}
+
+		/*  Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko. */
+		if ((encryptionalgo == _WEP40_ || encryptionalgo == _WEP104_) &&
+		    (key->KeyLength != 5 && key->KeyLength != 13)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		bgroup = false;
+
+		/*  Check the pairwise key. Added by Annie, 2005-07-06. */
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("[Pairwise Key set]\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key index: 0x%8x(0x%8x)\n", key->KeyIndex, (key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key Length: %d\n", key->KeyLength));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+	} else {
+		/*  Group key - KeyIndex(BIT30== 0) */
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
+
+		/*  when add wep key through add key and didn't assigned encryption type before */
+		if ((padapter->securitypriv.ndisauthtype <= 3) &&
+		    (padapter->securitypriv.dot118021XGrpPrivacy == 0)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 ("keylen=%d(adapter->securitypriv.dot11PrivacyAlgrthm =%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n",
+				 key->KeyLength, padapter->securitypriv.dot11PrivacyAlgrthm,
+				 padapter->securitypriv.dot118021XGrpPrivacy));
+
+			switch (key->KeyLength) {
+			case 5:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
+				break;
+			case 13:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
+				break;
+			default:
+				padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("adapter->securitypriv.dot11PrivacyAlgrthm = %x key->KeyLength=%u\n",
+					 padapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));
+				break;
+			}
+			encryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 (" adapter->securitypriv.dot11PrivacyAlgrthm =%x\n",
+				 padapter->securitypriv.dot11PrivacyAlgrthm));
+		} else {
+			encryptionalgo = padapter->securitypriv.dot118021XGrpPrivacy;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 ("(adapter->securitypriv.dot11PrivacyAlgrthm =%x )encryptionalgo(%x) = padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n",
+				 padapter->securitypriv.dot11PrivacyAlgrthm, encryptionalgo, padapter->securitypriv.dot118021XGrpPrivacy, key->KeyLength));
+		}
+
+		if ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE) == true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" IBSS but BSSID is not Broadcast Address.\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  Check key length for TKIP */
+		if ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
+			ret = _FAIL;
+			goto exit;
+
+		} else if (encryptionalgo == _AES_ && (key->KeyLength != 16 && key->KeyLength != 32)) {
+			/*  Check key length for AES */
+			/*  For NDTEST, we allow keylen= 32 in this case. 2005.01.27, by rcnjko. */
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03. */
+		if ((encryptionalgo ==  _AES_) && (key->KeyLength == 32)) {
+			key->KeyLength = 16;
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("AES key length changed: %u\n", key->KeyLength));
+		}
+
+		if (key->KeyIndex & 0x8000000) /* error ??? 0x8000_0000 */
+			bgrouptkey = true;
+
+		if ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE) == true) &&
+		    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == true))
+			bgrouptkey = true;
+
+		bgroup = true;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("[Group Key set]\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key index: 0x%8x(0x%8x)\n", key->KeyIndex, (key->KeyIndex&0x3)));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key Length: %d\n", key->KeyLength));
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));
+	}
+
+	/*  If WEP encryption algorithm, just call rtw_set_802_11_add_wep(). */
+	if ((padapter->securitypriv.dot11AuthAlgrthm != dot11AuthAlgrthm_8021X) && (encryptionalgo == _WEP40_ ||
+	    encryptionalgo == _WEP104_)) {
+		u32 keyindex;
+		u32 len = FIELD_OFFSET(struct ndis_802_11_key, KeyMaterial) + key->KeyLength;
+		struct ndis_802_11_wep *wep = &padapter->securitypriv.ndiswep;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));
+
+		wep->Length = len;
+		keyindex = key->KeyIndex&0x7fffffff;
+		wep->KeyIndex = keyindex;
+		wep->KeyLength = key->KeyLength;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY:Before memcpy\n"));
+
+		memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);
+		memcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
+
+		padapter->securitypriv.dot11DefKeylen[keyindex] = key->KeyLength;
+		padapter->securitypriv.dot11PrivacyKeyIndex = keyindex;
+
+		ret = rtw_set_802_11_add_wep(padapter, wep);
+
+		goto exit;
+	}
+
+	if (key->KeyIndex & 0x20000000) {
+		/*  SetRSC */
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
+		if (bgroup == true) {
+			unsigned long long keysrc = key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			memcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);
+		} else {
+			unsigned long long keysrc = key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			memcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);
+		}
+	}
+
+	/*  Indicate this key idx is used for TX */
+	/*  Save the key in KeyMaterial */
+	if (bgroup == true) { /*  Group transmit key */
+		int res;
+
+		if (bgrouptkey == true)
+			padapter->securitypriv.dot118021XGrpKeyid = (u8)key->KeyIndex;
+
+		if ((key->KeyIndex&0x3) == 0) {
+			ret = _FAIL;
+			goto exit;
+		}
+
+		memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
+		memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
+		memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);
+
+		if ((key->KeyIndex & 0x10000000)) {
+			memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
+			memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 ("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+
+		} else {
+			memcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
+			memcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
+
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+				 ("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],
+				 padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));
+			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));
+		}
+
+		/* set group key by index */
+		memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);
+
+		key->KeyIndex = key->KeyIndex & 0x03;
+
+		padapter->securitypriv.binstallGrpkey = true;
+
+		padapter->securitypriv.bcheck_grpkey = false;
+
+		RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("reset group key"));
+
+		res = rtw_set_key(padapter, &padapter->securitypriv, key->KeyIndex, 1);
+
+		if (res == _FAIL)
+			ret = _FAIL;
+
+		goto exit;
+
+	} else { /*  Pairwise Key */
+		u8 res;
+
+		pbssid = get_bssid(&padapter->mlmepriv);
+		stainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);
+
+		if (stainfo != NULL) {
+			memset(&stainfo->dot118021x_UncstKey, 0, 16);/*  clear keybuffer */
+
+			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
+
+			if (encryptionalgo == _TKIP_) {
+				padapter->securitypriv.busetkipkey = false;
+
+				/* _set_timer(&padapter->securitypriv.tkip_timer, 50); */
+
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n ========== _set_timer\n"));
+
+				/*  if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255] */
+				if ((key->KeyIndex & 0x10000000)) {
+					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
+					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
+
+				} else {
+					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);
+					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
+				}
+			}
+
+			/* Set key to CAM through H2C command */
+			if (bgrouptkey) { /* never go to here */
+				res = rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
+			} else {
+				res = rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, true);
+				RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,
+					 ("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));
+			}
+
+			if (res == false)
+				ret = _FAIL;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+u8 rtw_set_802_11_remove_key(struct rtw_adapter *padapter,
+			     struct ndis_802_11_remove_key *key)
+{
+	u8 *pbssid;
+	struct sta_info *stainfo;
+	u8	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false : true;
+	u8	keyIndex = (u8)key->KeyIndex & 0x03;
+	u8	ret = _SUCCESS;
+
+	if ((key->KeyIndex & 0xbffffffc) > 0) {
+		ret = _FAIL;
+		goto exit;
+	}
+	if (bgroup == true) {
+		/*  clear group key by index */
+
+		memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
+
+		/*  \todo Send a H2C Command to Firmware for removing this Key in CAM Entry. */
+	} else {
+		pbssid = get_bssid(&padapter->mlmepriv);
+		stainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);
+		if (stainfo != NULL) {
+			/*  clear key by BSSID */
+			memset(&stainfo->dot118021x_UncstKey, 0, 16);
+			/*  \todo Send a H2C Command to Firmware for disable this Key in CAM Entry. */
+		} else {
+			ret = _FAIL;
+			goto exit;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+/*
+* rtw_get_cur_max_rate -
+* @adapter: pointer to _adapter structure
+*
+* Return 0 or 100Kbps
+*/
+u16 rtw_get_cur_max_rate(struct rtw_adapter *adapter)
+{
+	int	i = 0;
+	u8	*p;
+	u16	rate = 0, max_rate = 0;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+	struct wlan_bssid_ex  *pcur_bss = &pmlmepriv->cur_network.network;
+#ifdef CONFIG_80211N_HT
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	u8	rf_type = 0;
+	u8	bw_40MHz = 0, short_GI_20 = 0, short_GI_40 = 0;
+	u16	mcs_rate = 0;
+	u32	ht_ielen = 0;
+#endif
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true))
+		return 0;
+
+#ifdef CONFIG_80211N_HT
+	if (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N|WIRELESS_11_5N)) {
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if (p && ht_ielen > 0) {
+			pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+
+			memcpy(&mcs_rate, pht_capie->supp_mcs_set, 2);
+
+			/* cur_bwmod is updated by beacon, pmlmeinfo is updated by association response */
+			bw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1 : 0;
+
+			short_GI_20 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_20) ? 1 : 0;
+			short_GI_40 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_40) ? 1 : 0;
+
+			rtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+			max_rate = rtw_mcs_rate(
+				rf_type,
+				bw_40MHz & (pregistrypriv->cbw40_enable),
+				short_GI_20,
+				short_GI_40,
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate
+			);
+		}
+	} else
+#endif /* CONFIG_80211N_HT */
+	{
+		while ((pcur_bss->SupportedRates[i] != 0) && (pcur_bss->SupportedRates[i] != 0xFF)) {
+			rate = pcur_bss->SupportedRates[i]&0x7F;
+			if (rate > max_rate)
+				max_rate = rate;
+			i++;
+		}
+
+		max_rate = max_rate*10/2;
+	}
+
+	return max_rate;
+}
+
+/*
+* rtw_set_scan_mode -
+* @adapter: pointer to _adapter structure
+* @scan_mode:
+*
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_scan_mode(struct rtw_adapter *adapter, enum RT_SCAN_TYPE scan_mode)
+{
+	if (scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
+		return _FAIL;
+
+	adapter->mlmepriv.scan_mode = scan_mode;
+
+	return _SUCCESS;
+}
+
+/*
+* rtw_set_channel_plan -
+* @adapter: pointer to _adapter structure
+* @channel_plan:
+*
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_channel_plan(struct rtw_adapter *adapter, u8 channel_plan)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	/* handle by cmd_thread to sync with scan operation */
+	return rtw_set_chplan_cmd(adapter, channel_plan, 1);
+}
+
+/*
+* rtw_set_country -
+* @adapter: pointer to _adapter structure
+* @country_code: string of country code
+*
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_country(struct rtw_adapter *adapter, const char *country_code)
+{
+	int channel_plan = RT_CHANNEL_DOMAIN_WORLD_WIDE_5G;
+
+	DBG_8192D("%s country_code:%s\n", __func__, country_code);
+
+	/* TODO: should have a table to match country code and RT_CHANNEL_DOMAIN */
+	/* TODO: should consider 2-character and 3-character country code */
+	if (0 == strcmp(country_code, "US"))
+		channel_plan = RT_CHANNEL_DOMAIN_FCC;
+	else if (0 == strcmp(country_code, "EU"))
+		channel_plan = RT_CHANNEL_DOMAIN_ETSI;
+	else if (0 == strcmp(country_code, "JP"))
+		channel_plan = RT_CHANNEL_DOMAIN_MKK;
+	else if (0 == strcmp(country_code, "CN"))
+		channel_plan = RT_CHANNEL_DOMAIN_CHINA;
+	else
+		DBG_8192D("%s unknown country_code:%s\n", __func__, country_code);
+
+	return rtw_set_channel_plan(adapter, channel_plan);
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_mlme.c b/drivers/net/wireless/rtl8192du/core/rtw_mlme.c
new file mode 100644
index 0000000..70405b4
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_mlme.c
@@ -0,0 +1,3015 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_MLME_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_intf.h>
+#include <mlme_osdep.h>
+#include <sta_info.h>
+#include <wifi.h>
+#include <wlan_bssdef.h>
+#include <rtw_ioctl_set.h>
+#include <mlme_osdep.h>
+#include <usb_osintf.h>
+#include <rtw_mlme.h>
+#include <linux/vmalloc.h>
+
+extern unsigned char MCS_rate_2R[16];
+extern unsigned char MCS_rate_1R[16];
+
+int _rtw_init_mlme_priv(struct rtw_adapter *padapter)
+{
+	int i;
+	u8 *pbuf;
+	struct wlan_network *pnetwork;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	int res = _SUCCESS;
+
+	/*  We don't need to memset padapter->XXX to zero,
+	 * because adapter is allocated by vzalloc(). */
+
+	pmlmepriv->nic_hdl = (u8 *)padapter;
+
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode = NDIS802_11AUTOUNK;
+	pmlmepriv->scan_mode = SCAN_ACTIVE;	/*  1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff) */
+
+	_rtw_spinlock_init(&(pmlmepriv->lock));
+	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
+	_rtw_init_queue(&(pmlmepriv->scanned_queue));
+
+	set_scanned_network_val(pmlmepriv, 0);
+
+	memset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));
+
+	pbuf = vzalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+
+	if (pbuf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	pmlmepriv->free_bss_buf = pbuf;
+
+	pnetwork = (struct wlan_network *)pbuf;
+
+	for (i = 0; i < MAX_BSS_CNT; i++) {
+		INIT_LIST_HEAD(&(pnetwork->list));
+
+		rtw_list_insert_tail(&(pnetwork->list),
+				     &(pmlmepriv->free_bss_pool.queue));
+
+		pnetwork++;
+	}
+
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+
+	rtw_clear_scan_deny(padapter);
+
+	rtw_init_mlme_timer(padapter);
+
+exit:
+
+	return res;
+}
+
+static void rtw_mfree_mlme_priv_lock(struct mlme_priv *pmlmepriv)
+{
+	_rtw_spinlock_free(&pmlmepriv->lock);
+	_rtw_spinlock_free(&(pmlmepriv->free_bss_pool.lock));
+	_rtw_spinlock_free(&(pmlmepriv->scanned_queue.lock));
+}
+
+static void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)
+{
+	if (*ppie) {
+		kfree(*ppie);
+		*plen = 0;
+		*ppie = NULL;
+	}
+}
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
+{
+#if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	rtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);
+	rtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_beacon_ie,
+			      &pmlmepriv->wps_beacon_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie,
+			      &pmlmepriv->wps_probe_req_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie,
+			      &pmlmepriv->wps_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie,
+			      &pmlmepriv->wps_assoc_resp_ie_len);
+
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie,
+			      &pmlmepriv->p2p_beacon_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie,
+			      &pmlmepriv->p2p_probe_req_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie,
+			      &pmlmepriv->p2p_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_go_probe_resp_ie,
+			      &pmlmepriv->p2p_go_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie,
+			      &pmlmepriv->p2p_assoc_req_ie_len);
+#endif
+}
+
+void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
+{
+
+	rtw_free_mlme_priv_ie_data(pmlmepriv);
+
+	if (pmlmepriv) {
+		rtw_mfree_mlme_priv_lock(pmlmepriv);
+
+		if (pmlmepriv->free_bss_buf)
+			vfree(pmlmepriv->free_bss_buf);
+	}
+
+}
+
+int _rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
+{
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	spin_lock_bh(&queue->lock);
+
+	rtw_list_insert_tail(&pnetwork->list, &queue->queue);
+
+	spin_unlock_bh(&queue->lock);
+
+exit:
+
+	return _SUCCESS;
+}
+
+struct wlan_network *_rtw_dequeue_network(struct __queue *queue)
+{
+	struct wlan_network *pnetwork;
+
+	spin_lock_bh(&queue->lock);
+
+	if (_rtw_queue_empty(queue) == true) {
+		pnetwork = NULL;
+	} else {
+		pnetwork =
+		    container_of((&queue->queue)->next, struct wlan_network,
+				   list);
+
+		list_del_init(&(pnetwork->list));
+	}
+
+	spin_unlock_bh(&queue->lock);
+
+	return pnetwork;
+}
+
+struct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv)
+{				/* struct __queue *free_queue) */
+	struct wlan_network *pnetwork;
+	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct list_head *plist = NULL;
+
+	spin_lock_bh(&free_queue->lock);
+
+	if (_rtw_queue_empty(free_queue) == true) {
+		pnetwork = NULL;
+		goto exit;
+	}
+	plist = (&free_queue->queue)->next;
+
+	pnetwork = container_of(plist, struct wlan_network, list);
+
+	list_del_init(&pnetwork->list);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("_rtw_alloc_network: ptr=%p\n", plist));
+	pnetwork->network_type = 0;
+	pnetwork->fixed = false;
+	pnetwork->last_scanned = rtw_get_current_time();
+	pnetwork->aid = 0;
+	pnetwork->join_res = 0;
+
+	pmlmepriv->num_of_scanned++;
+
+exit:
+	spin_unlock_bh(&free_queue->lock);
+
+	return pnetwork;
+}
+
+void _rtw_free_network(struct mlme_priv *pmlmepriv,
+		       struct wlan_network *pnetwork, u8 isfreeall)
+{
+	u32 curr_time, delta_time;
+	u32 lifetime = SCANQUEUE_LIFETIME;
+	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		return;
+
+	if (pnetwork->fixed == true)
+		return;
+
+	curr_time = rtw_get_current_time();
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		lifetime = 1;
+
+	if (!isfreeall) {
+		delta_time = (curr_time - pnetwork->last_scanned) / HZ;
+
+		if (delta_time < lifetime)	/*  unit:sec */
+			return;
+	}
+
+	spin_lock_bh(&free_queue->lock);
+
+	list_del_init(&(pnetwork->list));
+
+	rtw_list_insert_tail(&(pnetwork->list), &(free_queue->queue));
+
+	pmlmepriv->num_of_scanned--;
+
+	spin_unlock_bh(&free_queue->lock);
+}
+
+void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
+			      struct wlan_network *pnetwork)
+{
+	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		return;
+
+	if (pnetwork->fixed == true)
+		return;
+
+	list_del_init(&(pnetwork->list));
+
+	rtw_list_insert_tail(&(pnetwork->list), get_list_head(free_queue));
+
+	pmlmepriv->num_of_scanned--;
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be called under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network *_rtw_find_network(struct __queue *scanned_queue, u8 *addr)
+{
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork = NULL;
+	u8 zero_addr[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+
+	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)) {
+		pnetwork = NULL;
+		goto exit;
+	}
+
+	/* spin_lock_bh(&scanned_queue->lock); */
+
+	phead = get_list_head(scanned_queue);
+	plist = phead->next;
+
+	while (plist != phead) {
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) ==
+		    true)
+			break;
+
+		plist = plist->next;
+	}
+
+	if (plist == phead)
+		pnetwork = NULL;
+
+	/* spin_unlock_bh(&scanned_queue->lock); */
+
+exit:
+
+	return pnetwork;
+}
+
+void _rtw_free_network_queue(struct rtw_adapter *padapter, u8 isfreeall)
+{
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct __queue *scanned_queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_bh(&scanned_queue->lock);
+
+	phead = get_list_head(scanned_queue);
+	plist = phead->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		plist = plist->next;
+
+		_rtw_free_network(pmlmepriv, pnetwork, isfreeall);
+	}
+
+	spin_unlock_bh(&scanned_queue->lock);
+
+}
+
+int rtw_if_up(struct rtw_adapter *padapter)
+{
+	int res;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved ||
+	    (check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false)) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+			 ("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+			  padapter->bDriverStopped,
+			  padapter->bSurpriseRemoved));
+		res = false;
+	} else {
+		res = true;
+	}
+
+	return res;
+}
+
+void rtw_generate_random_ibss(u8 *pibss)
+{
+	u32 curtime = rtw_get_current_time();
+
+	pibss[0] = 0x02;	/* in ad-hoc mode bit1 must set to 1 */
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (u8) (curtime & 0xff);	/* p[0]; */
+	pibss[4] = (u8) ((curtime >> 8) & 0xff);	/* p[1]; */
+	pibss[5] = (u8) ((curtime >> 16) & 0xff);	/* p[2]; */
+
+	return;
+}
+
+u8 *rtw_get_capability_from_ie(u8 *ie)
+{
+	return ie + 10;
+}
+
+u16 rtw_get_capability(struct wlan_bssid_ex *bss)
+{
+	__le16 val;
+
+	memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
+
+	return le16_to_cpu(val);
+}
+
+u8 *rtw_get_timestampe_from_ie(u8 *ie)
+{
+	return ie + 0;
+}
+
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
+{
+	return ie + 8;
+}
+
+int rtw_init_mlme_priv(struct rtw_adapter *padapter)
+{				/* struct mlme_priv *pmlmepriv) */
+	int res;
+
+	res = _rtw_init_mlme_priv(padapter);	/*  (pmlmepriv); */
+
+	return res;
+}
+
+void rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
+{
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("rtw_free_mlme_priv\n"));
+	_rtw_free_mlme_priv(pmlmepriv);
+
+}
+
+static int rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
+{
+	int res;
+
+	res = _rtw_enqueue_network(queue, pnetwork);
+
+	return res;
+}
+
+static struct wlan_network *rtw_dequeue_network(struct __queue *queue)
+{
+	struct wlan_network *pnetwork;
+
+	pnetwork = _rtw_dequeue_network(queue);
+
+	return pnetwork;
+}
+
+static struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv)
+{
+	struct wlan_network *pnetwork;
+
+	pnetwork = _rtw_alloc_network(pmlmepriv);
+
+	return pnetwork;
+}
+
+static void rtw_free_network(struct mlme_priv *pmlmepriv,
+			     struct wlan_network *pnetwork, u8 is_freeall)
+{
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("rtw_free_network==> ssid = %s\n\n",
+		  pnetwork->network.Ssid.Ssid));
+	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
+
+}
+
+static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv,
+				    struct wlan_network *pnetwork)
+{
+
+	/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s\n\n" , pnetwork->network.Ssid.Ssid)); */
+	_rtw_free_network_nolock(pmlmepriv, pnetwork);
+
+}
+
+void rtw_free_network_queue(struct rtw_adapter *dev, u8 isfreeall)
+{
+
+	_rtw_free_network_queue(dev, isfreeall);
+
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be called under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network *rtw_find_network(struct __queue *scanned_queue, u8 *addr)
+{
+	struct wlan_network *pnetwork = _rtw_find_network(scanned_queue, addr);
+
+	return pnetwork;
+}
+
+int rtw_is_same_ibss(struct rtw_adapter *adapter, struct wlan_network *pnetwork)
+{
+	int ret = true;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if ((psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_) &&
+	    (pnetwork->network.Privacy == 0)) {
+		ret = false;
+	} else if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_) &&
+		   (pnetwork->network.Privacy == 1)) {
+		ret = false;
+	} else {
+		ret = true;
+	}
+
+	return ret;
+}
+
+static inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)
+{
+	return (a->Ssid.SsidLength == b->Ssid.SsidLength) &&
+		_rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid,
+			    a->Ssid.SsidLength) == true;
+}
+
+int is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst)
+{
+	u16 s_cap, d_cap;
+	__le16 le_scap, le_dcap;
+
+	memcpy((u8 *)&le_scap, rtw_get_capability_from_ie(src->IEs), 2);
+	memcpy((u8 *)&le_dcap, rtw_get_capability_from_ie(dst->IEs), 2);
+
+	s_cap = le16_to_cpu(le_scap);
+	d_cap = le16_to_cpu(le_dcap);
+
+	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+		((_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
+		((_rtw_memcmp
+		  (src->Ssid.Ssid, dst->Ssid.Ssid,
+		   src->Ssid.SsidLength)) == true) &&
+		   ((s_cap & WLAN_CAPABILITY_IBSS) ==
+		    (d_cap & WLAN_CAPABILITY_IBSS)) &&
+		   ((s_cap & WLAN_CAPABILITY_BSS) ==
+		    (d_cap & WLAN_CAPABILITY_BSS)));
+}
+
+struct wlan_network *rtw_get_oldest_wlan_network(struct __queue *scanned_queue)
+{
+	struct list_head *plist, *phead;
+	struct wlan_network *pwlan = NULL;
+	struct wlan_network *oldest = NULL;
+
+	phead = get_list_head(scanned_queue);
+
+	plist = phead->next;
+
+	while (1) {
+		if (rtw_end_of_queue_search(phead, plist) == true)
+			break;
+
+		pwlan = container_of(plist, struct wlan_network, list);
+
+		if (pwlan->fixed != true) {
+			if (oldest == NULL ||
+			    time_after(oldest->last_scanned,
+				       pwlan->last_scanned))
+				oldest = pwlan;
+		}
+
+		plist = plist->next;
+	}
+
+	return oldest;
+}
+
+static void update_network(struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src,
+			   struct rtw_adapter *padapter, bool update_ie)
+{
+	u8 ss_ori = dst->PhyInfo.SignalStrength;
+	u8 sq_ori = dst->PhyInfo.SignalQuality;
+	long rssi_ori = dst->Rssi;
+
+	u8 ss_smp = src->PhyInfo.SignalStrength;
+	u8 sq_smp = src->PhyInfo.SignalQuality;
+	long rssi_smp = src->Rssi;
+
+	u8 ss_final;
+	u8 sq_final;
+	long rssi_final;
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	rtw_hal_antdiv_rssi_compared(padapter, dst, src);	/* this will update src.Rssi, need consider again */
+#endif
+
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
+	if (strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+		DBG_8192D
+		    ("%s %s(%pM, ch%u) ss_ori:%3u, sq_ori:%3u, rssi_ori:%3ld, ss_smp:%3u, sq_smp:%3u, rssi_smp:%3ld\n",
+		     __func__, src->Ssid.Ssid, src->MacAddress,
+		     src->Configuration.DSConfig, ss_ori, sq_ori, rssi_ori,
+		     ss_smp, sq_smp, rssi_smp);
+	}
+#endif
+
+	/* The rule below is 1/5 for sample value, 4/5 for history value */
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) &&
+	    is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {
+		/* Take the recvpriv's value for the connected AP */
+		ss_final = padapter->recvpriv.signal_strength;
+		sq_final = padapter->recvpriv.signal_qual;
+		/* the rssi value here is undecorated, and will be used for antenna diversity */
+		if (sq_smp != 101)	/* from the right channel */
+			rssi_final = (src->Rssi + dst->Rssi * 4) / 5;
+		else
+			rssi_final = rssi_ori;
+	} else {
+		if (sq_smp != 101) {	/* from the right channel */
+			ss_final =
+			    ((u32) (src->PhyInfo.SignalStrength) +
+			     (u32) (dst->PhyInfo.SignalStrength) * 4) / 5;
+			sq_final =
+			    ((u32) (src->PhyInfo.SignalQuality) +
+			     (u32) (dst->PhyInfo.SignalQuality) * 4) / 5;
+			rssi_final = (src->Rssi + dst->Rssi * 4) / 5;
+		} else {
+			/* bss info not receving from the right channel, use the original RX signal infos */
+			ss_final = dst->PhyInfo.SignalStrength;
+			sq_final = dst->PhyInfo.SignalQuality;
+			rssi_final = dst->Rssi;
+		}
+	}
+
+	if (update_ie)
+		memcpy((u8 *)dst, (u8 *)src, get_wlan_bssid_ex_sz(src));
+
+	dst->PhyInfo.SignalStrength = ss_final;
+	dst->PhyInfo.SignalQuality = sq_final;
+	dst->Rssi = rssi_final;
+
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
+	if (strcmp(dst->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+		DBG_8192D
+		    ("%s %s(%pM), SignalStrength:%u, SignalQuality:%u, RawRSSI:%ld\n",
+		     __func__, dst->Ssid.Ssid, dst->MacAddress,
+		     dst->PhyInfo.SignalStrength, dst->PhyInfo.SignalQuality,
+		     dst->Rssi);
+	}
+#endif
+
+}
+
+static void update_current_network(struct rtw_adapter *adapter,
+				   struct wlan_bssid_ex *pnetwork)
+{
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&
+	    (is_same_network(&(pmlmepriv->cur_network.network), pnetwork))) {
+		/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n"); */
+
+		/* if (pmlmepriv->cur_network.network.IELength<= pnetwork->IELength) */
+		{
+			update_network(&(pmlmepriv->cur_network.network),
+				       pnetwork, adapter, true);
+			rtw_update_protection(adapter,
+					      (pmlmepriv->cur_network.network.
+					       IEs) +
+					      sizeof(struct
+						     ndis_802_11_fixed_ies),
+					      pmlmepriv->cur_network.network.
+					      IELength);
+		}
+	}
+
+}
+
+/*
+
+Caller must hold pmlmepriv->lock first.
+
+*/
+void rtw_update_scanned_network(struct rtw_adapter *adapter,
+				struct wlan_bssid_ex *target)
+{
+	struct list_head *plist, *phead;
+	u32 bssid_ex_sz;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *oldest = NULL;
+
+	spin_lock_bh(&queue->lock);
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	while (1) {
+		if (rtw_end_of_queue_search(phead, plist) == true)
+			break;
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		if ((unsigned long)(pnetwork) < 0x7ffffff) {
+		}
+
+		if (is_same_network(&(pnetwork->network), target))
+			break;
+
+		if ((oldest == ((struct wlan_network *)0)) ||
+		    time_after(oldest->last_scanned, pnetwork->last_scanned))
+			oldest = pnetwork;
+		plist = plist->next;
+	}
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (rtw_end_of_queue_search(phead, plist) == true) {
+		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == true) {
+			/* If there are no more slots, expire the oldest */
+			/* list_del_init(&oldest->list); */
+			pnetwork = oldest;
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA,
+					    &(target->PhyInfo.Optimum_antenna));
+#endif
+			memcpy(&(pnetwork->network), target,
+			       get_wlan_bssid_ex_sz(target));
+			/*  variable initialize */
+			pnetwork->fixed = false;
+			pnetwork->last_scanned = rtw_get_current_time();
+
+			pnetwork->network_type = 0;
+			pnetwork->aid = 0;
+			pnetwork->join_res = 0;
+
+			/* bss info not receving from the right channel */
+			if (pnetwork->network.PhyInfo.SignalQuality == 101)
+				pnetwork->network.PhyInfo.SignalQuality = 0;
+		} else {
+			/* Otherwise just pull from the free list */
+
+			pnetwork = rtw_alloc_network(pmlmepriv);	/*  will update scan_time */
+
+			if (pnetwork == NULL) {
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+					 ("\n\n\nsomething wrong here\n\n\n"));
+				goto exit;
+			}
+
+			bssid_ex_sz = get_wlan_bssid_ex_sz(target);
+			target->Length = bssid_ex_sz;
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			/* target->PhyInfo.Optimum_antenna = pHalData->CurAntenna; */
+			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA,
+					    &(target->PhyInfo.Optimum_antenna));
+#endif
+			memcpy(&(pnetwork->network), target, bssid_ex_sz);
+
+			pnetwork->last_scanned = rtw_get_current_time();
+
+			/* bss info not receving from the right channel */
+			if (pnetwork->network.PhyInfo.SignalQuality == 101)
+				pnetwork->network.PhyInfo.SignalQuality = 0;
+
+			rtw_list_insert_tail(&(pnetwork->list),
+					     &(queue->queue));
+		}
+	} else {
+		/* we have an entry and we are going to update it. But this entry may
+		 * be already expired. In this case we do the same as we found a new
+		 * net and call the new_net handler
+		 */
+		bool update_ie = true;
+
+		pnetwork->last_scanned = rtw_get_current_time();
+
+		/* target.Reserved[0]==1, means that scaned network is a bcn frame. */
+		if ((pnetwork->network.IELength > target->IELength) &&
+		    (target->Reserved[0] == 1))
+			update_ie = false;
+
+		update_network(&(pnetwork->network), target, adapter,
+			       update_ie);
+	}
+
+exit:
+	spin_unlock_bh(&queue->lock);
+
+}
+
+static void rtw_add_network(struct rtw_adapter *adapter,
+			    struct wlan_bssid_ex *pnetwork)
+{
+	struct mlme_priv *pmlmepriv =
+	    &(((struct rtw_adapter *)adapter)->mlmepriv);
+
+	update_current_network(adapter, pnetwork);
+
+	rtw_update_scanned_network(adapter, pnetwork);
+}
+
+/* select the desired network based on the capability of the (i)bss. */
+/*  check items: (1) security */
+/*			   (2) network_type */
+/*			   (3) WMM */
+/*			   (4) HT */
+/*                      (5) others */
+static int rtw_is_desired_network(struct rtw_adapter *adapter,
+				  struct wlan_network *pnetwork)
+{
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u32 desired_encmode;
+	u32 privacy;
+
+	/* u8 wps_ie[512]; */
+	uint wps_ielen;
+
+	int bselected = true;
+
+	desired_encmode = psecuritypriv->ndisencryptstatus;
+	privacy = pnetwork->network.Privacy;
+
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {
+		if (rtw_get_wps_ie
+		    (pnetwork->network.IEs + _FIXED_IE_LENGTH_,
+		     pnetwork->network.IELength - _FIXED_IE_LENGTH_, NULL,
+		     &wps_ielen) != NULL) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+	if (adapter->registrypriv.wifi_spec == 1) {	/* for  correct flow of 8021X  to do.... */
+		if ((desired_encmode == NDIS802_11ENCRYPTION_DISABLED) && (privacy != 0))
+			bselected = false;
+	}
+
+	if ((desired_encmode != NDIS802_11ENCRYPTION_DISABLED) && (privacy == 0)) {
+		DBG_8192D("desired_encmode: %d, privacy: %d\n", desired_encmode,
+			  privacy);
+		bselected = false;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {
+		if (pnetwork->network.InfrastructureMode !=
+		    pmlmepriv->cur_network.network.InfrastructureMode)
+			bselected = false;
+	}
+
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void rtw_atimdone_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("receive atimdone_evet\n"));
+
+	return;
+}
+
+void rtw_survey_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+	u32 len;
+	struct wlan_bssid_ex *pnetwork;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+
+	pnetwork = (struct wlan_bssid_ex *)pbuf;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("rtw_survey_event_callback, ssid=%s\n", pnetwork->Ssid.Ssid));
+
+	len = get_wlan_bssid_ex_sz(pnetwork);
+	if (len > (sizeof(struct wlan_bssid_ex))) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("\n ****rtw_survey_event_callback: return a wrong bss ***\n"));
+		return;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	/*  update IBSS_network 's timestamp */
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {
+		if (_rtw_memcmp
+		    (&(pmlmepriv->cur_network.network.MacAddress),
+		     pnetwork->MacAddress, ETH_ALEN)) {
+			struct wlan_network *ibss_wlan = NULL;
+
+			memcpy(pmlmepriv->cur_network.network.IEs,
+			       pnetwork->IEs, 8);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			ibss_wlan =
+			    rtw_find_network(&pmlmepriv->scanned_queue,
+					     pnetwork->MacAddress);
+			if (ibss_wlan) {
+				memcpy(ibss_wlan->network.IEs, pnetwork->IEs,
+				       8);
+				spin_unlock_bh(&
+					       (pmlmepriv->scanned_queue.lock));
+				goto exit;
+			}
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		}
+	}
+
+	/*  lock pmlmepriv->lock when you accessing network_q */
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false) {
+		if (pnetwork->Ssid.Ssid[0] == 0) {
+			pnetwork->Ssid.SsidLength = 0;
+		}
+		rtw_add_network(adapter, pnetwork);
+	}
+
+exit:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	return;
+}
+
+void rtw_surveydone_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+#ifdef CONFIG_MLME_EXT
+
+	mlmeext_surveydone_event_callback(adapter);
+
+#endif
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (pmlmepriv->wps_probe_req_ie) {
+		u32 free_len = pmlmepriv->wps_probe_req_ie_len;
+		pmlmepriv->wps_probe_req_ie_len = 0;
+		kfree(pmlmepriv->wps_probe_req_ie);
+		pmlmepriv->wps_probe_req_ie = NULL;
+	}
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("rtw_surveydone_event_callback: fw_state:%x\n\n",
+		  get_fwstate(pmlmepriv)));
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		u8 timer_cancelled;
+
+		_cancel_timer(&pmlmepriv->scan_to_timer, &timer_cancelled);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("nic status =%x, survey done event comes too late!\n",
+			  get_fwstate(pmlmepriv)));
+	}
+	rtw_set_signal_stat_timer(&adapter->recvpriv);
+
+	if (pmlmepriv->to_join == true) {
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == false) {
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+				if (rtw_select_and_join_from_scanned_queue
+				    (pmlmepriv) == _SUCCESS) {
+					_set_timer(&pmlmepriv->assoc_timer,
+						   MAX_JOIN_TIMEOUT);
+				} else {
+					struct wlan_bssid_ex *pdev_network =
+					    &(adapter->registrypriv.
+					      dev_network);
+					u8 *pibss =
+					    adapter->registrypriv.dev_network.
+					    MacAddress;
+
+					_clr_fwstate_(pmlmepriv,
+						      _FW_UNDER_SURVEY);
+
+					RT_TRACE(_module_rtl871x_mlme_c_,
+						 _drv_err_,
+						 ("switching to adhoc master\n"));
+
+					memset(&pdev_network->Ssid, 0,
+					       sizeof(struct ndis_802_11_ssid));
+					memcpy(&pdev_network->Ssid,
+					       &pmlmepriv->assoc_ssid,
+					       sizeof(struct ndis_802_11_ssid));
+
+					rtw_update_registrypriv_dev_network
+					    (adapter);
+					rtw_generate_random_ibss(pibss);
+
+					pmlmepriv->fw_state =
+					    WIFI_ADHOC_MASTER_STATE;
+
+					if (rtw_createbss_cmd(adapter) !=
+					    _SUCCESS) {
+						RT_TRACE
+						    (_module_rtl871x_mlme_c_,
+						     _drv_err_,
+						     ("Error=>rtw_createbss_cmd status FAIL\n"));
+					}
+
+					pmlmepriv->to_join = false;
+				}
+			}
+		} else {
+			int s_ret;
+			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+			pmlmepriv->to_join = false;
+			s_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);
+			if (_SUCCESS == s_ret) {
+				_set_timer(&pmlmepriv->assoc_timer,
+					   MAX_JOIN_TIMEOUT);
+			} else if (s_ret == 2) {	/* there is no need to wait for join */
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+				rtw_indicate_connect(adapter);
+			} else {
+				DBG_8192D
+				    ("try_to_join, but select scanning queue fail, to_roaming:%d\n",
+				     rtw_to_roaming(adapter));
+#ifdef CONFIG_LAYER2_ROAMING
+				if (rtw_to_roaming(adapter) != 0) {
+					if (--pmlmepriv->to_roaming == 0 || _SUCCESS !=
+					    rtw_sitesurvey_cmd(adapter,
+							       &pmlmepriv->
+							       assoc_ssid, 1,
+							       NULL, 0)
+					    ) {
+						rtw_set_roaming(adapter, 0);
+						rtw_free_assoc_resources
+						    (adapter, 1);
+						rtw_indicate_disconnect
+						    (adapter);
+					} else {
+						pmlmepriv->to_join = true;
+					}
+				}
+#endif
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+			}
+		}
+	}
+
+	indicate_wx_scan_complete_event(adapter);
+	/* DBG_8192D("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time)); */
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_os_xmit_schedule(adapter);
+#ifdef CONFIG_CONCURRENT_MODE
+	rtw_os_xmit_schedule(adapter->pbuddy_adapter);
+#endif
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	dc_resume_xmit(adapter);
+#endif
+
+#ifdef CONFIG_DRVEXT_MODULE_WSC
+	drvext_surveydone_callback(&adapter->drvextpriv);
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	{
+		struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+		if (pmlmeext->sitesurvey_res.bss_cnt == 0) {
+			rtw_hal_sreset_reset(adapter);
+		}
+	}
+#endif
+
+	rtw_cfg80211_surveydone_event_callback(adapter);
+}
+
+static void free_scanqueue(struct mlme_priv *pmlmepriv)
+{
+	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct __queue *scan_queue = &pmlmepriv->scanned_queue;
+	struct list_head *plist, *phead, *ptemp;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));
+	spin_lock_bh(&scan_queue->lock);
+	spin_lock_bh(&free_queue->lock);
+
+	phead = get_list_head(scan_queue);
+	plist = phead->next;
+
+	while (plist != phead) {
+		ptemp = plist->next;
+		list_del_init(plist);
+		rtw_list_insert_tail(plist, &free_queue->queue);
+		plist = ptemp;
+		pmlmepriv->num_of_scanned--;
+	}
+
+	spin_unlock_bh(&free_queue->lock);
+	spin_unlock_bh(&scan_queue->lock);
+
+}
+
+/*
+*rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
+*/
+void rtw_free_assoc_resources(struct rtw_adapter *adapter,
+			      int lock_scanned_queue)
+{
+	struct wlan_network *pwlan = NULL;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+rtw_free_assoc_resources\n"));
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("tgt_network->network.MacAddress=%pM ssid=%s\n",
+		  tgt_network->network.MacAddress,
+		  tgt_network->network.Ssid.Ssid));
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE)) {
+		struct sta_info *psta;
+
+		psta =
+		    rtw_get_stainfo(&adapter->stapriv,
+				    tgt_network->network.MacAddress);
+
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(adapter, psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+	}
+
+	if (check_fwstate
+	    (pmlmepriv,
+	     WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE)) {
+		struct sta_info *psta;
+
+		rtw_free_all_stainfo(adapter);
+
+		psta = rtw_get_bcmc_stainfo(adapter);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(adapter, psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+		rtw_init_bcmc_stainfo(adapter);
+	}
+
+	if (lock_scanned_queue)
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	pwlan =
+	    rtw_find_network(&pmlmepriv->scanned_queue,
+			     tgt_network->network.MacAddress);
+	if (pwlan) {
+		pwlan->fixed = false;
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("rtw_free_assoc_resources : pwlan== NULL\n\n"));
+	}
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) &&
+	    (adapter->stapriv.asoc_sta_count == 1)))
+		rtw_free_network_nolock(pmlmepriv, pwlan);
+
+	/* Sparse warning ifor context imbalance is OK here */
+	if (lock_scanned_queue)
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	pmlmepriv->key_mask = 0;
+}
+
+/*
+*rtw_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_connect(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("+rtw_indicate_connect\n"));
+
+	pmlmepriv->to_join = false;
+
+	if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+#ifdef CONFIG_SW_ANTENNA_DIVERSITY
+		rtw_hal_set_hwreg(padapter, HW_VAR_ANTENNA_DIVERSITY_LINK, 0);
+#endif
+		set_fwstate(pmlmepriv, _FW_LINKED);
+
+		rtw_led_control(padapter, LED_CTL_LINK);
+
+#ifdef CONFIG_DRVEXT_MODULE
+		if (padapter->drvextpriv.enable_wpa) {
+			indicate_l2_connect(padapter);
+		} else
+#endif
+		{
+			rtw_os_indicate_connect(padapter);
+		}
+	}
+
+	rtw_set_roaming(padapter, 0);
+
+	rtw_set_scan_deny(padapter, 3000);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("-rtw_indicate_connect: fw_state=0x%08x\n",
+		  get_fwstate(pmlmepriv)));
+
+}
+
+/*
+*rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_disconnect(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("+rtw_indicate_disconnect\n"));
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING | WIFI_UNDER_WPS);
+
+	if (rtw_to_roaming(padapter) > 0)
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED) ||
+	    (rtw_to_roaming(padapter) <= 0)) {
+		rtw_os_indicate_disconnect(padapter);
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+		rtw_led_control(padapter, LED_CTL_NO_LINK);
+		rtw_clear_scan_deny(padapter);
+	}
+#ifdef CONFIG_LPS
+#ifdef CONFIG_WOWLAN
+	if (padapter->pwrctrlpriv.wowlan_mode == false)
+#endif /* CONFIG_WOWLAN */
+		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);
+
+#endif
+
+}
+
+inline void rtw_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
+{
+	rtw_os_indicate_scan_done(padapter, aborted);
+}
+
+void rtw_scan_abort(struct rtw_adapter *adapter)
+{
+	u32 cnt = 0;
+	u32 start;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+
+	start = rtw_get_current_time();
+	pmlmeext->scan_abort = true;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) &&
+	       rtw_get_passing_time_ms(start) <= 200) {
+		if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+			break;
+
+		DBG_8192D(FUNC_NDEV_FMT "fw_state=_FW_UNDER_SURVEY!\n",
+			  FUNC_NDEV_ARG(adapter->pnetdev));
+		rtw_msleep_os(20);
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		if (!adapter->bDriverStopped && !adapter->bSurpriseRemoved)
+			DBG_8192D(FUNC_NDEV_FMT
+				  "waiting for scan_abort time out!\n",
+				  FUNC_NDEV_ARG(adapter->pnetdev));
+		rtw_indicate_scan_done(adapter, true);
+	}
+	pmlmeext->scan_abort = false;
+}
+
+static struct sta_info *rtw_joinbss_update_stainfo(struct rtw_adapter *padapter,
+						   struct wlan_network
+						   *pnetwork)
+{
+	int i;
+	struct sta_info *bmc_sta, *psta = NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	psta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);
+	if (psta == NULL) {
+		psta =
+		    rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+	}
+
+	if (psta) {		/* update ptarget_sta */
+		DBG_8192D("%s\n", __func__);
+
+		psta->aid = pnetwork->join_res;
+#ifdef CONFIG_CONCURRENT_MODE
+
+		if (PRIMARY_ADAPTER == padapter->adapter_type)
+			psta->mac_id = 0;
+		else
+			psta->mac_id = 2;
+#else
+		psta->mac_id = 0;
+#endif
+
+		psta->raid = networktype_to_raid(pmlmeext->cur_wireless_mode);
+
+		/* security related */
+		if (padapter->securitypriv.dot11AuthAlgrthm ==
+		    dot11AuthAlgrthm_8021X) {
+			padapter->securitypriv.binstallGrpkey = false;
+			padapter->securitypriv.busetkipkey = false;
+			padapter->securitypriv.bgrpkey_handshake = false;
+
+			psta->ieee8021x_blocked = true;
+			psta->dot118021XPrivacy =
+			    padapter->securitypriv.dot11PrivacyAlgrthm;
+
+			memset((u8 *)&psta->dot118021x_UncstKey, 0,
+			       sizeof(union Keytype));
+
+			memset((u8 *)&psta->dot11tkiprxmickey, 0,
+			       sizeof(union Keytype));
+			memset((u8 *)&psta->dot11tkiptxmickey, 0,
+			       sizeof(union Keytype));
+
+			memset((u8 *)&psta->dot11txpn, 0, sizeof(union pn48));
+			memset((u8 *)&psta->dot11rxpn, 0, sizeof(union pn48));
+		}
+
+		/*      Commented by Albert 2012/07/21 */
+		/*      When doing the WPS, the wps_ie_len won't equal to 0 */
+		/*      And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted. */
+		if (padapter->securitypriv.wps_ie_len != 0) {
+			psta->ieee8021x_blocked = true;
+			padapter->securitypriv.wps_ie_len = 0;
+		}
+
+		/* for A-MPDU Rx reordering buffer control for bmc_sta & sta_info */
+		/* if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff */
+		/* todo: check if AP can send A-MPDU packets */
+		for (i = 0; i < 16; i++) {
+			/* preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; */
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->enable = false;
+			preorder_ctrl->indicate_seq = 0xffff;
+#ifdef DBG_RX_SEQ
+			DBG_8192D("DBG_RX_SEQ %s:%d indicate_seq:%u\n",
+				  __func__, __LINE__,
+				  preorder_ctrl->indicate_seq);
+#endif
+			preorder_ctrl->wend_b = 0xffff;
+			preorder_ctrl->wsize_b = 64;	/* max_ampdu_sz; ex. 32(kbytes) -> wsize_b=32 */
+		}
+
+		bmc_sta = rtw_get_bcmc_stainfo(padapter);
+		if (bmc_sta) {
+			for (i = 0; i < 16; i++) {
+				/* preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; */
+				preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+				preorder_ctrl->enable = false;
+				preorder_ctrl->indicate_seq = 0xffff;
+#ifdef DBG_RX_SEQ
+				DBG_8192D("DBG_RX_SEQ %s:%d indicate_seq:%u\n",
+					  __func__, __LINE__,
+					  preorder_ctrl->indicate_seq);
+#endif
+				preorder_ctrl->wend_b = 0xffff;
+				preorder_ctrl->wsize_b = 64;	/* max_ampdu_sz; ex. 32(kbytes) -> wsize_b=32 */
+			}
+		}
+		/* misc. */
+		update_sta_info(padapter, psta);
+	}
+	return psta;
+}
+
+/* pnetwork : returns from rtw_joinbss_event_callback */
+/* ptarget_wlan: found from scanned_queue */
+static void rtw_joinbss_update_network(struct rtw_adapter *padapter,
+				       struct wlan_network *ptarget_wlan,
+				       struct wlan_network *pnetwork)
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+
+	DBG_8192D("%s\n", __func__);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("\nfw_state:%x, BSSID:%pM\n", get_fwstate(pmlmepriv),
+		  pnetwork->network.MacAddress));
+
+	/*  why not use ptarget_wlan?? */
+	memcpy(&cur_network->network, &pnetwork->network,
+	       pnetwork->network.Length);
+
+	cur_network->aid = pnetwork->join_res;
+
+	rtw_set_signal_stat_timer(&padapter->recvpriv);
+	padapter->recvpriv.signal_strength =
+	    ptarget_wlan->network.PhyInfo.SignalStrength;
+	padapter->recvpriv.signal_qual =
+	    ptarget_wlan->network.PhyInfo.SignalQuality;
+	/* the ptarget_wlan->network.Rssi is raw data,
+	 * we use scaled ptarget_wlan->network.PhyInfo.SignalStrength instead
+	 */
+	padapter->recvpriv.rssi =
+	    translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.
+					SignalStrength);
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
+	DBG_8192D("%s signal_strength:%3u, rssi:%3d, signal_qual:%3u"
+		  "\n", __func__, adapter->recvpriv.signal_strength,
+		  adapter->recvpriv.rssi, adapter->recvpriv.signal_qual);
+#endif
+	rtw_set_signal_stat_timer(&padapter->recvpriv);
+
+	/* update fw_state will clr _FW_UNDER_LINKING here indirectly */
+	switch (pnetwork->network.InfrastructureMode) {
+	case NDIS802_11INFRA:
+
+		if (pmlmepriv->fw_state & WIFI_UNDER_WPS)
+			pmlmepriv->fw_state =
+			    WIFI_STATION_STATE | WIFI_UNDER_WPS;
+		else
+			pmlmepriv->fw_state = WIFI_STATION_STATE;
+
+		break;
+	case NDIS802_11IBSS:
+		pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+		break;
+	default:
+		pmlmepriv->fw_state = WIFI_NULL_STATE;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("Invalid network_mode\n"));
+		break;
+	}
+
+	rtw_update_protection(padapter,
+			      (cur_network->network.IEs) +
+			      sizeof(struct ndis_802_11_fixed_ies),
+			      (cur_network->network.IELength));
+
+#ifdef CONFIG_80211N_HT
+	rtw_update_ht_cap(padapter, cur_network->network.IEs,
+			  cur_network->network.IELength,
+			  (u8) cur_network->network.Configuration.DSConfig);
+#endif
+}
+
+/* Notes: the fucntion could be > passive_level (the same context as Rx tasklet) */
+/* pnetwork : returns from rtw_joinbss_event_callback */
+/* ptarget_wlan: found from scanned_queue */
+/* if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist. */
+/* if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist. */
+/* if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL). */
+/*  */
+/* define REJOIN */
+void rtw_joinbss_event_prehandle(struct rtw_adapter *adapter, u8 *pbuf)
+{
+#ifdef REJOIN
+	static u8 retry;
+#endif
+	u8 timer_cancelled;
+	struct sta_info *ptarget_sta = NULL, *pcur_sta = NULL;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct wlan_network *pnetwork = (struct wlan_network *)pbuf;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network *pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int the_same_macaddr = false;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("joinbss event call back received with res=%d\n",
+		  pnetwork->join_res));
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("@@@@@   joinbss event call back  for Any SSid\n"));
+	} else {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("@@@@@   rtw_joinbss_event_callback for SSid:%s\n",
+			  pmlmepriv->assoc_ssid.Ssid));
+	}
+
+	the_same_macaddr =
+	    _rtw_memcmp(pnetwork->network.MacAddress,
+			cur_network->network.MacAddress, ETH_ALEN);
+
+	pnetwork->network.Length = get_wlan_bssid_ex_sz(&pnetwork->network);
+	if (pnetwork->network.Length > sizeof(struct wlan_bssid_ex)) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));
+		return;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("\n rtw_joinbss_event_callback !! _enter_critical\n"));
+
+	if (pnetwork->join_res > 0) {
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+#ifdef REJOIN
+		retry = 0;
+#endif
+		if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {
+			/* s1. find ptarget_wlan */
+			if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+				if (the_same_macaddr == true) {
+					ptarget_wlan =
+					    rtw_find_network(&pmlmepriv->
+							     scanned_queue,
+							     cur_network->
+							     network.
+							     MacAddress);
+				} else {
+					pcur_wlan =
+					    rtw_find_network(&pmlmepriv->
+							     scanned_queue,
+							     cur_network->
+							     network.
+							     MacAddress);
+					if (pcur_wlan)
+						pcur_wlan->fixed = false;
+
+					pcur_sta =
+					    rtw_get_stainfo(pstapriv,
+							    cur_network->
+							    network.MacAddress);
+					if (pcur_sta) {
+						spin_lock_bh(&
+							     (pstapriv->
+							      sta_hash_lock));
+						rtw_free_stainfo(adapter,
+								 pcur_sta);
+						spin_unlock_bh(&
+							       (pstapriv->
+								sta_hash_lock));
+					}
+
+					ptarget_wlan =
+					    rtw_find_network(&pmlmepriv->
+							     scanned_queue,
+							     pnetwork->network.
+							     MacAddress);
+					if (check_fwstate
+					    (pmlmepriv,
+					     WIFI_STATION_STATE) == true) {
+						if (ptarget_wlan)
+							ptarget_wlan->fixed =
+							    true;
+					}
+				}
+
+			} else {
+				ptarget_wlan =
+				    rtw_find_network(&pmlmepriv->scanned_queue,
+						     pnetwork->network.
+						     MacAddress);
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+				    == true) {
+					if (ptarget_wlan)
+						ptarget_wlan->fixed = true;
+				}
+			}
+
+			/* s2. update cur_network */
+			if (ptarget_wlan) {
+				rtw_joinbss_update_network(adapter,
+							   ptarget_wlan,
+							   pnetwork);
+			} else {
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+					 ("Can't find ptarget_wlan when joinbss_event callback\n"));
+				spin_unlock_bh(&
+					       (pmlmepriv->scanned_queue.lock));
+				goto ignore_joinbss_callback;
+			}
+
+			/* s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode */
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) ==
+			    true) {
+				ptarget_sta =
+				    rtw_joinbss_update_stainfo(adapter,
+							       pnetwork);
+				if (ptarget_sta == NULL) {
+					RT_TRACE(_module_rtl871x_mlme_c_,
+						 _drv_err_,
+						 ("Can't update stainfo when joinbss_event callback\n"));
+					spin_unlock_bh(&
+						       (pmlmepriv->
+							scanned_queue.lock));
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			/* s4. indicate connect */
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) ==
+			    true) {
+				rtw_indicate_connect(adapter);
+			} else {
+				/* adhoc mode will rtw_indicate_connect when rtw_stassoc_event_callback */
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+					 ("adhoc mode, fw_state:%x",
+					  get_fwstate(pmlmepriv)));
+			}
+
+			/* s5. Cancle assoc_timer */
+			_cancel_timer(&pmlmepriv->assoc_timer,
+				      &timer_cancelled);
+
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+				 ("Cancle assoc_timer\n"));
+
+		} else {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("rtw_joinbss_event_callback err: fw_state:%x",
+				  get_fwstate(pmlmepriv)));
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			goto ignore_joinbss_callback;
+		}
+
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	} else if (pnetwork->join_res == -4) {
+		rtw_reset_securitypriv(adapter);
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+
+		/* rtw_free_assoc_resources(adapter, 1); */
+
+		if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true) {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n",
+				  get_fwstate(pmlmepriv)));
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+
+	} else {		/* if join_res < 0 (join fails), then try again */
+
+#ifdef REJOIN
+		res = _FAIL;
+		if (retry < 2) {
+			res = rtw_select_and_join_from_scanned_queue(pmlmepriv);
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("rtw_select_and_join_from_scanned_queue again! res:%d\n",
+				  res));
+		}
+
+		if (res == _SUCCESS) {
+			/* extend time of assoc_timer */
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+			retry++;
+		} else if (res == 2) {	/* there is no need to wait for join */
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+			rtw_indicate_connect(adapter);
+		} else {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("Set Assoc_Timer = 1; can't find match ssid in scanned_q\n"));
+#endif
+
+			_set_timer(&pmlmepriv->assoc_timer, 1);
+			/* rtw_free_assoc_resources(adapter, 1); */
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+#ifdef REJOIN
+			retry = 0;
+		}
+#endif
+	}
+
+ignore_joinbss_callback:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+void rtw_joinbss_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+	struct wlan_network *pnetwork = (struct wlan_network *)pbuf;
+
+	mlmeext_joinbss_event_callback(adapter, pnetwork->join_res);
+
+	rtw_os_xmit_schedule(adapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	rtw_os_xmit_schedule(adapter->pbuddy_adapter);
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	dc_resume_xmit(adapter);
+#endif
+
+}
+
+void rtw_stassoc_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stassoc_event *pstassoc = (struct stassoc_event *)pbuf;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network *ptarget_wlan = NULL;
+
+	if (rtw_access_ctrl(adapter, pstassoc->macaddr) == false)
+		return;
+
+#if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+		if (psta) {
+			u8 *passoc_req = NULL;
+			u32 assoc_req_len;
+
+			spin_lock_bh(&psta->lock);
+			if (psta->passoc_req && psta->assoc_req_len > 0) {
+				passoc_req = kzalloc(psta->assoc_req_len, GFP_ATOMIC);
+				if (passoc_req) {
+					assoc_req_len = psta->assoc_req_len;
+					memcpy(passoc_req, psta->passoc_req,
+					       assoc_req_len);
+
+					kfree(psta->passoc_req);
+					psta->passoc_req = NULL;
+					psta->assoc_req_len = 0;
+				}
+			}
+			spin_unlock_bh(&psta->lock);
+
+			if (passoc_req && assoc_req_len > 0) {
+				rtw_cfg80211_indicate_sta_assoc(adapter,
+								passoc_req,
+								assoc_req_len);
+
+				kfree(passoc_req);
+			}
+
+			ap_sta_info_defer_update(adapter, psta);
+		}
+		return;
+	}
+#endif
+
+	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta != NULL) {
+		/* the sta have been in sta_info_queue => do nothing */
+
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue\n"));
+
+		return;	/* between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) */
+	}
+
+	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("Can't alloc sta_info when rtw_stassoc_event_callback\n"));
+		return;
+	}
+
+	/* to do : init sta_info variable */
+	psta->qos_option = 0;
+	psta->mac_id = (uint) pstassoc->cam_id;
+	/* psta->aid = (uint)pstassoc->cam_id; */
+
+	if (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
+		psta->dot118021XPrivacy =
+		    adapter->securitypriv.dot11PrivacyAlgrthm;
+
+	psta->ieee8021x_blocked = false;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+		if (adapter->stapriv.asoc_sta_count == 2) {
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			ptarget_wlan =
+			    rtw_find_network(&pmlmepriv->scanned_queue,
+					     cur_network->network.MacAddress);
+			if (ptarget_wlan)
+				ptarget_wlan->fixed = true;
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			/*  a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			rtw_indicate_connect(adapter);
+		}
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	mlmeext_sta_add_event_callback(adapter, psta);
+}
+
+void rtw_stadel_event_callback(struct rtw_adapter *adapter, u8 *pbuf)
+{
+	struct sta_info *psta;
+	struct wlan_network *pwlan = NULL;
+	struct wlan_bssid_ex *pdev_network = NULL;
+	u8 *pibss = NULL;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct stadel_event *pstadel = (struct stadel_event *)pbuf;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+#ifdef CONFIG_92D_AP_MODE
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		rtw_cfg80211_indicate_sta_disassoc(adapter, pstadel->macaddr,
+						   *(u16 *)pstadel->rsvd);
+		return;
+	}
+#endif
+	mlmeext_sta_del_event_callback(adapter);
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+#ifdef CONFIG_LAYER2_ROAMING
+		if (rtw_to_roaming(adapter) > 0)
+			pmlmepriv->to_roaming--;	/* this stadel_event is caused by roaming, decrease to_roaming */
+		else if (rtw_to_roaming(adapter) == 0)
+			rtw_set_roaming(adapter,
+					adapter->registrypriv.
+					max_roaming_times);
+			if (*((unsigned short *)(pstadel->rsvd)) !=
+			    WLAN_REASON_EXPIRATION_CHK)
+				rtw_set_roaming(adapter, 0);	/* don't roam */
+#endif
+
+		rtw_free_uc_swdec_pending_queue(adapter);
+
+		rtw_free_assoc_resources(adapter, 1);
+		rtw_indicate_disconnect(adapter);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+		/*  remove the network entry in scanned_queue */
+		pwlan =
+		    rtw_find_network(&pmlmepriv->scanned_queue,
+				     tgt_network->network.MacAddress);
+		if (pwlan) {
+			pwlan->fixed = false;
+			rtw_free_network_nolock(pmlmepriv, pwlan);
+		}
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+		_rtw_roaming(adapter, tgt_network);
+
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||
+	    check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+		psta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);
+
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(adapter, psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+		if (adapter->stapriv.asoc_sta_count == 1) {	/* a sta + bc/mc_stainfo (not Ibss_stainfo) */
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			/* free old ibss network */
+			pwlan =
+			    rtw_find_network(&pmlmepriv->scanned_queue,
+					     tgt_network->network.MacAddress);
+			if (pwlan) {
+				pwlan->fixed = false;
+				rtw_free_network_nolock(pmlmepriv, pwlan);
+			}
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			/* re-create ibss */
+			pdev_network = &(adapter->registrypriv.dev_network);
+			pibss = adapter->registrypriv.dev_network.MacAddress;
+
+			memcpy(pdev_network, &tgt_network->network,
+			       get_wlan_bssid_ex_sz(&tgt_network->network));
+
+			memset(&pdev_network->Ssid, 0,
+			       sizeof(struct ndis_802_11_ssid));
+			memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid,
+			       sizeof(struct ndis_802_11_ssid));
+
+			rtw_update_registrypriv_dev_network(adapter);
+
+			rtw_generate_random_ibss(pibss);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+
+			if (rtw_createbss_cmd(adapter) != _SUCCESS) {
+				RT_TRACE(_module_rtl871x_ioctl_set_c_,
+					 _drv_err_,
+					 ("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL***\n "));
+			}
+		}
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+}
+
+void rtw_cpwm_event_callback(struct rtw_adapter *padapter, u8 *pbuf)
+{
+#ifdef CONFIG_LPS_LCLK
+	struct reportpwrstate_parm *preportpwrstate;
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("rtw_cpwm_event_callback !!!\n"));
+#ifdef CONFIG_LPS_LCLK
+	preportpwrstate = (struct reportpwrstate_parm *)pbuf;
+	preportpwrstate->state |= (u8) (padapter->pwrctrlpriv.cpwm_tog + 0x80);
+	cpwm_int_hdl(padapter, preportpwrstate);
+#endif
+
+}
+
+/*
+* _rtw_join_timeout_handler - Timeout/faliure handler for CMD JoinBss
+* @adapter: pointer to _adapter structure
+*/
+void _rtw_join_timeout_handler(struct rtw_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+#ifdef CONFIG_LAYER2_ROAMING
+	int do_join_r;
+#endif /* CONFIG_LAYER2_ROAMING */
+
+	DBG_8192D("%s, fw_state=%x\n", __func__, get_fwstate(pmlmepriv));
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved)
+		return;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+#ifdef CONFIG_LAYER2_ROAMING
+	if (rtw_to_roaming(adapter) > 0) {	/* join timeout caused by roaming */
+		while (1) {
+			pmlmepriv->to_roaming--;
+			if (rtw_to_roaming(adapter) != 0) {	/* try another */
+				DBG_8192D("%s try another roaming\n", __func__);
+				do_join_r = rtw_do_join(adapter);
+				if (_SUCCESS != do_join_r) {
+					DBG_8192D
+					    ("%s roaming do_join return %d\n",
+					     __func__, do_join_r);
+					continue;
+				}
+				break;
+			} else {
+				DBG_8192D("%s We've try roaming but fail\n",
+					  __func__);
+				rtw_indicate_disconnect(adapter);
+				break;
+			}
+		}
+
+	} else
+#endif
+	{
+		rtw_indicate_disconnect(adapter);
+		free_scanqueue(pmlmepriv);	/*  */
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+#ifdef CONFIG_DRVEXT_MODULE_WSC
+	drvext_assoc_fail_indicate(&adapter->drvextpriv);
+#endif
+
+}
+
+/*
+* rtw_scan_timeout_handler - Timeout/Faliure handler for CMD SiteSurvey
+* @adapter: pointer to _adapter structure
+*/
+void rtw_scan_timeout_handler(struct rtw_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	DBG_8192D(FUNC_ADPT_FMT " fw_state=%x\n", FUNC_ADPT_ARG(adapter),
+		  get_fwstate(pmlmepriv));
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_indicate_scan_done(adapter, true);
+}
+
+static void rtw_auto_scan_handler(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	/* auto site survey per 60sec */
+	if (pmlmepriv->scan_interval > 0) {
+		pmlmepriv->scan_interval--;
+		if (pmlmepriv->scan_interval == 0) {
+#ifdef CONFIG_CONCURRENT_MODE
+			if (rtw_buddy_adapter_up(padapter)) {
+				if ((check_buddy_fwstate
+				     (padapter,
+				      _FW_UNDER_SURVEY | _FW_UNDER_LINKING) ==
+				     true) ||
+				     (padapter->pbuddy_adapter->mlmepriv.
+					LinkDetectInfo.bBusyTraffic == true)) {
+					DBG_8192D
+					    ("%s, but buddy_intf is under scanning or linking or BusyTraffic\n",
+					     __func__);
+					return;
+				}
+			}
+#endif
+
+			DBG_8192D("%s\n", __func__);
+
+			rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
+
+			pmlmepriv->scan_interval = SCAN_INTERVAL;	/*  30*2 sec = 60sec */
+		}
+	}
+}
+
+void rtw_dynamic_check_timer_handlder(struct rtw_adapter *adapter)
+{
+#ifdef CONFIG_92D_AP_MODE
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+#endif /* CONFIG_92D_AP_MODE */
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = adapter->pbuddy_adapter;
+#endif
+
+	if (!adapter)
+		return;
+
+	if (adapter->hw_init_completed == false)
+		return;
+
+	if ((adapter->bDriverStopped == true) ||
+	    (adapter->bSurpriseRemoved == true))
+		return;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (pbuddy_adapter) {
+		if (adapter->net_closed == true &&
+		    pbuddy_adapter->net_closed == true) {
+			return;
+		}
+	} else
+#endif /* CONFIG_CONCURRENT_MODE */
+	if (adapter->net_closed == true) {
+		return;
+	}
+
+	rtw_dynamic_chk_wk_cmd(adapter);
+
+	if (pregistrypriv->wifi_spec == 1) {
+		/* auto site survey */
+		rtw_auto_scan_handler(adapter);
+	}
+}
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+inline bool rtw_is_scan_deny(struct rtw_adapter *adapter)
+{
+	struct mlme_priv *mlmepriv = &adapter->mlmepriv;
+	return (ATOMIC_READ(&mlmepriv->set_scan_deny) != 0) ? true : false;
+}
+
+inline void rtw_clear_scan_deny(struct rtw_adapter *adapter)
+{
+	struct mlme_priv *mlmepriv = &adapter->mlmepriv;
+	ATOMIC_SET(&mlmepriv->set_scan_deny, 0);
+}
+
+void rtw_set_scan_deny_timer_hdl(struct rtw_adapter *adapter)
+{
+	rtw_clear_scan_deny(adapter);
+}
+
+void rtw_set_scan_deny(struct rtw_adapter *adapter, u32 ms)
+{
+	struct mlme_priv *mlmepriv = &adapter->mlmepriv;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct mlme_priv *b_mlmepriv;
+#endif
+	ATOMIC_SET(&mlmepriv->set_scan_deny, 1);
+	_set_timer(&mlmepriv->set_scan_deny_timer, ms);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (!adapter->pbuddy_adapter)
+		return;
+
+	b_mlmepriv = &adapter->pbuddy_adapter->mlmepriv;
+	ATOMIC_SET(&b_mlmepriv->set_scan_deny, 1);
+	_set_timer(&b_mlmepriv->set_scan_deny_timer, ms);
+#endif
+}
+#endif
+
+#if defined(IEEE80211_SCAN_RESULT_EXPIRE)
+#define RTW_SCAN_RESULT_EXPIRE (IEEE80211_SCAN_RESULT_EXPIRE/HZ*1000 - 1000)	/* 3000 -1000 */
+#else
+#define RTW_SCAN_RESULT_EXPIRE 2000
+#endif
+
+/*
+* Select a new join candidate from the original @param candidate and @param competitor
+* @return true: candidate is updated
+* @return false: candidate is not updated
+*/
+static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv,
+				    struct wlan_network **candidate,
+				    struct wlan_network *competitor)
+{
+	int updated = false;
+	struct rtw_adapter *adapter =
+	    container_of(pmlmepriv, struct rtw_adapter, mlmepriv);
+
+	/* check bssid, if needed */
+	if (pmlmepriv->assoc_by_bssid == true) {
+		if (_rtw_memcmp
+		    (competitor->network.MacAddress, pmlmepriv->assoc_bssid,
+		     ETH_ALEN) == false)
+			goto exit;
+	}
+
+	/* check ssid, if needed */
+	if (pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
+		if (competitor->network.Ssid.SsidLength !=
+		    pmlmepriv->assoc_ssid.SsidLength ||
+		    _rtw_memcmp(competitor->network.Ssid.Ssid,
+				   pmlmepriv->assoc_ssid.Ssid,
+				   pmlmepriv->assoc_ssid.SsidLength) == false)
+			goto exit;
+	}
+
+	if (rtw_is_desired_network(adapter, competitor) == false)
+		goto exit;
+
+#ifdef CONFIG_LAYER2_ROAMING
+	if (rtw_to_roaming(adapter) > 0) {
+		if (rtw_get_passing_time_ms((u32) competitor->last_scanned) >=
+		    RTW_SCAN_RESULT_EXPIRE ||
+		    is_same_ess(&competitor->network,
+				   &pmlmepriv->cur_network.network) == false)
+			goto exit;
+	}
+#endif
+
+	if (*candidate == NULL ||
+	    (*candidate)->network.Rssi < competitor->network.Rssi) {
+		*candidate = competitor;
+		updated = true;
+	}
+
+	if (updated) {
+		DBG_8192D("[by_bssid:%u][assoc_ssid:%s]"
+			  "new candidate: %s(%pM) rssi:%d\n",
+			  pmlmepriv->assoc_by_bssid, pmlmepriv->assoc_ssid.Ssid,
+			  (*candidate)->network.Ssid.Ssid,
+			  (*candidate)->network.MacAddress,
+			  (int)(*candidate)->network.Rssi);
+#ifdef CONFIG_LAYER2_ROAMING
+		DBG_8192D("[to_roaming:%u]\n", rtw_to_roaming(adapter));
+#endif
+	}
+
+exit:
+	return updated;
+}
+
+/*
+Calling context:
+The caller of the sub-routine will be in critical section...
+
+The caller must hold the following spinlock
+
+pmlmepriv->lock
+
+*/
+
+int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)
+{
+	int ret;
+	struct list_head *phead;
+	struct rtw_adapter *adapter;
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	struct wlan_network *pnetwork = NULL;
+	struct wlan_network *candidate = NULL;
+	u8 bSupportAntDiv = false;
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+	phead = get_list_head(queue);
+	adapter = (struct rtw_adapter *)pmlmepriv->nic_hdl;
+
+	pmlmepriv->pscanned = phead->next;
+
+	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
+		pnetwork =
+		    container_of(pmlmepriv->pscanned, struct wlan_network,
+				   list);
+		if (pnetwork == NULL) {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("%s return _FAIL:(pnetwork==NULL)\n",
+				  __func__));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+		rtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);
+	}
+
+	if (candidate == NULL) {
+		DBG_8192D("%s: return _FAIL(candidate == NULL)\n", __func__);
+		ret = _FAIL;
+		goto exit;
+	} else {
+		DBG_8192D("%s: candidate: %s(%pM, ch:%u)\n", __func__,
+			  candidate->network.Ssid.Ssid,
+			  candidate->network.MacAddress,
+			  candidate->network.Configuration.DSConfig);
+	}
+
+	/*  check for situation of  _FW_LINKED */
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		DBG_8192D("%s: _FW_LINKED while ask_for_joinbss!!!\n",
+			  __func__);
+
+		rtw_disassoc_cmd(adapter, 0, true);
+		rtw_indicate_disconnect(adapter);
+		rtw_free_assoc_resources(adapter, 0);
+	}
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	rtw_hal_get_def_var(adapter, HAL_DEF_IS_SUPPORT_ANT_DIV,
+			    &(bSupportAntDiv));
+	if (true == bSupportAntDiv) {
+		u8 CurrentAntenna;
+		rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA,
+				    &(CurrentAntenna));
+		DBG_8192D("#### Opt_Ant_(%s) , cur_Ant(%s)\n",
+			  (2 ==
+			   candidate->network.PhyInfo.
+			   Optimum_antenna) ? "A" : "B",
+			  (2 == CurrentAntenna) ? "A" : "B");
+	}
+#endif
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	ret = rtw_joinbss_cmd(adapter, candidate);
+
+exit:
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	return ret;
+}
+
+int rtw_set_auth(struct rtw_adapter *adapter,
+		 struct security_priv *psecuritypriv)
+{
+	struct cmd_obj *pcmd;
+	struct setauth_parm *psetauthparm;
+	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
+	int res = _SUCCESS;
+
+	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (pcmd == NULL) {
+		res = _FAIL;	/* try again */
+		goto exit;
+	}
+
+	psetauthparm =
+	    (struct setauth_parm *)kzalloc(sizeof(struct setauth_parm), GFP_KERNEL);
+	if (psetauthparm == NULL) {
+		kfree(pcmd);
+		res = _FAIL;
+		goto exit;
+	}
+
+	memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode = (unsigned char)psecuritypriv->dot11AuthAlgrthm;
+
+	pcmd->cmdcode = _SETAUTH_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;
+	pcmd->cmdsz = (sizeof(struct setauth_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("after enqueue set_auth_cmd, auth_mode=%x\n",
+		  psecuritypriv->dot11AuthAlgrthm));
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+}
+
+int rtw_set_key(struct rtw_adapter *adapter,
+		struct security_priv *psecuritypriv, int keyid, u8 set_tx)
+{
+	u8 keylen;
+	struct cmd_obj *pcmd;
+	struct setkey_parm *psetkeyparm;
+	struct cmd_priv *pcmdpriv = &(adapter->cmdpriv);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	int res = _SUCCESS;
+
+	pcmd = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (pcmd == NULL) {
+		res = _FAIL;	/* try again */
+		goto exit;
+	}
+	psetkeyparm =
+	    (struct setkey_parm *)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
+	if (psetkeyparm == NULL) {
+		kfree(pcmd);
+		res = _FAIL;
+		goto exit;
+	}
+
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {
+		psetkeyparm->algorithm =
+		    (unsigned char)psecuritypriv->dot118021XGrpPrivacy;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d\n",
+			  psetkeyparm->algorithm));
+	} else {
+		psetkeyparm->algorithm =
+		    (u8) psecuritypriv->dot11PrivacyAlgrthm;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d\n",
+			  psetkeyparm->algorithm));
+	}
+	psetkeyparm->keyid = (u8) keyid;	/* 0~3 */
+	psetkeyparm->set_tx = set_tx;
+	pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
+#ifdef CONFIG_AUTOSUSPEND
+	if (true == adapter->pwrctrlpriv.bInternalAutoSuspend) {
+		adapter->pwrctrlpriv.wepkeymask = pmlmepriv->key_mask;
+		DBG_8192D("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",
+			  adapter->pwrctrlpriv.wepkeymask);
+	}
+#endif
+	DBG_8192D("==> rtw_set_key algorithm(%x),keyid(%x),key_mask(%x)\n",
+		  psetkeyparm->algorithm, psetkeyparm->keyid,
+		  pmlmepriv->key_mask);
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+		 ("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d\n",
+		  psetkeyparm->algorithm, keyid));
+
+	switch (psetkeyparm->algorithm) {
+	case _WEP40_:
+		keylen = 5;
+		memcpy(&(psetkeyparm->key[0]),
+		       &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+		break;
+	case _WEP104_:
+		keylen = 13;
+		memcpy(&(psetkeyparm->key[0]),
+		       &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+		break;
+	case _TKIP_:
+		keylen = 16;
+		memcpy(&psetkeyparm->key,
+		       &psecuritypriv->dot118021XGrpKey[keyid], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	case _AES_:
+		keylen = 16;
+		memcpy(&psetkeyparm->key,
+		       &psecuritypriv->dot118021XGrpKey[keyid], keylen);
+		psetkeyparm->grpkey = 1;
+		break;
+	default:
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("\n rtw_set_key:psecuritypriv->dot11PrivacyAlgrthm = %x (must be 1 or 2 or 4 or 5)\n",
+			  psecuritypriv->dot11PrivacyAlgrthm));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pcmd->cmdcode = _SETKEY_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz = (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	/* _rtw_init_sema(&(pcmd->cmd_sem), 0); */
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+}
+
+/* adjust IEs for rtw_joinbss_cmd in WMM */
+int rtw_restruct_wmm_ie(struct rtw_adapter *adapter, u8 *in_ie, u8 *out_ie,
+			uint in_len, uint initial_out_len)
+{
+	unsigned int ielength = 0;
+	unsigned int i, j;
+
+	i = 12;			/* after the fixed IE */
+	while (i < in_len) {
+		ielength = initial_out_len;
+
+		if (in_ie[i] == 0xDD && in_ie[i + 2] == 0x00 && in_ie[i + 3] == 0x50 && in_ie[i + 4] == 0xF2 && in_ie[i + 5] == 0x02 && i + 5 < in_len) {	/* WMM element ID and OUI */
+			/* Append WMM IE to the last index of out_ie */
+			for (j = i; j < i + 9; j++) {
+				out_ie[ielength] = in_ie[j];
+				ielength++;
+			}
+			out_ie[initial_out_len + 1] = 0x07;
+			out_ie[initial_out_len + 6] = 0x00;
+			out_ie[initial_out_len + 8] = 0x00;
+
+			break;
+		}
+
+		i += (in_ie[i + 1] + 2);	/*  to the next IE element */
+	}
+
+	return ielength;
+}
+
+/*  */
+/*  Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.) */
+/*  Added by Annie, 2006-05-07. */
+/*  */
+/*  Search by BSSID, */
+/*  Return Value: */
+/*		-1		:if there is no pre-auth key in the  table */
+/*		>=0		:if there is pre-auth key, and   return the entry id */
+/*  */
+/*  */
+
+static int SecIsInPMKIDList(struct rtw_adapter *adapter, u8 *bssid)
+{
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	int i = 0;
+
+	do {
+		if ((psecuritypriv->PMKIDList[i].bUsed) &&
+		    (_rtw_memcmp
+		     (psecuritypriv->PMKIDList[i].Bssid, bssid,
+		      ETH_ALEN) == true)) {
+			break;
+		} else {
+			i++;
+			/* continue; */
+		}
+
+	} while (i < NUM_PMKID_CACHE);
+
+	if (i == NUM_PMKID_CACHE) {
+		i = -1;		/*  Could not find. */
+	} else {
+		/*  There is one Pre-Authentication Key for the specific BSSID. */
+	}
+	return i;
+}
+
+/*  */
+/*  Check the RSN IE length */
+/*  If the RSN IE length <= 20, the RSN IE didn't include the PMKID information */
+/*  0-11th element in the array are the fixed IE */
+/*  12th element in the array is the IE */
+/*  13th element in the array is the IE length */
+/*  */
+
+static int rtw_append_pmkid(struct rtw_adapter *adapter, int iEntry, u8 *ie,
+			    uint ie_len)
+{
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	if (ie[13] <= 20) {
+		/*  The RSN IE didn't include the PMK ID, append the PMK information */
+		ie[ie_len] = 1;
+		ie_len++;
+		ie[ie_len] = 0;	/* PMKID count = 0x0100 */
+		ie_len++;
+		memcpy(&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID,
+		       16);
+
+		ie_len += 16;
+		ie[13] += 18;	/* PMKID length = 2+16 */
+	}
+	return ie_len;
+}
+
+int rtw_restruct_sec_ie(struct rtw_adapter *adapter, u8 *in_ie, u8 *out_ie,
+			uint in_len)
+{
+	u8 authmode, securitytype, match;
+	u8 sec_ie[255], uncst_oui[4], bkup_ie[255];
+	u8 wpa_oui[4] = { 0x0, 0x50, 0xf2, 0x01 };
+	uint ielength, cnt, remove_cnt;
+	int iEntry;
+
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	uint ndisauthmode = psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
+		  ndisauthmode, ndissecuritytype));
+
+	/* copy fixed ie only */
+	memcpy(out_ie, in_ie, 12);
+	ielength = 12;
+	if ((ndisauthmode == NDIS802_11AUTHMODEWPA) ||
+	    (ndisauthmode == NDIS802_11AUTHMODEWPAPSK))
+		authmode = _WPA_IE_ID_;
+	if ((ndisauthmode == NDIS802_11AUTHMODEWPA2) ||
+	    (ndisauthmode == NDIS802_11AUTHMODEWPA2PSK))
+		authmode = _WPA2_IE_ID_;
+
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {
+		memcpy(out_ie + ielength, psecuritypriv->wps_ie,
+		       psecuritypriv->wps_ie_len);
+
+		ielength += psecuritypriv->wps_ie_len;
+	} else if ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {
+		/* copy RSN or SSN */
+		memcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0],
+		       psecuritypriv->supplicant_ie[1] + 2);
+		ielength += psecuritypriv->supplicant_ie[1] + 2;
+		rtw_report_sec_ie(adapter, authmode,
+				  psecuritypriv->supplicant_ie);
+
+#ifdef CONFIG_DRVEXT_MODULE
+		drvext_report_sec_ie(&adapter->drvextpriv, authmode, sec_ie);
+#endif
+	}
+
+	iEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);
+	if (iEntry < 0) {
+		return ielength;
+	} else {
+		if (authmode == _WPA2_IE_ID_) {
+			ielength =
+			    rtw_append_pmkid(adapter, iEntry, out_ie, ielength);
+		}
+	}
+
+	return ielength;
+}
+
+void rtw_init_registrypriv_dev_network(struct rtw_adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct eeprom_priv *peepriv = &adapter->eeprompriv;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	u8 *myhwaddr = myid(peepriv);
+
+	memcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);
+
+	memcpy(&pdev_network->Ssid, &pregistrypriv->ssid,
+	       sizeof(struct ndis_802_11_ssid));
+
+	pdev_network->Configuration.Length = sizeof(struct ndis_802_11_config);
+	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+
+}
+
+void rtw_update_registrypriv_dev_network(struct rtw_adapter *adapter)
+{
+	int sz = 0;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	struct wlan_network *cur_network = &adapter->mlmepriv.cur_network;
+	/* struct       xmit_priv       *pxmitpriv = &adapter->xmitpriv; */
+
+	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0);	/*  adhoc no 802.1x */
+
+	pdev_network->Rssi = 0;
+
+	switch (pregistrypriv->wireless_mode) {
+	case WIRELESS_11B:
+		pdev_network->NetworkTypeInUse = (NDIS802_11DS);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+	case WIRELESS_11_24N:
+	case WIRELESS_11G_24N:
+	case WIRELESS_11BG_24N:
+		pdev_network->NetworkTypeInUse = (NDIS802_11OFDM24);
+		break;
+	case WIRELESS_11A:
+	case WIRELESS_11A_5N:
+		pdev_network->NetworkTypeInUse = (NDIS802_11OFDM5);
+		break;
+	case WIRELESS_11ABGN:
+		if (pregistrypriv->channel > 14)
+			pdev_network->NetworkTypeInUse = (NDIS802_11OFDM5);
+		else
+			pdev_network->NetworkTypeInUse = (NDIS802_11OFDM24);
+		break;
+	default:
+		/*  TODO */
+		break;
+	}
+
+	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n",
+		  pregistrypriv->channel,
+		  pdev_network->Configuration.DSConfig));
+
+	if (cur_network->network.InfrastructureMode == NDIS802_11IBSS)
+		pdev_network->Configuration.ATIMWindow = (0);
+
+	pdev_network->InfrastructureMode =
+	    (cur_network->network.InfrastructureMode);
+
+	/*  1. Supported rates */
+	/*  2. IE */
+
+	sz = rtw_generate_ie(pregistrypriv);
+
+	pdev_network->IELength = sz;
+
+	pdev_network->Length =
+	    get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);
+
+}
+
+/* the fucntion is at passive_level */
+void rtw_joinbss_reset(struct rtw_adapter *padapter)
+{
+	u8 threshold;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+#endif
+
+	/* todo: if you want to do something io/reg/hw setting before join_bss, please add code here */
+
+#ifdef CONFIG_80211N_HT
+
+	pmlmepriv->num_FortyMHzIntolerant = 0;
+
+	pmlmepriv->num_sta_no_ht = 0;
+
+	phtpriv->ampdu_enable = false;	/* reset to disabled */
+
+	/*  TH=1 => means that invalidate usb rx aggregation */
+	/*  TH=0 => means that validate usb rx aggregation, use init value. */
+	if (phtpriv->ht_option) {
+		if (padapter->registrypriv.wifi_spec == 1)
+			threshold = 1;
+		else
+			threshold = 0;
+		rtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH,
+				  (u8 *)(&threshold));
+	} else {
+		threshold = 1;
+		rtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH,
+				  (u8 *)(&threshold));
+	}
+#endif
+}
+
+#ifdef CONFIG_80211N_HT
+
+/* the fucntion is >= passive_level */
+unsigned int rtw_restructure_ht_ie(struct rtw_adapter *padapter, u8 *in_ie,
+				   u8 *out_ie, uint in_len, uint *pout_len,
+				   u8 channel)
+{
+	u32 ielen, out_len;
+	unsigned char *p, *pframe;
+	struct rtw_ieee80211_ht_cap ht_capie;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+	u8 cbw40_enable = 0;
+ 	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+
+	phtpriv->ht_option = false;
+
+	p = rtw_get_ie(in_ie + 12, _HT_CAPABILITY_IE_, &ielen, in_len - 12);
+
+	if (p && ielen > 0) {
+		if (pqospriv->qos_option == 0) {
+			out_len = *pout_len;
+			pframe =
+			    rtw_set_ie(out_ie + out_len, _VENDOR_SPECIFIC_IE_,
+				       _WMM_IE_Length_, WMM_IE, pout_len);
+
+			pqospriv->qos_option = 1;
+		}
+
+		out_len = *pout_len;
+
+		memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
+
+		ht_capie.cap_info =
+		    IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_TX_STBC |
+		    IEEE80211_HT_CAP_DSSSCCK40;
+		/* if insert module set only support 20MHZ, don't add the 40MHZ and SGI_40 */
+		if (channel > 14) {
+			if (pregpriv->cbw40_enable & BIT(1))
+				cbw40_enable = 1;
+		} else if (pregpriv->cbw40_enable & BIT(0)) {
+			cbw40_enable = 1;
+		}
+
+		if (cbw40_enable != 0)
+			ht_capie.cap_info |=
+			    IEEE80211_HT_CAP_SUP_WIDTH |
+			    IEEE80211_HT_CAP_SGI_40;
+
+		{
+			u32 rx_packet_offset, max_recvbuf_sz;
+			rtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET,
+					    &rx_packet_offset);
+			rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ,
+					    &max_recvbuf_sz);
+		}
+
+		ht_capie.ampdu_params_info =
+		    (IEEE80211_HT_CAP_AMPDU_FACTOR & 0x03);
+
+		if (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+			ht_capie.ampdu_params_info |=
+			    (IEEE80211_HT_CAP_AMPDU_DENSITY & (0x07 << 2));
+		else
+			ht_capie.ampdu_params_info |=
+			    (IEEE80211_HT_CAP_AMPDU_DENSITY & 0x00);
+
+		pframe = rtw_set_ie(out_ie + out_len, _HT_CAPABILITY_IE_,
+				    sizeof(struct rtw_ieee80211_ht_cap),
+				    (unsigned char *)&ht_capie, pout_len);
+		phtpriv->ht_option = true;
+
+		p = rtw_get_ie(in_ie + 12, _HT_ADD_INFO_IE_, &ielen,
+			       in_len - 12);
+		if (p && (ielen == sizeof(struct ieee80211_ht_addt_info))) {
+			out_len = *pout_len;
+			pframe =
+			    rtw_set_ie(out_ie + out_len, _HT_ADD_INFO_IE_,
+				       ielen, p + 2, pout_len);
+		}
+	}
+	return phtpriv->ht_option;
+}
+
+/* the function is > passive_level (in critical_section) */
+void rtw_update_ht_cap(struct rtw_adapter *padapter, u8 *pie, uint ie_len,
+		       u8 channel)
+{
+	u8 *p, max_ampdu_sz;
+	int len;
+	/* struct sta_info *bmc_sta, *psta; */
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	/* struct recv_reorder_ctrl *preorder_ctrl; */
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	/* struct wlan_network *pcur_network = &(pmlmepriv->cur_network);; */
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 cbw40_enable = 0;
+
+	if (!phtpriv->ht_option)
+		return;
+
+	if ((!pmlmeinfo->HT_info_enable) || (!pmlmeinfo->HT_caps_enable))
+		return;
+
+	DBG_8192D("+rtw_update_ht_cap()\n");
+
+	/* maybe needs check if ap supports rx ampdu. */
+	if ((phtpriv->ampdu_enable == false) &&
+	    (pregistrypriv->ampdu_enable == 1)) {
+		if (pregistrypriv->wifi_spec == 1) {
+			phtpriv->ampdu_enable = false;
+		} else {
+			phtpriv->ampdu_enable = true;
+		}
+	} else if (pregistrypriv->ampdu_enable == 2) {
+		phtpriv->ampdu_enable = true;
+	}
+
+	/* check Max Rx A-MPDU Size */
+	len = 0;
+	p = rtw_get_ie(pie + sizeof(struct ndis_802_11_fixed_ies),
+		       _HT_CAPABILITY_IE_, &len,
+		       ie_len - sizeof(struct ndis_802_11_fixed_ies));
+	if (p && len > 0) {
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p + 2);
+		max_ampdu_sz =
+		    (pht_capie->
+		     ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
+		max_ampdu_sz = 1 << (max_ampdu_sz + 3);	/*  max_ampdu_sz (kbytes); */
+
+		/* DBG_8192D("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz); */
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+	}
+
+	len = 0;
+	p = rtw_get_ie(pie + sizeof(struct ndis_802_11_fixed_ies),
+		       _HT_ADD_INFO_IE_, &len,
+		       ie_len - sizeof(struct ndis_802_11_fixed_ies));
+
+	if (channel > 14) {
+		if (pregistrypriv->cbw40_enable & BIT(1))
+			cbw40_enable = 1;
+	} else if (pregistrypriv->cbw40_enable & BIT(0)) {
+		cbw40_enable = 1;
+	}
+
+	/* update cur_bwmode & cur_ch_offset */
+	if ((cbw40_enable) &&
+	    (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & BIT(1)) &&
+	    (pmlmeinfo->HT_info.infos[0] & BIT(2))) {
+		int i;
+		u8 rf_type;
+
+		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+		/* update the MCS rates */
+		for (i = 0; i < 16; i++) {
+			if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R)) {
+				pmlmeinfo->HT_caps.u.HT_cap_element.
+				    MCS_rate[i] &= MCS_rate_1R[i];
+			} else {
+				pmlmeinfo->HT_caps.u.HT_cap_element.
+				    MCS_rate[i] &= MCS_rate_2R[i];
+			}
+			if (pregistrypriv->special_rf_path)
+				pmlmeinfo->HT_caps.u.HT_cap_element.
+				    MCS_rate[i] &= MCS_rate_1R[i];
+		}
+		/* switch to the 40M Hz mode accoring to the AP */
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
+		switch ((pmlmeinfo->HT_info.infos[0] & 0x3)) {
+		case HT_EXTCHNL_OFFSET_UPPER:
+			pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+			break;
+
+		case HT_EXTCHNL_OFFSET_LOWER:
+			pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+			break;
+
+		default:
+			pmlmeext->cur_ch_offset =
+			    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			break;
+		}
+	}
+
+	/*  */
+	/*  Config SM Power Save setting */
+	/*  */
+	pmlmeinfo->SM_PS =
+	    (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & 0x0C) >> 2;
+	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC) {
+		DBG_8192D("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);
+	}
+
+	/*  */
+	/*  Config current HT Protection mode. */
+	/*  */
+	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
+}
+
+void rtw_issue_addbareq_cmd(struct rtw_adapter *padapter,
+			    struct xmit_frame *pxmitframe)
+{
+	u8 issued;
+	int priority;
+	struct sta_info *psta = NULL;
+	struct ht_priv *phtpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	s32 bmcst = IS_MCAST(pattrib->ra);
+
+	if (bmcst
+	    || (padapter->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false))
+		return;
+
+	priority = pattrib->priority;
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else
+		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+
+	if (psta == NULL)
+		return;
+
+	phtpriv = &psta->htpriv;
+
+	if ((phtpriv->ht_option == true) && (phtpriv->ampdu_enable == true)) {
+		issued = (phtpriv->agg_enable_bitmap >> priority) & 0x1;
+		issued |= (phtpriv->candidate_tid_bitmap >> priority) & 0x1;
+
+		if (0 == issued) {
+			DBG_8192D("rtw_issue_addbareq_cmd, p=%d\n", priority);
+			psta->htpriv.candidate_tid_bitmap |= BIT((u8) priority);
+			rtw_addbareq_cmd(padapter, (u8) priority, pattrib->ra);
+		}
+	}
+}
+
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+inline void rtw_set_roaming(struct rtw_adapter *adapter, u8 to_roaming)
+{
+	if (to_roaming == 0)
+		adapter->mlmepriv.to_join = false;
+	adapter->mlmepriv.to_roaming = to_roaming;
+}
+
+inline u8 rtw_to_roaming(struct rtw_adapter *adapter)
+{
+	return adapter->mlmepriv.to_roaming;
+}
+
+void rtw_roaming(struct rtw_adapter *padapter, struct wlan_network *tgt_network)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	spin_lock_bh(&pmlmepriv->lock);
+	_rtw_roaming(padapter, tgt_network);
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+void _rtw_roaming(struct rtw_adapter *padapter,
+		  struct wlan_network *tgt_network)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	int do_join_r;
+
+	struct wlan_network *pnetwork;
+
+	if (tgt_network != NULL)
+		pnetwork = tgt_network;
+	else
+		pnetwork = &pmlmepriv->cur_network;
+
+	if (0 < rtw_to_roaming(padapter)) {
+		DBG_8192D("roaming from %s(%pM), length:%d\n",
+			  pnetwork->network.Ssid.Ssid,
+			  pnetwork->network.MacAddress,
+			  pnetwork->network.Ssid.SsidLength);
+		memcpy(&pmlmepriv->assoc_ssid, &pnetwork->network.Ssid,
+		       sizeof(struct ndis_802_11_ssid));
+
+		pmlmepriv->assoc_by_bssid = false;
+
+		while (1) {
+			do_join_r = rtw_do_join(padapter);
+			if (_SUCCESS == do_join_r) {
+				break;
+			} else {
+				DBG_8192D("roaming do_join return %d\n",
+					  do_join_r);
+				pmlmepriv->to_roaming--;
+
+				if (0 < rtw_to_roaming(padapter)) {
+					continue;
+				} else {
+					DBG_8192D
+					    ("%s(%d) -to roaming fail, indicate_disconnect\n",
+					     __func__, __LINE__);
+					rtw_indicate_disconnect(padapter);
+					break;
+				}
+			}
+		}
+	}
+}
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+int rtw_buddy_adapter_up(struct rtw_adapter *padapter)
+{
+	int res = false;
+
+	if (padapter == NULL)
+		return res;
+
+	if (padapter->pbuddy_adapter == NULL) {
+		res = false;
+	} else if ((padapter->pbuddy_adapter->bDriverStopped) ||
+		   (padapter->pbuddy_adapter->bSurpriseRemoved) ||
+		   (padapter->pbuddy_adapter->bup == false) ||
+		   (padapter->pbuddy_adapter->hw_init_completed == false)) {
+		res = false;
+	} else {
+		res = true;
+	}
+
+	return res;
+}
+
+int check_buddy_fwstate(struct rtw_adapter *padapter, int state)
+{
+	if (padapter == NULL)
+		return false;
+
+	if (padapter->pbuddy_adapter == NULL)
+		return false;
+
+	if ((state == WIFI_FW_NULL_STATE) &&
+	    (padapter->pbuddy_adapter->mlmepriv.fw_state == WIFI_FW_NULL_STATE))
+		return true;
+
+	if (padapter->pbuddy_adapter->mlmepriv.fw_state & state)
+		return true;
+
+	return false;
+}
+#endif /* CONFIG_CONCURRENT_MODE */
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_mlme_ext.c b/drivers/net/wireless/rtl8192du/core/rtw_mlme_ext.c
new file mode 100644
index 0000000..8779d40
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_mlme_ext.c
@@ -0,0 +1,8231 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ *published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_MLME_EXT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <rtw_mlme_ext.h>
+#include <wlan_bssdef.h>
+#include <mlme_osdep.h>
+#include <recv_osdep.h>
+
+static struct mlme_handler mlme_sta_tbl[] = {
+	{WIFI_ASSOCREQ, "OnAssocReq", &OnAssocReq},
+	{WIFI_ASSOCRSP, "OnAssocRsp", &OnAssocRsp},
+	{WIFI_REASSOCREQ, "OnReAssocReq", &OnAssocReq},
+	{WIFI_REASSOCRSP, "OnReAssocRsp", &OnAssocRsp},
+	{WIFI_PROBEREQ, "OnProbeReq", &OnProbeReq},
+	{WIFI_PROBERSP, "OnProbeRsp", &OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0, "DoReserved", &DoReserved},
+	{0, "DoReserved", &DoReserved},
+	{WIFI_BEACON, "OnBeacon", &OnBeacon},
+	{WIFI_ATIM, "OnATIM", &OnAtim},
+	{WIFI_DISASSOC, "OnDisassoc", &OnDisassoc},
+	{WIFI_AUTH, "OnAuth", &OnAuthClient},
+	{WIFI_DEAUTH, "OnDeAuth", &OnDeAuth},
+	{WIFI_ACTION, "OnAction", &OnAction},
+};
+
+#ifdef _CONFIG_NATIVEAP_MLME_
+static struct mlme_handler mlme_ap_tbl[] = {
+	{WIFI_ASSOCREQ, "OnAssocReq", &OnAssocReq},
+	{WIFI_ASSOCRSP, "OnAssocRsp", &OnAssocRsp},
+	{WIFI_REASSOCREQ, "OnReAssocReq", &OnAssocReq},
+	{WIFI_REASSOCRSP, "OnReAssocRsp", &OnAssocRsp},
+	{WIFI_PROBEREQ, "OnProbeReq", &OnProbeReq},
+	{WIFI_PROBERSP, "OnProbeRsp", &OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0, "DoReserved", &DoReserved},
+	{0, "DoReserved", &DoReserved},
+	{WIFI_BEACON, "OnBeacon", &OnBeacon},
+	{WIFI_ATIM, "OnATIM", &OnAtim},
+	{WIFI_DISASSOC, "OnDisassoc", &OnDisassoc},
+	{WIFI_AUTH, "OnAuth", &OnAuth},
+	{WIFI_DEAUTH, "OnDeAuth", &OnDeAuth},
+	{WIFI_ACTION, "OnAction", &OnAction},
+};
+#endif
+
+static struct action_handler OnAction_tbl[] = {
+	{RTW_WLAN_CATEGORY_SPECTRUM_MGMT, "ACTION_SPECTRUM_MGMT",
+	 on_action_spct},
+	{RTW_WLAN_CATEGORY_QOS, "ACTION_QOS", &OnAction_qos},
+	{RTW_WLAN_CATEGORY_DLS, "ACTION_DLS", &OnAction_dls},
+	{RTW_WLAN_CATEGORY_BACK, "ACTION_BACK", &OnAction_back},
+	{RTW_WLAN_CATEGORY_PUBLIC, "ACTION_PUBLIC", on_action_public},
+	{RTW_WLAN_CATEGORY_RADIO_MEASUREMENT, "ACTION_RADIO_MEASUREMENT",
+	 &DoReserved},
+	{RTW_WLAN_CATEGORY_FT, "ACTION_FT", &DoReserved},
+	{RTW_WLAN_CATEGORY_HT, "ACTION_HT", &OnAction_ht},
+	{RTW_WLAN_CATEGORY_SA_QUERY, "ACTION_SA_QUERY", &DoReserved},
+	{RTW_WLAN_CATEGORY_WMM, "ACTION_WMM", &OnAction_wmm},
+	{RTW_WLAN_CATEGORY_P2P, "ACTION_P2P", &OnAction_p2p},
+};
+
+static u8 null_addr[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+
+/**************************************************
+OUI definitions for the vendor specific IE
+***************************************************/
+unsigned char RTW_WPA_OUI[] = { 0x00, 0x50, 0xf2, 0x01 };
+unsigned char WMM_OUI[] = { 0x00, 0x50, 0xf2, 0x02 };
+unsigned char WPS_OUI[] = { 0x00, 0x50, 0xf2, 0x04 };
+unsigned char P2P_OUI[] = { 0x50, 0x6F, 0x9A, 0x09 };
+unsigned char WFD_OUI[] = { 0x50, 0x6F, 0x9A, 0x0A };
+
+unsigned char WMM_INFO_OUI[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01 };
+unsigned char WMM_PARA_OUI[] = { 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01 };
+
+unsigned char WPA_TKIP_CIPHER[4] = { 0x00, 0x50, 0xf2, 0x02 };
+unsigned char RSN_TKIP_CIPHER[4] = { 0x00, 0x0f, 0xac, 0x02 };
+
+extern unsigned char REALTEK_96B_IE[];
+
+/********************************************************
+MCS rate definitions
+*********************************************************/
+unsigned char MCS_rate_2R[16] = {
+	0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x0
+};
+
+unsigned char MCS_rate_1R[16] = {
+	0xff, 0x00, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	0x0, 0x0
+};
+
+/********************************************************
+ChannelPlan definitions
+*********************************************************/
+
+static struct rt_channel_plan_2g RTW_ChannelPlan2G[RT_CHANNEL_DOMAIN_2G_MAX] = {
+	{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},	/*  0x00, RT_CHANNEL_DOMAIN_2G_WORLD , Passive scan CH 12, 13 */
+	{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}, 13},	/*  0x01, RT_CHANNEL_DOMAIN_2G_ETSI1 */
+	{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, 11},	/*  0x02, RT_CHANNEL_DOMAIN_2G_FCC1 */
+	{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}, 14},	/*  0x03, RT_CHANNEL_DOMAIN_2G_MIKK1 */
+	{{10, 11, 12, 13}, 4},	/*  0x04, RT_CHANNEL_DOMAIN_2G_ETSI2 */
+	{{}, 0},		/*  0x05, RT_CHANNEL_DOMAIN_2G_NULL */
+};
+
+static struct rt_channel_plan_5g RTW_ChannelPlan5G[RT_CHANNEL_DOMAIN_5G_MAX] = {
+	{{}, 0},		/*  0x00, RT_CHANNEL_DOMAIN_5G_NULL */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}, 19},	/*  0x01, RT_CHANNEL_DOMAIN_5G_ETSI1 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165}, 24},	/*  0x02, RT_CHANNEL_DOMAIN_5G_ETSI2 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 149, 153, 157, 161, 165}, 22},	/*  0x03, RT_CHANNEL_DOMAIN_5G_ETSI3 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 149, 153, 157, 161, 165}, 24},	/*  0x04, RT_CHANNEL_DOMAIN_5G_FCC1 */
+	{{36, 40, 44, 48, 149, 153, 157, 161, 165}, 9},	/*  0x05, RT_CHANNEL_DOMAIN_5G_FCC2 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161, 165}, 13},	/*  0x06, RT_CHANNEL_DOMAIN_5G_FCC3 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 149, 153, 157, 161}, 12},	/*  0x07, RT_CHANNEL_DOMAIN_5G_FCC4 */
+	{{149, 153, 157, 161, 165}, 5},	/*  0x08, RT_CHANNEL_DOMAIN_5G_FCC5 */
+	{{36, 40, 44, 48, 52, 56, 60, 64}, 8},	/*  0x09, RT_CHANNEL_DOMAIN_5G_FCC6 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165}, 20},	/*  0x0A, RT_CHANNEL_DOMAIN_5G_FCC7_IC1 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 149, 153, 157, 161, 165}, 20},	/*  0x0B, RT_CHANNEL_DOMAIN_5G_KCC1 */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}, 19},	/*  0x0C, RT_CHANNEL_DOMAIN_5G_MKK1 */
+	{{36, 40, 44, 48, 52, 56, 60, 64}, 8},	/*  0x0D, RT_CHANNEL_DOMAIN_5G_MKK2 */
+	{{100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140}, 11},	/*  0x0E, RT_CHANNEL_DOMAIN_5G_MKK3 */
+	{{56, 60, 64, 100, 104, 108, 112, 116, 136, 140, 149, 153, 157, 161, 165}, 15},	/*  0x0F, RT_CHANNEL_DOMAIN_5G_NCC1 */
+	{{56, 60, 64, 149, 153, 157, 161, 165}, 8},	/*  0x10, RT_CHANNEL_DOMAIN_5G_NCC2 */
+
+	/*  Driver self defined for old channel plan Compatible ,Remember to modify if have new channel plan definition ===== */
+	{{36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 132, 136, 140, 149, 153, 157, 161, 165}, 21},	/*  0x11, RT_CHANNEL_DOMAIN_5G_FCC */
+	{{36, 40, 44, 48}, 4},	/*  0x12, RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS */
+	{{36, 40, 44, 48, 149, 153, 157, 161}, 8},	/*  0x13, RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS */
+};
+
+static struct rt_channel_plan_map RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
+	/*  0x00 ~ 0x1F , Old Define ===== */
+	{0x02, 0x11},		/* 0x00, RT_CHANNEL_DOMAIN_FCC */
+	{0x02, 0x0A},		/* 0x01, RT_CHANNEL_DOMAIN_IC */
+	{0x01, 0x01},		/* 0x02, RT_CHANNEL_DOMAIN_ETSI */
+	{0x01, 0x00},		/* 0x03, RT_CHANNEL_DOMAIN_SPAIN */
+	{0x01, 0x00},		/* 0x04, RT_CHANNEL_DOMAIN_FRANCE */
+	{0x03, 0x00},		/* 0x05, RT_CHANNEL_DOMAIN_MKK */
+	{0x03, 0x00},		/* 0x06, RT_CHANNEL_DOMAIN_MKK1 */
+	{0x01, 0x09},		/* 0x07, RT_CHANNEL_DOMAIN_ISRAEL */
+	{0x03, 0x09},		/* 0x08, RT_CHANNEL_DOMAIN_TELEC */
+	{0x03, 0x00},		/* 0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN */
+	{0x00, 0x00},		/* 0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13 */
+	{0x02, 0x0F},		/* 0x0B, RT_CHANNEL_DOMAIN_TAIWAN */
+	{0x01, 0x08},		/* 0x0C, RT_CHANNEL_DOMAIN_CHINA */
+	{0x02, 0x06},		/* 0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO */
+	{0x02, 0x0B},		/* 0x0E, RT_CHANNEL_DOMAIN_KOREA */
+	{0x02, 0x09},		/* 0x0F, RT_CHANNEL_DOMAIN_TURKEY */
+	{0x01, 0x01},		/* 0x10, RT_CHANNEL_DOMAIN_JAPAN */
+	{0x02, 0x05},		/* 0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS */
+	{0x01, 0x12},		/* 0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS */
+	{0x00, 0x04},		/* 0x13, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G */
+	{0x02, 0x10},		/* 0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS */
+	{0x00, 0x12},		/* 0x15, RT_CHANNEL_DOMAIN_ETSI_NO_DFS */
+	{0x00, 0x13},		/* 0x16, RT_CHANNEL_DOMAIN_KOREA_NO_DFS */
+	{0x03, 0x12},		/* 0x17, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS */
+	{0x05, 0x08},		/* 0x18, RT_CHANNEL_DOMAIN_PAKISTAN_NO_DFS */
+	{0x02, 0x08},		/* 0x19, RT_CHANNEL_DOMAIN_TAIWAN2_NO_DFS */
+	{0x00, 0x00},		/* 0x1A, */
+	{0x00, 0x00},		/* 0x1B, */
+	{0x00, 0x00},		/* 0x1C, */
+	{0x00, 0x00},		/* 0x1D, */
+	{0x00, 0x00},		/* 0x1E, */
+	{0x05, 0x04},		/* 0x1F, RT_CHANNEL_DOMAIN_WORLD_WIDE_ONLY_5G */
+	/*  0x20 ~ 0x7F ,New Define ===== */
+	{0x00, 0x00},		/* 0x20, RT_CHANNEL_DOMAIN_WORLD_NULL */
+	{0x01, 0x00},		/* 0x21, RT_CHANNEL_DOMAIN_ETSI1_NULL */
+	{0x02, 0x00},		/* 0x22, RT_CHANNEL_DOMAIN_FCC1_NULL */
+	{0x03, 0x00},		/* 0x23, RT_CHANNEL_DOMAIN_MKK1_NULL */
+	{0x04, 0x00},		/* 0x24, RT_CHANNEL_DOMAIN_ETSI2_NULL */
+	{0x02, 0x04},		/* 0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1 */
+	{0x00, 0x01},		/* 0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1 */
+	{0x03, 0x0C},		/* 0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1 */
+	{0x00, 0x0B},		/* 0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1 */
+	{0x00, 0x05},		/* 0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2 */
+	{0x00, 0x00},		/* 0x2A, */
+	{0x00, 0x00},		/* 0x2B, */
+	{0x00, 0x00},		/* 0x2C, */
+	{0x00, 0x00},		/* 0x2D, */
+	{0x00, 0x00},		/* 0x2E, */
+	{0x00, 0x00},		/* 0x2F, */
+	{0x00, 0x06},		/* 0x30, RT_CHANNEL_DOMAIN_WORLD_FCC3 */
+	{0x00, 0x07},		/* 0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4 */
+	{0x00, 0x08},		/* 0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5 */
+	{0x00, 0x09},		/* 0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6 */
+	{0x02, 0x0A},		/* 0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7 */
+	{0x00, 0x02},		/* 0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2 */
+	{0x00, 0x03},		/* 0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3 */
+	{0x03, 0x0D},		/* 0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2 */
+	{0x03, 0x0E},		/* 0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3 */
+	{0x02, 0x0F},		/* 0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1 */
+	{0x00, 0x00},		/* 0x3A, */
+	{0x00, 0x00},		/* 0x3B, */
+	{0x00, 0x00},		/* 0x3C, */
+	{0x00, 0x00},		/* 0x3D, */
+	{0x00, 0x00},		/* 0x3E, */
+	{0x00, 0x00},		/* 0x3F, */
+	{0x02, 0x10},		/* 0x40, RT_CHANNEL_DOMAIN_FCC1_NCC2 */
+};
+
+static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = { 0x03, 0x02 };	/* use the conbination for max channel numbers */
+
+/*
+ * Search the @param channel_num in given @param channel_set
+ * @ch_set: the given channel set
+ * @ch: the given channel number
+ *
+ * return the index of channel_num in channel_set, -1 if not found
+ */
+int rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch)
+{
+	int i;
+	for (i = 0; ch_set[i].ChannelNum != 0; i++) {
+		if (ch == ch_set[i].ChannelNum)
+			break;
+	}
+
+	if (i >= ch_set[i].ChannelNum)
+		return -1;
+	return i;
+}
+
+/****************************************************************************
+
+Following are the initialization functions for WiFi MLME
+
+*****************************************************************************/
+
+int init_hw_mlme_ext(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+
+	set_channel_bwmode(adapt, pmlmeext->cur_channel,
+			   pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	return _SUCCESS;
+}
+
+static void init_mlme_ext_priv_value(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	unsigned char mixed_datarate[NUMRATES] = {
+		_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _9M_RATE_,
+		_12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff
+	};
+	unsigned char mixed_basicrate[NUMRATES] = {
+		_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,
+		_12M_RATE_, _24M_RATE_, 0xff,
+	 };
+
+	ATOMIC_SET(&pmlmeext->event_seq, 0);
+	pmlmeext->mgnt_seq = 0;	/* reset to zero when disconnect at client mode */
+
+	pmlmeext->cur_channel = adapt->registrypriv.channel;
+	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	pmlmeext->retry = 0;
+
+	pmlmeext->cur_wireless_mode = adapt->registrypriv.wireless_mode;
+
+	memcpy(pmlmeext->datarate, mixed_datarate, NUMRATES);
+	memcpy(pmlmeext->basicrate, mixed_basicrate, NUMRATES);
+
+	if (pmlmeext->cur_channel > 14)
+		pmlmeext->tx_rate = IEEE80211_OFDM_RATE_6MB;
+	else
+		pmlmeext->tx_rate = IEEE80211_CCK_RATE_1MB;
+
+	pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
+	pmlmeext->sitesurvey_res.channel_idx = 0;
+	pmlmeext->sitesurvey_res.bss_cnt = 0;
+	pmlmeext->scan_abort = false;
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+	pmlmeinfo->auth_seq = 0;
+	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
+	pmlmeinfo->key_index = 0;
+	pmlmeinfo->iv = 0;
+
+	pmlmeinfo->enc_algo = _NO_PRIVACY_;
+	pmlmeinfo->authModeToggle = 0;
+
+	memset(pmlmeinfo->chg_txt, 0, 128);
+
+	pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+	pmlmeinfo->preamble_mode = PREAMBLE_AUTO;
+
+	pmlmeinfo->dialogToken = 0;
+
+	pmlmeext->action_public_rxseq = 0xffff;
+	pmlmeext->action_public_dialog_token = 0xff;
+}
+
+static int has_channel(struct rt_channel_info *channel_set,
+		       u8 chanset_size, u8 chan)
+{
+	int i;
+
+	for (i = 0; i < chanset_size; i++) {
+		if (channel_set[i].ChannelNum == chan) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void init_channel_list(struct rtw_adapter *adapt,
+			      struct rt_channel_info *channel_set,
+			      u8 chanset_size,
+			      struct p2p_channels *channel_list)
+{
+	struct p2p_oper_class_map op_class[] = {
+		{IEEE80211G, 81, 1, 13, 1, BW20},
+		{IEEE80211G, 82, 14, 14, 1, BW20},
+		{IEEE80211A, 115, 36, 48, 4, BW20},
+		{IEEE80211A, 116, 36, 44, 8, BW40PLUS},
+		{IEEE80211A, 117, 40, 48, 8, BW40MINUS},
+		{IEEE80211A, 124, 149, 161, 4, BW20},
+		{IEEE80211A, 125, 149, 169, 4, BW20},
+		{IEEE80211A, 126, 149, 157, 8, BW40PLUS},
+		{IEEE80211A, 127, 153, 161, 8, BW40MINUS},
+		{-1, 0, 0, 0, 0, BW20}
+	};
+
+	int cla, op;
+
+	cla = 0;
+
+	for (op = 0; op_class[op].op_class; op++) {
+		u8 ch;
+		struct p2p_oper_class_map *o = &op_class[op];
+		struct p2p_reg_class *reg = NULL;
+
+		for (ch = o->min_chan; ch <= o->max_chan; ch += o->inc) {
+			if (!has_channel(channel_set, chanset_size, ch)) {
+				continue;
+			}
+
+			if ((0 == adapt->registrypriv.ht_enable) &&
+			    (8 == o->inc))
+				continue;
+
+			if ((0 == (adapt->registrypriv.cbw40_enable & BIT(1))) &&
+			    ((BW40MINUS == o->bw) || (BW40PLUS == o->bw)))
+				continue;
+
+			if (reg == NULL) {
+				reg = &channel_list->reg_class[cla];
+				cla++;
+				reg->reg_class = o->op_class;
+				reg->channels = 0;
+			}
+			reg->channel[reg->channels] = ch;
+			reg->channels++;
+		}
+	}
+	channel_list->reg_classes = cla;
+}
+
+static u8 init_channel_set(struct rtw_adapter *adapt, u8 ChannelPlan,
+			   struct rt_channel_info *channel_set)
+{
+	u8 index, chanset_size = 0;
+	u8 b5GBand = false, b2_4GBand = false;
+	u8 Index2G = 0, Index5G = 0;
+
+	memset(channel_set, 0,
+	       sizeof(struct rt_channel_info) * MAX_CHANNEL_NUM);
+
+	if (ChannelPlan >= RT_CHANNEL_DOMAIN_MAX &&
+	    ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE) {
+		DBG_8192D("ChannelPlan ID %x error !!!!!\n", ChannelPlan);
+		return chanset_size;
+	}
+
+	if (adapt->registrypriv.wireless_mode & WIRELESS_11G) {
+		b2_4GBand = true;
+		if (RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
+			Index2G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index2G;
+		else
+			Index2G = RTW_ChannelPlanMap[ChannelPlan].Index2G;
+	}
+
+	if (adapt->registrypriv.wireless_mode & WIRELESS_11A) {
+		b5GBand = true;
+		if (RT_CHANNEL_DOMAIN_REALTEK_DEFINE == ChannelPlan)
+			Index5G = RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE.Index5G;
+		else
+			Index5G = RTW_ChannelPlanMap[ChannelPlan].Index5G;
+	}
+
+	if (b2_4GBand) {
+		for (index = 0; index < RTW_ChannelPlan2G[Index2G].Len; index++) {
+			channel_set[chanset_size].ChannelNum =
+			    RTW_ChannelPlan2G[Index2G].Channel[index];
+
+			if (RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) {	/* Channel 1~11 is active, and 12~14 is passive */
+				if (channel_set[chanset_size].ChannelNum >= 1 &&
+				    channel_set[chanset_size].ChannelNum <= 11)
+					channel_set[chanset_size].ScanType =
+					    SCAN_ACTIVE;
+				else if ((channel_set[chanset_size].ChannelNum >= 12 &&
+					 channel_set[chanset_size].ChannelNum <= 14))
+					channel_set[chanset_size].ScanType =
+					    SCAN_PASSIVE;
+			} else if (RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan || RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan || RT_CHANNEL_DOMAIN_2G_WORLD == Index2G) {	/*  channel 12~13, passive scan */
+				if (channel_set[chanset_size].ChannelNum <= 11)
+					channel_set[chanset_size].ScanType =
+					    SCAN_ACTIVE;
+				else
+					channel_set[chanset_size].ScanType =
+					    SCAN_PASSIVE;
+			} else {
+				channel_set[chanset_size].ScanType =
+				    SCAN_ACTIVE;
+			}
+
+			chanset_size++;
+		}
+	}
+
+	if (b5GBand) {
+		for (index = 0; index < RTW_ChannelPlan5G[Index5G].Len; index++) {
+#ifdef CONFIG_DFS
+			channel_set[chanset_size].ChannelNum =
+			    RTW_ChannelPlan5G[Index5G].Channel[index];
+			if (channel_set[chanset_size].ChannelNum <= 48 ||
+			    channel_set[chanset_size].ChannelNum >= 149) {
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)	/*passive scan for all 5G channels */
+					channel_set[chanset_size].ScanType =
+					    SCAN_PASSIVE;
+				else
+					channel_set[chanset_size].ScanType =
+					    SCAN_ACTIVE;
+			} else {
+				channel_set[chanset_size].ScanType =
+				    SCAN_PASSIVE;
+			}
+			chanset_size++;
+#else /* CONFIG_DFS */
+			if (RTW_ChannelPlan5G[Index5G].Channel[index] <= 48 ||
+			    RTW_ChannelPlan5G[Index5G].Channel[index] >= 149) {
+				channel_set[chanset_size].ChannelNum =
+				    RTW_ChannelPlan5G[Index5G].Channel[index];
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)	/*passive scan for all 5G channels */
+					channel_set[chanset_size].ScanType =
+					    SCAN_PASSIVE;
+				else
+					channel_set[chanset_size].ScanType =
+					    SCAN_ACTIVE;
+				DBG_8192D
+				    ("%s(): channel_set[%d].ChannelNum = %d\n",
+				     __func__, chanset_size,
+				     channel_set[chanset_size].ChannelNum);
+				chanset_size++;
+			}
+#endif /* CONFIG_DFS */
+		}
+	}
+
+	return chanset_size;
+}
+
+int init_mlme_ext_priv(struct rtw_adapter *adapt)
+{
+	int res = _SUCCESS;
+	struct registry_priv *pregistrypriv = &adapt->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pmlmeext->padapter = adapt;
+
+	init_mlme_ext_priv_value(adapt);
+	pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
+
+	init_mlme_ext_timer(adapt);
+
+#ifdef CONFIG_92D_AP_MODE
+	init_mlme_ap_info(adapt);
+#endif
+
+	pmlmeext->max_chan_nums =
+	    init_channel_set(adapt, pmlmepriv->ChannelPlan,
+			     pmlmeext->channel_set);
+	init_channel_list(adapt, pmlmeext->channel_set,
+			  pmlmeext->max_chan_nums, &pmlmeext->channel_list);
+
+	pmlmeext->chan_scan_time = SURVEY_TO;
+	pmlmeext->mlmeext_init = true;
+
+	pmlmeext->active_keep_alive_check = true;
+	return res;
+}
+
+void free_mlme_ext_priv(struct mlme_ext_priv *pmlmeext)
+{
+	struct rtw_adapter *adapt = pmlmeext->padapter;
+
+	if (!adapt)
+		return;
+
+	if (adapt->bDriverStopped == true) {
+		_cancel_timer_ex(&pmlmeext->survey_timer);
+		_cancel_timer_ex(&pmlmeext->link_timer);
+	}
+}
+
+static u8 cmp_pkt_chnl_diff(struct rtw_adapter *adapt, u8 *pframe,
+			    uint packet_len)
+{				/*  if the channel is same, return 0. else return channel differential */
+	uint len;
+	u8 channel;
+	u8 *p;
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_,
+		       _DSSET_IE_, &len, packet_len - _BEACON_IE_OFFSET_);
+	if (p) {
+		channel = *(p + 2);
+		if (adapt->mlmeextpriv.cur_channel >= channel) {
+			return adapt->mlmeextpriv.cur_channel - channel;
+		} else {
+			return channel - adapt->mlmeextpriv.cur_channel;
+		}
+	} else {
+		return 0;
+	}
+}
+
+static void _mgt_dispatcher(struct rtw_adapter *adapt,
+			    struct mlme_handler *ptable,
+			    struct recv_frame_hdr *precv_frame)
+{
+	u8 bc_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	u8 *pframe = precv_frame->rx_data;
+
+	if (ptable->func) {
+		/* receive the frames that ra(a1) is my address or ra(a1) is bc address. */
+		if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&adapt->eeprompriv), ETH_ALEN) &&
+		    !_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
+			return;
+		ptable->func(adapt, precv_frame);
+	}
+}
+
+void mgt_dispatcher(struct rtw_adapter *adapt, struct recv_frame_hdr *precv_frame)
+{
+	int index;
+	struct mlme_handler *ptable;
+#ifdef CONFIG_92D_AP_MODE
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+#endif /* CONFIG_92D_AP_MODE */
+	u8 bc_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	u8 *pframe = precv_frame->rx_data;
+	struct sta_info *psta =
+	    rtw_get_stainfo(&adapt->stapriv, GetAddr2Ptr(pframe));
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,
+		 ("+mgt_dispatcher: type(0x%x) subtype(0x%x)\n",
+		  GetFrameType(pframe), GetFrameSubType(pframe)));
+
+	if (GetFrameType(pframe) != WIFI_MGT_TYPE) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("mgt_dispatcher: type(0x%x) error!\n",
+			  GetFrameType(pframe)));
+		return;
+	}
+
+	/* receive the frames that ra(a1) is my address or ra(a1) is bc address. */
+	if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&adapt->eeprompriv), ETH_ALEN) &&
+	    !_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN)) {
+		return;
+	}
+
+	ptable = mlme_sta_tbl;
+
+	index = GetFrameSubType(pframe) >> 4;
+
+	if (index > 13) {
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+			 ("Currently we do not support reserved sub-fr-type=%d\n",
+			  index));
+		return;
+	}
+	ptable += index;
+
+	if (psta != NULL) {
+		if (GetRetry(pframe)) {
+			if (precv_frame->attrib.seq_num ==
+			    psta->RxMgmtFrameSeqNum) {
+				/* drop the duplicate management frame */
+				DBG_8192D
+				    ("Drop duplicate management frame with seq_num = %d.\n",
+				     precv_frame->attrib.seq_num);
+				return;
+			}
+		}
+		psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
+	}
+#ifdef CONFIG_92D_AP_MODE
+	switch (GetFrameSubType(pframe)) {
+	case WIFI_AUTH:
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			ptable->func = &OnAuth;
+		else
+			ptable->func = &OnAuthClient;
+		/*pass through */
+	case WIFI_ASSOCREQ:
+	case WIFI_REASSOCREQ:
+		_mgt_dispatcher(adapt, ptable, precv_frame);
+#ifdef CONFIG_HOSTAPD_MLME
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			rtw_hostapd_mlme_rx(adapt, precv_frame);
+#endif
+		break;
+	case WIFI_PROBEREQ:
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+#ifdef CONFIG_HOSTAPD_MLME
+			rtw_hostapd_mlme_rx(adapt, precv_frame);
+#else
+			_mgt_dispatcher(adapt, ptable, precv_frame);
+#endif
+		} else
+			_mgt_dispatcher(adapt, ptable, precv_frame);
+		break;
+	case WIFI_BEACON:
+		_mgt_dispatcher(adapt, ptable, precv_frame);
+		break;
+	case WIFI_ACTION:
+		/* if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) */
+		_mgt_dispatcher(adapt, ptable, precv_frame);
+		break;
+	default:
+		_mgt_dispatcher(adapt, ptable, precv_frame);
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			rtw_hostapd_mlme_rx(adapt, precv_frame);
+		break;
+	}
+#else
+
+	_mgt_dispatcher(adapt, ptable, precv_frame);
+
+#endif
+}
+
+/****************************************************************************
+
+Following are the callback functions for each subtype of the management frames
+
+*****************************************************************************/
+
+unsigned int OnProbeReq(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+	unsigned int ielen;
+	unsigned char *p;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *cur = &(pmlmeinfo->network);
+	u8 *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	u8 is_valid_p2p_probereq = false;
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		return _SUCCESS;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == false &&
+	    check_fwstate(pmlmepriv,
+			  WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE) == false) {
+		return _SUCCESS;
+	}
+#ifdef CONFIG_CONCURRENT_MODE
+	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
+		/* don't process probe req */
+		return _SUCCESS;
+	}
+#endif
+
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_,
+		       _SSID_IE_, (int *)&ielen,
+		       len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+
+	/* check (wildcard) SSID */
+	if (p != NULL) {
+		if (is_valid_p2p_probereq == true) {
+			goto _issue_probersp;
+		}
+
+		if ((ielen != 0 &&
+		    false == _rtw_memcmp((void *)(p + 2),
+					 (void *)cur->Ssid.Ssid,
+					 cur->Ssid.SsidLength)) ||
+		    (ielen == 0 && pmlmeinfo->hidden_ssid_mode)
+		   ) {
+			return _SUCCESS;
+		}
+
+_issue_probersp:
+
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+		    pmlmepriv->cur_network.join_res == true) {
+			issue_probersp(adapt, get_sa(pframe),
+				       is_valid_p2p_probereq);
+		}
+	}
+	return _SUCCESS;
+}
+
+unsigned int OnProbeRsp(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+	struct sta_info *psta;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	u8 *pframe = precv_frame->rx_data;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
+		report_survey_event(adapt, precv_frame);
+#ifdef CONFIG_CONCURRENT_MODE
+		report_survey_event(adapt->pbuddy_adapter, precv_frame);
+#endif
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		dc_report_survey_event(adapt, precv_frame);
+#endif
+		return _SUCCESS;
+	}
+
+	return _SUCCESS;
+}
+
+unsigned int OnBeacon(struct rtw_adapter *adapt,
+		      struct recv_frame_hdr *precv_frame)
+{
+	int cam_idx;
+	struct sta_info *psta;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	u8 *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
+		report_survey_event(adapt, precv_frame);
+#ifdef CONFIG_CONCURRENT_MODE
+		report_survey_event(adapt->pbuddy_adapter, precv_frame);
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		dc_report_survey_event(adapt, precv_frame);
+#endif
+
+		return _SUCCESS;
+	}
+
+	if (_rtw_memcmp
+	    (GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network),
+	     ETH_ALEN)) {
+		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {
+			/* check the vendor of the assoc AP */
+			pmlmeinfo->assoc_AP_vendor =
+			    check_assoc_AP(pframe +
+					   sizeof(struct
+						  rtw_ieee80211_hdr_3addr),
+					   len -
+					   sizeof(struct
+						  rtw_ieee80211_hdr_3addr));
+			/* update TSF Value */
+			update_TSF(pmlmeext, pframe, len);
+
+			/* start auth */
+			start_clnt_auth(adapt);
+
+			return _SUCCESS;
+		}
+
+		if (((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) &&
+		    (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
+			psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+			if (psta != NULL) {
+#ifdef CONFIG_PATCH_JOIN_WRONG_CHANNEL
+				/* Merge from 8712 FW code */
+				if (cmp_pkt_chnl_diff(adapt, pframe, len) != 0) {	/*  join wrong channel, deauth and reconnect */
+					issue_deauth(adapt,
+						     (&(pmlmeinfo->network))->
+						     MacAddress,
+						     WLAN_REASON_DEAUTH_LEAVING);
+
+					report_del_sta_event(adapt,
+							     (&
+							      (pmlmeinfo->
+							       network))->
+							     MacAddress,
+							     WLAN_REASON_JOIN_WRONG_CHANNEL);
+					pmlmeinfo->state &=
+					    (~WIFI_FW_ASSOC_SUCCESS);
+					return _SUCCESS;
+				}
+#endif /* CONFIG_PATCH_JOIN_WRONG_CHANNEL */
+
+				/* update WMM, ERP in the beacon */
+				/* todo: the timer is used instead of the number of the beacon received */
+				if ((sta_rx_pkts(psta) & 0xf) == 0) {
+					/* DBG_8192D("update_bcn_info\n"); */
+					update_beacon_info(adapt, pframe,
+							   len, psta);
+				}
+#ifdef CONFIG_DFS
+				process_csa_ie(adapt, pframe, len);	/* channel switch announcement */
+#endif /* CONFIG_DFS */
+			}
+		} else if ((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) {
+			psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+			if (psta != NULL) {
+				/* update WMM, ERP in the beacon */
+				/* todo: the timer is used instead of the number of the beacon received */
+				if ((sta_rx_pkts(psta) & 0xf) == 0)
+					update_beacon_info(adapt, pframe,
+							   len, psta);
+
+			} else {
+				/* allocate a new CAM entry for IBSS station */
+				cam_idx = allocate_fw_sta_entry(adapt);
+				if (cam_idx == NUM_STA)
+					goto _END_ONBEACON_;
+
+				/* get supported rate */
+				if (update_sta_support_rate
+				    (adapt,
+				     (pframe + WLAN_HDR_A3_LEN +
+				      _BEACON_IE_OFFSET_),
+				     (len - WLAN_HDR_A3_LEN -
+				      _BEACON_IE_OFFSET_), cam_idx) == _FAIL) {
+					pmlmeinfo->FW_sta_info[cam_idx].status =
+					    0;
+					goto _END_ONBEACON_;
+				}
+
+				/* update TSF Value */
+				update_TSF(pmlmeext, pframe, len);
+
+				/* report sta add event */
+				report_add_sta_event(adapt,
+						     GetAddr2Ptr(pframe),
+						     cam_idx);
+			}
+		}
+	}
+
+_END_ONBEACON_:
+
+	return _SUCCESS;
+}
+
+unsigned int OnAuth(struct rtw_adapter *adapt, struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_92D_AP_MODE
+	unsigned int auth_mode, seq, ie_len;
+	unsigned char *sa, *p;
+	u16 algorithm;
+	int status;
+	static struct sta_info stat;
+	struct sta_info *pstat = NULL;
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	struct security_priv *psecuritypriv = &adapt->securitypriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
+		/* don't process auth request; */
+		return _SUCCESS;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
+		return _FAIL;
+
+	DBG_8192D("+OnAuth\n");
+
+	sa = GetAddr2Ptr(pframe);
+
+	auth_mode = psecuritypriv->dot11AuthAlgrthm;
+	seq = le16_to_cpu(*(__le16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + 2));
+	algorithm = le16_to_cpu(*(__le16 *)((SIZE_PTR) pframe + WLAN_HDR_A3_LEN));
+
+	DBG_8192D("auth alg=%x, seq=%X\n", algorithm, seq);
+
+	if (auth_mode == 2 &&
+	    psecuritypriv->dot11PrivacyAlgrthm != _WEP40_ &&
+	    psecuritypriv->dot11PrivacyAlgrthm != _WEP104_)
+		auth_mode = 0;
+
+	if ((algorithm > 0 && auth_mode == 0) ||	/*  rx a shared-key auth but shared not enabled */
+	    (algorithm == 0 && auth_mode == 1)) {	/*  rx a open-system auth but shared-key is enabled */
+		DBG_8192D
+		    ("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",
+		     algorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4],
+		     sa[5]);
+
+		status = _STATS_NO_SUPP_ALG_;
+
+		goto auth_fail;
+	}
+
+	if (rtw_access_ctrl(adapt, sa) == false) {
+		status = _STATS_UNABLE_HANDLE_STA_;
+		goto auth_fail;
+	}
+
+	pstat = rtw_get_stainfo(pstapriv, sa);
+	if (pstat == NULL) {
+		/*  allocate a new one */
+		DBG_8192D("going to alloc stainfo for sa=%pM\n", sa);
+		pstat = rtw_alloc_stainfo(pstapriv, sa);
+		if (pstat == NULL) {
+			DBG_8192D
+			    (" Exceed the upper limit of supported clients...\n");
+			status = _STATS_UNABLE_HANDLE_STA_;
+			goto auth_fail;
+		}
+
+		pstat->state = WIFI_FW_AUTH_NULL;
+		pstat->auth_seq = 0;
+	} else {
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if (rtw_is_list_empty(&pstat->asoc_list) == false) {
+			list_del_init(&pstat->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			if (pstat->expire_to > 0) {
+				/* TODO: STA re_auth within expire_to */
+			}
+		}
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+		if (seq == 1) {
+			/* TODO: STA re_auth and auth timeout */
+		}
+	}
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (rtw_is_list_empty(&pstat->auth_list)) {
+		rtw_list_insert_tail(&pstat->auth_list, &pstapriv->auth_list);
+		pstapriv->auth_list_cnt++;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	if (pstat->auth_seq == 0)
+		pstat->expire_to = pstapriv->auth_to;
+
+	if ((pstat->auth_seq + 1) != seq) {
+		DBG_8192D
+		    ("(1)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+		     seq, pstat->auth_seq + 1);
+		status = _STATS_OUT_OF_AUTH_SEQ_;
+		goto auth_fail;
+	}
+
+	if (algorithm == 0 && (auth_mode == 0 || auth_mode == 2)) {
+		if (seq == 1) {
+			pstat->state &= ~WIFI_FW_AUTH_NULL;
+			pstat->state |= WIFI_FW_AUTH_SUCCESS;
+			pstat->expire_to = pstapriv->assoc_to;
+			pstat->authalg = algorithm;
+		} else {
+			DBG_8192D
+			    ("(2)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+			     seq, pstat->auth_seq + 1);
+			status = _STATS_OUT_OF_AUTH_SEQ_;
+			goto auth_fail;
+		}
+	} else {		/*  shared system or auto authentication */
+
+		if (seq == 1) {
+			/*prepare for the challenging txt... */
+			pstat->state &= ~WIFI_FW_AUTH_NULL;
+			pstat->state |= WIFI_FW_AUTH_STATE;
+			pstat->authalg = algorithm;
+			pstat->auth_seq = 2;
+		} else if (seq == 3) {
+			/* checking for challenging txt... */
+			DBG_8192D("checking for challenging txt...\n");
+
+			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 +
+				       _AUTH_IE_OFFSET_, _CHLGETXT_IE_,
+				       (int *)&ie_len,
+				       len - WLAN_HDR_A3_LEN -
+				       _AUTH_IE_OFFSET_ - 4);
+
+			if ((p == NULL) || (ie_len <= 0)) {
+				DBG_8192D
+				    ("auth rejected because challenge failure!(1)\n");
+				status = _STATS_CHALLENGE_FAIL_;
+				goto auth_fail;
+			}
+
+			if (_rtw_memcmp((void *)(p + 2), pstat->chg_txt, 128)) {
+				pstat->state &= (~WIFI_FW_AUTH_STATE);
+				pstat->state |= WIFI_FW_AUTH_SUCCESS;
+				/*  challenging txt is correct... */
+				pstat->expire_to = pstapriv->assoc_to;
+			} else {
+				DBG_8192D
+				    ("auth rejected because challenge failure!\n");
+				status = _STATS_CHALLENGE_FAIL_;
+				goto auth_fail;
+			}
+		} else {
+			DBG_8192D
+			    ("(3)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+			     seq, pstat->auth_seq + 1);
+			status = _STATS_OUT_OF_AUTH_SEQ_;
+			goto auth_fail;
+		}
+	}
+
+	/*  Now, we are going to issue_auth... */
+	pstat->auth_seq = seq + 1;
+
+#ifdef CONFIG_NATIVEAP_MLME
+	issue_auth(adapt, pstat, (unsigned short)(_STATS_SUCCESSFUL_));
+#endif
+
+	if (pstat->state & WIFI_FW_AUTH_SUCCESS)
+		pstat->auth_seq = 0;
+
+	return _SUCCESS;
+
+auth_fail:
+
+	if (pstat)
+		rtw_free_stainfo(adapt, pstat);
+
+	pstat = &stat;
+	memset((char *)pstat, '\0', sizeof(stat));
+	pstat->auth_seq = 2;
+	memcpy(pstat->hwaddr, sa, 6);
+
+#ifdef CONFIG_NATIVEAP_MLME
+	issue_auth(adapt, pstat, (unsigned short)status);
+#endif
+
+#endif
+	return _FAIL;
+}
+
+unsigned int OnAuthClient(struct rtw_adapter *adapt,
+			  struct recv_frame_hdr *precv_frame)
+{
+	unsigned int seq, len, status, offset;
+	unsigned char *p;
+	unsigned int go2asoc = 0;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+
+	DBG_8192D("%s\n", __func__);
+
+	/* check A1 matches or not */
+	if (!_rtw_memcmp
+	    (myid(&(adapt->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))
+		return _SUCCESS;
+
+	offset = (GetPrivacy(pframe)) ? 4 : 0;
+
+	seq = le16_to_cpu(*(__le16 *)
+			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 2));
+	status = le16_to_cpu(*(__le16 *)
+			((SIZE_PTR) pframe + WLAN_HDR_A3_LEN + offset + 4));
+
+	if (status != 0) {
+		DBG_8192D("clnt auth fail, status: %d\n", status);
+		if (status == 13) {	/*  pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto) */
+			if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
+			else
+				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
+		}
+
+		set_link_timer(pmlmeext, 1);
+		goto authclnt_fail;
+	}
+
+	if (seq == 2) {
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) {
+			/*  legendary shared system */
+			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN +
+				       _AUTH_IE_OFFSET_, _CHLGETXT_IE_,
+				       (int *)&len,
+				       pkt_len - WLAN_HDR_A3_LEN -
+				       _AUTH_IE_OFFSET_);
+
+			if (p == NULL)
+				goto authclnt_fail;
+
+			memcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2),
+			       len);
+			pmlmeinfo->auth_seq = 3;
+			issue_auth(adapt, NULL, 0);
+			set_link_timer(pmlmeext, REAUTH_TO);
+
+			return _SUCCESS;
+		} else {
+			/*  open system */
+			go2asoc = 1;
+		}
+	} else if (seq == 4) {
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) {
+			go2asoc = 1;
+		} else {
+			goto authclnt_fail;
+		}
+	} else {
+		/*  this is also illegal */
+		goto authclnt_fail;
+	}
+
+	if (go2asoc) {
+		start_clnt_assoc(adapt);
+		return _SUCCESS;
+	}
+
+authclnt_fail:
+
+	return _FAIL;
+}
+
+unsigned int OnAssocReq(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_92D_AP_MODE
+	u16 capab_info;
+	struct rtw_ieee802_11_elems elems;
+	struct sta_info *pstat;
+	unsigned char reassoc, *p, *pos, *wpa_ie;
+	unsigned char WMM_IE[] = { 0x00, 0x50, 0xf2, 0x02, 0x00, 0x01 };
+	int i, ie_len, wpa_ie_len, left;
+	unsigned char supportRate[16];
+	int supportRateNum;
+	unsigned short status = _STATS_SUCCESSFUL_;
+	unsigned short frame_type, ie_offset = 0;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct security_priv *psecuritypriv = &adapt->securitypriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *cur = &(pmlmeinfo->network);
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	u8 *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+#ifdef CONFIG_CONCURRENT_MODE
+	if (((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+	    check_buddy_fwstate(adapt, _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
+		/* don't process assoc request; */
+		return _SUCCESS;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
+		return _FAIL;
+
+	frame_type = GetFrameSubType(pframe);
+	if (frame_type == WIFI_ASSOCREQ) {
+		reassoc = 0;
+		ie_offset = _ASOCREQ_IE_OFFSET_;
+	} else {		/*  WIFI_REASSOCREQ */
+
+		reassoc = 1;
+		ie_offset = _REASOCREQ_IE_OFFSET_;
+	}
+
+	if (pkt_len < IEEE80211_3ADDR_LEN + ie_offset) {
+		DBG_8192D
+		    ("handle_assoc(reassoc=%d) - too short payload (len=%lu)"
+		     "\n", reassoc, (unsigned long)pkt_len);
+		return _FAIL;
+	}
+
+	pstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+	if (pstat == (struct sta_info *)NULL) {
+		status = _RSON_CLS2_;
+		goto asoc_class2_error;
+	}
+
+	capab_info = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN);
+
+	left = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);
+	pos = pframe + (IEEE80211_3ADDR_LEN + ie_offset);
+
+	DBG_8192D("%s\n", __func__);
+
+	/*  check if this stat has been successfully authenticated/assocated */
+	if (!((pstat->state) & WIFI_FW_AUTH_SUCCESS)) {
+		if (!((pstat->state) & WIFI_FW_ASSOC_SUCCESS)) {
+			status = _RSON_CLS2_;
+			goto asoc_class2_error;
+		} else {
+			pstat->state &= (~WIFI_FW_ASSOC_SUCCESS);
+			pstat->state |= WIFI_FW_ASSOC_STATE;
+		}
+	} else {
+		pstat->state &= (~WIFI_FW_AUTH_SUCCESS);
+		pstat->state |= WIFI_FW_ASSOC_STATE;
+	}
+
+	pstat->capability = capab_info;
+
+	/* now parse all ieee802_11 ie to point to elems */
+	if (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == PARSE_FAIL ||
+	    !elems.ssid) {
+		DBG_8192D("STA %pM sent invalid association request\n",
+			  pstat->hwaddr);
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+
+	/*  now we should check all the fields... */
+	/*  checking SSID */
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SSID_IE_, &ie_len,
+		       pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+	if (p == NULL) {
+		status = _STATS_FAILURE_;
+	}
+
+	if (ie_len == 0)	/*  broadcast ssid, however it is not allowed in assocreq */
+		status = _STATS_FAILURE_;
+	else {
+		/*  check if ssid match */
+		if (!_rtw_memcmp
+		    ((void *)(p + 2), cur->Ssid.Ssid, cur->Ssid.SsidLength))
+			status = _STATS_FAILURE_;
+
+		if (ie_len != cur->Ssid.SsidLength)
+			status = _STATS_FAILURE_;
+	}
+
+	if (_STATS_SUCCESSFUL_ != status)
+		goto OnAssocReqFail;
+
+	/*  check if the supported rate is ok */
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset,
+		       _SUPPORTEDRATES_IE_, &ie_len,
+		       pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+	if (p == NULL) {
+		DBG_8192D
+		    ("Rx a sta assoc-req which supported rate is empty!\n");
+		/*  use our own rate set as statoin used */
+		/* memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN); */
+		/* supportRateNum = AP_BSSRATE_LEN; */
+
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	} else {
+		memcpy(supportRate, p + 2, ie_len);
+		supportRateNum = ie_len;
+
+		p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset,
+			       _EXT_SUPPORTEDRATES_IE_, &ie_len,
+			       pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+		if (p != NULL) {
+			if (supportRateNum <= sizeof(supportRate)) {
+				memcpy(supportRate + supportRateNum, p + 2,
+				       ie_len);
+				supportRateNum += ie_len;
+			}
+		}
+	}
+
+	/* todo: mask supportRate between AP & STA -> move to update raid */
+	/* get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0); */
+
+	/* update station supportRate */
+	pstat->bssratelen = supportRateNum;
+	memcpy(pstat->bssrateset, supportRate, supportRateNum);
+
+	/* check RSN/WPA/WPS */
+	pstat->dot8021xalg = 0;
+	pstat->wpa_psk = 0;
+	pstat->wpa_group_cipher = 0;
+	pstat->wpa2_group_cipher = 0;
+	pstat->wpa_pairwise_cipher = 0;
+	pstat->wpa2_pairwise_cipher = 0;
+	memset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));
+	if ((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
+		int group_cipher = 0, pairwise_cipher = 0;
+
+		wpa_ie = elems.rsn_ie;
+		wpa_ie_len = elems.rsn_ie_len;
+
+		if (rtw_parse_wpa2_ie
+		    (wpa_ie - 2, wpa_ie_len + 2, &group_cipher,
+		     &pairwise_cipher) == _SUCCESS) {
+			pstat->dot8021xalg = 1;	/*psk,  todo:802.1x */
+			pstat->wpa_psk |= BIT(1);
+
+			pstat->wpa2_group_cipher =
+			    group_cipher & psecuritypriv->wpa2_group_cipher;
+			pstat->wpa2_pairwise_cipher =
+			    pairwise_cipher & psecuritypriv->
+			    wpa2_pairwise_cipher;
+
+			if (!pstat->wpa2_group_cipher)
+				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
+
+			if (!pstat->wpa2_pairwise_cipher)
+				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
+		} else {
+			status = WLAN_STATUS_INVALID_IE;
+		}
+
+	} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {
+		int group_cipher = 0, pairwise_cipher = 0;
+
+		wpa_ie = elems.wpa_ie;
+		wpa_ie_len = elems.wpa_ie_len;
+
+		if (rtw_parse_wpa_ie
+		    (wpa_ie - 2, wpa_ie_len + 2, &group_cipher,
+		     &pairwise_cipher) == _SUCCESS) {
+			pstat->dot8021xalg = 1;	/*psk,  todo:802.1x */
+			pstat->wpa_psk |= BIT(0);
+
+			pstat->wpa_group_cipher =
+			    group_cipher & psecuritypriv->wpa_group_cipher;
+			pstat->wpa_pairwise_cipher =
+			    pairwise_cipher & psecuritypriv->
+			    wpa_pairwise_cipher;
+
+			if (!pstat->wpa_group_cipher)
+				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
+
+			if (!pstat->wpa_pairwise_cipher)
+				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
+
+		} else {
+			status = WLAN_STATUS_INVALID_IE;
+		}
+
+	} else {
+		wpa_ie = NULL;
+		wpa_ie_len = 0;
+	}
+
+	if (_STATS_SUCCESSFUL_ != status)
+		goto OnAssocReqFail;
+
+	pstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);
+	if (wpa_ie == NULL) {
+		if (elems.wps_ie) {
+			DBG_8192D("STA included WPS IE in "
+				  "(Re)Association Request - assume WPS is "
+				  "used\n");
+			pstat->flags |= WLAN_STA_WPS;
+			/* wpabuf_free(sta->wps_ie); */
+			/* sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4, */
+			/*                              elems.wps_ie_len - 4); */
+		} else {
+			DBG_8192D("STA did not include WPA/RSN IE "
+				  "in (Re)Association Request - possible WPS "
+				  "use\n");
+			pstat->flags |= WLAN_STA_MAYBE_WPS;
+		}
+
+		/*  AP support WPA/RSN, and sta is going to do WPS, but AP is not ready */
+		/*  that the selected registrar of AP is _FLASE */
+		if ((psecuritypriv->wpa_psk > 0) &&
+		    (pstat->flags & (WLAN_STA_WPS | WLAN_STA_MAYBE_WPS))) {
+			if (pmlmepriv->wps_beacon_ie) {
+				u8 selected_registrar = 0;
+
+				rtw_get_wps_attr_content(pmlmepriv->
+							 wps_beacon_ie,
+							 pmlmepriv->
+							 wps_beacon_ie_len,
+							 WPS_ATTR_SELECTED_REGISTRAR,
+							 &selected_registrar,
+							 NULL);
+
+				if (!selected_registrar) {
+					DBG_8192D
+					    ("selected_registrar is false , or AP is not ready to do WPS\n");
+
+					status = _STATS_UNABLE_HANDLE_STA_;
+
+					goto OnAssocReqFail;
+				}
+			}
+		}
+
+	} else {
+		int copy_len;
+
+		if (psecuritypriv->wpa_psk == 0) {
+			DBG_8192D("STA %pM: WPA/RSN IE in association "
+				  "request, but AP don't support WPA/RSN\n",
+				  pstat->hwaddr);
+
+			status = WLAN_STATUS_INVALID_IE;
+			goto OnAssocReqFail;
+		}
+		if (elems.wps_ie) {
+			DBG_8192D("STA included WPS IE in "
+				  "(Re)Association Request - WPS is " "used\n");
+			pstat->flags |= WLAN_STA_WPS;
+			copy_len = 0;
+		} else {
+			copy_len =
+			    ((wpa_ie_len + 2) >
+			     sizeof(pstat->wpa_ie)) ? (sizeof(pstat->
+							      wpa_ie))
+			    : (wpa_ie_len + 2);
+		}
+		if (copy_len > 0)
+			memcpy(pstat->wpa_ie, wpa_ie - 2, copy_len);
+	}
+	/*  check if there is WMM IE & support WWM-PS */
+	pstat->flags &= ~WLAN_STA_WME;
+	pstat->qos_option = 0;
+	pstat->qos_info = 0;
+	pstat->has_legacy_ac = true;
+	pstat->uapsd_vo = 0;
+	pstat->uapsd_vi = 0;
+	pstat->uapsd_be = 0;
+	pstat->uapsd_bk = 0;
+	if (pmlmepriv->qospriv.qos_option) {
+		p = pframe + WLAN_HDR_A3_LEN + ie_offset;
+		ie_len = 0;
+		for (;;) {
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len,
+				       pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+			if (p != NULL) {
+				if (_rtw_memcmp(p + 2, WMM_IE, 6)) {
+					pstat->flags |= WLAN_STA_WME;
+
+					pstat->qos_option = 1;
+					pstat->qos_info = *(p + 8);
+
+					pstat->max_sp_len =
+					    (pstat->qos_info >> 5) & 0x3;
+
+					if ((pstat->qos_info & 0xf) != 0xf)
+						pstat->has_legacy_ac = true;
+					else
+						pstat->has_legacy_ac = false;
+
+					if (pstat->qos_info & 0xf) {
+						if (pstat->qos_info & BIT(0))
+							pstat->uapsd_vo =
+							    BIT(0) | BIT(1);
+						else
+							pstat->uapsd_vo = 0;
+
+						if (pstat->qos_info & BIT(1))
+							pstat->uapsd_vi =
+							    BIT(0) | BIT(1);
+						else
+							pstat->uapsd_vi = 0;
+
+						if (pstat->qos_info & BIT(2))
+							pstat->uapsd_bk =
+							    BIT(0) | BIT(1);
+						else
+							pstat->uapsd_bk = 0;
+
+						if (pstat->qos_info & BIT(3))
+							pstat->uapsd_be =
+							    BIT(0) | BIT(1);
+						else
+							pstat->uapsd_be = 0;
+					}
+					break;
+				}
+			} else {
+				break;
+			}
+			p = p + ie_len + 2;
+		}
+	}
+
+#ifdef CONFIG_80211N_HT
+	/* save HT capabilities in the sta object */
+	memset(&pstat->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));
+	if (elems.ht_capabilities &&
+	    elems.ht_capabilities_len >= sizeof(struct rtw_ieee80211_ht_cap)) {
+		pstat->flags |= WLAN_STA_HT;
+
+		pstat->flags |= WLAN_STA_WME;
+
+		memcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities,
+		       sizeof(struct rtw_ieee80211_ht_cap));
+
+	} else
+		pstat->flags &= ~WLAN_STA_HT;
+
+	if ((pmlmepriv->htpriv.ht_option == false) &&
+	    (pstat->flags & WLAN_STA_HT)) {
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+
+	if ((pstat->flags & WLAN_STA_HT) &&
+	    ((pstat->wpa2_pairwise_cipher & WPA_CIPHER_TKIP) ||
+	     (pstat->wpa_pairwise_cipher & WPA_CIPHER_TKIP))) {
+		DBG_8192D("HT: %pM tried to use TKIP with HT association\n",
+			  pstat->hwaddr);
+
+		/* status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY; */
+		/* goto OnAssocReqFail; */
+	}
+#endif /* CONFIG_80211N_HT */
+
+	pstat->flags |= WLAN_STA_NONERP;
+	for (i = 0; i < pstat->bssratelen; i++) {
+		if ((pstat->bssrateset[i] & 0x7f) > 22) {
+			pstat->flags &= ~WLAN_STA_NONERP;
+			break;
+		}
+	}
+
+	if (pstat->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		pstat->flags |= WLAN_STA_SHORT_PREAMBLE;
+	else
+		pstat->flags &= ~WLAN_STA_SHORT_PREAMBLE;
+
+	if (status != _STATS_SUCCESSFUL_)
+		goto OnAssocReqFail;
+
+	/* TODO: identify_proprietary_vendor_ie(); */
+	/*  Realtek proprietary IE */
+	/*  identify if this is Broadcom sta */
+	/*  identify if this is ralink sta */
+	/*  Customer proprietary IE */
+
+	/* get a unique AID */
+	if (pstat->aid > 0) {
+		DBG_8192D("  old AID %d\n", pstat->aid);
+	} else {
+		for (pstat->aid = 1; pstat->aid <= NUM_STA; pstat->aid++)
+			if (pstapriv->sta_aid[pstat->aid - 1] == NULL)
+				break;
+
+		if (pstat->aid > pstapriv->max_num_sta) {
+			pstat->aid = 0;
+
+			DBG_8192D("  no room for more AIDs\n");
+
+			status = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
+
+			goto OnAssocReqFail;
+
+		} else {
+			pstapriv->sta_aid[pstat->aid - 1] = pstat;
+			DBG_8192D("allocate new AID = (%d)\n", pstat->aid);
+		}
+	}
+
+	pstat->state &= (~WIFI_FW_ASSOC_STATE);
+	pstat->state |= WIFI_FW_ASSOC_SUCCESS;
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!rtw_is_list_empty(&pstat->auth_list)) {
+		list_del_init(&pstat->auth_list);
+		pstapriv->auth_list_cnt--;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	if (rtw_is_list_empty(&pstat->asoc_list)) {
+		pstat->expire_to = pstapriv->expire_to;
+		rtw_list_insert_tail(&pstat->asoc_list, &pstapriv->asoc_list);
+		pstapriv->asoc_list_cnt++;
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	/*  now the station is qualified to join our BSS... */
+	if (pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) &&
+	    (_STATS_SUCCESSFUL_ == status)) {
+#ifdef CONFIG_NATIVEAP_MLME
+		/* 1 bss_cap_update & sta_info_update */
+		bss_cap_update_on_sta_join(adapt, pstat);
+		sta_info_update(adapt, pstat);
+
+		/* issue assoc rsp before notify station join event. */
+		if (frame_type == WIFI_ASSOCREQ)
+			issue_asocrsp(adapt, status, pstat, WIFI_ASSOCRSP);
+		else
+			issue_asocrsp(adapt, status, pstat, WIFI_REASSOCRSP);
+
+		/* 2 - report to upper layer */
+		DBG_8192D("indicate_sta_join_event to upper layer - hostapd\n");
+		spin_lock_bh(&pstat->lock);
+		kfree(pstat->passoc_req);
+		pstat->passoc_req = NULL;
+		pstat->assoc_req_len = 0;
+
+		pstat->passoc_req = kzalloc(pkt_len, GFP_ATOMIC);
+		if (pstat->passoc_req) {
+			memcpy(pstat->passoc_req, pframe, pkt_len);
+			pstat->assoc_req_len = pkt_len;
+		}
+		spin_unlock_bh(&pstat->lock);
+
+		/* 3-(1) report sta add event */
+		report_add_sta_event(adapt, pstat->hwaddr, pstat->aid);
+
+#endif
+	}
+
+	return _SUCCESS;
+
+asoc_class2_error:
+
+#ifdef CONFIG_NATIVEAP_MLME
+	issue_deauth(adapt, (void *)GetAddr2Ptr(pframe), status);
+#endif
+
+	return _FAIL;
+
+OnAssocReqFail:
+
+#ifdef CONFIG_NATIVEAP_MLME
+	pstat->aid = 0;
+	if (frame_type == WIFI_ASSOCREQ)
+		issue_asocrsp(adapt, status, pstat, WIFI_ASSOCRSP);
+	else
+		issue_asocrsp(adapt, status, pstat, WIFI_REASSOCRSP);
+#endif
+
+#endif /* CONFIG_92D_AP_MODE */
+
+	return _FAIL;
+}
+
+unsigned int OnAssocRsp(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+	uint i;
+	int res;
+	unsigned short status;
+	struct ndis_802_11_variable_ies *pIE;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	/* struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network); */
+	u8 *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+
+	DBG_8192D("%s\n", __func__);
+
+	/* check A1 matches or not */
+	if (!_rtw_memcmp
+	    (myid(&(adapt->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))
+		return _SUCCESS;
+
+	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+		return _SUCCESS;
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	/* status */
+	status = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 2));
+	if (status > 0) {
+		DBG_8192D("assoc reject, status code: %d\n", status);
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		res = -4;
+		goto report_assoc_result;
+	}
+
+	/* get capabilities */
+	pmlmeinfo->capability =
+	    le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
+
+	/* set slot time */
+	pmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10)) ? 9 : 20;
+
+	/* AID */
+	res =
+	    (int)(le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN + 4))
+		  & 0x3fff);
+	pmlmeinfo->aid = res;
+
+	/* following are moved to join event callback function */
+	/* to handle HT, WMM, rate adaptive, update MAC reg */
+	/* for not to handle the synchronous IO in the tasklet */
+	for (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pframe + i);
+
+		switch (pIE->ElementID) {
+		case _VENDOR_SPECIFIC_IE_:
+			if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6)) {	/* WMM */
+				WMM_param_handler(adapt, pIE);
+			}
+			break;
+
+		case _HT_CAPABILITY_IE_:	/* HT caps */
+			HT_caps_handler(adapt, pIE);
+			break;
+
+		case _HT_EXTRA_INFO_IE_:	/* HT info */
+			HT_info_handler(adapt, pIE);
+			break;
+
+		case _ERPINFO_IE_:
+			ERP_IE_handler(adapt, pIE);
+
+		default:
+			break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	pmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);
+	pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+
+	/* Update Basic Rate Table for spec, 2010-12-28 , by thomas */
+	UpdateBrateTbl(adapt, pmlmeinfo->network.SupportedRates);
+
+report_assoc_result:
+	if (res > 0) {
+		rtw_buf_update(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len,
+			       pframe, pkt_len);
+	} else {
+		rtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);
+	}
+
+	report_join_res(adapt, res);
+
+	return _SUCCESS;
+}
+
+unsigned int OnDeAuth(struct rtw_adapter *adapt,
+		      struct recv_frame_hdr *precv_frame)
+{
+	unsigned short reason;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->rx_data;
+
+	/* check A3 */
+	if (!
+	    (_rtw_memcmp
+	     (GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network),
+	      ETH_ALEN)))
+		return _SUCCESS;
+
+	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
+
+	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
+
+#ifdef CONFIG_92D_AP_MODE
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &adapt->stapriv;
+
+		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr2Ptr(pframe));
+
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		if (psta) {
+			u8 updated;
+
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if (rtw_is_list_empty(&psta->asoc_list) == false) {
+				list_del_init(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+				updated =
+				    ap_free_sta(adapt, psta, false, reason);
+			}
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+			associated_clients_update(adapt, updated);
+		}
+
+		return _SUCCESS;
+	} else
+#endif
+	{
+		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr3Ptr(pframe));
+
+		receive_disconnect(adapt, GetAddr3Ptr(pframe), reason);
+	}
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+	return _SUCCESS;
+}
+
+unsigned int OnDisassoc(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+	unsigned short reason;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->rx_data;
+
+	/* check A3 */
+	if (!
+	    (_rtw_memcmp
+	     (GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network),
+	      ETH_ALEN)))
+		return _SUCCESS;
+
+	reason = le16_to_cpu(*(__le16 *)(pframe + WLAN_HDR_A3_LEN));
+
+	DBG_8192D("%s Reason code(%d)\n", __func__, reason);
+
+#ifdef CONFIG_92D_AP_MODE
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &adapt->stapriv;
+
+		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr2Ptr(pframe));
+
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		if (psta) {
+			u8 updated;
+
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if (rtw_is_list_empty(&psta->asoc_list) == false) {
+				list_del_init(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+				updated =
+				    ap_free_sta(adapt, psta, false, reason);
+			}
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+			associated_clients_update(adapt, updated);
+		}
+
+		return _SUCCESS;
+	} else
+#endif
+	{
+		DBG_8192D("%s, STA: %pM\n", __func__, GetAddr3Ptr(pframe));
+
+		receive_disconnect(adapt, GetAddr3Ptr(pframe), reason);
+	}
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+	return _SUCCESS;
+}
+
+unsigned int OnAtim(struct rtw_adapter *adapt, struct recv_frame_hdr *precv_frame)
+{
+	DBG_8192D("%s\n", __func__);
+	return _SUCCESS;
+}
+
+static unsigned int on_action_spct_ch_switch(struct rtw_adapter *adapt,
+					     struct sta_info *psta, u8 *ies,
+					     uint ies_len)
+{
+	unsigned int ret = _FAIL;
+	struct mlme_ext_priv *mlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(mlmeext->mlmext_info);
+
+	if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
+		ret = _SUCCESS;
+		goto exit;
+	}
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		int ch_switch_mode = -1, ch = -1, ch_switch_cnt = -1;
+		int ch_offset = -1;
+		u8 bwmode;
+		struct ieee80211_info_element *ie;
+
+		DBG_8192D(FUNC_NDEV_FMT " from %pM\n",
+			  FUNC_NDEV_ARG(adapt->pnetdev), psta->hwaddr);
+
+		for_each_ie(ie, ies, ies_len) {
+			if (ie->id == WLAN_EID_CHANNEL_SWITCH) {
+				ch_switch_mode = ie->data[0];
+				ch = ie->data[1];
+				ch_switch_cnt = ie->data[2];
+				DBG_8192D
+				    ("ch_switch_mode:%d, ch:%d, ch_switch_cnt:%d\n",
+				     ch_switch_mode, ch, ch_switch_cnt);
+			} else if (ie->id == WLAN_EID_SECONDARY_CHANNEL_OFFSET) {
+				ch_offset =
+				    secondary_ch_offset_to_hal_ch_offset(ie->
+									 data
+									 [0]);
+				DBG_8192D("ch_offset:%d\n", ch_offset);
+			}
+		}
+
+		if (ch == -1)
+			return _SUCCESS;
+
+		if (ch_offset == -1)
+			bwmode = mlmeext->cur_bwmode;
+		else
+			bwmode =
+			    (ch_offset ==
+			     HAL_PRIME_CHNL_OFFSET_DONT_CARE) ?
+			    HT_CHANNEL_WIDTH_20 : HT_CHANNEL_WIDTH_40;
+
+		ch_offset =
+		    (ch_offset == -1) ? mlmeext->cur_ch_offset : ch_offset;
+
+		/* todo:
+		 * 1. the decision of channel switching
+		 * 2. things after channel switching
+		 */
+
+		ret = rtw_set_ch_cmd(adapt, ch, bwmode, ch_offset, true);
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int on_action_spct(struct rtw_adapter *adapt,
+			    struct recv_frame_hdr *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	u8 *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	u8 *frame_body =
+	    (u8 *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+	u8 category;
+	u8 action;
+
+	DBG_8192D(FUNC_NDEV_FMT "\n", FUNC_NDEV_ARG(adapt->pnetdev));
+
+	psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+
+	if (!psta)
+		goto exit;
+
+	category = frame_body[0];
+	if (category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)
+		goto exit;
+
+	action = frame_body[1];
+	switch (action) {
+	case RTW_WLAN_ACTION_SPCT_MSR_REQ:
+	case RTW_WLAN_ACTION_SPCT_MSR_RPRT:
+	case RTW_WLAN_ACTION_SPCT_TPC_REQ:
+	case RTW_WLAN_ACTION_SPCT_TPC_RPRT:
+		break;
+	case RTW_WLAN_ACTION_SPCT_CHL_SWITCH:
+#ifdef CONFIG_SPCT_CH_SWITCH
+		ret = on_action_spct_ch_switch(adapt, psta, &frame_body[2],
+					       frame_len - (frame_body -
+							    pframe) - 2);
+#endif
+		break;
+	default:
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int OnAction_qos(struct rtw_adapter *adapt,
+			  struct recv_frame_hdr *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_dls(struct rtw_adapter *adapt,
+			  struct recv_frame_hdr *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_back(struct rtw_adapter *adapt,
+			   struct recv_frame_hdr *precv_frame)
+{
+	u8 *addr;
+	struct sta_info *psta = NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	unsigned char *frame_body;
+	unsigned char category, action;
+	unsigned short tid, status, reason_code = 0;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 *pframe = precv_frame->rx_data;
+	struct sta_priv *pstapriv = &adapt->stapriv;
+
+	/* check RA matches or not */
+	if (!_rtw_memcmp(myid(&(adapt->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))	/* for if1, sta/ap mode */
+		return _SUCCESS;
+
+	DBG_8192D("%s\n", __func__);
+
+	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+
+	addr = GetAddr2Ptr(pframe);
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if (psta == NULL)
+		return _SUCCESS;
+
+	frame_body =
+	    (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	category = frame_body[0];
+	if (category == RTW_WLAN_CATEGORY_BACK) {	/*  representing Block Ack */
+		if (!pmlmeinfo->HT_enable) {
+			return _SUCCESS;
+		}
+
+		action = frame_body[1];
+		DBG_8192D("%s, action=%d\n", __func__, action);
+		switch (action) {
+		case RTW_WLAN_ACTION_ADDBA_REQ:	/* ADDBA request */
+
+			memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]),
+			       sizeof(struct ADDBA_request));
+			/*process_addba_req(adapt, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe)); */
+			process_addba_req(adapt,
+					  (u8 *)&(pmlmeinfo->ADDBA_req),
+					  addr);
+
+			if (pmlmeinfo->bAcceptAddbaReq == true) {
+				issue_action_BA(adapt, addr,
+						RTW_WLAN_ACTION_ADDBA_RESP, 0);
+			} else {
+				issue_action_BA(adapt, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);	/* reject ADDBA Req */
+			}
+
+			break;
+
+		case RTW_WLAN_ACTION_ADDBA_RESP:	/* ADDBA response */
+
+			status = RTW_GET_LE16(&frame_body[3]);
+			tid = ((frame_body[5] >> 2) & 0x7);
+
+			if (status == 0) {	/* successful */
+				DBG_8192D("agg_enable for TID=%d\n", tid);
+				psta->htpriv.agg_enable_bitmap |= 1 << tid;
+				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+			} else {
+				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+			}
+
+			/* DBG_8192D("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap); */
+			break;
+
+		case RTW_WLAN_ACTION_DELBA:	/* DELBA */
+			if ((frame_body[3] & BIT(3)) == 0) {
+				psta->htpriv.agg_enable_bitmap &=
+				    ~(1 << ((frame_body[3] >> 4) & 0xf));
+				psta->htpriv.candidate_tid_bitmap &=
+				    ~(1 << ((frame_body[3] >> 4) & 0xf));
+
+				/* reason_code = frame_body[4] | (frame_body[5] << 8); */
+				reason_code = RTW_GET_LE16(&frame_body[4]);
+			} else if ((frame_body[3] & BIT(3)) == BIT(3)) {
+				tid = (frame_body[3] >> 4) & 0x0F;
+
+				preorder_ctrl = &psta->recvreorder_ctrl[tid];
+				preorder_ctrl->enable = false;
+				preorder_ctrl->indicate_seq = 0xffff;
+#ifdef DBG_RX_SEQ
+				DBG_8192D("DBG_RX_SEQ %s:%d indicate_seq:%u\n",
+					  __func__, __LINE__,
+					  preorder_ctrl->indicate_seq);
+#endif
+			}
+
+			DBG_8192D("%s(): DELBA: %x(%x)\n", __func__,
+				  pmlmeinfo->agg_enable_bitmap, reason_code);
+			/* todo: how to notify the host while receiving DELETE BA */
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return _SUCCESS;
+}
+
+static s32 rtw_action_public_decache(struct recv_frame_hdr *recv_frame, s32 token)
+{
+	struct rtw_adapter *adapter = recv_frame->adapter;
+	struct mlme_ext_priv *mlmeext = &(adapter->mlmeextpriv);
+	u8 *frame = recv_frame->rx_data;
+	u16 seq_ctrl = ((recv_frame->attrib.seq_num & 0xffff) << 4) |
+	    (recv_frame->attrib.frag_num & 0xf);
+
+	if (GetRetry(frame)) {
+		if (token >= 0) {
+			if ((seq_ctrl == mlmeext->action_public_rxseq) &&
+			    (token == mlmeext->action_public_dialog_token)) {
+				DBG_8192D(FUNC_ADPT_FMT
+					  " seq_ctrl=0x%x, rxseq=0x%x, token:%d\n",
+					  FUNC_ADPT_ARG(adapter), seq_ctrl,
+					  mlmeext->action_public_rxseq, token);
+				return _FAIL;
+			}
+		} else {
+			if (seq_ctrl == mlmeext->action_public_rxseq) {
+				DBG_8192D(FUNC_ADPT_FMT
+					  " seq_ctrl=0x%x, rxseq=0x%x\n",
+					  FUNC_ADPT_ARG(adapter), seq_ctrl,
+					  mlmeext->action_public_rxseq);
+				return _FAIL;
+			}
+		}
+	}
+
+	mlmeext->action_public_rxseq = seq_ctrl;
+
+	if (token >= 0)
+		mlmeext->action_public_dialog_token = token;
+
+	return _SUCCESS;
+}
+
+static unsigned int on_action_public_p2p(struct recv_frame_hdr *precv_frame)
+{
+	struct rtw_adapter *adapt = precv_frame->adapter;
+	u8 *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	u8 *frame_body;
+	u8 dialogToken = 0;
+
+	frame_body =
+	    (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	dialogToken = frame_body[7];
+
+	if (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)
+		return _FAIL;
+	return _SUCCESS;
+}
+
+static unsigned int on_action_public_vendor(struct recv_frame_hdr *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	u8 *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	u8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (_rtw_memcmp(frame_body + 2, P2P_OUI, 4) == true) {
+		ret = on_action_public_p2p(precv_frame);
+	}
+
+	return ret;
+}
+
+static unsigned int on_action_public_default(struct recv_frame_hdr *precv_frame, u8 action)
+{
+	unsigned int ret = _FAIL;
+	u8 *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	u8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	u8 token;
+	struct rtw_adapter *adapter = precv_frame->adapter;
+	int cnt = 0;
+	char msg[64];
+
+	token = frame_body[2];
+
+	if (rtw_action_public_decache(precv_frame, token) == _FAIL)
+		goto exit;
+
+	cnt +=
+	    sprintf((msg + cnt), "%s(token:%u)", action_public_str(action),
+		    token);
+	rtw_cfg80211_rx_action(adapter, pframe, frame_len, msg);
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+unsigned int on_action_public(struct rtw_adapter *adapt,
+			      struct recv_frame_hdr *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	u8 *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	u8 *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	u8 category, action;
+
+	/* check RA matches or not */
+	if (!_rtw_memcmp
+	    (myid(&(adapt->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))
+		goto exit;
+
+	category = frame_body[0];
+	if (category != RTW_WLAN_CATEGORY_PUBLIC)
+		goto exit;
+
+	action = frame_body[1];
+	switch (action) {
+	case ACT_PUBLIC_VENDOR:
+		ret = on_action_public_vendor(precv_frame);
+		break;
+	default:
+		ret = on_action_public_default(precv_frame, action);
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int OnAction_ht(struct rtw_adapter *adapt,
+			 struct recv_frame_hdr *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_wmm(struct rtw_adapter *adapt,
+			  struct recv_frame_hdr *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_p2p(struct rtw_adapter *adapt,
+			  struct recv_frame_hdr *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction(struct rtw_adapter *adapt,
+		      struct recv_frame_hdr *precv_frame)
+{
+	int i;
+	unsigned char category;
+	struct action_handler *ptable;
+	unsigned char *frame_body;
+	u8 *pframe = precv_frame->rx_data;
+
+	frame_body =
+	    (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	category = frame_body[0];
+
+	for (i = 0; i < sizeof(OnAction_tbl) / sizeof(struct action_handler);
+	     i++) {
+		ptable = &OnAction_tbl[i];
+
+		if (category == ptable->num)
+			ptable->func(adapt, precv_frame);
+	}
+	return _SUCCESS;
+}
+
+unsigned int DoReserved(struct rtw_adapter *adapt,
+			struct recv_frame_hdr *precv_frame)
+{
+	/* DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe)); */
+	return _SUCCESS;
+}
+
+struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)
+{
+	struct xmit_frame *pmgntframe;
+	struct xmit_buf *pxmitbuf;
+
+	pmgntframe = rtw_alloc_xmitframe(pxmitpriv);
+	if (pmgntframe == NULL) {
+		DBG_8192D("%s, alloc xmitframe fail\n", __func__);
+		return NULL;
+	}
+
+	pxmitbuf = rtw_alloc_xmitbuf_ext(pxmitpriv);
+	if (pxmitbuf == NULL) {
+		DBG_8192D("%s, alloc xmitbuf fail\n", __func__);
+		rtw_free_xmitframe(pxmitpriv, pmgntframe);
+		return NULL;
+	}
+
+	pmgntframe->frame_tag = MGNT_FRAMETAG;
+
+	pmgntframe->pxmitbuf = pxmitbuf;
+
+	pmgntframe->buf_addr = pxmitbuf->pbuf;
+
+	pxmitbuf->priv_data = pmgntframe;
+
+	return pmgntframe;
+}
+
+/****************************************************************************
+
+Following are some TX fuctions for WiFi MLME
+
+*****************************************************************************/
+
+void update_mgnt_tx_rate(struct rtw_adapter *adapt, u8 rate)
+{
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+
+	pmlmeext->tx_rate = rate;
+
+	/* DBG_8192D("%s(): rate = %x\n",__func__, rate); */
+}
+
+void update_mgntframe_attrib(struct rtw_adapter *adapt,
+			     struct pkt_attrib *pattrib)
+{
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+
+	memset((u8 *)(pattrib), 0, sizeof(struct pkt_attrib));
+
+	pattrib->hdrlen = 24;
+	pattrib->nr_frags = 1;
+	pattrib->priority = 7;
+	pattrib->mac_id = 0;
+	pattrib->qsel = 0x12;
+
+	pattrib->pktlen = 0;
+
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
+		pattrib->raid = 6;	/* b mode */
+	else
+		pattrib->raid = 5;	/* a/g mode */
+
+	pattrib->encrypt = _NO_PRIVACY_;
+	pattrib->bswenc = false;
+
+	pattrib->qos_en = false;
+	pattrib->ht_en = false;
+	pattrib->bwmode = HT_CHANNEL_WIDTH_20;
+	pattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pattrib->sgi = false;
+
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+
+	pattrib->retry_ctrl = true;
+}
+
+void dump_mgntframe(struct rtw_adapter *adapt, struct xmit_frame *pmgntframe)
+{
+	if (adapt->bSurpriseRemoved == true ||
+	    adapt->bDriverStopped == true)
+		return;
+
+	rtw_hal_mgnt_xmit(adapt, pmgntframe);
+}
+
+s32 dump_mgntframe_and_wait(struct rtw_adapter *adapt,
+			    struct xmit_frame *pmgntframe, int timeout_ms)
+{
+	s32 ret = _FAIL;
+	struct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;
+	struct submit_ctx sctx;
+
+	if (adapt->bSurpriseRemoved == true ||
+	    adapt->bDriverStopped == true)
+		return ret;
+
+	rtw_sctx_init(&sctx, timeout_ms);
+	pxmitbuf->sctx = &sctx;
+
+	ret = rtw_hal_mgnt_xmit(adapt, pmgntframe);
+
+	if (ret == _SUCCESS)
+		ret = rtw_sctx_wait(&sctx);
+
+	return ret;
+}
+
+s32 dump_mgntframe_and_wait_ack(struct rtw_adapter *adapt,
+				struct xmit_frame *pmgntframe)
+{
+	struct xmit_priv *pxmitpriv = &adapt->xmitpriv;
+	s32 ret = _FAIL;
+	u32 timeout_ms = 500;	/*   500ms */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapt->pbuddy_adapter && !adapt->isprimary)
+		pxmitpriv = &(adapt->pbuddy_adapter->xmitpriv);
+#endif
+
+	if (adapt->bSurpriseRemoved == true ||
+	    adapt->bDriverStopped == true)
+		return -1;
+
+	_enter_critical_mutex(&pxmitpriv->ack_tx_mutex);
+	pxmitpriv->ack_tx = true;
+
+	pmgntframe->ack_report = 1;
+	if (rtw_hal_mgnt_xmit(adapt, pmgntframe) == _SUCCESS) {
+		ret = rtw_ack_tx_wait(pxmitpriv, timeout_ms);
+	}
+
+	pxmitpriv->ack_tx = false;
+	_exit_critical_mutex(&pxmitpriv->ack_tx_mutex);
+
+	return ret;
+}
+
+static int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
+{
+	u8 *ssid_ie;
+	int ssid_len_ori;
+	int len_diff = 0;
+
+	ssid_ie = rtw_get_ie(ies, WLAN_EID_SSID, &ssid_len_ori, ies_len);
+
+	/* DBG_8192D("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __func__, hidden_ssid_mode, ssid_ie, ssid_len_ori); */
+
+	if (ssid_ie && ssid_len_ori > 0) {
+		switch (hidden_ssid_mode) {
+		case 1:
+			{
+				u8 *next_ie = ssid_ie + 2 + ssid_len_ori;
+				u32 remain_len = 0;
+
+				remain_len = ies_len - (next_ie - ies);
+
+				ssid_ie[1] = 0;
+				memcpy(ssid_ie + 2, next_ie, remain_len);
+				len_diff -= ssid_len_ori;
+
+				break;
+			}
+		case 2:
+			memset(&ssid_ie[2], 0, ssid_len_ori);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return len_diff;
+}
+
+void issue_beacon(struct rtw_adapter *adapt)
+{
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	unsigned int rate_len;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
+	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL) {
+		DBG_8192D("%s, alloc mgnt frame fail\n", __func__);
+		return;
+	}
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+	pattrib->qsel = 0x10;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	/*pmlmeext->mgnt_seq++; */
+	SetFrameSubType(pframe, WIFI_BEACON);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+		{
+			int len_diff;
+			memcpy(pframe, cur_network->IEs, cur_network->IELength);
+			len_diff =
+			    update_hidden_ssid(pframe + _BEACON_IE_OFFSET_,
+					       cur_network->IELength -
+					       _BEACON_IE_OFFSET_,
+					       pmlmeinfo->hidden_ssid_mode);
+			pframe += (cur_network->IELength + len_diff);
+			pattrib->pktlen += (cur_network->IELength + len_diff);
+		}
+
+		{
+			u8 *wps_ie;
+			uint wps_ielen;
+			u8 sr = 0;
+			wps_ie =
+			    rtw_get_wps_ie(pmgntframe->buf_addr +
+					   TXDESC_OFFSET +
+					   sizeof(struct
+						  rtw_ieee80211_hdr_3addr) +
+					   _BEACON_IE_OFFSET_,
+					   pattrib->pktlen -
+					   sizeof(struct
+						  rtw_ieee80211_hdr_3addr) -
+					   _BEACON_IE_OFFSET_, NULL,
+					   &wps_ielen);
+			if (wps_ie && wps_ielen > 0) {
+				rtw_get_wps_attr_content(wps_ie, wps_ielen,
+							 WPS_ATTR_SELECTED_REGISTRAR,
+							 (u8 *)(&sr), NULL);
+			}
+			if (sr != 0)
+				set_fwstate(pmlmepriv, WIFI_UNDER_WPS);
+			else
+				_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);
+		}
+
+		goto _issue_bcn;
+	}
+
+	/* below for ad-hoc mode */
+
+	/* timestamp will be inserted by hardware */
+	pframe += 8;
+	pattrib->pktlen += 8;
+
+	/*  beacon interval: 2 bytes */
+
+	memcpy(pframe,
+	       (unsigned char
+		*)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	/*  capability info: 2 bytes */
+
+	memcpy(pframe,
+	       (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)),
+	       2);
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	/*  SSID */
+	pframe =
+	    rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength,
+		       cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+	/*  supported rates... */
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe =
+	    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_,
+		       ((rate_len > 8) ? 8 : rate_len),
+		       cur_network->SupportedRates, &pattrib->pktlen);
+
+	/*  DS parameter set */
+	pframe =
+	    rtw_set_ie(pframe, _DSSET_IE_, 1,
+		       (unsigned char *)&(cur_network->Configuration.DSConfig),
+		       &pattrib->pktlen);
+
+	/* if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) */
+	{
+		u8 erpinfo = 0;
+		u32 ATIMWindow;
+		/*  IBSS Parameter Set... */
+		/* ATIMWindow = cur->Configuration.ATIMWindow; */
+		ATIMWindow = 0;
+		pframe =
+		    rtw_set_ie(pframe, _IBSS_PARA_IE_, 2,
+			       (unsigned char *)(&ATIMWindow),
+			       &pattrib->pktlen);
+
+		/* ERP IE */
+		pframe =
+		    rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo,
+			       &pattrib->pktlen);
+	}
+
+	/*  EXTERNDED SUPPORTED RATE */
+	if (rate_len > 8) {
+		pframe =
+		    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8),
+			       (cur_network->SupportedRates + 8),
+			       &pattrib->pktlen);
+	}
+
+	/* todo:HT for adhoc */
+
+_issue_bcn:
+
+	pmlmepriv->update_bcn = false;
+
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
+
+	if ((pattrib->pktlen + TXDESC_SIZE) > 512) {
+		DBG_8192D("beacon frame too large\n");
+		return;
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(adapt, pmgntframe);
+}
+
+void issue_probersp(struct rtw_adapter *adapt, unsigned char *da,
+		    u8 is_valid_p2p_probereq)
+{
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	unsigned char *mac, *bssid;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+#if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	u8 *pwps_ie;
+	uint wps_ielen;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+#endif /* if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
+	unsigned int rate_len;
+
+	/* DBG_8192D("%s\n", __func__); */
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL) {
+		DBG_8192D("%s, alloc mgnt frame fail\n", __func__);
+		return;
+	}
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	mac = myid(&(adapt->eeprompriv));
+	bssid = cur_network->MacAddress;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, bssid, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+
+	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = pattrib->hdrlen;
+	pframe += pattrib->hdrlen;
+
+	if (cur_network->IELength > MAX_IE_SZ)
+		return;
+
+#if defined (CONFIG_92D_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+		pwps_ie =
+		    rtw_get_wps_ie(cur_network->IEs + _FIXED_IE_LENGTH_,
+				   cur_network->IELength - _FIXED_IE_LENGTH_,
+				   NULL, &wps_ielen);
+
+		/* inerset & update wps_probe_resp_ie */
+		if ((pmlmepriv->wps_probe_resp_ie != NULL) &&
+		    pwps_ie && (wps_ielen > 0)) {
+			uint wps_offset, remainder_ielen;
+			u8 *premainder_ie;
+
+			wps_offset = (uint) (pwps_ie - cur_network->IEs);
+
+			premainder_ie = pwps_ie + wps_ielen;
+
+			remainder_ielen =
+			    cur_network->IELength - wps_offset - wps_ielen;
+
+			memcpy(pframe, cur_network->IEs, wps_offset);
+			pframe += wps_offset;
+			pattrib->pktlen += wps_offset;
+
+			wps_ielen = (uint) pmlmepriv->wps_probe_resp_ie[1];	/* to get ie data len */
+			if ((wps_offset + wps_ielen + 2) <= MAX_IE_SZ) {
+				memcpy(pframe, pmlmepriv->wps_probe_resp_ie,
+				       wps_ielen + 2);
+				pframe += wps_ielen + 2;
+				pattrib->pktlen += wps_ielen + 2;
+			}
+
+			if ((wps_offset + wps_ielen + 2 + remainder_ielen) <=
+			    MAX_IE_SZ) {
+				memcpy(pframe, premainder_ie, remainder_ielen);
+				pframe += remainder_ielen;
+				pattrib->pktlen += remainder_ielen;
+			}
+		} else {
+			memcpy(pframe, cur_network->IEs, cur_network->IELength);
+			pframe += cur_network->IELength;
+			pattrib->pktlen += cur_network->IELength;
+		}
+
+		/* retrieve SSID IE from cur_network->Ssid */
+		{
+			u8 *ssid_ie;
+			int ssid_ielen;
+			int ssid_ielen_diff;
+			u8 buf[MAX_IE_SZ];
+			u8 *ies =
+			    pmgntframe->buf_addr + TXDESC_OFFSET +
+			    sizeof(struct rtw_ieee80211_hdr_3addr);
+
+			ssid_ie =
+			    rtw_get_ie(ies + _FIXED_IE_LENGTH_, _SSID_IE_,
+				       &ssid_ielen,
+				       (pframe - ies) - _FIXED_IE_LENGTH_);
+
+			ssid_ielen_diff =
+			    cur_network->Ssid.SsidLength - ssid_ielen;
+
+			if (ssid_ie && cur_network->Ssid.SsidLength) {
+				uint remainder_ielen;
+				u8 *remainder_ie;
+				remainder_ie = ssid_ie + 2;
+				remainder_ielen = (pframe - remainder_ie);
+
+				LOG_LEVEL(_drv_warning_,
+					  FUNC_ADPT_FMT
+					  " remainder_ielen > MAX_IE_SZ\n",
+					  FUNC_ADPT_ARG(adapt));
+				if (remainder_ielen > MAX_IE_SZ) {
+					remainder_ielen = MAX_IE_SZ;
+				}
+
+				memcpy(buf, remainder_ie, remainder_ielen);
+				memcpy(remainder_ie + ssid_ielen_diff, buf,
+				       remainder_ielen);
+				*(ssid_ie + 1) = cur_network->Ssid.SsidLength;
+				memcpy(ssid_ie + 2, cur_network->Ssid.Ssid,
+				       cur_network->Ssid.SsidLength);
+
+				pframe += ssid_ielen_diff;
+				pattrib->pktlen += ssid_ielen_diff;
+			}
+		}
+	} else
+#endif
+	{
+		/* timestamp will be inserted by hardware */
+		pframe += 8;
+		pattrib->pktlen += 8;
+
+		/*  beacon interval: 2 bytes */
+
+		memcpy(pframe,
+		       (unsigned char
+			*)(rtw_get_beacon_interval_from_ie(cur_network->IEs)),
+		       2);
+
+		pframe += 2;
+		pattrib->pktlen += 2;
+
+		/*  capability info: 2 bytes */
+
+		memcpy(pframe,
+		       (unsigned char
+			*)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+		pframe += 2;
+		pattrib->pktlen += 2;
+
+		/* below for ad-hoc mode */
+
+		/*  SSID */
+		pframe =
+		    rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength,
+			       cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+		/*  supported rates... */
+		rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_,
+			       ((rate_len > 8) ? 8 : rate_len),
+			       cur_network->SupportedRates, &pattrib->pktlen);
+
+		/*  DS parameter set */
+		pframe =
+		    rtw_set_ie(pframe, _DSSET_IE_, 1,
+			       (unsigned char *)&(cur_network->Configuration.
+						  DSConfig), &pattrib->pktlen);
+
+		if ((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) {
+			u8 erpinfo = 0;
+			u32 ATIMWindow;
+			/*  IBSS Parameter Set... */
+			/* ATIMWindow = cur->Configuration.ATIMWindow; */
+			ATIMWindow = 0;
+			pframe =
+			    rtw_set_ie(pframe, _IBSS_PARA_IE_, 2,
+				       (unsigned char *)(&ATIMWindow),
+				       &pattrib->pktlen);
+
+			/* ERP IE */
+			pframe =
+			    rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo,
+				       &pattrib->pktlen);
+		}
+
+		/*  EXTERNDED SUPPORTED RATE */
+		if (rate_len > 8) {
+			pframe =
+			    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_,
+				       (rate_len - 8),
+				       (cur_network->SupportedRates + 8),
+				       &pattrib->pktlen);
+		}
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(adapt, pmgntframe);
+
+	return;
+}
+
+static int _issue_probereq(struct rtw_adapter *adapt,
+		    struct ndis_802_11_ssid *pssid, u8 *da, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	unsigned char *mac;
+	unsigned char bssrate[NUMRATES];
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	int bssrate_len = 0;
+	u8 bc_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+issue_probereq\n"));
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		goto exit;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	mac = myid(&(adapt->eeprompriv));
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if (da) {
+		/*      unicast probe request frame */
+		memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, da, ETH_ALEN);
+	} else {
+		/*      broadcast probe request frame */
+		memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
+	}
+
+	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_PROBEREQ);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (pssid)
+		pframe =
+		    rtw_set_ie(pframe, _SSID_IE_, pssid->SsidLength,
+			       pssid->Ssid, &(pattrib->pktlen));
+	else
+		pframe =
+		    rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &(pattrib->pktlen));
+
+	get_rate_set(adapt, bssrate, &bssrate_len);
+
+	if (bssrate_len > 8) {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, bssrate,
+			       &(pattrib->pktlen));
+		pframe =
+		    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_,
+			       (bssrate_len - 8), (bssrate + 8),
+			       &(pattrib->pktlen));
+	} else {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, bssrate_len,
+			       bssrate, &(pattrib->pktlen));
+	}
+
+	/* add wps_ie for wps2.0 */
+	if (pmlmepriv->wps_probe_req_ie_len > 0 && pmlmepriv->wps_probe_req_ie) {
+		memcpy(pframe, pmlmepriv->wps_probe_req_ie,
+		       pmlmepriv->wps_probe_req_ie_len);
+		pframe += pmlmepriv->wps_probe_req_ie_len;
+		pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+		 ("issuing probe_req, tx_len=%d\n", pattrib->last_txcmdsz));
+
+	if (wait_ack) {
+		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
+	} else {
+		dump_mgntframe(adapt, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+inline void issue_probereq(struct rtw_adapter *adapt,
+			   struct ndis_802_11_ssid *pssid, u8 *da)
+{
+	_issue_probereq(adapt, pssid, da, false);
+}
+
+int issue_probereq_ex(struct rtw_adapter *adapt,
+		      struct ndis_802_11_ssid *pssid, u8 *da, int try_cnt,
+		      int wait_ms)
+{
+	int ret;
+	int i = 0;
+	u32 start = rtw_get_current_time();
+
+	do {
+		ret =
+		    _issue_probereq(adapt, pssid, da,
+				    wait_ms > 0 ? true : false);
+
+		i++;
+
+		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
+			break;
+
+		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+			rtw_msleep_os(wait_ms);
+
+	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+#ifndef DBG_XMIT_ACK
+		goto exit;
+#endif
+	}
+
+	if (try_cnt && wait_ms) {
+		if (da)
+			DBG_8192D(FUNC_ADPT_FMT
+				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt), da,
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+		else
+			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt),
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+	}
+exit:
+	return ret;
+}
+
+/*  if psta == NULL, indiate we are station(client) now... */
+void issue_auth(struct rtw_adapter *adapt, struct sta_info *psta,
+		unsigned short status)
+{
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	unsigned int val32;
+	unsigned short val16;
+	int use_shared_key = 0;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		return;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_AUTH);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (psta) {		/*  for AP mode */
+#ifdef CONFIG_NATIVEAP_MLME
+		__le16 le_tmp16;
+
+		memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);
+		memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)),
+		       ETH_ALEN);
+		memcpy(pwlanhdr->addr3, myid(&(adapt->eeprompriv)),
+		       ETH_ALEN);
+
+		/*  setting auth algo number */
+		val16 = (u16) psta->authalg;
+
+		if (status != _STATS_SUCCESSFUL_)
+			val16 = 0;
+
+		if (val16) {
+			use_shared_key = 1;
+		}
+
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  setting auth seq number */
+		val16 = (u16) psta->auth_seq;
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  setting status code... */
+		val16 = status;
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _STATUS_CODE_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  added challenging text... */
+		if ((psta->auth_seq == 2) &&
+		    (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {
+			pframe =
+			    rtw_set_ie(pframe, _CHLGETXT_IE_, 128,
+				       psta->chg_txt, &(pattrib->pktlen));
+		}
+#endif
+	} else {
+		__le32 le_tmp32;
+		__le16 le_tmp16;
+		memcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network),
+		       ETH_ALEN);
+		memcpy(pwlanhdr->addr2, myid(&adapt->eeprompriv), ETH_ALEN);
+		memcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network),
+		       ETH_ALEN);
+
+		/*  setting auth algo number */
+		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared) ? 1 : 0;	/*  0:OPEN System, 1:Shared key */
+		if (val16) {
+			use_shared_key = 1;
+		}
+
+		/* setting IV for auth seq #3 */
+		if ((pmlmeinfo->auth_seq == 3) &&
+		    (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key == 1)) {
+			val32 =
+			    ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));
+			le_tmp32 = cpu_to_le32(val32);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 4, (unsigned char *)&le_tmp32,
+					     &(pattrib->pktlen));
+
+			pattrib->iv_len = 4;
+		}
+
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  setting auth seq number */
+		val16 = pmlmeinfo->auth_seq;
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  setting status code... */
+		val16 = status;
+		le_tmp16 = cpu_to_le16(val16);
+		pframe =
+		    rtw_set_fixed_ie(pframe, _STATUS_CODE_,
+				     (unsigned char *)&le_tmp16,
+				     &(pattrib->pktlen));
+
+		/*  then checking to see if sending challenging text... */
+		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) &&
+		    (use_shared_key == 1)) {
+			pframe =
+			    rtw_set_ie(pframe, _CHLGETXT_IE_, 128,
+				       pmlmeinfo->chg_txt, &(pattrib->pktlen));
+
+			SetPrivacy(fctrl);
+
+			pattrib->hdrlen =
+			    sizeof(struct rtw_ieee80211_hdr_3addr);
+
+			pattrib->encrypt = _WEP40_;
+
+			pattrib->icv_len = 4;
+
+			pattrib->pktlen += pattrib->icv_len;
+		}
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	rtw_wep_encrypt(adapt, (u8 *)pmgntframe);
+
+	dump_mgntframe(adapt, pmgntframe);
+
+	return;
+}
+
+void issue_asocrsp(struct rtw_adapter *adapt, unsigned short status,
+		   struct sta_info *pstat, int pkt_type)
+{
+#ifdef CONFIG_92D_AP_MODE
+	struct xmit_frame *pmgntframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	struct pkt_attrib *pattrib;
+	unsigned char *pbuf, *pframe;
+	unsigned short val;
+	__le16 *fctrl;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork = &(pmlmeinfo->network);
+	u8 *ie = pnetwork->IEs;
+	__le16 leval, lestatus;
+
+	DBG_8192D("%s\n", __func__);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		return;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy((void *)GetAddr1Ptr(pwlanhdr), pstat->hwaddr, ETH_ALEN);
+	memcpy((void *)GetAddr2Ptr(pwlanhdr), myid(&(adapt->eeprompriv)),
+	       ETH_ALEN);
+	memcpy((void *)GetAddr3Ptr(pwlanhdr),
+	       get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	if ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))
+		SetFrameSubType(pwlanhdr, pkt_type);
+	else
+		return;
+
+	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen += pattrib->hdrlen;
+	pframe += pattrib->hdrlen;
+
+	/* capability */
+	val = *(unsigned short *)rtw_get_capability_from_ie(ie);
+
+	pframe =
+	    rtw_set_fixed_ie(pframe, _CAPABILITY_, (unsigned char *)&val,
+			     &(pattrib->pktlen));
+
+	lestatus = cpu_to_le16(status);
+	pframe =
+	    rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&lestatus,
+			     &(pattrib->pktlen));
+
+	leval = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));
+	pframe =
+	    rtw_set_fixed_ie(pframe, _ASOC_ID_, (unsigned char *)&leval,
+			     &(pattrib->pktlen));
+
+	if (pstat->bssratelen <= 8) {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, pstat->bssratelen,
+			       pstat->bssrateset, &(pattrib->pktlen));
+	} else {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8,
+			       pstat->bssrateset, &(pattrib->pktlen));
+		pframe =
+		    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_,
+			       (pstat->bssratelen - 8), pstat->bssrateset + 8,
+			       &(pattrib->pktlen));
+	}
+
+#ifdef CONFIG_80211N_HT
+	if ((pstat->flags & WLAN_STA_HT) && (pmlmepriv->htpriv.ht_option)) {
+		uint ie_len = 0;
+
+		/* FILL HT CAP INFO IE */
+		/*p = hostapd_eid_ht_capabilities_info(hapd, p); */
+		pbuf =
+		    rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_,
+			       &ie_len,
+			       (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if (pbuf && ie_len > 0) {
+			memcpy(pframe, pbuf, ie_len + 2);
+			pframe += (ie_len + 2);
+			pattrib->pktlen += (ie_len + 2);
+		}
+
+		/* FILL HT ADD INFO IE */
+		/*p = hostapd_eid_ht_operation(hapd, p); */
+		pbuf =
+		    rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_,
+			       &ie_len,
+			       (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if (pbuf && ie_len > 0) {
+			memcpy(pframe, pbuf, ie_len + 2);
+			pframe += (ie_len + 2);
+			pattrib->pktlen += (ie_len + 2);
+		}
+	}
+#endif
+
+	/* FILL WMM IE */
+	if ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option)) {
+		uint ie_len = 0;
+		unsigned char WMM_PARA_IE[] = {
+			0x00, 0x50, 0xf2, 0x02, 0x01, 0x01
+		};
+
+		for (pbuf = ie + _BEACON_IE_OFFSET_;; pbuf += (ie_len + 2)) {
+			pbuf =
+			    rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len,
+				       (pnetwork->IELength -
+					_BEACON_IE_OFFSET_ - (ie_len + 2)));
+			if (pbuf && _rtw_memcmp(pbuf + 2, WMM_PARA_IE, 6)) {
+				memcpy(pframe, pbuf, ie_len + 2);
+				pframe += (ie_len + 2);
+				pattrib->pktlen += (ie_len + 2);
+				break;
+			}
+			if ((pbuf == NULL) || (ie_len == 0))
+				break;
+		}
+	}
+
+	if (pmlmeinfo->assoc_AP_vendor == realtekAP) {
+		pframe =
+		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6, REALTEK_96B_IE,
+			       &(pattrib->pktlen));
+	}
+
+	/* add WPS IE ie for wps 2.0 */
+	if (pmlmepriv->wps_assoc_resp_ie &&
+	    pmlmepriv->wps_assoc_resp_ie_len > 0) {
+		memcpy(pframe, pmlmepriv->wps_assoc_resp_ie,
+		       pmlmepriv->wps_assoc_resp_ie_len);
+
+		pframe += pmlmepriv->wps_assoc_resp_ie_len;
+		pattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;
+	}
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(adapt, pmgntframe);
+
+#endif
+}
+
+void issue_assocreq(struct rtw_adapter *adapt)
+{
+	int ret = _FAIL;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe, *p;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	unsigned short val16;
+	__le16 le_tmp;
+	unsigned int i, j, ie_len, index = 0;
+	unsigned char rf_type, bssrate[NUMRATES], sta_bssrate[NUMRATES];
+	struct ndis_802_11_variable_ies *pIE;
+	struct registry_priv *pregpriv = &adapt->registrypriv;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	int bssrate_len = 0, sta_bssrate_len = 0;
+	u8 cbw40_enable = 0;
+#ifdef CONFIG_DFS
+	u16 cap;
+	u8 pow_cap_ele[2] = { 0x00 };
+	u8 sup_ch[30 * 2] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+#endif /* CONFIG_DFS */
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		goto exit;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ASSOCREQ);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	/* caps */
+
+#ifdef CONFIG_DFS
+	memcpy(&cap, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
+	if (pmlmeext->cur_channel > 14)
+		cap |= BIT(8);	/* Spectrum Mgmt. Enabled */
+	memcpy(pframe, &cap, 2);
+#else
+	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
+#endif /* CONFIG_DFS */
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	/* listen interval */
+	/* todo: listen interval for power saving */
+	le_tmp = cpu_to_le16(3);
+	memcpy(pframe, (unsigned char *)&le_tmp, 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	/* SSID */
+	pframe =
+	    rtw_set_ie(pframe, _SSID_IE_, pmlmeinfo->network.Ssid.SsidLength,
+		       pmlmeinfo->network.Ssid.Ssid, &(pattrib->pktlen));
+
+	/* supported rate & extended supported rate */
+
+	get_rate_set(adapt, sta_bssrate, &sta_bssrate_len);
+
+	if (pmlmeext->cur_channel == 14) {	/*  for JAPAN, channel 14 can only uses B Mode(CCK) */
+		sta_bssrate_len = 4;
+	}
+
+	/* for (i = 0; i < sta_bssrate_len; i++) { */
+	/*      DBG_8192D("sta_bssrate[%d]=%02X\n", i, sta_bssrate[i]); */
+	/*  */
+
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		if (pmlmeinfo->network.SupportedRates[i] == 0)
+			break;
+		DBG_8192D("network.SupportedRates[%d]=%02X\n", i,
+			  pmlmeinfo->network.SupportedRates[i]);
+	}
+
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		if (pmlmeinfo->network.SupportedRates[i] == 0)
+			break;
+
+		/*  Check if the AP's supported rates are also supported by STA. */
+		for (j = 0; j < sta_bssrate_len; j++) {
+			/*  Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP */
+			if ((pmlmeinfo->network.
+			     SupportedRates[i] | IEEE80211_BASIC_RATE_MASK)
+			    == (sta_bssrate[j] | IEEE80211_BASIC_RATE_MASK)) {
+				/* DBG_8192D("match i = %d, j=%d\n", i, j); */
+				break;
+			} else {
+				/* DBG_8192D("not match: %02X != %02X\n", (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK), (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)); */
+			}
+		}
+
+		if (j == sta_bssrate_len) {
+			/*  the rate is not supported by STA */
+			DBG_8192D
+			    ("%s(): the rate[%d]=%02X is not supported by STA!\n",
+			     __func__, i, pmlmeinfo->network.SupportedRates[i]);
+		} else {
+			/*  the rate is supported by STA */
+			bssrate[index++] = pmlmeinfo->network.SupportedRates[i];
+		}
+	}
+
+	bssrate_len = index;
+	DBG_8192D("bssrate_len = %d\n", bssrate_len);
+
+	if (bssrate_len == 0) {
+		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
+		rtw_free_xmitframe(pxmitpriv, pmgntframe);
+		goto exit;	/* don't connect to AP if no joint supported rate */
+	}
+
+	if (bssrate_len > 8) {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, bssrate,
+			       &(pattrib->pktlen));
+		pframe =
+		    rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_,
+			       (bssrate_len - 8), (bssrate + 8),
+			       &(pattrib->pktlen));
+	} else {
+		pframe =
+		    rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, bssrate_len,
+			       bssrate, &(pattrib->pktlen));
+	}
+
+#ifdef CONFIG_DFS
+	if (pmlmeext->cur_channel > 14) {
+		pow_cap_ele[0] = 13;	/*  Minimum transmit power capability */
+		pow_cap_ele[1] = 21;	/*  Maximum transmit power capability */
+		pframe =
+		    rtw_set_ie(pframe, _POW_CAP_IE_, 2, pow_cap_ele,
+			       &(pattrib->pktlen));
+
+		/* supported channels */
+		do {
+			if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14) {
+				sup_ch[0] = 1;	/* First channel number */
+				sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	/* Number of channel */
+			} else {
+				sup_ch[idx_5g++] =
+				    pmlmeext->channel_set[sup_ch_idx].
+				    ChannelNum;
+				sup_ch[idx_5g++] = 1;
+			}
+			sup_ch_idx++;
+		} while (pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0);
+		pframe = rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen));
+	}
+#endif /* CONFIG_DFS */
+
+	/* RSN */
+	p = rtw_get_ie((pmlmeinfo->network.IEs +
+			sizeof(struct ndis_802_11_fixed_ies)), _RSN_IE_2_,
+		       &ie_len,
+		       (pmlmeinfo->network.IELength -
+			sizeof(struct ndis_802_11_fixed_ies)));
+	if (p != NULL) {
+		pframe =
+		    rtw_set_ie(pframe, _RSN_IE_2_, ie_len, (p + 2),
+			       &(pattrib->pktlen));
+	}
+#ifdef CONFIG_80211N_HT
+	/* HT caps */
+	if (adapt->mlmepriv.htpriv.ht_option == true) {
+		p = rtw_get_ie((pmlmeinfo->network.IEs +
+				sizeof(struct ndis_802_11_fixed_ies)),
+			       _HT_CAPABILITY_IE_, &ie_len,
+			       (pmlmeinfo->network.IELength -
+				sizeof(struct ndis_802_11_fixed_ies)));
+		if ((p != NULL) && (!(is_ap_in_tkip(adapt)))) {
+			memcpy(&(pmlmeinfo->HT_caps), (p + 2),
+			       sizeof(struct HT_caps_element));
+
+			/* to disable 40M Hz support while gd_bw_40MHz_en = 0 */
+			if (pmlmeext->cur_channel > 14) {
+				if (pregpriv->cbw40_enable & BIT(1))
+					cbw40_enable = 1;
+			} else if (pregpriv->cbw40_enable & BIT(0)) {
+				cbw40_enable = 1;
+			}
+
+			if (cbw40_enable == 0) {
+				pmlmeinfo->HT_caps.u.HT_cap_element.
+				    HT_caps_info &= cpu_to_le16((~(BIT(6) | BIT(1))));
+			} else {
+				pmlmeinfo->HT_caps.u.HT_cap_element.
+				    HT_caps_info |= cpu_to_le16(BIT(1));
+			}
+
+			/* todo: disable SM power save mode */
+			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |=
+			    cpu_to_le16(0x000c);
+
+			rtw_hal_get_hwreg(adapt, HW_VAR_RF_TYPE,
+					  (u8 *)(&rf_type));
+			switch (rf_type) {
+			case RF_1T1R:
+
+				if (pregpriv->rx_stbc)
+					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);	/* RX STBC One spatial stream */
+
+				memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.
+				       MCS_rate, MCS_rate_1R, 16);
+				break;
+
+			case RF_2T2R:
+			case RF_1T2R:
+			default:
+				if (pregpriv->special_rf_path) {
+					if (pregpriv->rx_stbc)
+						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);	/* RX STBC One spatial stream */
+					memcpy(pmlmeinfo->HT_caps.u.
+					       HT_cap_element.MCS_rate,
+					       MCS_rate_1R, 16);
+					break;
+				}
+
+				if ((pregpriv->rx_stbc == 0x3) ||	/* enable for 2.4/5 GHz */
+				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) ||	/* enable for 2.4GHz */
+				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2)) ||	/* enable for 5GHz */
+				    (pregpriv->wifi_spec == 1)) {
+					DBG_8192D
+					    ("declare supporting RX STBC\n");
+					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);	/* RX STBC two spatial stream */
+				}
+				memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.
+				       MCS_rate, MCS_rate_2R, 16);
+				break;
+			}
+			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info =
+			    pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
+			pframe =
+			    rtw_set_ie(pframe, _HT_CAPABILITY_IE_, ie_len,
+				       (u8 *)(&(pmlmeinfo->HT_caps)),
+				       &(pattrib->pktlen));
+		}
+	}
+#endif
+
+	/* vendor specific IE, such as WPA, WMM, WPS */
+	for (i = sizeof(struct ndis_802_11_fixed_ies);
+	     i < pmlmeinfo->network.IELength;) {
+		pIE =
+		    (struct ndis_802_11_variable_ies *)(pmlmeinfo->network.IEs +
+							i);
+
+		switch (pIE->ElementID) {
+		case _VENDOR_SPECIFIC_IE_:
+			if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) ||
+			    (_rtw_memcmp(pIE->data, WMM_OUI, 4)) ||
+			    (_rtw_memcmp(pIE->data, WPS_OUI, 4))) {
+				if (!adapt->registrypriv.wifi_spec) {
+					/* Commented by Kurt 20110629 */
+					/* In some older APs, WPS handshake */
+					/* would be fail if we append vender extensions informations to AP */
+					if (_rtw_memcmp(pIE->data, WPS_OUI, 4)) {
+						pIE->Length = 14;
+					}
+				}
+				pframe =
+				    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_,
+					       pIE->Length, pIE->data,
+					       &(pattrib->pktlen));
+			}
+			break;
+
+		default:
+			break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	if (pmlmeinfo->assoc_AP_vendor == realtekAP) {
+		pframe =
+		    rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6, REALTEK_96B_IE,
+			       &(pattrib->pktlen));
+	}
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	dump_mgntframe(adapt, pmgntframe);
+
+	ret = _SUCCESS;
+
+exit:
+	if (ret == _SUCCESS)
+		rtw_buf_update(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len,
+			       (u8 *)pwlanhdr, pattrib->pktlen);
+	else
+		rtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);
+
+	return;
+}
+
+/* when wait_ack is ture, this function shoule be called at process context */
+static int _issue_nulldata(struct rtw_adapter *adapt, unsigned char *da,
+			   unsigned int power_mode, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	struct xmit_priv *pxmitpriv;
+	struct mlme_ext_priv *pmlmeext;
+	struct mlme_ext_info *pmlmeinfo;
+
+	/* DBG_8192D("%s:%d\n", __func__, power_mode); */
+
+	if (!adapt)
+		goto exit;
+
+	pxmitpriv = &(adapt->xmitpriv);
+	pmlmeext = &(adapt->mlmeextpriv);
+	pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		goto exit;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+	pattrib->retry_ctrl = false;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+		SetFrDs(fctrl);
+	} else if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		SetToDs(fctrl);
+	}
+
+	if (power_mode) {
+		SetPwrMgt(fctrl);
+	}
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (wait_ack) {
+		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
+	} else {
+		dump_mgntframe(adapt, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+/* when wait_ms >0 , this function shoule be called at process context */
+/* da == NULL for station mode */
+int issue_nulldata(struct rtw_adapter *adapt, unsigned char *da,
+		   unsigned int power_mode, int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	u32 start = rtw_get_current_time();
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* da == NULL, assum it's null data for sta to ap */
+	if (da == NULL)
+		da = get_my_bssid(&(pmlmeinfo->network));
+
+	do {
+		ret =
+		    _issue_nulldata(adapt, da, power_mode,
+				    wait_ms > 0 ? true : false);
+
+		i++;
+
+		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
+			break;
+
+		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+			rtw_msleep_os(wait_ms);
+
+	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+#ifndef DBG_XMIT_ACK
+		goto exit;
+#endif
+	}
+
+	if (try_cnt && wait_ms) {
+		if (da)
+			DBG_8192D(FUNC_ADPT_FMT
+				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt), da,
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+		else
+			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt),
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+	}
+exit:
+	return ret;
+}
+
+/* when wait_ack is ture, this function shoule be called at process context */
+static int _issue_qos_nulldata(struct rtw_adapter *adapt, unsigned char *da,
+			       u16 tid, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	u16 *qc;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_8192D("%s\n", __func__);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		goto exit;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	pattrib->hdrlen += 2;
+	pattrib->qos_en = true;
+	pattrib->eosp = 1;
+	pattrib->ack_policy = 0;
+	pattrib->mdata = 0;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+		SetFrDs(fctrl);
+	} else if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		SetToDs(fctrl);
+	}
+
+	if (pattrib->mdata)
+		SetMData(fctrl);
+
+	qc = (unsigned short *)(pframe + pattrib->hdrlen - 2);
+
+	SetPriority(qc, tid);
+
+	SetEOSP(qc, pattrib->eosp);
+
+	SetAckpolicy(qc, pattrib->ack_policy);
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_QOS_DATA_NULL);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (wait_ack) {
+		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
+	} else {
+		dump_mgntframe(adapt, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+/* when wait_ms >0 , this function shoule be called at process context */
+/* da == NULL for station mode */
+int issue_qos_nulldata(struct rtw_adapter *adapt, unsigned char *da, u16 tid,
+		       int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	u32 start = rtw_get_current_time();
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* da == NULL, assum it's null data for sta to ap */
+	if (da == NULL)
+		da = get_my_bssid(&(pmlmeinfo->network));
+
+	do {
+		ret =
+		    _issue_qos_nulldata(adapt, da, tid,
+					wait_ms > 0 ? true : false);
+
+		i++;
+
+		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
+			break;
+
+		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+			rtw_msleep_os(wait_ms);
+
+	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+#ifndef DBG_XMIT_ACK
+		goto exit;
+#endif
+	}
+
+	if (try_cnt && wait_ms) {
+		if (da)
+			DBG_8192D(FUNC_ADPT_FMT
+				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt), da,
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+		else
+			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt),
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+	}
+exit:
+	return ret;
+}
+
+static int _issue_deauth(struct rtw_adapter *adapt, unsigned char *da,
+			 unsigned short reason, u8 wait_ack)
+{
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	int ret = _FAIL;
+	__le16 le_tmp;
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		goto exit;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+	pattrib->retry_ctrl = false;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DEAUTH);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	le_tmp = cpu_to_le16(reason);
+	pframe =
+	    rtw_set_fixed_ie(pframe, _RSON_CODE_, (unsigned char *)&le_tmp,
+			     &(pattrib->pktlen));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (wait_ack) {
+		ret = dump_mgntframe_and_wait_ack(adapt, pmgntframe);
+	} else {
+		dump_mgntframe(adapt, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+int issue_deauth(struct rtw_adapter *adapt, unsigned char *da,
+		 unsigned short reason)
+{
+	DBG_8192D("%s to %pM\n", __func__, da);
+	return _issue_deauth(adapt, da, reason, false);
+}
+
+int issue_deauth_ex(struct rtw_adapter *adapt, u8 *da,
+		    unsigned short reason, int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	u32 start = rtw_get_current_time();
+
+	do {
+		ret =
+		    _issue_deauth(adapt, da, reason,
+				  wait_ms > 0 ? true : false);
+
+		i++;
+
+		if (adapt->bDriverStopped || adapt->bSurpriseRemoved)
+			break;
+
+		if (i < try_cnt && wait_ms > 0 && ret == _FAIL)
+			rtw_msleep_os(wait_ms);
+
+	} while ((i < try_cnt) && ((ret == _FAIL) || (wait_ms == 0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+#ifndef DBG_XMIT_ACK
+		goto exit;
+#endif
+	}
+
+	if (try_cnt && wait_ms) {
+		if (da)
+			DBG_8192D(FUNC_ADPT_FMT
+				  " to %pM, ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt), da,
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+		else
+			DBG_8192D(FUNC_ADPT_FMT ", ch:%u%s, %d/%d in %u ms\n",
+				  FUNC_ADPT_ARG(adapt),
+				  rtw_get_oper_ch(adapt),
+				  ret == _SUCCESS ? ", acked" : "", i, try_cnt,
+				  rtw_get_passing_time_ms(start));
+	}
+exit:
+	return ret;
+}
+
+void issue_action_spct_ch_switch(struct rtw_adapter *adapt, u8 *ra,
+				 u8 new_ch, u8 ch_offset)
+{
+	struct list_head *plist, *phead;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_8192D(FUNC_NDEV_FMT " ra=%pM, ch:%u, offset:%u\n",
+		  FUNC_NDEV_ARG(adapt->pnetdev), ra, new_ch, ch_offset);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		return;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, ra, ETH_ALEN);	/* RA */
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);	/* TA */
+	memcpy(pwlanhdr->addr3, ra, ETH_ALEN);	/* DA = RA */
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	/* category, action */
+	{
+		u8 category, action;
+		category = RTW_WLAN_CATEGORY_SPECTRUM_MGMT;
+		action = RTW_WLAN_ACTION_SPCT_CHL_SWITCH;
+
+		pframe =
+		    rtw_set_fixed_ie(pframe, 1, &(category),
+				     &(pattrib->pktlen));
+		pframe =
+		    rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+	}
+
+	pframe = rtw_set_ie_ch_switch(pframe, &(pattrib->pktlen), 0, new_ch, 0);
+	pframe = rtw_set_ie_secondary_ch_offset(pframe, &(pattrib->pktlen),
+						hal_ch_offset_to_secondary_ch_offset
+						(ch_offset));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(adapt, pmgntframe);
+}
+
+void issue_action_BA(struct rtw_adapter *adapt, unsigned char *raddr,
+		     unsigned char action, unsigned short status)
+{
+	u8 category = RTW_WLAN_CATEGORY_BACK;
+	u16 start_seq;
+	u16 BA_para_set;
+	u16 reason_code;
+	u16 BA_timeout_value;
+	u16 BA_starting_seqctrl;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	u8 *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info *psta;
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	struct registry_priv *pregpriv = &adapt->registrypriv;
+	__le16 le_tmp;
+
+	DBG_8192D("%s, category=%d, action=%d, status=%d\n", __func__, category,
+		  action, status);
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		return;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	/* memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN); */
+	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+	if (category == 3) {
+		switch (action) {
+		case 0:	/* ADDBA req */
+			do {
+				pmlmeinfo->dialogToken++;
+			} while (pmlmeinfo->dialogToken == 0);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 1,
+					     &(pmlmeinfo->dialogToken),
+					     &(pattrib->pktlen));
+
+			BA_para_set = (0x1002 | ((status & 0xf) << 2));	/* immediate ack & 64 buffer size */
+			le_tmp = cpu_to_le16(BA_para_set);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&(le_tmp)),
+					     &(pattrib->pktlen));
+
+			BA_timeout_value = 5000;	/*  5ms */
+			le_tmp = cpu_to_le16(BA_timeout_value);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char
+					      *)(&(le_tmp)),
+					     &(pattrib->pktlen));
+
+			psta = rtw_get_stainfo(pstapriv, raddr);
+			if (psta != NULL) {
+				start_seq =
+				    (psta->sta_xmitpriv.
+				     txseq_tid[status & 0x07] & 0xfff) + 1;
+
+				DBG_8192D
+				    ("BA_starting_seqctrl = %d for TID=%d\n",
+				     start_seq, status & 0x07);
+
+				psta->BA_starting_seqctrl[status & 0x07] =
+				    start_seq;
+
+				BA_starting_seqctrl = start_seq << 4;
+			}
+
+			le_tmp = cpu_to_le16(BA_starting_seqctrl);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char
+					      *)(&(le_tmp)),
+					     &(pattrib->pktlen));
+			break;
+
+		case 1:	/* ADDBA rsp */
+			pframe =
+			    rtw_set_fixed_ie(pframe, 1,
+					     &(pmlmeinfo->ADDBA_req.
+					       dialog_token),
+					     &(pattrib->pktlen));
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&status),
+					     &(pattrib->pktlen));
+
+			BA_para_set =
+				(le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) &
+				 0x3f) | 0x1000;/*64 buffer size*/
+
+			if (pregpriv->ampdu_amsdu == 0)	/* disabled */
+				le_tmp = cpu_to_le16(BA_para_set & ~BIT(0));
+			else if (pregpriv->ampdu_amsdu == 1)	/* enabled */
+				le_tmp = cpu_to_le16(BA_para_set | BIT(0));
+			else	/* auto */
+				le_tmp = cpu_to_le16(BA_para_set);
+
+			pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(le_tmp)), &(pattrib->pktlen));
+			pframe = rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&(pmlmeinfo->ADDBA_req.  BA_timeout_value)), &(pattrib->pktlen));
+			break;
+		case 2:	/* DELBA */
+			BA_para_set = (status & 0x1F) << 3;
+			le_tmp = cpu_to_le16(BA_para_set);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&(le_tmp)),
+					     &(pattrib->pktlen));
+
+			reason_code = 37;	/* Requested from peer STA as it does not want to use the mechanism */
+			le_tmp = cpu_to_le16(reason_code);
+			pframe =
+			    rtw_set_fixed_ie(pframe, 2,
+					     (unsigned char *)(&(le_tmp)),
+					     &(pattrib->pktlen));
+			break;
+		default:
+			break;
+		}
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(adapt, pmgntframe);
+}
+
+static void issue_action_BSSCoexistPacket(struct rtw_adapter *adapt)
+{
+	struct list_head *plist, *phead;
+	unsigned char category, action;
+	struct xmit_frame *pmgntframe;
+	struct pkt_attrib *pattrib;
+	unsigned char *pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	struct wlan_network *pnetwork = NULL;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	u8 InfoContent[16] = { 0 };
+	u8 ICS[8][15];
+
+	if ((pmlmepriv->num_FortyMHzIntolerant == 0) ||
+	    (pmlmepriv->num_sta_no_ht == 0))
+		return;
+
+	if (true == pmlmeinfo->bwmode_updated)
+		return;
+
+	DBG_8192D("%s\n", __func__);
+
+	category = RTW_WLAN_CATEGORY_PUBLIC;
+	action = ACT_PUBLIC_BSSCOEXIST;
+
+	pmgntframe = alloc_mgtxmitframe(pxmitpriv);
+	if (pmgntframe == NULL)
+		return;
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapt, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(adapt->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+	/*  */
+	if (pmlmepriv->num_FortyMHzIntolerant > 0) {
+		u8 iedata = 0;
+
+		iedata |= BIT(2);	/* 20 MHz BSS Width Request */
+
+		pframe =
+		    rtw_set_ie(pframe, EID_BSSCoexistence, 1, &iedata,
+			       &(pattrib->pktlen));
+	}
+
+	/*  */
+	memset(ICS, 0, sizeof(ICS));
+	if (pmlmepriv->num_sta_no_ht > 0) {
+		int i;
+
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+		phead = get_list_head(queue);
+		plist = phead->next;
+
+		while (1) {
+			int len;
+			u8 *p;
+			struct wlan_bssid_ex *pbss_network;
+
+			if (rtw_end_of_queue_search(phead, plist) == true)
+				break;
+
+			pnetwork =
+			    container_of(plist, struct wlan_network, list);
+
+			plist = plist->next;
+
+			pbss_network =
+			    (struct wlan_bssid_ex *)&pnetwork->network;
+
+			p = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_,
+				       _HT_CAPABILITY_IE_, &len,
+				       pbss_network->IELength -
+				       _FIXED_IE_LENGTH_);
+			if ((p == NULL) || (len == 0)) {	/* non-HT */
+				if ((pbss_network->Configuration.DSConfig <= 0) ||
+				    (pbss_network->Configuration.DSConfig > 14))
+					continue;
+				ICS[0][pbss_network->Configuration.DSConfig] = 1;
+				if (ICS[0][0] == 0)
+					ICS[0][0] = 1;
+			}
+		}
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+		for (i = 0; i < 8; i++) {
+			if (ICS[i][0] == 1) {
+				int j, k = 0;
+
+				InfoContent[k] = i;
+				/* SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i); */
+				k++;
+
+				for (j = 1; j <= 14; j++) {
+					if (ICS[i][j] == 1) {
+						if (k < 16) {
+							InfoContent[k] = j;	/* channel number */
+							/* SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j); */
+							k++;
+						}
+					}
+				}
+
+				pframe =
+				    rtw_set_ie(pframe,
+					       EID_BSSIntolerantChlReport, k,
+					       InfoContent, &(pattrib->pktlen));
+			}
+		}
+	}
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	dump_mgntframe(adapt, pmgntframe);
+}
+
+unsigned int send_delba(struct rtw_adapter *adapt, u8 initiator, u8 *addr)
+{
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	struct sta_info *psta = NULL;
+	/* struct recv_reorder_ctrl *preorder_ctrl; */
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u16 tid;
+
+	if ((pmlmeinfo->state & 0x03) != WIFI_FW_AP_STATE)
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+
+	psta = rtw_get_stainfo(pstapriv, addr);
+	if (psta == NULL)
+		return _SUCCESS;
+
+	/* DBG_8192D("%s:%s\n", __func__, (initiator==0)?"RX_DIR":"TX_DIR"); */
+
+	if (initiator == 0) {	/*  recipient */
+		for (tid = 0; tid < MAXTID; tid++) {
+			if (psta->recvreorder_ctrl[tid].enable == true) {
+				DBG_8192D("rx agg disable tid(%d)\n", tid);
+				issue_action_BA(adapt, addr,
+						RTW_WLAN_ACTION_DELBA,
+						(((tid << 1) | initiator) &
+						 0x1F));
+				psta->recvreorder_ctrl[tid].enable = false;
+				psta->recvreorder_ctrl[tid].indicate_seq =
+				    0xffff;
+#ifdef DBG_RX_SEQ
+				DBG_8192D("DBG_RX_SEQ %s:%d indicate_seq:%u\n",
+					  __func__, __LINE__,
+					  psta->recvreorder_ctrl[tid].
+					  indicate_seq);
+#endif
+			}
+		}
+	} else if (initiator == 1) {	/*  originator */
+		/* DBG_8192D("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap); */
+		for (tid = 0; tid < MAXTID; tid++) {
+			if (psta->htpriv.agg_enable_bitmap & BIT(tid)) {
+				DBG_8192D("tx agg disable tid(%d)\n", tid);
+				issue_action_BA(adapt, addr,
+						RTW_WLAN_ACTION_DELBA,
+						(((tid << 1) | initiator) &
+						 0x1F));
+				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+			}
+		}
+	}
+
+	return _SUCCESS;
+}
+
+unsigned int send_beacon(struct rtw_adapter *adapt)
+{
+	u8 bxmitok = false;
+	int issue = 0;
+	int poll = 0;
+
+	u32 start = rtw_get_current_time();
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_BCN_VALID, NULL);
+	do {
+		issue_beacon(adapt);
+		issue++;
+		do {
+			rtw_yield_os();
+			rtw_hal_get_hwreg(adapt, HW_VAR_BCN_VALID,
+					  (u8 *)(&bxmitok));
+			poll++;
+		} while ((poll % 10) != 0 && false == bxmitok &&
+			 !adapt->bSurpriseRemoved && !adapt->bDriverStopped);
+
+	} while (false == bxmitok && issue < 100 && !adapt->bSurpriseRemoved &&
+		 !adapt->bDriverStopped);
+
+	if (adapt->bSurpriseRemoved || adapt->bDriverStopped)
+		return _FAIL;
+	if (false == bxmitok) {
+		DBG_8192D("%s fail! %u ms\n", __func__,
+			  rtw_get_passing_time_ms(start));
+		return _FAIL;
+	} else {
+		u32 passing_time = rtw_get_passing_time_ms(start);
+
+		if (passing_time > 100 || issue > 3)
+			DBG_8192D("%s success, issue:%d, poll:%d, %u ms\n",
+				  __func__, issue, poll,
+				  rtw_get_passing_time_ms(start));
+		return _SUCCESS;
+	}
+}
+
+/****************************************************************************
+
+Following are some utitity fuctions for WiFi MLME
+
+*****************************************************************************/
+
+bool IsLegal5GChannel(struct rtw_adapter *adapter, u8 channel)
+{
+	int i = 0;
+	u8 Channel_5G[45] = { 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
+		60, 62, 64, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
+		    120, 122,
+		124, 126, 128, 130, 132, 134, 136, 138, 140, 149, 151, 153, 155,
+		    157, 159,
+		161, 163, 165
+	};
+	for (i = 0; i < sizeof(Channel_5G); i++)
+		if (channel == Channel_5G[i])
+			return true;
+	return false;
+}
+
+void site_survey(struct rtw_adapter *adapt)
+{
+	unsigned char survey_channel = 0, val8;
+	enum RT_SCAN_TYPE ScanType = SCAN_PASSIVE;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32 initialgain = 0;
+
+	{
+		struct rtw_ieee80211_channel *ch;
+		if (pmlmeext->sitesurvey_res.channel_idx <
+		    pmlmeext->sitesurvey_res.ch_num) {
+			ch = &pmlmeext->sitesurvey_res.ch[pmlmeext->
+							  sitesurvey_res.
+							  channel_idx];
+			survey_channel = ch->hw_value;
+			ScanType =
+			    (ch->
+			     flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ?
+			    SCAN_PASSIVE : SCAN_ACTIVE;
+		}
+	}
+
+	if (survey_channel != 0) {
+		/* PAUSE 4-AC Queue when site_survey */
+#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+		if ((adapt->pbuddy_adapter->mlmeextpriv.mlmext_info.
+		     state & 0x03) == WIFI_FW_AP_STATE) {
+			if (pmlmeinfo->scan_cnt == RTW_SCAN_NUM_OF_CH) {
+				pmlmeinfo->scan_cnt = 0;
+				survey_channel = pbuddy_mlmeext->cur_channel;
+				ScanType = SCAN_ACTIVE;
+				stay_buddy_ch = 1;
+			} else {
+				if (pmlmeinfo->scan_cnt == 0)
+					stay_buddy_ch = 2;
+				pmlmeinfo->scan_cnt++;
+			}
+		}
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+#endif /* CONFIG_CONCURRENT_MODE */
+		if (pmlmeext->sitesurvey_res.channel_idx == 0) {
+			set_channel_bwmode(adapt, survey_channel,
+					   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
+					   HT_CHANNEL_WIDTH_20);
+		} else {
+			SelectChannel(adapt, survey_channel);
+		}
+
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+		if (stay_buddy_ch == 1) {
+			val8 = 0;	/* survey done */
+			rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
+					  (u8 *)(&val8));
+
+			if (check_buddy_mlmeinfo_state(adapt, WIFI_FW_AP_STATE) &&
+			    check_buddy_fwstate(adapt, _FW_LINKED)) {
+				update_beacon(adapt->pbuddy_adapter, 0, NULL,
+					      true);
+			}
+		} else if (stay_buddy_ch == 2) {
+			val8 = 1;	/* under site survey */
+			rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
+					  (u8 *)(&val8));
+		}
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+
+		if (ScanType == SCAN_ACTIVE) {	/* obey the channel plan setting... */
+			{
+				int i;
+				for (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {
+					if (pmlmeext->sitesurvey_res.ssid[i].
+					    SsidLength) {
+						/* todo: to issue two probe req??? */
+						issue_probereq(adapt,
+							       &(pmlmeext->
+								 sitesurvey_res.
+								 ssid[i]),
+							       NULL);
+						/* rtw_msleep_os(SURVEY_TO>>1); */
+						issue_probereq(adapt,
+							       &(pmlmeext->
+								 sitesurvey_res.
+								 ssid[i]),
+							       NULL);
+					} else {
+						break;
+					}
+				}
+
+				if (pmlmeext->sitesurvey_res.scan_mode ==
+				    SCAN_ACTIVE) {
+					/* todo: to issue two probe req??? */
+					issue_probereq(adapt, NULL, NULL);
+					/* rtw_msleep_os(SURVEY_TO>>1); */
+					issue_probereq(adapt, NULL, NULL);
+				}
+			}
+		}
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+		if (stay_buddy_ch == 1)
+			set_survey_timer(pmlmeext,
+					 pmlmeext->chan_scan_time *
+					 RTW_STAY_AP_CH_MILLISECOND);
+		else
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+
+	} else {
+		/*      channel number is 0 or this channel is not valid. */
+
+#ifdef CONFIG_CONCURRENT_MODE
+		u8 cur_channel;
+		u8 cur_bwmode;
+		u8 cur_ch_offset;
+
+		if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+			cur_channel = pmlmeext->cur_channel;
+			cur_bwmode = pmlmeext->cur_bwmode;
+			cur_ch_offset = pmlmeext->cur_ch_offset;
+		}
+		/* else if ((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) */
+		else if (check_buddy_fwstate(adapt, _FW_LINKED)) {	/*  for AP or STA */
+			cur_channel = pbuddy_mlmeext->cur_channel;
+			cur_bwmode = pbuddy_mlmeext->cur_bwmode;
+			cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
+		} else {
+			cur_channel = pmlmeext->cur_channel;
+			cur_bwmode = pmlmeext->cur_bwmode;
+			cur_ch_offset = pmlmeext->cur_ch_offset;
+		}
+#endif
+
+		{
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+			pmlmeinfo->scan_cnt = 0;
+#endif /* CONFIG_DMP_STA_NODE_SCAN_UNDER_AP_MODE */
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+			/*  20100721:Interrupt scan operation here. */
+			/*  For SW antenna diversity before link, it needs to switch to another antenna and scan again. */
+			/*  It compares the scan result and select beter one to do connection. */
+			if (rtw_hal_antdiv_before_linked(adapt)) {
+				pmlmeext->sitesurvey_res.bss_cnt = 0;
+				pmlmeext->sitesurvey_res.channel_idx = -1;
+				pmlmeext->chan_scan_time = SURVEY_TO / 2;
+				set_survey_timer(pmlmeext,
+						 pmlmeext->chan_scan_time);
+				return;
+			}
+#endif
+			pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
+
+			/* switch back to the original channel */
+			/* SelectChannel(adapt, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); */
+
+			{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+				dc_set_channel_bwmode_survey_done(adapt);
+#else
+#ifdef CONFIG_CONCURRENT_MODE
+					set_channel_bwmode(adapt,
+							   cur_channel,
+							   cur_ch_offset,
+							   cur_bwmode);
+#else
+					set_channel_bwmode(adapt,
+							   pmlmeext->
+							   cur_channel,
+							   pmlmeext->
+							   cur_ch_offset,
+							   pmlmeext->
+							   cur_bwmode);
+#endif
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+			}
+
+			/* flush 4-AC Queue after site_survey */
+			/* val8 = 0; */
+			/* rtw_hal_set_hwreg(adapt, HW_VAR_TXPAUSE, (u8 *)(&val8)); */
+
+			val8 = 0;	/* survey done */
+			rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
+					  (u8 *)(&val8));
+
+			/* config MSR */
+			Set_MSR(adapt, (pmlmeinfo->state & 0x3));
+
+			initialgain = 0xff;	/* restore RX GAIN */
+			rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
+					  (u8 *)(&initialgain));
+			/* turn on dynamic functions */
+			Restore_DM_Func_Flag(adapt);
+			/* Switch_DM_Func(adapt, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
+
+			if (is_client_associated_to_ap(adapt) == true) {
+				issue_nulldata(adapt, NULL, 0, 3, 500);
+
+#ifdef CONFIG_CONCURRENT_MODE
+				if (is_client_associated_to_ap
+				    (adapt->pbuddy_adapter) == true) {
+					DBG_8192D
+					    ("adapter is surveydone(buddy_adapter is linked), issue nulldata(pwrbit=0)\n");
+
+					issue_nulldata(adapt->pbuddy_adapter,
+						       NULL, 0, 3, 500);
+				}
+#endif
+			}
+#ifdef CONFIG_CONCURRENT_MODE
+			else if (is_client_associated_to_ap
+				 (adapt->pbuddy_adapter) == true) {
+				issue_nulldata(adapt->pbuddy_adapter, NULL,
+					       0, 3, 500);
+			}
+#endif
+
+			report_surveydone_event(adapt);
+
+			pmlmeext->chan_scan_time = SURVEY_TO;
+			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
+
+			issue_action_BSSCoexistPacket(adapt);
+			issue_action_BSSCoexistPacket(adapt);
+			issue_action_BSSCoexistPacket(adapt);
+		}
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (check_buddy_mlmeinfo_state(adapt, WIFI_FW_AP_STATE) &&
+		    check_buddy_fwstate(adapt, _FW_LINKED)) {
+			DBG_8192D
+			    ("survey done, current CH=%d, BW=%d, offset=%d\n",
+			     cur_channel, cur_bwmode, cur_ch_offset);
+			DBG_8192D("restart pbuddy_adapter's beacon\n");
+			update_beacon(adapt->pbuddy_adapter, 0, NULL, true);
+		}
+#endif
+	}
+
+	return;
+}
+
+/* collect bss info from Beacon and Probe response frames. */
+u8 collect_bss_info(struct rtw_adapter *adapt,
+		    struct recv_frame_hdr *precv_frame,
+		    struct wlan_bssid_ex *bssid)
+{
+	int i;
+	u32 len;
+	u8 *p;
+	u16 val16, subtype;
+	u8 *pframe = precv_frame->rx_data;
+	u32 packet_len = precv_frame->len;
+	struct registry_priv *pregistrypriv = &adapt->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	__le32 le32_tmp;
+
+	len = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (len > MAX_IE_SZ) {
+		/* DBG_8192D("IE too long for survey event\n"); */
+		return _FAIL;
+	}
+
+	memset(bssid, 0, sizeof(struct wlan_bssid_ex));
+
+	subtype = GetFrameSubType(pframe);
+
+	if (subtype == WIFI_BEACON)
+		bssid->Reserved[0] = 1;
+	else
+		bssid->Reserved[0] = 0;
+
+	bssid->Length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;
+
+	/* below is to copy the information element */
+	bssid->IELength = len;
+	memcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)),
+	       bssid->IELength);
+
+	/* get the signal strength */
+	bssid->PhyInfo.SignalQuality = precv_frame->attrib.signal_qual;	/* in percentage */
+	bssid->PhyInfo.SignalStrength = precv_frame->attrib.signal_strength;	/* in percentage */
+	bssid->Rssi = precv_frame->attrib.recvsignalpower;	/*  in dBM.raw data */
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	/* rtw_hal_get_hwreg(adapt, HW_VAR_CURRENT_ANTENNA, (u8 *)(&bssid->PhyInfo.Optimum_antenna)); */
+	rtw_hal_get_def_var(adapt, HAL_DEF_CURRENT_ANTENNA,
+			    &bssid->PhyInfo.Optimum_antenna);
+#endif
+
+	/*  checking SSID */
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p == NULL) {
+		DBG_8192D("marc: cannot find SSID for survey event\n");
+		return _FAIL;
+	}
+
+	if (*(p + 1)) {
+		if (len > NDIS_802_11_LENGTH_SSID) {
+			DBG_8192D
+			    ("%s()-%d: IE too long (%d) for survey event\n",
+			     __func__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));
+		bssid->Ssid.SsidLength = *(p + 1);
+	} else {
+		bssid->Ssid.SsidLength = 0;
+	}
+
+	memset(bssid->SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	/* checking rate info... */
+	i = 0;
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SUPPORTEDRATES_IE_,
+		       &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL) {
+		if (len > NDIS_802_11_LENGTH_RATES_EX) {
+			DBG_8192D
+			    ("%s()-%d: IE too long (%d) for survey event\n",
+			     __func__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->SupportedRates, (p + 2), len);
+		i = len;
+	}
+
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _EXT_SUPPORTEDRATES_IE_,
+		       &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL) {
+		if (len > (NDIS_802_11_LENGTH_RATES_EX - i)) {
+			DBG_8192D
+			    ("%s()-%d: IE too long (%d) for survey event\n",
+			     __func__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->SupportedRates + i, (p + 2), len);
+	}
+
+	/* todo: */
+	bssid->NetworkTypeInUse = NDIS802_11OFDM24;
+
+	if (bssid->IELength < 12)
+		return _FAIL;
+
+	/*  Checking for DSConfig */
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len,
+		       bssid->IELength - _FIXED_IE_LENGTH_);
+
+	bssid->Configuration.DSConfig = 0;
+	bssid->Configuration.Length = 0;
+
+	if (p) {
+		bssid->Configuration.DSConfig = *(p + 2);
+	} else {		/*  In 5G, some ap do not have DSSET IE */
+		/*  checking HT info for channel */
+		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_,
+			       &len, bssid->IELength - _FIXED_IE_LENGTH_);
+		if (p) {
+			struct HT_info_element *HT_info =
+			    (struct HT_info_element *)(p + 2);
+			bssid->Configuration.DSConfig =
+			    HT_info->primary_channel;
+		} else {	/*  use current channel */
+			bssid->Configuration.DSConfig =
+			    rtw_get_oper_ch(adapt);
+		}
+	}
+
+	memcpy(&le32_tmp, rtw_get_beacon_interval_from_ie(bssid->IEs), 2);
+	bssid->Configuration.BeaconPeriod = le32_to_cpu(le32_tmp);
+
+	val16 = rtw_get_capability((struct wlan_bssid_ex *)bssid);
+
+	if (val16 & BIT(0)) {
+		bssid->InfrastructureMode = NDIS802_11INFRA;
+		memcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);
+	} else {
+		bssid->InfrastructureMode = NDIS802_11IBSS;
+		memcpy(bssid->MacAddress, GetAddr3Ptr(pframe), ETH_ALEN);
+	}
+
+	if (val16 & BIT(4))
+		bssid->Privacy = 1;
+	else
+		bssid->Privacy = 0;
+
+	bssid->Configuration.ATIMWindow = 0;
+
+	/* 20/40 BSS Coexistence check */
+	if ((pregistrypriv->wifi_spec == 1) &&
+	    (false == pmlmeinfo->bwmode_updated)) {
+		struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+
+		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_,
+			       _HT_CAPABILITY_IE_, &len,
+			       bssid->IELength - _FIXED_IE_LENGTH_);
+		if (p && len > 0) {
+			struct HT_caps_element *pHT_caps;
+			pHT_caps = (struct HT_caps_element *)(p + 2);
+
+			if (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & BIT(14))
+				pmlmepriv->num_FortyMHzIntolerant++;
+		} else {
+			pmlmepriv->num_sta_no_ht++;
+		}
+	}
+
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) & 1
+	if (strcmp(bssid->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
+		DBG_8192D
+		    ("Receiving %s(%pM, DSConfig:%u) from ch%u with ss:%3u, sq:%3u, RawRSSI:%3ld\n",
+		     bssid->Ssid.Ssid, bssid->MacAddress,
+		     bssid->Configuration.DSConfig, rtw_get_oper_ch(adapt)
+		     , bssid->PhyInfo.SignalStrength,
+		     bssid->PhyInfo.SignalQuality, bssid->Rssi);
+	}
+#endif
+
+	/*  mark bss info receving from nearby channel as SignalQuality 101 */
+	if (bssid->Configuration.DSConfig != rtw_get_oper_ch(adapt)) {
+		bssid->PhyInfo.SignalQuality = 101;
+	}
+
+	return _SUCCESS;
+}
+
+void start_create_ibss(struct rtw_adapter *adapt)
+{
+	unsigned short caps;
+	u8 val8;
+	u8 join_type;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+	pmlmeext->cur_channel = (u8) pnetwork->Configuration.DSConfig;
+	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
+
+	/* update wireless mode */
+	update_wireless_mode(adapt);
+
+	/* udpate capability */
+	caps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);
+	update_capinfo(adapt, caps);
+	if (caps & cap_IBSS) {	/* adhoc master */
+		val8 = 0xcf;
+		rtw_hal_set_hwreg(adapt, HW_VAR_SEC_CFG, (u8 *)(&val8));
+
+		/* switch channel */
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
+				   HT_CHANNEL_WIDTH_20);
+
+		beacon_timing_control(adapt);
+
+		/* set msr to WIFI_FW_ADHOC_STATE */
+		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+		Set_MSR(adapt, (pmlmeinfo->state & 0x3));
+
+		/* issue beacon */
+		if (send_beacon(adapt) == _FAIL) {
+			RT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,
+				 ("issuing beacon frame fail....\n"));
+
+			report_join_res(adapt, -1);
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		} else {
+			rtw_hal_set_hwreg(adapt, HW_VAR_BSSID,
+					  adapt->registrypriv.dev_network.
+					  MacAddress);
+			join_type = 0;
+			rtw_hal_set_hwreg(adapt, HW_VAR_MLME_JOIN,
+					  (u8 *)(&join_type));
+
+			report_join_res(adapt, 1);
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+		}
+	} else {
+		DBG_8192D("start_create_ibss, invalid cap:%x\n", caps);
+		return;
+	}
+}
+
+void start_clnt_join(struct rtw_adapter *adapt)
+{
+	unsigned short caps;
+	u8 val8;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	u8 dc_join_status;
+#endif
+
+	pmlmeext->cur_channel = (u8) pnetwork->Configuration.DSConfig;
+	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
+
+	/* update wireless mode */
+	update_wireless_mode(adapt);
+
+	/* udpate capability */
+	caps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);
+	update_capinfo(adapt, caps);
+	if (caps & cap_ESS) {
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		dc_join_status = dc_handle_join_request(adapt);
+		if (dc_join_status == _FAIL) {
+			DBG_8192D("dc_handle_join_request for STA fail !!!\n");
+			return;
+		}
+#endif
+#ifdef CONFIG_CONCURRENT_MODE
+		if (concurrent_chk_start_clnt_join(adapt) == _FAIL)
+			return;
+#endif
+
+		Set_MSR(adapt, WIFI_FW_STATION_STATE);
+
+		val8 =
+		    (pmlmeinfo->auth_algo ==
+		     dot11AuthAlgrthm_8021X) ? 0xcc : 0xcf;
+		rtw_hal_set_hwreg(adapt, HW_VAR_SEC_CFG, (u8 *)(&val8));
+
+		/* switch channel */
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   pmlmeext->cur_ch_offset,
+				   pmlmeext->cur_bwmode);
+
+		/* here wait for receiving the beacon to start auth */
+		/* and enable a timer */
+		set_link_timer(pmlmeext,
+			       decide_wait_for_beacon_timeout(pmlmeinfo->
+							      bcn_interval));
+
+		pmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;
+	} else if (caps & cap_IBSS) {	/* adhoc client */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		dc_join_status = dc_handle_join_request(adapt);
+		if (dc_join_status == _FAIL) {
+			DBG_8192D
+			    ("dc_handle_join_request for Ad-hoc fail !!!\n");
+			return;
+		}
+#endif
+
+		Set_MSR(adapt, WIFI_FW_ADHOC_STATE);
+
+		val8 = 0xcf;
+		rtw_hal_set_hwreg(adapt, HW_VAR_SEC_CFG, (u8 *)(&val8));
+
+		/* switch channel */
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   pmlmeext->cur_ch_offset,
+				   pmlmeext->cur_bwmode);
+
+		beacon_timing_control(adapt);
+
+		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+
+		report_join_res(adapt, 1);
+	} else {
+		/* DBG_8192D("marc: invalid cap:%x\n", caps); */
+		return;
+	}
+}
+
+void start_clnt_auth(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~WIFI_FW_AUTH_NULL);
+	pmlmeinfo->state |= WIFI_FW_AUTH_STATE;
+
+	pmlmeinfo->auth_seq = 1;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+	pmlmeext->retry = 0;
+
+	/*  Because of AP's not receiving deauth before */
+	/*  AP may: 1)not response auth or 2)deauth us after link is complete */
+	/*  issue deauth before issuing auth to deal with the situation */
+	/*      Commented by Albert 2012/07/21 */
+	/*      For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it. */
+	issue_deauth(adapt, (&(pmlmeinfo->network))->MacAddress,
+		     WLAN_REASON_DEAUTH_LEAVING);
+
+	issue_auth(adapt, NULL, 0);
+
+	set_link_timer(pmlmeext, REAUTH_TO);
+}
+
+void start_clnt_assoc(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE));
+	pmlmeinfo->state |= (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE);
+
+	issue_assocreq(adapt);
+
+	set_link_timer(pmlmeext, REASSOC_TO);
+}
+
+unsigned int receive_disconnect(struct rtw_adapter *adapt,
+				unsigned char *MacAddr, unsigned short reason)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* check A3 */
+	if (!
+	    (_rtw_memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+
+	DBG_8192D("%s\n", __func__);
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_del_sta_event(adapt, MacAddr, reason);
+
+		} else if (pmlmeinfo->state & WIFI_FW_LINKING_STATE) {
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_join_res(adapt, -2);
+		}
+	}
+
+	return _SUCCESS;
+}
+
+#ifdef CONFIG_80211D
+static void process_80211d(struct rtw_adapter *adapt,
+			   struct wlan_bssid_ex *bssid)
+{
+	struct registry_priv *pregistrypriv;
+	struct mlme_ext_priv *pmlmeext;
+	struct rt_channel_info *chplan_new;
+	u8 channel;
+	u8 i;
+
+	pregistrypriv = &adapt->registrypriv;
+	pmlmeext = &adapt->mlmeextpriv;
+
+	/*  Adjust channel plan by AP Country IE */
+	if (pregistrypriv->enable80211d &&
+	    (!pmlmeext->update_channel_plan_by_ap_done)) {
+		u8 *ie, *p;
+		u32 len;
+		struct rt_channel_plan chplan_ap;
+		struct rt_channel_info chplan_sta[MAX_CHANNEL_NUM];
+		u8 country[4];
+		u8 fcn;		/*  first channel number */
+		u8 noc;		/*  number of channel */
+		u8 j, k;
+
+		ie = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _COUNTRY_IE_,
+				&len, bssid->IELength - _FIXED_IE_LENGTH_);
+		if (!ie)
+			return;
+		if (len < 6)
+			return;
+
+		ie += 2;
+		p = ie;
+		ie += len;
+
+		memset(country, 0, 4);
+		memcpy(country, p, 3);
+		p += 3;
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+			 ("%s: 802.11d country=%s\n", __func__, country));
+
+		i = 0;
+		while ((ie - p) >= 3) {
+			fcn = *(p++);
+			noc = *(p++);
+			p++;
+
+			for (j = 0; j < noc; j++) {
+				if (fcn <= 14)
+					channel = fcn + j;	/*  2.4 GHz */
+				else
+					channel = fcn + j * 4;	/*  5 GHz */
+
+				chplan_ap.Channel[i++] = channel;
+			}
+		}
+		chplan_ap.Len = i;
+
+		i = 0;
+		DBG_8192D("%s: AP[%s] channel plan {", __func__,
+			  bssid->Ssid.Ssid);
+		while ((i < chplan_ap.Len) && (chplan_ap.Channel[i] != 0)) {
+			DBG_8192D("%02d,", chplan_ap.Channel[i]);
+			i++;
+		}
+		DBG_8192D("}\n");
+
+		memcpy(chplan_sta, pmlmeext->channel_set, sizeof(chplan_sta));
+		i = 0;
+		DBG_8192D("%s: STA channel plan {", __func__);
+		while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0)) {
+			DBG_8192D("%02d(%c),", chplan_sta[i].ChannelNum,
+			       chplan_sta[i].ScanType ==
+			       SCAN_PASSIVE ? 'p' : 'a');
+			i++;
+		}
+		DBG_8192D("}\n");
+
+		memset(pmlmeext->channel_set, 0, sizeof(pmlmeext->channel_set));
+		chplan_new = pmlmeext->channel_set;
+
+		i = 0;
+		j = 0;
+		k = 0;
+		if (pregistrypriv->wireless_mode & WIRELESS_11G) {
+			do {
+				if ((i == MAX_CHANNEL_NUM) ||
+				    (chplan_sta[i].ChannelNum == 0) ||
+				    (chplan_sta[i].ChannelNum > 14))
+					break;
+
+				if ((j == chplan_ap.Len) || (chplan_ap.Channel[j] > 14))
+					break;
+
+				if (chplan_sta[i].ChannelNum ==
+				    chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_ap.Channel[j];
+					chplan_new[k].ScanType = SCAN_ACTIVE;
+					i++;
+					j++;
+					k++;
+				} else if (chplan_sta[i].ChannelNum <
+					   chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_sta[i].ChannelNum;
+/*					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+					chplan_new[k].ScanType = SCAN_PASSIVE;
+					i++;
+					k++;
+				} else if (chplan_sta[i].ChannelNum >
+					   chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_ap.Channel[j];
+					chplan_new[k].ScanType = SCAN_ACTIVE;
+					j++;
+					k++;
+				}
+			} while (1);
+
+			/*  change AP not support channel to Passive scan */
+			while ((i < MAX_CHANNEL_NUM) &&
+			       (chplan_sta[i].ChannelNum != 0) &&
+			       (chplan_sta[i].ChannelNum <= 14)) {
+				chplan_new[k].ChannelNum =
+				    chplan_sta[i].ChannelNum;
+/*				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+				chplan_new[k].ScanType = SCAN_PASSIVE;
+				i++;
+				k++;
+			}
+
+			/*  add channel AP supported */
+			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14)) {
+				chplan_new[k].ChannelNum = chplan_ap.Channel[j];
+				chplan_new[k].ScanType = SCAN_ACTIVE;
+				j++;
+				k++;
+			}
+		} else {
+			/*  keep original STA 2.4G channel plan */
+			while ((i < MAX_CHANNEL_NUM) &&
+			       (chplan_sta[i].ChannelNum != 0) &&
+			       (chplan_sta[i].ChannelNum <= 14)) {
+				chplan_new[k].ChannelNum =
+				    chplan_sta[i].ChannelNum;
+				chplan_new[k].ScanType = chplan_sta[i].ScanType;
+				i++;
+				k++;
+			}
+
+			/*  skip AP 2.4G channel plan */
+			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14))
+				j++;
+		}
+
+		if (pregistrypriv->wireless_mode & WIRELESS_11A) {
+			do {
+				if ((i == MAX_CHANNEL_NUM) ||
+				    (chplan_sta[i].ChannelNum == 0))
+					break;
+
+				if ((j == chplan_ap.Len) || (chplan_ap.Channel[j] == 0))
+					break;
+
+				if (chplan_sta[i].ChannelNum ==
+				    chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_ap.Channel[j];
+					chplan_new[k].ScanType = SCAN_ACTIVE;
+					i++;
+					j++;
+					k++;
+				} else if (chplan_sta[i].ChannelNum <
+					   chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_sta[i].ChannelNum;
+/*					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+					chplan_new[k].ScanType = SCAN_PASSIVE;
+					i++;
+					k++;
+				} else if (chplan_sta[i].ChannelNum >
+					   chplan_ap.Channel[j]) {
+					chplan_new[k].ChannelNum =
+					    chplan_ap.Channel[j];
+					chplan_new[k].ScanType = SCAN_ACTIVE;
+					j++;
+					k++;
+				}
+			} while (1);
+
+			/*  change AP not support channel to Passive scan */
+			while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0)) {
+				chplan_new[k].ChannelNum =
+				    chplan_sta[i].ChannelNum;
+/*				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
+				chplan_new[k].ScanType = SCAN_PASSIVE;
+				i++;
+				k++;
+			}
+
+			/*  add channel AP supported */
+			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] != 0)) {
+				chplan_new[k].ChannelNum = chplan_ap.Channel[j];
+				chplan_new[k].ScanType = SCAN_ACTIVE;
+				j++;
+				k++;
+			}
+		} else {
+			/*  keep original STA 5G channel plan */
+			while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0)) {
+				chplan_new[k].ChannelNum =
+				    chplan_sta[i].ChannelNum;
+				chplan_new[k].ScanType = chplan_sta[i].ScanType;
+				i++;
+				k++;
+			}
+		}
+
+		pmlmeext->update_channel_plan_by_ap_done = 1;
+
+		k = 0;
+		DBG_8192D("%s: new STA channel plan {", __func__);
+		while ((k < MAX_CHANNEL_NUM) && (chplan_new[k].ChannelNum != 0)) {
+			DBG_8192D("%02d(%c),", chplan_new[k].ChannelNum,
+			        chplan_new[k].ScanType ==
+			        SCAN_PASSIVE ? 'p' : 'c');
+			k++;
+		}
+		DBG_8192D("}\n");
+	}
+
+	/*  If channel is used by AP, set channel scan type to active */
+	channel = bssid->Configuration.DSConfig;
+	chplan_new = pmlmeext->channel_set;
+	i = 0;
+	while ((i < MAX_CHANNEL_NUM) && (chplan_new[i].ChannelNum != 0)) {
+		if (chplan_new[i].ChannelNum == channel) {
+			if (chplan_new[i].ScanType == SCAN_PASSIVE) {
+				/* 5G Bnad 2, 3 (DFS) doesn't change to active scan */
+				if (channel >= 52 && channel <= 144)
+					break;
+
+				chplan_new[i].ScanType = SCAN_ACTIVE;
+				RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,
+					 ("%s: change channel %d scan type from passive to active\n",
+					  __func__, channel));
+			}
+			break;
+		}
+		i++;
+	}
+}
+#endif
+
+/****************************************************************************
+
+Following are the functions to report events
+
+*****************************************************************************/
+
+void report_survey_event(struct rtw_adapter *adapt,
+			 struct recv_frame_hdr *precv_frame)
+{
+	struct cmd_obj *pcmd_obj;
+	u8 *pevtcmd;
+	u32 cmdsz;
+	struct survey_event *psurvey_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext;
+	struct cmd_priv *pcmdpriv;
+	/* u8 *pframe = precv_frame->rx_data; */
+	/* uint len = precv_frame->len; */
+
+	if (!adapt)
+		return;
+
+	pmlmeext = &adapt->mlmeextpriv;
+	pcmdpriv = &adapt->cmdpriv;
+
+	pcmd_obj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd_obj == NULL)
+		return;
+
+	cmdsz = (sizeof(struct survey_event) + sizeof(struct C2HEvent_Header));
+	pevtcmd = (u8 *)kzalloc(cmdsz, GFP_ATOMIC);
+	if (pevtcmd == NULL) {
+		kfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_SET_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct survey_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_SURVEY);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	psurvey_evt =
+	    (struct survey_event *)(pevtcmd + sizeof(struct C2HEvent_Header));
+
+	if (collect_bss_info
+	    (adapt, precv_frame,
+	     (struct wlan_bssid_ex *)&psurvey_evt->bss) == _FAIL) {
+		kfree(pcmd_obj);
+		kfree(pevtcmd);
+		return;
+	}
+#ifdef CONFIG_80211D
+	process_80211d(adapt, &psurvey_evt->bss);
+#endif
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	pmlmeext->sitesurvey_res.bss_cnt++;
+
+	return;
+}
+
+void report_surveydone_event(struct rtw_adapter *adapt)
+{
+	struct cmd_obj *pcmd_obj;
+	u8 *pevtcmd;
+	u32 cmdsz;
+	struct surveydone_event *psurveydone_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
+
+	pcmd_obj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd_obj == NULL)
+		return;
+
+	cmdsz =
+	    (sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header));
+	pevtcmd = (u8 *)kzalloc(cmdsz, GFP_ATOMIC);
+	if (pevtcmd == NULL) {
+		kfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_SET_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct surveydone_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_SURVEYDONE);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	psurveydone_evt =
+	    (struct surveydone_event *)(pevtcmd +
+					sizeof(struct C2HEvent_Header));
+	psurveydone_evt->bss_cnt = pmlmeext->sitesurvey_res.bss_cnt;
+
+	DBG_8192D("survey done event(%x)\n", psurveydone_evt->bss_cnt);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+void report_join_res(struct rtw_adapter *adapt, int res)
+{
+	struct cmd_obj *pcmd_obj;
+	u8 *pevtcmd;
+	u32 cmdsz;
+	struct joinbss_event *pjoinbss_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
+
+	pcmd_obj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd_obj == NULL)
+		return;
+
+	cmdsz = (sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header));
+	pevtcmd = (u8 *)kzalloc(cmdsz, GFP_ATOMIC);
+	if (pevtcmd == NULL) {
+		kfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_SET_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct joinbss_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_JOINBSS);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	pjoinbss_evt =
+	    (struct joinbss_event *)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(pjoinbss_evt->network.network)),
+	       &(pmlmeinfo->network), sizeof(struct wlan_bssid_ex));
+	pjoinbss_evt->network.join_res = res;
+	pjoinbss_evt->network.aid = res;
+
+	DBG_8192D("report_join_res(%d)\n", res);
+
+	rtw_joinbss_event_prehandle(adapt, (u8 *)&pjoinbss_evt->network);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+void report_del_sta_event(struct rtw_adapter *adapt, unsigned char *MacAddr,
+			  unsigned short reason)
+{
+	struct cmd_obj *pcmd_obj;
+	u8 *pevtcmd;
+	u32 cmdsz;
+	struct sta_info *psta;
+	int mac_id;
+	struct stadel_event *pdel_sta_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
+
+	pcmd_obj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd_obj == NULL)
+		return;
+
+	cmdsz = (sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header));
+	pevtcmd = (u8 *)kzalloc(cmdsz, GFP_ATOMIC);
+	if (pevtcmd == NULL) {
+		kfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_SET_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stadel_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_DELSTA);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	pdel_sta_evt =
+	    (struct stadel_event *)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(pdel_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+	memcpy((unsigned char *)(pdel_sta_evt->rsvd),
+	       (unsigned char *)(&reason), 2);
+
+	psta = rtw_get_stainfo(&adapt->stapriv, MacAddr);
+	if (psta)
+		mac_id = (int)psta->mac_id;
+	else
+		mac_id = (-1);
+
+	pdel_sta_evt->mac_id = mac_id;
+
+	DBG_8192D("report_del_sta_event: delete STA, mac_id=%d\n", mac_id);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+void report_add_sta_event(struct rtw_adapter *adapt, unsigned char *MacAddr,
+			  int cam_idx)
+{
+	struct cmd_obj *pcmd_obj;
+	u8 *pevtcmd;
+	u32 cmdsz;
+	struct stassoc_event *padd_sta_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
+
+	pcmd_obj = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (pcmd_obj == NULL)
+		return;
+
+	cmdsz = (sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header));
+	pevtcmd = (u8 *)kzalloc(cmdsz, GFP_ATOMIC);
+	if (pevtcmd == NULL) {
+		kfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_SET_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header *)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stassoc_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_ADDSTA);
+	pc2h_evt_hdr->seq = ATOMIC_INC_RETURN(&pmlmeext->event_seq);
+
+	padd_sta_evt =
+	    (struct stassoc_event *)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(padd_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+	padd_sta_evt->cam_id = cam_idx;
+
+	DBG_8192D("report_add_sta_event: add STA\n");
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+/****************************************************************************
+
+Following are the event callback functions
+
+*****************************************************************************/
+
+/* for sta/adhoc mode */
+void update_sta_info(struct rtw_adapter *adapt, struct sta_info *psta)
+{
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* ERP */
+	VCS_update(adapt, psta);
+
+	/* HT */
+	if (pmlmepriv->htpriv.ht_option) {
+		psta->htpriv.ht_option = true;
+
+		psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
+
+		if (support_short_GI(adapt, &(pmlmeinfo->HT_caps)))
+			psta->htpriv.sgi = true;
+
+		psta->qos_option = true;
+
+	} else {
+		psta->htpriv.ht_option = false;
+
+		psta->htpriv.ampdu_enable = false;
+
+		psta->htpriv.sgi = false;
+
+		psta->qos_option = false;
+	}
+
+	psta->htpriv.bwmode = pmlmeext->cur_bwmode;
+	psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
+
+	psta->htpriv.agg_enable_bitmap = 0x0;	/* reset */
+	psta->htpriv.candidate_tid_bitmap = 0x0;	/* reset */
+
+	/* QoS */
+	if (pmlmepriv->qospriv.qos_option)
+		psta->qos_option = true;
+
+	psta->state = _FW_LINKED;
+}
+
+void mlmeext_joinbss_event_callback(struct rtw_adapter *adapt, int join_res)
+{
+	struct sta_info *psta, *psta_bmc;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);
+	struct sta_priv *pstapriv = &adapt->stapriv;
+	u8 join_type;
+
+	if (join_res < 0) {
+		join_type = 1;
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_JOIN,
+				  (u8 *)(&join_type));
+		rtw_hal_set_hwreg(adapt, HW_VAR_BSSID, null_addr);
+
+		/* restore to initial setting. */
+		update_tx_basic_rate(adapt,
+				     adapt->registrypriv.wireless_mode);
+		goto exit_mlmeext_joinbss_event_callback;
+	}
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) {
+		/* for bc/mc */
+		psta_bmc = rtw_get_bcmc_stainfo(adapt);
+		if (psta_bmc) {
+			pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta =
+			    psta_bmc;
+			update_bmc_sta_support_rate(adapt, psta_bmc->mac_id);
+			Update_RA_Entry(adapt, psta_bmc->mac_id);
+		}
+	}
+
+	/* turn on dynamic functions */
+	Switch_DM_Func(adapt,
+		       DYNAMIC_FUNC_DIG | DYNAMIC_FUNC_HP | DYNAMIC_FUNC_SS,
+		       true);
+
+	/*  update IOT-releated issue */
+	update_IOT_info(adapt);
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_BASIC_RATE,
+			  cur_network->SupportedRates);
+
+	/* BCN interval */
+	rtw_hal_set_hwreg(adapt, HW_VAR_BEACON_INTERVAL,
+			  (u8 *)(&pmlmeinfo->bcn_interval));
+
+	/* udpate capability */
+	update_capinfo(adapt, pmlmeinfo->capability);
+
+	/* WMM, Update EDCA param */
+	WMMOnAssocRsp(adapt);
+
+	/* HT */
+	HTOnAssocRsp(adapt);
+
+#ifndef CONFIG_CONCURRENT_MODE
+	/*      Call set_channel_bwmode when the CONFIG_CONCURRENT_MODE doesn't be defined. */
+	/* Set cur_channel&cur_bwmode&cur_ch_offset */
+	set_channel_bwmode(adapt, pmlmeext->cur_channel,
+			   pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+#endif
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+	if (psta) {		/* only for infra. mode */
+		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+		/* DBG_8192D("set_sta_rate\n"); */
+
+		/* set per sta rate after updating HT cap. */
+		set_sta_rate(adapt, psta);
+	}
+
+	join_type = 2;
+	rtw_hal_set_hwreg(adapt, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		/*  correcting TSF */
+		correct_TSF(adapt, pmlmeext);
+
+		/* set_link_timer(pmlmeext, DISCONNECT_TO); */
+	}
+#ifdef CONFIG_LPS
+	rtw_lps_ctrl_wk_cmd(adapt, LPS_CTRL_CONNECT, 0);
+#endif
+
+exit_mlmeext_joinbss_event_callback:
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	dc_handle_join_done(adapt, join_res);
+#endif
+#ifdef CONFIG_CONCURRENT_MODE
+	concurrent_chk_joinbss_done(adapt, join_res);
+#endif
+
+	DBG_8192D("=>%s\n", __func__);
+}
+
+void mlmeext_sta_add_event_callback(struct rtw_adapter *adapt,
+				    struct sta_info *psta)
+{
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 join_type;
+
+	DBG_8192D("%s\n", __func__);
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) {
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {	/* adhoc master or sta_count>1 */
+			/* nothing to do */
+		} else {	/* adhoc client */
+
+			/* update TSF Value */
+			/* update_TSF(pmlmeext, pframe, len); */
+
+			/*  correcting TSF */
+			correct_TSF(adapt, pmlmeext);
+
+			/* start beacon */
+			if (send_beacon(adapt) == _FAIL) {
+				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
+				pmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;
+				return;
+			}
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+		}
+
+		join_type = 2;
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_JOIN,
+				  (u8 *)(&join_type));
+	}
+
+	pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+	/* rate radaptive */
+	Update_RA_Entry(adapt, psta->mac_id);
+
+	/* update adhoc sta_info */
+	update_sta_info(adapt, psta);
+}
+
+void mlmeext_sta_del_event_callback(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (is_client_associated_to_ap(adapt) || is_IBSS_empty(adapt)) {
+		/* set_opmode_cmd(adapt, infra_client_with_mlme); */
+
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
+		rtw_hal_set_hwreg(adapt, HW_VAR_BSSID, null_addr);
+
+		/* restore to initial setting. */
+		update_tx_basic_rate(adapt,
+				     adapt->registrypriv.wireless_mode);
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		dc_set_channel_bwmode_disconnect(adapt);
+#else
+#ifdef CONFIG_CONCURRENT_MODE
+		if ((check_buddy_fwstate(adapt, _FW_LINKED)) != true) {
+#endif /* CONFIG_CONCURRENT_MODE */
+
+			/* switch to the 20M Hz mode after disconnect */
+			pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+			pmlmeext->cur_ch_offset =
+			    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+			/* SelectChannel(adapt, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); */
+			set_channel_bwmode(adapt, pmlmeext->cur_channel,
+					   pmlmeext->cur_ch_offset,
+					   pmlmeext->cur_bwmode);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		}
+#endif /* CONFIG_CONCURRENT_MODE */
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+
+		flush_all_cam_entry(adapt);
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		/* set MSR to no link state -> infra. mode */
+		Set_MSR(adapt, _HW_STATE_STATION_);
+
+		_cancel_timer_ex(&pmlmeext->link_timer);
+	}
+}
+
+/****************************************************************************
+
+Following are the functions for the timer handlers
+
+*****************************************************************************/
+static void _linked_rx_signal_strehgth_display(struct rtw_adapter *adapt)
+{
+	int UndecoratedSmoothedPWDB;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	DBG_8192D
+	    ("============ pbuddy_adapter linked status check ===================\n");
+	DBG_8192D("buddy_adapter_type=%d\n", pbuddy_adapter->adapter_type);
+	DBG_8192D("pbuddy_adapter pathA Rx SNRdb:%d\n",
+		  pbuddy_adapter->recvpriv.RxSNRdB[0]);
+	DBG_8192D("pbuddy_adapter pathA Rx PWDB:%d\n",
+		  pbuddy_adapter->recvpriv.rxpwdb);
+	DBG_8192D("pbuddy_adapter pathA Rx RSSI:%d,pathB Rx RSSI:%d\n",
+		  pbuddy_adapter->recvpriv.RxRssi[0],
+		  pbuddy_adapter->recvpriv.RxRssi[1]);
+	rtw_hal_get_def_var(pbuddy_adapter, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
+			    &UndecoratedSmoothedPWDB);
+	DBG_8192D("pbuddy_adapter UndecoratedSmoothedPWDB:%d\n",
+		  UndecoratedSmoothedPWDB);
+	DBG_8192D("Rx RSSI:%d\n", pbuddy_adapter->recvpriv.rssi);
+	DBG_8192D("Rx Signal_strength:%d\n",
+		  pbuddy_adapter->recvpriv.signal_strength);
+	DBG_8192D("Rx Signal_qual:%d\n", pbuddy_adapter->recvpriv.signal_qual);
+	DBG_8192D("============ linked status check ===================\n");
+	DBG_8192D("adapter_type=%d\n", adapt->adapter_type);
+#else /* CONFIG_CONCURRENT_MODE */
+	DBG_8192D("============ linked status check ===================\n");
+#endif /* CONFIG_CONCURRENT_MODE */
+	DBG_8192D("pathA Rx SNRdb:%d, pathB Rx SNRdb:%d\n",
+		  adapt->recvpriv.RxSNRdB[0], adapt->recvpriv.RxSNRdB[1]);
+	DBG_8192D("pathA Rx PWDB:%d\n", adapt->recvpriv.rxpwdb);
+	DBG_8192D("pathA Rx RSSI:%d,pathB Rx RSSI:%d\n",
+		  adapt->recvpriv.RxRssi[0], adapt->recvpriv.RxRssi[1]);
+	rtw_hal_get_def_var(adapt, HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
+			    &UndecoratedSmoothedPWDB);
+	DBG_8192D("UndecoratedSmoothedPWDB:%d\n", UndecoratedSmoothedPWDB);
+	DBG_8192D("Rx RSSI:%d\n", adapt->recvpriv.rssi);
+	DBG_8192D("Rx Signal_strength:%d\n",
+		  adapt->recvpriv.signal_strength);
+	DBG_8192D("Rx Signal_qual:%d\n", adapt->recvpriv.signal_qual);
+	if (check_fwstate(&adapt->mlmepriv, _FW_LINKED)) {
+		DBG_8192D("bw mode: %d, channel: %d\n",
+			  adapt->mlmeextpriv.cur_bwmode,
+			  adapt->mlmeextpriv.cur_channel);
+		DBG_8192D("received bytes = %d\n",
+			  (u32) (adapt->recvpriv.rx_bytes -
+				 adapt->recvpriv.last_rx_bytes));
+	}
+	DBG_8192D("============ linked status check ===================\n");
+	DBG_8192D(" DIG PATH-A(0x%02x), PATH-B(0x%02x)\n",
+		  rtw_read8(adapt, 0xc50), rtw_read8(adapt, 0xc58));
+	DBG_8192D
+	    (" OFDM -Alarm DA2(0x%04x),DA4(0x%04x),DA6(0x%04x),DA8(0x%04x)\n",
+	     rtw_read16(adapt, 0xDA2), rtw_read16(adapt, 0xDA4),
+	     rtw_read16(adapt, 0xDA6), rtw_read16(adapt, 0xDA8));
+
+	DBG_8192D(" CCK -Alarm A5B(0x%02x),A5C(0x%02x)\n",
+		  rtw_read8(adapt, 0xA5B), rtw_read8(adapt, 0xA5C));
+	DBG_8192D(" FalseAlmCnt_all(%d)\n", adapt->recvpriv.falsealmcnt_all);
+}
+
+static u8 chk_ap_is_alive(struct rtw_adapter *adapt, struct sta_info *psta)
+{
+	u8 ret = false;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta)) &&
+	    sta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta) &&
+	    sta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta))
+		ret = false;
+	else
+		ret = true;
+
+	sta_update_last_rx_pkts(psta);
+
+	return ret;
+}
+
+void linked_status_chk(struct rtw_adapter *adapt)
+{
+	u32 i;
+	struct sta_info *psta;
+	struct xmit_priv *pxmitpriv = &(adapt->xmitpriv);
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv *pstapriv = &adapt->stapriv;
+
+	if (adapt->bRxRSSIDisplay)
+		_linked_rx_signal_strehgth_display(adapt);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	rtw_hal_sreset_linked_status_check(adapt);
+#endif
+
+	if (is_client_associated_to_ap(adapt)) {
+		/* linked infrastructure client mode */
+
+		int tx_chk = _SUCCESS, rx_chk = _SUCCESS;
+		int rx_chk_limit;
+
+		rx_chk_limit = 4;
+
+		psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
+		if (psta != NULL) {
+			bool is_p2p_enable = false;
+			if (chk_ap_is_alive(adapt, psta) == false)
+				rx_chk = _FAIL;
+
+			if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)
+				tx_chk = _FAIL;
+
+			if (pmlmeext->active_keep_alive_check &&
+			    (rx_chk == _FAIL || tx_chk == _FAIL)) {
+				u8 backup_oper_channel = 0;
+
+				/* switch to correct channel of current network  before issue keep-alive frames */
+				if (rtw_get_oper_ch(adapt) !=
+				    pmlmeext->cur_channel) {
+					backup_oper_channel =
+					    rtw_get_oper_ch(adapt);
+					SelectChannel(adapt,
+						      pmlmeext->cur_channel);
+				}
+
+				if (rx_chk != _SUCCESS)
+					issue_probereq_ex(adapt,
+							  &pmlmeinfo->network.
+							  Ssid, psta->hwaddr, 3,
+							  1);
+
+				if ((tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) ||
+				    rx_chk != _SUCCESS) {
+					tx_chk =
+					    issue_nulldata(adapt,
+							   psta->hwaddr, 0, 3,
+							   1);
+					/* if tx acked and p2p disabled, set rx_chk _SUCCESS to reset retry count */
+					if (tx_chk == _SUCCESS && !is_p2p_enable)
+						rx_chk = _SUCCESS;
+				}
+
+				/* back to the original operation channel */
+				if (backup_oper_channel > 0)
+					SelectChannel(adapt,
+						      backup_oper_channel);
+
+			} else {
+				if (rx_chk != _SUCCESS) {
+					if (pmlmeext->retry == 0) {
+						issue_probereq(adapt,
+							       &pmlmeinfo->
+							       network.Ssid,
+							       pmlmeinfo->
+							       network.
+							       MacAddress);
+						issue_probereq(adapt,
+							       &pmlmeinfo->
+							       network.Ssid,
+							       pmlmeinfo->
+							       network.
+							       MacAddress);
+						issue_probereq(adapt,
+							       &pmlmeinfo->
+							       network.Ssid,
+							       pmlmeinfo->
+							       network.
+							       MacAddress);
+					}
+				}
+
+				if (tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) {
+					tx_chk = issue_nulldata(adapt, NULL, 0, 1, 0);
+				}
+			}
+
+			if (rx_chk == _FAIL) {
+				pmlmeext->retry++;
+				if (pmlmeext->retry > rx_chk_limit) {
+					DBG_8192D(FUNC_ADPT_FMT
+						  " disconnect or roaming\n",
+						  FUNC_ADPT_ARG(adapt));
+					receive_disconnect(adapt,
+							   pmlmeinfo->network.
+							   MacAddress,
+							   WLAN_REASON_EXPIRATION_CHK);
+					return;
+				}
+			} else {
+				pmlmeext->retry = 0;
+			}
+
+			if (tx_chk == _FAIL) {
+				pmlmeinfo->link_count &= 0xf;
+			} else {
+				pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
+				pmlmeinfo->link_count = 0;
+			}
+
+		}		/* end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL) */
+	} else if (is_client_associated_to_ibss(adapt)) {
+		/* linked IBSS mode */
+		/* for each assoc list entry to check the rx pkt counter */
+		for (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {
+			if (pmlmeinfo->FW_sta_info[i].status == 1) {
+				psta = pmlmeinfo->FW_sta_info[i].psta;
+
+				if (NULL == psta)
+					continue;
+
+				if (pmlmeinfo->FW_sta_info[i].rx_pkt ==
+				    sta_rx_pkts(psta)) {
+					if (pmlmeinfo->FW_sta_info[i].retry < 3) {
+						pmlmeinfo->FW_sta_info[i].
+						    retry++;
+					} else {
+						pmlmeinfo->FW_sta_info[i].
+						    retry = 0;
+						pmlmeinfo->FW_sta_info[i].
+						    status = 0;
+						report_del_sta_event(adapt, psta->hwaddr, 65535);	/*  indicate disconnect caused by no rx */
+					}
+				} else {
+					pmlmeinfo->FW_sta_info[i].retry = 0;
+					pmlmeinfo->FW_sta_info[i].rx_pkt =
+					    (u32) sta_rx_pkts(psta);
+				}
+			}
+		}
+	}
+}
+
+void survey_timer_hdl(struct rtw_adapter *adapt)
+{
+	struct cmd_obj *ph2c;
+	struct sitesurvey_parm *psurveyPara;
+	struct cmd_priv *pcmdpriv = &adapt->cmdpriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+
+	/* issue rtw_sitesurvey_cmd */
+	if (pmlmeext->sitesurvey_res.state > SCAN_START) {
+		if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+			if (adapt->mlmeextpriv.mlmext_info.scan_cnt !=
+			    RTW_SCAN_NUM_OF_CH)
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+				pmlmeext->sitesurvey_res.channel_idx++;
+		}
+
+		if (pmlmeext->scan_abort == true) {
+			pmlmeext->sitesurvey_res.channel_idx =
+			    pmlmeext->sitesurvey_res.ch_num;
+			DBG_8192D("%s idx:%d\n", __func__,
+				  pmlmeext->sitesurvey_res.channel_idx);
+
+			pmlmeext->scan_abort = false;	/* reset */
+		}
+
+		ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+		if (ph2c == NULL)
+			goto exit_survey_timer_hdl;
+
+		psurveyPara = (struct sitesurvey_parm *)kzalloc(sizeof(struct sitesurvey_parm), GFP_ATOMIC);
+		if (psurveyPara == NULL) {
+			kfree(ph2c);
+			goto exit_survey_timer_hdl;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara,
+					   GEN_CMD_CODE(_SITESURVEY));
+		rtw_enqueue_cmd(pcmdpriv, ph2c);
+	}
+
+exit_survey_timer_hdl:
+	return;
+}
+
+void link_timer_hdl(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmeinfo->state & WIFI_FW_AUTH_NULL) {
+		DBG_8192D("link_timer_hdl:no beacon while connecting\n");
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		report_join_res(adapt, -3);
+	} else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE) {
+		/* re-auth timer */
+		if (++pmlmeinfo->reauth_count > REAUTH_LIMIT) {
+			pmlmeinfo->state = 0;
+			report_join_res(adapt, -1);
+			return;
+		}
+
+		DBG_8192D("link_timer_hdl: auth timeout and try again\n");
+		pmlmeinfo->auth_seq = 1;
+		issue_auth(adapt, NULL, 0);
+		set_link_timer(pmlmeext, REAUTH_TO);
+	} else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE) {
+		/* re-assoc timer */
+		if (++pmlmeinfo->reassoc_count > REASSOC_LIMIT) {
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_join_res(adapt, -2);
+			return;
+		}
+
+		DBG_8192D("link_timer_hdl: assoc timeout and try again\n");
+		issue_assocreq(adapt);
+		set_link_timer(pmlmeext, REASSOC_TO);
+	}
+	return;
+}
+
+void addba_timer_hdl(struct sta_info *psta)
+{
+	struct ht_priv *phtpriv;
+
+	if (!psta)
+		return;
+
+	phtpriv = &psta->htpriv;
+
+	if ((phtpriv->ht_option == true) && (phtpriv->ampdu_enable == true)) {
+		if (phtpriv->candidate_tid_bitmap)
+			phtpriv->candidate_tid_bitmap = 0x0;
+	}
+}
+
+u8 NULL_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	return H2C_SUCCESS;
+}
+
+u8 setopmode_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	u8 type;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;
+
+	if (psetop->mode == NDIS802_11APMODE) {
+		pmlmeinfo->state = WIFI_FW_AP_STATE;
+		type = _HW_STATE_AP_;
+#ifdef CONFIG_NATIVEAP_MLME
+		/* start_ap_mode(adapt); */
+#endif
+	} else if (psetop->mode == NDIS802_11INFRA) {
+		pmlmeinfo->state &= ~(BIT(0) | BIT(1));	/*  clear state */
+		pmlmeinfo->state |= WIFI_FW_STATION_STATE;	/* set to     STATION_STATE */
+		type = _HW_STATE_STATION_;
+	} else if (psetop->mode == NDIS802_11IBSS) {
+		type = _HW_STATE_ADHOC_;
+	} else {
+		type = _HW_STATE_NOLINK_;
+	}
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_SET_OPMODE, (u8 *)(&type));
+	/* Set_NETYPE0_MSR(adapt, type); */
+
+	return H2C_SUCCESS;
+}
+
+u8 createbss_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
+	u32 initialgain;
+
+	if (pparm->network.InfrastructureMode == NDIS802_11APMODE) {
+#ifdef CONFIG_92D_AP_MODE
+
+		if (pmlmeinfo->state == WIFI_FW_AP_STATE) {
+			/* todo: */
+			return H2C_SUCCESS;
+		}
+#endif
+	}
+
+	/* below is for ad-hoc master */
+	if (pparm->network.InfrastructureMode == NDIS802_11IBSS) {
+		rtw_joinbss_reset(adapt);
+
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		pmlmeinfo->ERP_enable = 0;
+		pmlmeinfo->WMM_enable = 0;
+		pmlmeinfo->HT_enable = 0;
+		pmlmeinfo->HT_caps_enable = 0;
+		pmlmeinfo->HT_info_enable = 0;
+		pmlmeinfo->agg_enable_bitmap = 0;
+		pmlmeinfo->candidate_tid_bitmap = 0;
+
+		/* disable dynamic functions, such as high power, DIG */
+		Save_DM_Func_Flag(adapt);
+		Switch_DM_Func(adapt, DYNAMIC_FUNC_DISABLE, false);
+
+		/* config the initial gain under linking, need to write the BB registers */
+		initialgain = 0x1E;
+		rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
+				  (u8 *)(&initialgain));
+
+		/* cancel link timer */
+		_cancel_timer_ex(&pmlmeext->link_timer);
+
+		/* clear CAM */
+		flush_all_cam_entry(adapt);
+
+		memcpy(pnetwork, pbuf,
+		       FIELD_OFFSET(struct wlan_bssid_ex, IELength));
+		pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
+
+		if (pnetwork->IELength > MAX_IE_SZ)	/* Check pbuf->IELength */
+			return H2C_PARAMETERS_ERROR;
+
+		memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs,
+		       pnetwork->IELength);
+
+		start_create_ibss(adapt);
+	}
+	return H2C_SUCCESS;
+}
+
+u8 join_cmd_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	u8 join_type;
+	struct ndis_802_11_variable_ies *pIE;
+	struct registry_priv *pregpriv = &adapt->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
+#endif /* CONFIG_ANTENNA_DIVERSITY */
+	u32 initialgain, i;
+	u8 cbw40_enable = 0;
+	/* u32  acparm; */
+
+	/* check already connecting to AP or not */
+	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) {
+		if (pmlmeinfo->state & WIFI_FW_STATION_STATE) {
+			issue_deauth_ex(adapt, pnetwork->MacAddress,
+					WLAN_REASON_DEAUTH_LEAVING, 5, 100);
+		}
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		/* clear CAM */
+		flush_all_cam_entry(adapt);
+
+		_cancel_timer_ex(&pmlmeext->link_timer);
+
+		/* set MSR to nolink -> infra. mode */
+		/* Set_MSR(adapt, _HW_STATE_NOLINK_); */
+		Set_MSR(adapt, _HW_STATE_STATION_);
+
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
+	}
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	rtw_antenna_select_cmd(adapt, pparm->network.PhyInfo.Optimum_antenna,
+			       false);
+#endif
+
+	rtw_joinbss_reset(adapt);
+
+	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pmlmeinfo->ERP_enable = 0;
+	pmlmeinfo->WMM_enable = 0;
+	pmlmeinfo->HT_enable = 0;
+	pmlmeinfo->HT_caps_enable = 0;
+	pmlmeinfo->HT_info_enable = 0;
+	pmlmeinfo->agg_enable_bitmap = 0;
+	pmlmeinfo->candidate_tid_bitmap = 0;
+	pmlmeinfo->bwmode_updated = false;
+	/*pmlmeinfo->assoc_AP_vendor = maxAP; */
+
+	memcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, IELength));
+	pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
+
+	if (pnetwork->IELength > MAX_IE_SZ)	/* Check pbuf->IELength */
+		return H2C_PARAMETERS_ERROR;
+
+	memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs,
+	       pnetwork->IELength);
+
+	/* Check AP vendor to move rtw_joinbss_cmd() */
+	/*pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->IEs, pnetwork->IELength); */
+
+	for (i = sizeof(struct ndis_802_11_fixed_ies); i < pnetwork->IELength;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pnetwork->IEs + i);
+
+		switch (pIE->ElementID) {
+		case _VENDOR_SPECIFIC_IE_:	/* Get WMM IE. */
+			if (_rtw_memcmp(pIE->data, WMM_OUI, 4)) {
+				pmlmeinfo->WMM_enable = 1;
+			}
+			break;
+
+		case _HT_CAPABILITY_IE_:	/* Get HT Cap IE. */
+			pmlmeinfo->HT_caps_enable = 1;
+			break;
+
+		case _HT_EXTRA_INFO_IE_:	/* Get HT Info IE. */
+			pmlmeinfo->HT_info_enable = 1;
+
+			/* spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz */
+/* if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT) */
+/*				if (pmlmeinfo->assoc_AP_vendor == ciscoAP) */
+/* endif */
+			{
+				struct HT_info_element *pht_info =
+				    (struct HT_info_element *)(pIE->data);
+
+				if (pnetwork->Configuration.DSConfig > 14) {
+					if (pregpriv->cbw40_enable & BIT(1))
+						cbw40_enable = 1;
+				} else if (pregpriv->cbw40_enable & BIT(0)) {
+					cbw40_enable = 1;
+				}
+				if ((cbw40_enable) && (pht_info->infos[0] & BIT(2))) {
+					/* switch to the 40M Hz mode according to the AP */
+					pmlmeext->cur_bwmode =
+					    HT_CHANNEL_WIDTH_40;
+					switch (pht_info->infos[0] & 0x3) {
+					case 1:
+						pmlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_LOWER;
+						break;
+
+					case 3:
+						pmlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_UPPER;
+						break;
+
+					default:
+						pmlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+						break;
+					}
+
+					DBG_8192D
+					    ("set ch/bw before connected\n");
+				}
+			}
+			break;
+
+		default:
+			break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+	/* disable dynamic functions, such as high power, DIG */
+
+	/* config the initial gain under linking, need to write the BB registers */
+
+	initialgain = 0x1E;
+	rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_BSSID,
+			  pmlmeinfo->network.MacAddress);
+	join_type = 0;
+	rtw_hal_set_hwreg(adapt, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
+
+	/* cancel link timer */
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	start_clnt_join(adapt);
+
+	return H2C_SUCCESS;
+}
+
+u8 disconnect_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	struct disconnect_parm *param = (struct disconnect_parm *)pbuf;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+	u8 val8;
+
+	if (is_client_associated_to_ap(adapt)) {
+		issue_deauth_ex(adapt, pnetwork->MacAddress,
+				WLAN_REASON_DEAUTH_LEAVING,
+				param->deauth_timeout_ms / 100, 100);
+	}
+
+	/* set_opmode_cmd(adapt, infra_client_with_mlme); */
+
+	/*pmlmeinfo->state = WIFI_FW_NULL_STATE; */
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_MLME_DISCONNECT, NULL);
+	rtw_hal_set_hwreg(adapt, HW_VAR_BSSID, null_addr);
+
+	/* restore to initial setting. */
+	update_tx_basic_rate(adapt, adapt->registrypriv.wireless_mode);
+
+	if (((pmlmeinfo->state & 0x03) == WIFI_FW_ADHOC_STATE) ||
+	    ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE)) {
+		/* Stop BCN */
+		val8 = 0;
+		rtw_hal_set_hwreg(adapt, HW_VAR_BCN_FUNC, (u8 *)(&val8));
+	}
+
+	/* set MSR to no link state -> infra. mode */
+	Set_MSR(adapt, _HW_STATE_STATION_);
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	dc_set_channel_bwmode_disconnect(adapt);
+#else
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((check_buddy_fwstate(adapt, _FW_LINKED)) != true) {
+#endif /* CONFIG_CONCURRENT_MODE */
+		/* switch to the 20M Hz mode after disconnect */
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   pmlmeext->cur_ch_offset,
+				   pmlmeext->cur_bwmode);
+#ifdef CONFIG_CONCURRENT_MODE
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+
+	flush_all_cam_entry(adapt);
+
+	_cancel_timer_ex(&pmlmeext->link_timer);
+
+	rtw_free_uc_swdec_pending_queue(adapt);
+
+	return H2C_SUCCESS;
+}
+
+static int rtw_scan_ch_decision(struct rtw_adapter *adapt,
+			 struct rtw_ieee80211_channel *out, u32 out_num,
+			 struct rtw_ieee80211_channel *in, u32 in_num)
+{
+	int i, j;
+	int scan_ch_num = 0;
+	int set_idx;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+
+	/* clear out first */
+	memset(out, 0, sizeof(struct rtw_ieee80211_channel) * out_num);
+
+	/* acquire channels from in */
+	j = 0;
+	for (i = 0; i < in_num; i++) {
+		set_idx = rtw_ch_set_search_ch(pmlmeext->channel_set, in[i].hw_value);
+		if (in[i].hw_value &&
+		    !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED) &&
+		    set_idx >= 0) {
+			memcpy(&out[j], &in[i],
+			       sizeof(struct rtw_ieee80211_channel));
+
+			if (pmlmeext->channel_set[set_idx].ScanType ==
+			    SCAN_PASSIVE)
+				out[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
+
+			j++;
+		}
+		if (j >= out_num)
+			break;
+	}
+
+	/* if out is empty, use channel_set as default */
+	if (j == 0) {
+		for (i = 0; i < pmlmeext->max_chan_nums; i++) {
+			out[i].hw_value = pmlmeext->channel_set[i].ChannelNum;
+
+			if (pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+				out[i].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
+
+			j++;
+		}
+	}
+
+	if (adapt->setband == GHZ_24) {	/*  2.4G */
+		for (i = 0; i < j; i++) {
+			if (out[i].hw_value > 35)
+				memset(&out[i], 0,
+				       sizeof(struct rtw_ieee80211_channel));
+			else
+				scan_ch_num++;
+		}
+		j = scan_ch_num;
+	} else if (adapt->setband == GHZ_50) {	/*  5G */
+		for (i = 0; i < j; i++) {
+			if (out[i].hw_value > 35) {
+				memcpy(&out[scan_ch_num++], &out[i],
+				       sizeof(struct rtw_ieee80211_channel));
+			}
+		}
+		j = scan_ch_num;
+	} else {
+	}
+
+	return j;
+}
+
+u8 sitesurvey_cmd_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct sitesurvey_parm *pparm = (struct sitesurvey_parm *)pbuf;
+	u8 bdelayscan = false;
+	u8 val8;
+	u32 initialgain;
+	u32 i;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE) {
+		/* for first time sitesurvey_cmd */
+		rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, NULL);
+
+		pmlmeext->sitesurvey_res.state = SCAN_START;
+		pmlmeext->sitesurvey_res.bss_cnt = 0;
+		pmlmeext->sitesurvey_res.channel_idx = 0;
+
+		for (i = 0; i < RTW_SSID_SCAN_AMOUNT; i++) {
+			if (pparm->ssid[i].SsidLength) {
+				memcpy(pmlmeext->sitesurvey_res.ssid[i].Ssid,
+				       pparm->ssid[i].Ssid, IW_ESSID_MAX_SIZE);
+				pmlmeext->sitesurvey_res.ssid[i].SsidLength =
+				    pparm->ssid[i].SsidLength;
+			} else {
+				pmlmeext->sitesurvey_res.ssid[i].SsidLength = 0;
+			}
+		}
+
+		pmlmeext->sitesurvey_res.ch_num =
+		    rtw_scan_ch_decision(adapt, pmlmeext->sitesurvey_res.ch,
+					 RTW_CHANNEL_SCAN_AMOUNT, pparm->ch,
+					 pparm->ch_num);
+
+		pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		bdelayscan = dc_handle_site_survey(adapt);
+#endif
+
+		/* issue null data if associating to the AP */
+		if (is_client_associated_to_ap(adapt) == true) {
+			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
+
+			issue_nulldata(adapt, NULL, 1, 3, 500);
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if (is_client_associated_to_ap(adapt->pbuddy_adapter)
+			    == true) {
+				DBG_8192D
+				    ("adapter is scanning(buddy_adapter is linked), issue nulldata(pwrbit=1)\n");
+
+				issue_nulldata(adapt->pbuddy_adapter, NULL,
+					       1, 3, 500);
+			}
+#endif
+			bdelayscan = true;
+		}
+#ifdef CONFIG_CONCURRENT_MODE
+		else if (is_client_associated_to_ap(adapt->pbuddy_adapter) ==
+			 true) {
+			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
+
+			issue_nulldata(adapt->pbuddy_adapter, NULL, 1, 3,
+				       500);
+
+			bdelayscan = true;
+		}
+#endif
+		if (bdelayscan) {
+			/* delay 50ms to protect nulldata(1). */
+			set_survey_timer(pmlmeext, 50);
+			return H2C_SUCCESS;
+		}
+	}
+
+	if ((pmlmeext->sitesurvey_res.state == SCAN_START) ||
+	    (pmlmeext->sitesurvey_res.state == SCAN_TXNULL)) {
+#ifdef CONFIG_FIND_BEST_CHANNEL
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+		/* disable dynamic functions, such as high power, DIG */
+		Save_DM_Func_Flag(adapt);
+		Switch_DM_Func(adapt, DYNAMIC_FUNC_DISABLE, false);
+
+		/* config the initial gain under scaning, need to write the BB registers */
+		if ((wdev_to_priv(adapt->rtw_wdev))->p2p_enabled == true)
+			initialgain = 0x27;
+		else
+			initialgain = 0x17;
+		rtw_hal_set_hwreg(adapt, HW_VAR_INITIAL_GAIN,
+				  (u8 *)(&initialgain));
+
+		/* set MSR to no link state */
+		Set_MSR(adapt, _HW_STATE_NOLINK_);
+
+		val8 = 1;	/* under site survey */
+		rtw_hal_set_hwreg(adapt, HW_VAR_MLME_SITESURVEY,
+				  (u8 *)(&val8));
+
+		pmlmeext->sitesurvey_res.state = SCAN_PROCESS;
+	}
+	site_survey(adapt);
+	return H2C_SUCCESS;
+}
+
+u8 setauth_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	struct setauth_parm *pparm = (struct setauth_parm *)pbuf;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pparm->mode < 4) {
+		pmlmeinfo->auth_algo = pparm->mode;
+	}
+
+	return H2C_SUCCESS;
+}
+
+u8 setkey_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	unsigned short ctrl;
+	struct setkey_parm *pparm = (struct setkey_parm *)pbuf;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	unsigned char null_sta[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+
+	/* main tx key for wep. */
+	if (pparm->set_tx)
+		pmlmeinfo->key_index = pparm->keyid;
+
+	/* write cam */
+	ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;
+
+	write_cam(adapt, pparm->keyid, ctrl, null_sta, pparm->key);
+
+	/* allow multicast packets to driver */
+	rtw_hal_set_hwreg(adapt, HW_VAR_ON_RCR_AM, null_addr);
+
+	return H2C_SUCCESS;
+}
+
+u8 set_stakey_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	u16 ctrl = 0;
+	u8 cam_id;		/* cam_entry */
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct set_stakey_parm *pparm = (struct set_stakey_parm *)pbuf;
+
+	/* cam_entry: */
+	/* 0~3 for default key */
+
+	/* for concurrent mode (sta+sta): */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+		struct sta_priv *pstapriv = &adapt->stapriv;
+		struct sta_info *psta;
+
+		psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
+
+		if (psta && psta->mac_id == 2) {
+			cam_id = 5;
+		} else {
+			cam_id = 4;
+		}
+	}
+#else
+	cam_id = 4;
+#endif
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &adapt->stapriv;
+
+		if (pparm->algorithm == _NO_PRIVACY_) {	/*  clear cam entry */
+			clear_cam_entry(adapt, pparm->id);
+			return H2C_SUCCESS_RSP;
+		}
+
+		psta = rtw_get_stainfo(pstapriv, pparm->addr);
+		if (psta) {
+			ctrl = (BIT(15) | ((pparm->algorithm) << 2));
+
+			DBG_8192D("r871x_set_stakey_hdl(): enc_algorithm=%d\n",
+				  pparm->algorithm);
+
+			if ((psta->mac_id < 1) ||
+			    (psta->mac_id > (NUM_STA - 4))) {
+				DBG_8192D
+				    ("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n",
+				     psta->mac_id);
+				return H2C_REJECTED;
+			}
+
+			cam_id = (psta->mac_id + 3);	/* 0~3 for default key, cmd_id=macid + 3, macid=aid+1; */
+
+			DBG_8192D
+			    ("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n",
+			     pparm->addr[0], pparm->addr[1], pparm->addr[2],
+			     pparm->addr[3], pparm->addr[4], pparm->addr[5],
+			     cam_id);
+
+			write_cam(adapt, cam_id, ctrl, pparm->addr,
+				  pparm->key);
+
+			return H2C_SUCCESS_RSP;
+
+		} else {
+			DBG_8192D
+			    ("r871x_set_stakey_hdl(): sta has been free\n");
+			return H2C_REJECTED;
+		}
+	}
+
+	/* below for sta mode */
+
+	if (pparm->algorithm == _NO_PRIVACY_) {	/*  clear cam entry */
+		clear_cam_entry(adapt, pparm->id);
+		return H2C_SUCCESS;
+	}
+
+	ctrl = BIT(15) | ((pparm->algorithm) << 2);
+
+	write_cam(adapt, cam_id, ctrl, pparm->addr, pparm->key);
+
+	pmlmeinfo->enc_algo = pparm->algorithm;
+
+	return H2C_SUCCESS;
+}
+
+u8 add_ba_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	struct addBaReq_parm *pparm = (struct addBaReq_parm *)pbuf;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	struct sta_info *psta =
+	    rtw_get_stainfo(&adapt->stapriv, pparm->addr);
+
+	if (!psta)
+		return H2C_SUCCESS;
+
+	if (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||
+	    ((pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE)) {
+		/*pmlmeinfo->ADDBA_retry_count = 0; */
+		/*pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid); */
+		/*psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid); */
+		issue_action_BA(adapt, pparm->addr,
+				RTW_WLAN_ACTION_ADDBA_REQ, (u16) pparm->tid);
+		/* _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); */
+		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
+	} else {
+		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);
+	}
+
+	return H2C_SUCCESS;
+}
+
+u8 set_tx_beacon_cmd(struct rtw_adapter *adapt)
+{
+	struct cmd_obj *ph2c;
+	struct Tx_Beacon_param *ptxBeacon_parm;
+	struct cmd_priv *pcmdpriv = &(adapt->cmdpriv);
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 res = _SUCCESS;
+	int len_diff = 0;
+
+	ph2c = (struct cmd_obj *)kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	ptxBeacon_parm = (struct Tx_Beacon_param *)kzalloc(sizeof(struct Tx_Beacon_param), GFP_ATOMIC);
+	if (ptxBeacon_parm == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	memcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network),
+	       sizeof(struct wlan_bssid_ex));
+
+	len_diff =
+	    update_hidden_ssid(ptxBeacon_parm->network.IEs + _BEACON_IE_OFFSET_,
+			       ptxBeacon_parm->network.IELength -
+			       _BEACON_IE_OFFSET_, pmlmeinfo->hidden_ssid_mode);
+	ptxBeacon_parm->network.IELength += len_diff;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm,
+				   GEN_CMD_CODE(_TX_BEACON));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+u8 mlme_evt_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	u8 evt_code;
+#ifdef CHECK_EVENT_SEQ
+	u8 evt_seq;
+#endif
+	u16 evt_sz;
+	uint *peventbuf;
+	void (*event_callback) (struct rtw_adapter *dev, u8 *pbuf);
+	struct evt_priv *pevt_priv = &(adapt->evtpriv);
+
+	peventbuf = (uint *)pbuf;
+	evt_sz = (u16) (*peventbuf & 0xffff);
+#ifdef CHECK_EVENT_SEQ
+	evt_seq = (u8) ((*peventbuf >> 24) & 0x7f);
+#endif
+	evt_code = (u8) ((*peventbuf >> 16) & 0xff);
+
+#ifdef CHECK_EVENT_SEQ
+	/*  checking event sequence... */
+	if (evt_seq != (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f)) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_info_,
+			 ("Evetn Seq Error! %d vs %d\n", (evt_seq & 0x7f),
+			  (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f)));
+
+		pevt_priv->event_seq = (evt_seq + 1) & 0x7f;
+
+		goto _abort_event_;
+	}
+#endif
+
+	/*  checking if event code is valid */
+	if (evt_code >= MAX_C2HEVT) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\nEvent Code(%d) mismatch!\n", evt_code));
+		goto _abort_event_;
+	}
+
+	/*  checking if event size match the event parm size */
+	if ((wlanevents[evt_code].parmsize != 0) &&
+	    (wlanevents[evt_code].parmsize != evt_sz)) {
+		RT_TRACE(_module_rtl871x_cmd_c_, _drv_err_,
+			 ("\nEvent(%d) Parm Size mismatch (%d vs %d)!\n",
+			  evt_code, wlanevents[evt_code].parmsize, evt_sz));
+		goto _abort_event_;
+	}
+
+	ATOMIC_INC(&pevt_priv->event_seq);
+
+	peventbuf += 2;
+
+	if (peventbuf) {
+		event_callback = wlanevents[evt_code].event_callback;
+		event_callback(adapt, (u8 *)peventbuf);
+
+		pevt_priv->evt_done_cnt++;
+	}
+
+_abort_event_:
+
+	return H2C_SUCCESS;
+}
+
+u8 h2c_msg_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	return H2C_SUCCESS;
+}
+
+u8 tx_beacon_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	if (send_beacon(adapt) == _FAIL) {
+		DBG_8192D("issue_beacon, fail!\n");
+		return H2C_PARAMETERS_ERROR;
+	}
+#ifdef CONFIG_92D_AP_MODE
+	else {			/* tx bc/mc frames after update TIM */
+
+		struct sta_info *psta_bmc;
+		struct list_head *xmitframe_plist, *xmitframe_phead;
+		struct xmit_frame *pxmitframe = NULL;
+		struct sta_priv *pstapriv = &adapt->stapriv;
+
+		/* for BC/MC Frames */
+		psta_bmc = rtw_get_bcmc_stainfo(adapt);
+		if (!psta_bmc)
+			return H2C_SUCCESS;
+
+		if ((pstapriv->tim_bitmap & BIT(0)) && (psta_bmc->sleepq_len > 0)) {
+			rtw_msleep_os(10);	/*  10ms, ATIM(HIQ) Windows */
+			spin_lock_bh(&psta_bmc->sleep_q.lock);
+
+			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
+			xmitframe_plist = xmitframe_phead->next;
+
+			while ((rtw_end_of_queue_search
+				(xmitframe_phead, xmitframe_plist)) == false) {
+				pxmitframe =
+				    container_of(xmitframe_plist,
+						   struct xmit_frame, list);
+
+				xmitframe_plist = xmitframe_plist->next;
+
+				list_del_init(&pxmitframe->list);
+
+				psta_bmc->sleepq_len--;
+				if (psta_bmc->sleepq_len > 0)
+					pxmitframe->attrib.mdata = 1;
+				else
+					pxmitframe->attrib.mdata = 0;
+
+				pxmitframe->attrib.triggered = 1;
+
+				pxmitframe->attrib.qsel = 0x11;	/* HIQ */
+
+				spin_unlock_bh(&psta_bmc->sleep_q.lock);
+				if (rtw_hal_xmit(adapt, pxmitframe) == true) {
+					rtw_os_xmit_complete(adapt,
+							     pxmitframe);
+				}
+				spin_lock_bh(&psta_bmc->sleep_q.lock);
+			}
+			spin_unlock_bh(&psta_bmc->sleep_q.lock);
+		}
+	}
+#endif
+
+	return H2C_SUCCESS;
+}
+
+void change_band_update_ie(struct rtw_adapter *adapt,
+			   struct wlan_bssid_ex *pnetwork)
+{
+	u8 network_type, rate_len, total_rate_len, remainder_rate_len;
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	u8 erpinfo = 0x4;
+
+	/* DBG_8192D("%s\n", __func__); */
+
+	if (pmlmeext->cur_channel >= 36) {
+		network_type = WIRELESS_11A;
+		total_rate_len = IEEE80211_NUM_OFDM_RATESLEN;
+		DBG_8192D("%s(): change to 5G Band\n", __func__);
+#ifdef CONFIG_92D_AP_MODE
+		rtw_remove_bcn_ie(adapt, pnetwork, _ERPINFO_IE_);
+#endif
+	} else {
+		network_type = WIRELESS_11BG;
+		total_rate_len =
+		    IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
+		DBG_8192D("%s(): change to 2.4G Band\n", __func__);
+#ifdef CONFIG_92D_AP_MODE
+		rtw_add_bcn_ie(adapt, pnetwork, _ERPINFO_IE_, &erpinfo, 1);
+#endif
+	}
+
+	rtw_set_supported_rate(pnetwork->SupportedRates, network_type);
+
+	UpdateBrateTbl(adapt, pnetwork->SupportedRates);
+	rtw_hal_set_hwreg(adapt, HW_VAR_BASIC_RATE,
+			  pnetwork->SupportedRates);
+
+	if (total_rate_len > 8) {
+		rate_len = 8;
+		remainder_rate_len = total_rate_len - 8;
+	} else {
+		rate_len = total_rate_len;
+		remainder_rate_len = 0;
+	}
+
+#ifdef CONFIG_92D_AP_MODE
+	rtw_add_bcn_ie(adapt, pnetwork, _SUPPORTEDRATES_IE_,
+		       pnetwork->SupportedRates, rate_len);
+
+	if (remainder_rate_len) {
+		rtw_add_bcn_ie(adapt, pnetwork, _EXT_SUPPORTEDRATES_IE_,
+			       (pnetwork->SupportedRates + 8),
+			       remainder_rate_len);
+	} else {
+		rtw_remove_bcn_ie(adapt, pnetwork, _EXT_SUPPORTEDRATES_IE_);
+	}
+#endif
+}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+void dc_SelectChannel(struct rtw_adapter *adapt, unsigned char channel)
+{
+	struct rtw_adapter *ptarget_adapter;
+
+	if ((adapt->pbuddy_adapter != NULL) &&
+	    (adapt->DualMacConcurrent == true) &&
+	    (adapt->adapter_type == SECONDARY_ADAPTER)) {
+		/*  only mac0 could control BB&RF */
+		ptarget_adapter = adapt->pbuddy_adapter;
+	} else {
+		ptarget_adapter = adapt;
+	}
+
+	_enter_critical_mutex(&
+			      (adapter_to_dvobj(ptarget_adapter)->setch_mutex));
+
+	rtw_hal_set_chan(ptarget_adapter, channel);
+
+	_exit_critical_mutex(&(adapter_to_dvobj(ptarget_adapter)->setch_mutex));
+}
+
+void dc_SetBWMode(struct rtw_adapter *adapt, unsigned short bwmode,
+		  unsigned char channel_offset)
+{
+	struct rtw_adapter *ptarget_adapter;
+
+	if ((adapt->pbuddy_adapter != NULL) &&
+	    (adapt->DualMacConcurrent == true) &&
+	    (adapt->adapter_type == SECONDARY_ADAPTER)) {
+		/*  only mac0 could control BB&RF */
+		ptarget_adapter = adapt->pbuddy_adapter;
+	} else {
+		ptarget_adapter = adapt;
+	}
+
+	_enter_critical_mutex(&
+			      (adapter_to_dvobj(ptarget_adapter)->setbw_mutex));
+
+	rtw_hal_set_bwmode(ptarget_adapter, (HT_CHANNEL_WIDTH) bwmode,
+			   channel_offset);
+
+	_exit_critical_mutex(&(adapter_to_dvobj(ptarget_adapter)->setbw_mutex));
+}
+
+void dc_set_channel_bwmode_disconnect(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != true) {
+			/* switch to the 20M Hz mode after disconnect */
+			pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+			pmlmeext->cur_ch_offset =
+			    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+			set_channel_bwmode(adapt, pmlmeext->cur_channel,
+					   pmlmeext->cur_ch_offset,
+					   pmlmeext->cur_bwmode);
+		}
+	} else {
+		/* switch to the 20M Hz mode after disconnect */
+		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   pmlmeext->cur_ch_offset,
+				   pmlmeext->cur_bwmode);
+	}
+}
+
+u8 dc_handle_join_request(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+	u8 ret = _SUCCESS;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
+		    pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
+		    pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset) {
+			if ((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) ==
+			    true) {
+				/* issue deauth to all stas if if2 is at ap mode */
+				rtw_sta_flush(pbuddy_adapter);
+
+				/* rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, 0); */
+				rtw_hal_set_hwreg(pbuddy_adapter,
+						  HW_VAR_CHECK_TXBUF, 0);
+			} else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) ==
+				   true) {
+				if (pmlmeext->cur_channel ==
+				    pbuddy_mlmeext->cur_channel) {
+					/*  HT_CHANNEL_WIDTH_40 or HT_CHANNEL_WIDTH_20 but channel offset is different */
+					if ((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
+					    (pmlmeext->cur_ch_offset != pbuddy_mlmeext-> cur_ch_offset)) {
+						report_join_res(adapt, -4);
+						ret = _FAIL;
+					}
+				} else {
+					report_join_res(adapt, -4);
+					ret = _FAIL;
+				}
+			}
+		} else if (is_client_associated_to_ap(pbuddy_adapter) == true) {
+			issue_nulldata(pbuddy_adapter, NULL, 1, 0, 0);
+		}
+	}
+
+	return ret;
+}
+
+void dc_handle_join_done(struct rtw_adapter *adapt, u8 join_res)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
+	struct mlme_ext_info *pbuddy_mlmeinfo = NULL;
+	struct wlan_bssid_ex *pbuddy_network_mlmeext = NULL;
+	u8 change_band = false;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+		pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
+
+		if (((pbuddy_mlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+		    check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
+			/* restart and update beacon */
+			DBG_8192D
+			    ("after join, current adapter, CH=%d, BW=%d, offset=%d\n",
+			     pmlmeext->cur_channel, pmlmeext->cur_bwmode,
+			     pmlmeext->cur_ch_offset);
+
+			if (join_res >= 0) {
+				u8 *p;
+				int ie_len;
+				struct HT_info_element *pht_info = NULL;
+
+				if ((pbuddy_mlmeext->cur_channel <= 14 &&
+				     pmlmeext->cur_channel >= 36) ||
+				    (pbuddy_mlmeext->cur_channel >= 36 &&
+				     pmlmeext->cur_channel <= 14)) {
+					change_band = true;
+				}
+
+				/* sync channel/bwmode/ch_offset with another adapter */
+				pbuddy_mlmeext->cur_channel =
+				    pmlmeext->cur_channel;
+
+				if (pbuddy_mlmeext->cur_bwmode ==
+				    HT_CHANNEL_WIDTH_40) {
+					p = rtw_get_ie((pbuddy_network_mlmeext->
+							IEs +
+							sizeof(struct
+							       ndis_802_11_fixed_ies)),
+						       _HT_ADD_INFO_IE_,
+						       &ie_len,
+						       (pbuddy_network_mlmeext->
+							IELength -
+							sizeof(struct
+							       ndis_802_11_fixed_ies)));
+					if (p && ie_len) {
+						pht_info =
+						    (struct HT_info_element *)(p
+									       +
+									       2);
+						pht_info->infos[0] &= ~(BIT(0) | BIT(1));	/* no secondary channel is present */
+					}
+
+					if (pmlmeext->cur_bwmode ==
+					    HT_CHANNEL_WIDTH_40) {
+						pbuddy_mlmeext->cur_ch_offset =
+						    pmlmeext->cur_ch_offset;
+
+						/* to update cur_ch_offset value in beacon */
+						if (pht_info) {
+							switch (pmlmeext->
+								cur_ch_offset) {
+							case HAL_PRIME_CHNL_OFFSET_LOWER:
+								pht_info->
+								    infos[0] |=
+								    0x1;
+								break;
+							case HAL_PRIME_CHNL_OFFSET_UPPER:
+								pht_info->
+								    infos[0] |=
+								    0x3;
+								break;
+							case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
+							default:
+								break;
+							}
+						}
+					} else if (pmlmeext->cur_bwmode ==
+						   HT_CHANNEL_WIDTH_20) {
+						pbuddy_mlmeext->cur_bwmode =
+						    HT_CHANNEL_WIDTH_20;
+						pbuddy_mlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+						if (pmlmeext->cur_channel > 0 &&
+						    pmlmeext->cur_channel < 5) {
+							if (pht_info)
+								pht_info->
+								    infos[0] |=
+								    0x1;
+
+							pbuddy_mlmeext->
+							    cur_bwmode =
+							    HT_CHANNEL_WIDTH_40;
+							pbuddy_mlmeext->
+							    cur_ch_offset =
+							    HAL_PRIME_CHNL_OFFSET_LOWER;
+						}
+
+						if (pmlmeext->cur_channel > 7 &&
+						    pmlmeext->cur_channel < (14 + 1)) {
+							if (pht_info)
+								pht_info->
+								    infos[0] |=
+								    0x3;
+
+							pbuddy_mlmeext->
+							    cur_bwmode =
+							    HT_CHANNEL_WIDTH_40;
+							pbuddy_mlmeext->
+							    cur_ch_offset =
+							    HAL_PRIME_CHNL_OFFSET_UPPER;
+						}
+
+						set_channel_bwmode(adapt,
+								   pbuddy_mlmeext->
+								   cur_channel,
+								   pbuddy_mlmeext->
+								   cur_ch_offset,
+								   pbuddy_mlmeext->
+								   cur_bwmode);
+					}
+				}
+
+				/*  to update channel value in beacon */
+				pbuddy_network_mlmeext->Configuration.DSConfig =
+				    pmlmeext->cur_channel;
+				p = rtw_get_ie((pbuddy_network_mlmeext->IEs +
+						sizeof(struct
+						       ndis_802_11_fixed_ies)),
+					       _DSSET_IE_, &ie_len,
+					       (pbuddy_network_mlmeext->
+						IELength -
+						sizeof(struct
+						       ndis_802_11_fixed_ies)));
+				if (p && ie_len > 0)
+					*(p + 2) = pmlmeext->cur_channel;
+
+				p = rtw_get_ie((pbuddy_network_mlmeext->IEs +
+						sizeof(struct
+						       ndis_802_11_fixed_ies)),
+					       _HT_ADD_INFO_IE_, &ie_len,
+					       (pbuddy_network_mlmeext->
+						IELength -
+						sizeof(struct
+						       ndis_802_11_fixed_ies)));
+				if (p && ie_len) {
+					pht_info =
+					    (struct HT_info_element *)(p + 2);
+					pht_info->primary_channel =
+					    pmlmeext->cur_channel;
+				}
+
+				/*  update mlmepriv's cur_network */
+				memcpy(&pbuddy_mlmepriv->cur_network.network,
+				       pbuddy_network_mlmeext,
+				       pbuddy_network_mlmeext->Length);
+			} else {
+				/*  switch back to original channel/bwmode/ch_offset; */
+				set_channel_bwmode(adapt,
+						   pbuddy_mlmeext->cur_channel,
+						   pbuddy_mlmeext->
+						   cur_ch_offset,
+						   pbuddy_mlmeext->cur_bwmode);
+			}
+
+			DBG_8192D
+			    ("after join, another adapter, CH=%d, BW=%d, offset=%d\n",
+			     pbuddy_mlmeext->cur_channel,
+			     pbuddy_mlmeext->cur_bwmode,
+			     pbuddy_mlmeext->cur_ch_offset);
+
+			if (change_band == true)
+				change_band_update_ie(pbuddy_adapter,
+						      pbuddy_network_mlmeext);
+
+			DBG_8192D("update pbuddy_adapter's beacon\n");
+
+			update_beacon(pbuddy_adapter, 0, NULL, true);
+		} else if (is_client_associated_to_ap(pbuddy_adapter) == true) {
+			if ((pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+			    (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_20)) {
+				set_channel_bwmode(adapt,
+						   pbuddy_mlmeext->cur_channel,
+						   pbuddy_mlmeext->
+						   cur_ch_offset,
+						   pbuddy_mlmeext->cur_bwmode);
+			}
+
+			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
+		}
+	}
+}
+
+int dc_check_fwstate(struct rtw_adapter *adapt, int fw_state)
+{
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+
+	if (adapt->pbuddy_adapter != NULL &&
+	    adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+
+		return check_fwstate(pbuddy_mlmepriv, fw_state);
+	}
+
+	return false;
+}
+
+u8 dc_handle_site_survey(struct rtw_adapter *adapt)
+{
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+
+	/*  only mac0 can do scan request, help issue nulldata(1) for mac1 */
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		if (is_client_associated_to_ap(pbuddy_adapter) == true) {
+			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
+
+			issue_nulldata(pbuddy_adapter, NULL, 1, 2, 0);
+
+			return true;
+		}
+	}
+
+	return false;
+}
+
+void dc_report_survey_event(struct rtw_adapter *adapt,
+			    struct recv_frame_hdr *precv_frame)
+{
+	if (adapt->pbuddy_adapter != NULL &&
+	    adapt->DualMacConcurrent == true) {
+		report_survey_event(adapt->pbuddy_adapter, precv_frame);
+	}
+}
+
+void dc_set_channel_bwmode_survey_done(struct rtw_adapter *adapt)
+{
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
+	struct mlme_ext_info *pbuddy_mlmeinfo = NULL;
+	u8 cur_channel;
+	u8 cur_bwmode;
+	u8 cur_ch_offset;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+		pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+
+		if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
+			if (check_fwstate(pmlmepriv, _FW_LINKED) &&
+			    (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)) {
+				cur_channel = pmlmeext->cur_channel;
+				cur_bwmode = pmlmeext->cur_bwmode;
+				cur_ch_offset = pmlmeext->cur_ch_offset;
+			} else {
+				cur_channel = pbuddy_mlmeext->cur_channel;
+				cur_bwmode = pbuddy_mlmeext->cur_bwmode;
+				cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
+			}
+		} else {
+			cur_channel = pmlmeext->cur_channel;
+			cur_bwmode = pmlmeext->cur_bwmode;
+			cur_ch_offset = pmlmeext->cur_ch_offset;
+		}
+
+		set_channel_bwmode(adapt, cur_channel, cur_ch_offset,
+				   cur_bwmode);
+
+		if (is_client_associated_to_ap(pbuddy_adapter) == true) {
+			/* issue null data */
+			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
+		}
+
+		if (((pbuddy_mlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+		    check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
+			DBG_8192D
+			    ("survey done, current CH=%d, BW=%d, offset=%d\n",
+			     cur_channel, cur_bwmode, cur_ch_offset);
+
+			DBG_8192D("restart pbuddy_adapter's beacon\n");
+
+			update_beacon(pbuddy_adapter, 0, NULL, true);
+		}
+	} else {
+		set_channel_bwmode(adapt, pmlmeext->cur_channel,
+				   pmlmeext->cur_ch_offset,
+				   pmlmeext->cur_bwmode);
+	}
+}
+
+void dc_set_ap_channel_bandwidth(struct rtw_adapter *adapt, u8 channel,
+				 u8 channel_offset, u8 bwmode)
+{
+	u8 *p;
+	u8 val8, cur_channel, cur_bwmode, cur_ch_offset, change_band;
+	int ie_len;
+	struct registry_priv *pregpriv = &adapt->registrypriv;
+	struct mlme_priv *pmlmepriv = &(adapt->mlmepriv);
+	struct wlan_bssid_ex *pnetwork =
+	    (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
+	struct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct HT_info_element *pht_info = NULL;
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+	struct mlme_ext_priv *pbuddy_mlmeext = NULL;
+
+	DBG_8192D("dualmac_concurrent_ap_set_channel_bwmode ==>\n");
+
+	cur_channel = channel;
+	cur_bwmode = bwmode;
+	cur_ch_offset = channel_offset;
+	change_band = false;
+
+	p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)),
+		       _HT_ADD_INFO_IE_, &ie_len,
+		       (pnetwork->IELength -
+			sizeof(struct ndis_802_11_fixed_ies)));
+	if (p && ie_len) {
+		pht_info = (struct HT_info_element *)(p + 2);
+	}
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+
+		if (!check_fwstate
+		    (pbuddy_mlmepriv,
+		     _FW_LINKED | _FW_UNDER_LINKING | _FW_UNDER_SURVEY)) {
+			set_channel_bwmode(adapt, cur_channel, cur_ch_offset,
+					   cur_bwmode);
+		} else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true) {
+			/* To sync cur_channel/cur_bwmode/cur_ch_offset with another adapter */
+			DBG_8192D
+			    ("Another iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
+			DBG_8192D("Another adapter, CH=%d, BW=%d, offset=%d\n",
+				  pbuddy_mlmeext->cur_channel,
+				  pbuddy_mlmeext->cur_bwmode,
+				  pbuddy_mlmeext->cur_ch_offset);
+			DBG_8192D("Current adapter, CH=%d, BW=%d, offset=%d\n",
+				  cur_channel, cur_bwmode, cur_ch_offset);
+
+			cur_channel = pbuddy_mlmeext->cur_channel;
+			if (cur_bwmode == HT_CHANNEL_WIDTH_40) {
+				if (pht_info)
+					pht_info->infos[0] &=
+					    ~(BIT(0) | BIT(1));
+
+				if (pbuddy_mlmeext->cur_bwmode ==
+				    HT_CHANNEL_WIDTH_40) {
+					cur_ch_offset =
+					    pbuddy_mlmeext->cur_ch_offset;
+
+					/* to update cur_ch_offset value in beacon */
+					if (pht_info) {
+						switch (cur_ch_offset) {
+						case HAL_PRIME_CHNL_OFFSET_LOWER:
+							pht_info->infos[0] |=
+							    0x1;
+							break;
+						case HAL_PRIME_CHNL_OFFSET_UPPER:
+							pht_info->infos[0] |=
+							    0x3;
+							break;
+						case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
+						default:
+							break;
+						}
+					}
+				} else if (pbuddy_mlmeext->cur_bwmode ==
+					   HT_CHANNEL_WIDTH_20) {
+					cur_bwmode = HT_CHANNEL_WIDTH_20;
+					cur_ch_offset =
+					    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+					if (cur_channel > 0 && cur_channel < 5) {
+						if (pht_info)
+							pht_info->infos[0] |=
+							    0x1;
+
+						cur_bwmode =
+						    HT_CHANNEL_WIDTH_40;
+						cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_LOWER;
+					}
+
+					if (cur_channel > 7 && cur_channel < (14 + 1)) {
+						if (pht_info)
+							pht_info->infos[0] |=
+							    0x3;
+
+						cur_bwmode =
+						    HT_CHANNEL_WIDTH_40;
+						cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_UPPER;
+					}
+
+					set_channel_bwmode(adapt,
+							   cur_channel,
+							   cur_ch_offset,
+							   cur_bwmode);
+				}
+			}
+
+			/*  to update channel value in beacon */
+			pnetwork->Configuration.DSConfig = cur_channel;
+			p = rtw_get_ie((pnetwork->IEs +
+					sizeof(struct ndis_802_11_fixed_ies)),
+				       _DSSET_IE_, &ie_len,
+				       (pnetwork->IELength -
+					sizeof(struct ndis_802_11_fixed_ies)));
+			if (p && ie_len > 0)
+				*(p + 2) = cur_channel;
+
+			if (pht_info)
+				pht_info->primary_channel = cur_channel;
+		}
+	} else {
+		set_channel_bwmode(adapt, cur_channel, cur_ch_offset,
+				   cur_bwmode);
+	}
+
+	DBG_8192D("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode,
+		  cur_ch_offset);
+
+	if ((channel <= 14 && cur_channel >= 36) ||
+	    (channel >= 36 && cur_channel <= 14)) {
+		change_band = true;
+	}
+
+	pmlmeext->cur_channel = cur_channel;
+	pmlmeext->cur_bwmode = cur_bwmode;
+	pmlmeext->cur_ch_offset = cur_ch_offset;
+
+	if (change_band == true)
+		change_band_update_ie(adapt, pnetwork);
+
+	DBG_8192D("dualmac_concurrent_ap_set_channel_bwmode <==\n");
+}
+
+void dc_resume_xmit(struct rtw_adapter *adapt)
+{
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		DBG_8192D("dc_resume_xmit,  resume pbuddy_adapter Tx\n");
+		rtw_os_xmit_schedule(pbuddy_adapter);
+	}
+}
+
+u8 dc_check_xmit(struct rtw_adapter *adapt)
+{
+	struct rtw_adapter *pbuddy_adapter = adapt->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+
+	if (pbuddy_adapter != NULL && adapt->DualMacConcurrent == true) {
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+		if (check_fwstate
+		    (pbuddy_mlmepriv,
+		     _FW_UNDER_SURVEY | _FW_UNDER_LINKING) == true) {
+			DBG_8192D
+			    ("dc_check_xmit  pbuddy_adapter is under survey or under linking\n");
+			return false;
+		}
+	}
+
+	return true;
+}
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+int check_buddy_mlmeinfo_state(struct rtw_adapter *adapt, u32 state)
+{
+	struct rtw_adapter *pbuddy_adapter;
+	struct mlme_ext_priv *pbuddy_mlmeext;
+	struct mlme_ext_info *pbuddy_mlmeinfo;
+
+	if (adapt == NULL)
+		return false;
+
+	pbuddy_adapter = adapt->pbuddy_adapter;
+
+	if (pbuddy_adapter == NULL)
+		return false;
+
+	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+
+	if ((pbuddy_mlmeinfo->state & 0x03) == state)
+		return true;
+
+	return false;
+}
+
+int concurrent_chk_start_clnt_join(struct rtw_adapter *adapt)
+{
+	int ret = _FAIL;
+	struct mlme_ext_priv *pmlmeext;
+	struct rtw_adapter *pbuddy_adapter;
+	struct mlme_ext_priv *pbuddy_mlmeext;
+	struct mlme_ext_info *pbuddy_pmlmeinfo;
+	struct mlme_priv *pbuddy_mlmepriv;
+
+	if (!rtw_buddy_adapter_up(adapt))
+		return _SUCCESS;
+
+	pmlmeext = &adapt->mlmeextpriv;
+
+	pbuddy_adapter = adapt->pbuddy_adapter;
+	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+	pbuddy_pmlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+
+	if ((pbuddy_pmlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) {	/* for AP MODE */
+		bool inform_ch_switch = false;
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel) {
+			inform_ch_switch = true;
+		} else if ((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+			   (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+			   (pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)) {
+			inform_ch_switch = true;
+		}
+
+		if (inform_ch_switch) {
+#ifdef CONFIG_SPCT_CH_SWITCH
+			if (1) {
+				rtw_ap_inform_ch_switch(pbuddy_adapter,
+							pmlmeext->cur_channel,
+							pmlmeext->
+							cur_ch_offset);
+			} else
+#endif
+			{
+				/* issue deauth to all stas if if2 is at ap mode */
+				rtw_sta_flush(pbuddy_adapter);
+			}
+			rtw_hal_set_hwreg(adapt, HW_VAR_CHECK_TXBUF, 0);
+		}
+	} else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true && check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) {	/* for Client Mode/p2p client */
+
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel) {
+			DBG_8192D
+			    ("start_clnt_join(ch=%d), but channel mismatch with buddy(ch=%d) interface\n",
+			     pmlmeext->cur_channel,
+			     pbuddy_mlmeext->cur_channel);
+
+			report_join_res(adapt, (-4));
+
+			return ret;
+		}
+
+		if ((pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+		    (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) &&
+		    (pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)) {
+			DBG_8192D
+			    ("start_clnt_join(bwmode=%d, ch_offset=%d), but bwmode & ch_offset mismatch with buddy(bwmode=%d, ch_offset=%d) interface\n",
+			     pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset,
+			     pbuddy_mlmeext->cur_bwmode,
+			     pbuddy_mlmeext->cur_ch_offset);
+
+			report_join_res(adapt, (-4));
+			return ret;
+		}
+	}
+	return _SUCCESS;
+}
+
+void concurrent_chk_joinbss_done(struct rtw_adapter *adapt, int join_res)
+{
+	struct mlme_ext_priv *pmlmeext;
+	struct rtw_adapter *pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv;
+	struct mlme_ext_priv *pbuddy_mlmeext;
+	struct mlme_ext_info *pbuddy_mlmeinfo;
+	struct wlan_bssid_ex *pbuddy_network_mlmeext;
+
+	if (!rtw_buddy_adapter_up(adapt))
+		return;
+
+	pmlmeext = &adapt->mlmeextpriv;
+
+	pbuddy_adapter = adapt->pbuddy_adapter;
+	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+	pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+	pbuddy_mlmeinfo = &(pbuddy_mlmeext->mlmext_info);
+	pbuddy_network_mlmeext = &(pbuddy_mlmeinfo->network);
+
+	if (((pbuddy_mlmeinfo->state & 0x03) == WIFI_FW_AP_STATE) &&
+	    check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
+		/* restart and update beacon */
+
+		DBG_8192D
+		    ("after join,primary adapter, CH=%d, BW=%d, offset=%d\n",
+		     pmlmeext->cur_channel, pmlmeext->cur_bwmode,
+		     pmlmeext->cur_ch_offset);
+
+		if (join_res >= 0) {
+			u8 *p;
+			int ie_len;
+			u8 change_band = false;
+			struct HT_info_element *pht_info = NULL;
+
+			if ((pmlmeext->cur_channel <= 14 &&
+			     pbuddy_mlmeext->cur_channel >= 36) ||
+			    (pmlmeext->cur_channel >= 36 &&
+			     pbuddy_mlmeext->cur_channel <= 14))
+				change_band = true;
+
+			/* sync channel/bwmode/ch_offset with primary adapter */
+			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
+			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) {
+				p = rtw_get_ie((pbuddy_network_mlmeext->IEs +
+						sizeof(struct
+						       ndis_802_11_fixed_ies)),
+					       _HT_ADD_INFO_IE_, &ie_len,
+					       (pbuddy_network_mlmeext->
+						IELength -
+						sizeof(struct
+						       ndis_802_11_fixed_ies)));
+				if (p && ie_len) {
+					pht_info =
+					    (struct HT_info_element *)(p + 2);
+					pht_info->infos[0] &= ~(BIT(0) | BIT(1));	/* no secondary channel is present */
+				}
+
+				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40) {
+					pbuddy_mlmeext->cur_ch_offset =
+					    pmlmeext->cur_ch_offset;
+
+					/* to update cur_ch_offset value in beacon */
+					if (pht_info) {
+						switch (pmlmeext->cur_ch_offset) {
+						case HAL_PRIME_CHNL_OFFSET_LOWER:
+							pht_info->infos[0] |=
+							    0x1;
+							break;
+						case HAL_PRIME_CHNL_OFFSET_UPPER:
+							pht_info->infos[0] |=
+							    0x3;
+							break;
+						case HAL_PRIME_CHNL_OFFSET_DONT_CARE:
+						default:
+							break;
+						}
+					}
+				} else if (pmlmeext->cur_bwmode ==
+					   HT_CHANNEL_WIDTH_20) {
+					if (pmlmeext->cur_channel >= 1 &&
+					    pmlmeext->cur_channel <= 4) {
+						if (pht_info)
+							pht_info->infos[0] |=
+							    HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
+
+						pbuddy_mlmeext->cur_bwmode =
+						    HT_CHANNEL_WIDTH_40;
+						pbuddy_mlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_LOWER;
+					} else if (pmlmeext->cur_channel >= 5 &&
+						   pmlmeext->cur_channel <= 14) {
+						if (pht_info)
+							pht_info->infos[0] |=
+							    HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
+
+						pbuddy_mlmeext->cur_bwmode =
+						    HT_CHANNEL_WIDTH_40;
+						pbuddy_mlmeext->cur_ch_offset =
+						    HAL_PRIME_CHNL_OFFSET_UPPER;
+					} else {
+						switch (pmlmeext->cur_channel) {
+						case 36:
+						case 44:
+						case 52:
+						case 60:
+						case 100:
+						case 108:
+						case 116:
+						case 124:
+						case 132:
+						case 149:
+						case 157:
+							if (pht_info)
+								pht_info->
+								    infos
+								    [0]
+								    |=
+								    HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE;
+							pbuddy_mlmeext->
+							    cur_bwmode =
+							    HT_CHANNEL_WIDTH_40;
+							pbuddy_mlmeext->
+							    cur_ch_offset
+							    =
+							    HAL_PRIME_CHNL_OFFSET_LOWER;
+							break;
+						case 40:
+						case 48:
+						case 56:
+						case 64:
+						case 104:
+						case 112:
+						case 120:
+						case 128:
+						case 136:
+						case 153:
+						case 161:
+							if (pht_info)
+								pht_info->
+								    infos
+								    [0]
+								    |=
+								    HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
+
+							pbuddy_mlmeext->
+							    cur_bwmode =
+							    HT_CHANNEL_WIDTH_40;
+							pbuddy_mlmeext->
+							    cur_ch_offset
+							    =
+							    HAL_PRIME_CHNL_OFFSET_UPPER;
+							break;
+						default:
+							if (pht_info)
+								pht_info->
+								    infos[0] &=
+								    ~HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW;
+							pbuddy_mlmeext->
+							    cur_bwmode =
+							    HT_CHANNEL_WIDTH_20;
+							pbuddy_mlmeext->
+							    cur_ch_offset =
+							    HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+							break;
+						}
+					}
+				}
+
+				set_channel_bwmode(adapt,
+						   pbuddy_mlmeext->cur_channel,
+						   pbuddy_mlmeext->
+						   cur_ch_offset,
+						   pbuddy_mlmeext->cur_bwmode);
+			}
+
+			/*  to update channel value in beacon */
+			pbuddy_network_mlmeext->Configuration.DSConfig =
+			    pmlmeext->cur_channel;
+			p = rtw_get_ie((pbuddy_network_mlmeext->IEs +
+					sizeof(struct ndis_802_11_fixed_ies)),
+				       _DSSET_IE_, &ie_len,
+				       (pbuddy_network_mlmeext->IELength -
+					sizeof(struct ndis_802_11_fixed_ies)));
+			if (p && ie_len > 0)
+				*(p + 2) = pmlmeext->cur_channel;
+
+			p = rtw_get_ie((pbuddy_network_mlmeext->IEs +
+					sizeof(struct ndis_802_11_fixed_ies)),
+				       _HT_ADD_INFO_IE_, &ie_len,
+				       (pbuddy_network_mlmeext->IELength -
+					sizeof(struct ndis_802_11_fixed_ies)));
+			if (p && ie_len) {
+				pht_info = (struct HT_info_element *)(p + 2);
+				pht_info->primary_channel =
+				    pmlmeext->cur_channel;
+			}
+
+			/* buddy interface band is different from current interface, update ERP, support rate, ext support rate IE */
+			if (change_band == true)
+				change_band_update_ie(pbuddy_adapter,
+						      pbuddy_network_mlmeext);
+		} else {
+			/*  switch back to original channel/bwmode/ch_offset; */
+			set_channel_bwmode(adapt,
+					   pbuddy_mlmeext->cur_channel,
+					   pbuddy_mlmeext->cur_ch_offset,
+					   pbuddy_mlmeext->cur_bwmode);
+		}
+
+		DBG_8192D
+		    ("after join, second adapter, CH=%d, BW=%d, offset=%d\n",
+		     pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode,
+		     pbuddy_mlmeext->cur_ch_offset);
+
+		DBG_8192D("update pbuddy_adapter's beacon\n");
+
+		update_beacon(pbuddy_adapter, 0, NULL, true);
+
+	} else if (((pbuddy_mlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) &&
+		   check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) {
+		if (join_res >= 0) {
+			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
+			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+				set_channel_bwmode(adapt,
+						   pbuddy_mlmeext->cur_channel,
+						   pbuddy_mlmeext->
+						   cur_ch_offset,
+						   pbuddy_mlmeext->cur_bwmode);
+			else if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
+				set_channel_bwmode(adapt,
+						   pmlmeext->cur_channel,
+						   pmlmeext->cur_ch_offset,
+						   pmlmeext->cur_bwmode);
+			else
+				set_channel_bwmode(adapt,
+						   pmlmeext->cur_channel,
+						   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
+						   HT_CHANNEL_WIDTH_20);
+		} else {
+			/*  switch back to original channel/bwmode/ch_offset; */
+			set_channel_bwmode(adapt,
+					   pbuddy_mlmeext->cur_channel,
+					   pbuddy_mlmeext->cur_ch_offset,
+					   pbuddy_mlmeext->cur_bwmode);
+		}
+	}
+}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+u8 set_ch_hdl(struct rtw_adapter *adapt, u8 *pbuf)
+{
+	struct set_ch_parm *set_ch_parm;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	set_ch_parm = (struct set_ch_parm *)pbuf;
+
+	DBG_8192D(FUNC_NDEV_FMT " ch:%u, bw:%u, ch_offset:%u\n",
+		  FUNC_NDEV_ARG(adapt->pnetdev),
+		  set_ch_parm->ch, set_ch_parm->bw, set_ch_parm->ch_offset);
+
+	pmlmeext->cur_channel = set_ch_parm->ch;
+	pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
+	pmlmeext->cur_bwmode = set_ch_parm->bw;
+
+	set_channel_bwmode(adapt, set_ch_parm->ch, set_ch_parm->ch_offset,
+			   set_ch_parm->bw);
+
+	return H2C_SUCCESS;
+}
+
+u8 set_chplan_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	struct setchannelplan_param *setchannelplan_param;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	setchannelplan_param = (struct setchannelplan_param *)pbuf;
+
+	pmlmeext->max_chan_nums =
+	    init_channel_set(adapt, setchannelplan_param->channel_plan,
+			     pmlmeext->channel_set);
+	init_channel_list(adapt, pmlmeext->channel_set,
+			  pmlmeext->max_chan_nums, &pmlmeext->channel_list);
+
+	return H2C_SUCCESS;
+}
+
+u8 led_blink_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+#ifdef CONFIG_LED_HANDLED_BY_CMD_THREAD
+	struct LedBlink_param *ledBlink_param;
+#endif
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+#ifdef CONFIG_LED_HANDLED_BY_CMD_THREAD
+	ledBlink_param = (struct LedBlink_param *)pbuf;
+	BlinkHandler(ledBlink_param->pLed);
+#endif
+	return H2C_SUCCESS;
+}
+
+u8 set_csa_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+#ifdef CONFIG_DFS
+	struct setchannelswitch_param *setchannelswitch_param;
+	struct setchannelplan_param *setchannelplan_param;
+	struct mlme_priv *pmlmepriv = &adapt->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
+	u8 new_ch_no;
+	u8 gval8 = 0x00, sval8 = 0xff;
+
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	setchannelswitch_param = (struct setchannelswitch_param *)pbuf;
+	new_ch_no = setchannelswitch_param->new_ch_no;
+
+	rtw_hal_get_hwreg(adapt, HW_VAR_TXPAUSE, &gval8);
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_TXPAUSE, &sval8);
+
+	DBG_8192D("DFS detected! Swiching channel to %d!\n", new_ch_no);
+	SelectChannel(adapt, new_ch_no);
+
+	rtw_hal_set_hwreg(adapt, HW_VAR_TXPAUSE, &gval8);
+
+	rtw_free_network_queue(adapt, true);
+	rtw_indicate_disconnect(adapt);
+
+	if (((new_ch_no >= 52) && (new_ch_no <= 64)) ||
+	    ((new_ch_no >= 100) && (new_ch_no <= 140))) {
+		DBG_8192D("Switched to DFS band (ch %02x) again!!\n",
+			  new_ch_no);
+	}
+
+	return H2C_SUCCESS;
+#else
+	return H2C_REJECTED;
+#endif /* CONFIG_DFS */
+}
+
+/*  TDLS_WRCR		: write RCR DATA BIT */
+/*  TDLS_SD_PTI		: issue peer traffic indication */
+/*  TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure */
+/*  TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame */
+/*  TDLS_DONE_CH_SEN: channel sensing and report candidate channel */
+/*  TDLS_OFF_CH		: first time set channel to off channel */
+/*  TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel */
+/*  TDLS_P_OFF_CH	: periodically go to off channel */
+/*  TDLS_P_BASE_CH	: periodically go back to base channel */
+/*  TDLS_RS_RCR		: restore RCR */
+/*  TDLS_CKALV_PH1	: check alive timer phase1 */
+/*  TDLS_CKALV_PH2	: check alive timer phase2 */
+/*  TDLS_FREE_STA	: free tdls sta */
+u8 tdls_hdl(struct rtw_adapter *adapt, unsigned char *pbuf)
+{
+	return H2C_REJECTED;
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_p2p.c b/drivers/net/wireless/rtl8192du/core/rtw_p2p.c
new file mode 100644
index 0000000..be3195d
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_p2p.c
@@ -0,0 +1,28 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_P2P_C_
+
+#include <drv_types.h>
+#include <rtw_p2p.h>
+#include <wifi.h>
+
+void rtw_init_wifidirect_addrs(struct rtw_adapter *padapter, u8 *dev_addr, u8 *iface_addr)
+{
+}
+
+void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType)
+{
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_pwrctrl.c b/drivers/net/wireless/rtl8192du/core/rtw_pwrctrl.c
new file mode 100644
index 0000000..21b2ca6
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_pwrctrl.c
@@ -0,0 +1,1173 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_PWRCTRL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#ifdef CONFIG_IPS
+void ips_enter(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	_enter_pwrlock(&pwrpriv->lock);
+
+	pwrpriv->bips_processing = true;
+
+	/*  syn ips_mode with request */
+	pwrpriv->ips_mode = pwrpriv->ips_mode_req;
+
+	pwrpriv->ips_enter_cnts++;
+	DBG_8192D("==>ips_enter cnts:%d\n", pwrpriv->ips_enter_cnts);
+
+	if (rf_off == pwrpriv->change_rfpwrstate) {
+		if (pwrpriv->ips_mode == IPS_LEVEL_2)
+			pwrpriv->bkeepfwalive = true;
+
+		rtw_ips_pwr_down(padapter);
+		pwrpriv->rf_pwrstate = rf_off;
+	}
+	pwrpriv->bips_processing = false;
+	_exit_pwrlock(&pwrpriv->lock);
+}
+
+int ips_leave(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct security_priv *psecuritypriv = &(padapter->securitypriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int result = _SUCCESS;
+	int keyid;
+	_enter_pwrlock(&pwrpriv->lock);
+	if ((pwrpriv->rf_pwrstate == rf_off) && (!pwrpriv->bips_processing)) {
+		pwrpriv->bips_processing = true;
+		pwrpriv->change_rfpwrstate = rf_on;
+		pwrpriv->ips_leave_cnts++;
+		DBG_8192D("==>ips_leave cnts:%d\n", pwrpriv->ips_leave_cnts);
+
+		result = rtw_ips_pwr_up(padapter);
+		if (result == _SUCCESS)
+			pwrpriv->rf_pwrstate = rf_on;
+
+		if ((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) ||
+		    (_WEP104_ == psecuritypriv->dot11PrivacyAlgrthm)) {
+			DBG_8192D("==>%s,channel(%d),processing(%x)\n",
+				  __func__, padapter->mlmeextpriv.cur_channel,
+				  pwrpriv->bips_processing);
+			set_channel_bwmode(padapter,
+					   padapter->mlmeextpriv.cur_channel,
+					   HAL_PRIME_CHNL_OFFSET_DONT_CARE,
+					   HT_CHANNEL_WIDTH_20);
+			for (keyid = 0; keyid < 4; keyid++) {
+				if (pmlmepriv->key_mask & BIT(keyid)) {
+					if (keyid ==
+					    psecuritypriv->dot11PrivacyKeyIndex)
+						result =
+						    rtw_set_key(padapter,
+								psecuritypriv,
+								keyid, 1);
+					else
+						result =
+						    rtw_set_key(padapter,
+								psecuritypriv,
+								keyid, 0);
+				}
+			}
+		}
+
+		DBG_8192D("==> ips_leave.....LED(0x%08x)...\n",
+			  rtw_read32(padapter, 0x4c));
+		pwrpriv->bips_processing = false;
+
+		pwrpriv->bkeepfwalive = false;
+	}
+	_exit_pwrlock(&pwrpriv->lock);
+	return result;
+}
+
+#endif
+
+#ifdef CONFIG_AUTOSUSPEND
+extern void autosuspend_enter(struct rtw_adapter *padapter);
+extern int autoresume_enter(struct rtw_adapter *padapter);
+#endif
+
+static bool rtw_pwr_unassociated_idle(struct rtw_adapter *adapter)
+{
+	struct rtw_adapter *buddy = adapter->pbuddy_adapter;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	bool ret = false;
+
+	if (adapter->pwrctrlpriv.ips_deny_time >= rtw_get_current_time()) {
+		/* DBG_8192D("%s ips_deny_time\n", __func__); */
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
+	    check_fwstate(pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
+	    check_fwstate(pmlmepriv, WIFI_AP_STATE) ||
+	    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE))
+		goto exit;
+
+	/* consider buddy, if exist */
+	if (buddy) {
+		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
+
+		if (check_fwstate(b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
+		    check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
+		    check_fwstate(b_pmlmepriv, WIFI_AP_STATE) ||
+		    check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE)) {
+			goto exit;
+		}
+	}
+	ret = true;
+
+exit:
+	return ret;
+}
+
+void rtw_ps_processor(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	pwrpriv->ps_processing = true;
+
+	if (pwrpriv->ips_mode_req == IPS_NONE
+#ifdef CONFIG_CONCURRENT_MODE
+	    || padapter->pbuddy_adapter->pwrctrlpriv.ips_mode_req == IPS_NONE
+#endif
+	    )
+		goto exit;
+
+	if (rtw_pwr_unassociated_idle(padapter) == false)
+		goto exit;
+
+	if ((pwrpriv->rf_pwrstate == rf_on) &&
+	    ((pwrpriv->pwr_state_check_cnts % 4) == 0)) {
+		DBG_8192D("==>%s .fw_state(%x)\n", __func__,
+			  get_fwstate(pmlmepriv));
+		pwrpriv->change_rfpwrstate = rf_off;
+
+#ifdef CONFIG_AUTOSUSPEND
+		if (padapter->registrypriv.usbss_enable) {
+			if (pwrpriv->bHWPwrPindetect)
+				pwrpriv->bkeepfwalive = true;
+
+			if (padapter->net_closed == true)
+				pwrpriv->ps_flag = true;
+
+			padapter->bCardDisableWOHSM = true;
+			autosuspend_enter(padapter);
+		} else
+#endif /* CONFIG_AUTOSUSPEND */
+		{
+#ifdef CONFIG_IPS
+			ips_enter(padapter);
+#endif
+		}
+	}
+exit:
+	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
+	pwrpriv->ps_processing = false;
+	return;
+}
+
+static void pwr_state_check_handler(void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+
+	rtw_ps_cmd(padapter);
+}
+
+#ifdef CONFIG_LPS
+/*
+ *
+ * Parameters
+ *	padapter
+ *	pslv			power state level, only could be PS_STATE_S0 ~ PS_STATE_S4
+ *
+ */
+void rtw_set_rpwm(struct rtw_adapter *padapter, u8 pslv)
+{
+	u8 rpwm;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	pslv = PS_STATE(pslv);
+
+	if (pwrpriv->rpwm == pslv) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
+			 ("%s: Already set rpwm[0x%02x]!\n", __func__, pslv));
+		return;
+	}
+
+	if ((padapter->bDriverStopped == true) ||
+	    (padapter->bSurpriseRemoved == true)) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
+			 ("%s: bDriverStopped(%d) bSurpriseRemoved(%d)\n",
+			  __func__, padapter->bDriverStopped,
+			  padapter->bSurpriseRemoved));
+		return;
+	}
+
+	rpwm = pslv | pwrpriv->tog;
+#ifdef CONFIG_LPS_LCLK
+	if ((pwrpriv->cpwm < PS_STATE_S2) && (pslv >= PS_STATE_S2))
+		rpwm |= PS_ACK;
+#endif
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("rtw_set_rpwm: rpwm=0x%02x cpwm=0x%02x\n", rpwm,
+		  pwrpriv->cpwm));
+
+	pwrpriv->rpwm = pslv;
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_SET_RPWM, (u8 *)(&rpwm));
+
+	pwrpriv->tog += 0x80;
+
+	if (!(rpwm & PS_ACK))
+		pwrpriv->cpwm = pslv;
+
+}
+
+static u8 ps_rdy_check(struct rtw_adapter *padapter)
+{
+	u32 curr_time, delta_time;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	curr_time = rtw_get_current_time();
+
+	delta_time = curr_time - pwrpriv->DelayLPSLastTimeStamp;
+
+	if (delta_time < LPS_DELAY_TIME)
+		return false;
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
+	    (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		return false;
+
+	if (true == pwrpriv->bInSuspend)
+		return false;
+
+	if ((padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) &&
+	    (padapter->securitypriv.binstallGrpkey == false)) {
+		DBG_8192D("Group handshake still in progress !!!\n");
+		return false;
+	}
+	if (!rtw_cfg80211_pwr_mgmt(padapter))
+		return false;
+
+	return true;
+}
+
+void rtw_set_ps_mode(struct rtw_adapter *padapter, u8 ps_mode, u8 smart_ps)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("%s: PowerMode=%d Smart_PS=%d\n",
+		  __func__, ps_mode, smart_ps));
+
+	if (ps_mode > PM_Card_Disable) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
+			 ("ps_mode:%d error\n", ps_mode));
+		return;
+	}
+
+	if ((pwrpriv->pwr_mode == ps_mode) && (pwrpriv->smart_ps == smart_ps)) {
+		return;
+	}
+
+	/* if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) */
+	if (ps_mode == PS_MODE_ACTIVE) {
+		{
+#ifdef CONFIG_LPS_LCLK
+			_enter_pwrlock(&pwrpriv->lock);
+#endif
+			DBG_8192D
+			    ("rtw_set_ps_mode(): Busy Traffic , Leave 802.11 power save..\n");
+
+			pwrpriv->smart_ps = smart_ps;
+			pwrpriv->pwr_mode = ps_mode;
+
+			rtw_set_rpwm(padapter, PS_STATE_S4);
+#ifdef CONFIG_LPS_LCLK
+			{
+				u32 n = 0;
+				while (pwrpriv->cpwm != PS_STATE_S4) {
+					n++;
+					if (n == 10000)
+						break;
+					if (padapter->bSurpriseRemoved == true)
+						break;
+					rtw_msleep_os(1);
+				}
+				if (n == 10000)
+					printk(KERN_ERR
+					       "%s: wait CPWM to S4 too long! cpwm=0x%02x\n",
+					       __func__, pwrpriv->cpwm);
+			}
+#endif
+			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE,
+					  (u8 *)(&ps_mode));
+			pwrpriv->bFwCurrentInPSMode = false;
+#ifdef CONFIG_LPS_LCLK
+			_exit_pwrlock(&pwrpriv->lock);
+#endif
+		}
+	} else {
+		if (ps_rdy_check(padapter)) {
+#ifdef CONFIG_LPS_LCLK
+			_enter_pwrlock(&pwrpriv->lock);
+#endif
+			DBG_8192D
+			    ("rtw_set_ps_mode(): Enter 802.11 power save mode...\n");
+
+			pwrpriv->smart_ps = smart_ps;
+			pwrpriv->pwr_mode = ps_mode;
+			pwrpriv->bFwCurrentInPSMode = true;
+			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
+#ifdef CONFIG_LPS_LCLK
+			if (pwrpriv->alives == 0)
+				rtw_set_rpwm(padapter, PS_STATE_S0);
+#else
+			rtw_set_rpwm(padapter, PS_STATE_S2);
+#endif
+#ifdef CONFIG_LPS_LCLK
+			_exit_pwrlock(&pwrpriv->lock);
+#endif
+		}
+		/* else */
+		/*  */
+		/*      pwrpriv->pwr_mode = PS_MODE_ACTIVE; */
+		/*  */
+	}
+
+}
+
+/*  */
+/*	Description: */
+/*		Enter the leisure power save mode. */
+/*  */
+void rtw_lps_enter(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct rtw_adapter *buddy = padapter->pbuddy_adapter;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type != IFACE_PORT0)
+		return;		/* Skip power saving for concurrent mode port 1 */
+
+	/* consider buddy, if exist */
+	if (buddy) {
+		struct mlme_priv *b_pmlmepriv = &(buddy->mlmepriv);
+
+		if (check_fwstate
+		    (b_pmlmepriv, WIFI_ASOC_STATE | WIFI_SITE_MONITOR) ||
+		     check_fwstate(b_pmlmepriv, WIFI_UNDER_LINKING | WIFI_UNDER_WPS) ||
+		     check_fwstate(b_pmlmepriv, WIFI_AP_STATE) ||
+		     check_fwstate(b_pmlmepriv, WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE) ||
+		    rtw_is_scan_deny(buddy))
+			return;
+	}
+#endif
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
+	    (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		return;
+
+	if (true == pwrpriv->bInSuspend)
+		return;
+
+	if (pwrpriv->bLeisurePs) {
+		/*  Idle for a while if we connect to AP a while ago. */
+		if (pwrpriv->LpsIdleCount >= 2) {	/*   4 Sec */
+			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) {
+				rtw_set_ps_mode(padapter, pwrpriv->power_mgnt,
+						2);
+			}
+		} else {
+			pwrpriv->LpsIdleCount++;
+		}
+	}
+
+}
+
+/*  */
+/*	Description: */
+/*		Leave the leisure power save mode. */
+/*  */
+void rtw_lps_leave(struct rtw_adapter *padapter)
+{
+#define LPS_LEAVE_TIMEOUT_MS 100
+
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	u32 start_time;
+	bool bAwake = false;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type != IFACE_PORT0)
+		return;		/* Skip power saving for concurrent mode port 1 */
+#endif
+
+	if (pwrpriv->bLeisurePs) {
+		if (pwrpriv->pwr_mode != PS_MODE_ACTIVE) {
+			rtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0);
+
+			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) {
+				start_time = rtw_get_current_time();
+				while (1) {
+					rtw_hal_get_hwreg(padapter,
+							  HW_VAR_FWLPS_RF_ON,
+							  (u8 *)(&bAwake));
+
+					if (bAwake || padapter->bSurpriseRemoved)
+						break;
+
+					if (rtw_get_passing_time_ms(start_time) > LPS_LEAVE_TIMEOUT_MS) {
+						DBG_8192D
+						    ("Wait for FW LPS leave more than %u ms!!!\n",
+						     LPS_LEAVE_TIMEOUT_MS);
+						break;
+					}
+					rtw_usleep_os(100);
+				}
+			}
+		}
+	}
+
+}
+
+#endif
+
+/*  */
+/*  Description: Leave all power save mode: LPS, FwLPS, IPS if needed. */
+/*  Move code to function by tynli. 2010.03.26. */
+/*  */
+void LeaveAllPowerSaveMode(struct rtw_adapter *adapter)
+{
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+
+	/* DBG_8192D("%s.....\n",__func__); */
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {	/* connect */
+#ifdef CONFIG_LPS
+		/* DBG_8192D("==> leave LPS.......\n"); */
+		rtw_lps_leave(adapter);
+#endif
+	} else {
+		if (adapter->pwrctrlpriv.rf_pwrstate == rf_off) {
+#ifdef CONFIG_AUTOSUSPEND
+			if (adapter->registrypriv.usbss_enable) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+				usb_disable_autosuspend(adapter_to_dvobj
+							(adapter)->pusbdev);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 34))
+				adapter_to_dvobj(adapter)->pusbdev->autosuspend_disabled = adapter->bDisableAutosuspend;	/* autosuspend disabled by the user */
+#endif
+			} else
+#endif
+			{
+			}
+		}
+	}
+
+}
+
+#ifdef CONFIG_LPS_LCLK
+/*
+ * Caller:ISR handler...
+ *
+ * This will be called when CPWM interrupt is up.
+ *
+ * using to update cpwn of drv; and drv willl make a decision to up or down pwr level
+ */
+void cpwm_int_hdl(struct rtw_adapter *padapter,
+		  struct reportpwrstate_parm *preportpwrstate)
+{
+	struct pwrctrl_priv *pwrpriv;
+
+	pwrpriv = &padapter->pwrctrlpriv;
+	pwrpriv->cpwm = PS_STATE(preportpwrstate->state);
+	pwrpriv->cpwm_tog = preportpwrstate->state & PS_TOGGLE;
+
+	if (pwrpriv->cpwm >= PS_STATE_S2) {
+		if (pwrpriv->alives & CMD_ALIVE)
+			_rtw_up_sema(&padapter->cmdpriv.cmd_queue_sema);
+
+		if (pwrpriv->alives & XMIT_ALIVE)
+			_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
+	}
+
+exit:
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("cpwm_int_hdl: cpwm=0x%02x\n", pwrpriv->cpwm));
+
+}
+
+static inline void register_task_alive(struct pwrctrl_priv *pwrctrl, u32 tag)
+{
+	pwrctrl->alives |= tag;
+}
+
+static inline void unregister_task_alive(struct pwrctrl_priv *pwrctrl,
+					   u32 tag)
+{
+	pwrctrl->alives &= ~tag;
+}
+
+/*
+ * Caller: rtw_xmit_thread
+ *
+ * Check if the fw_pwrstate is okay for xmit.
+ * If not (cpwm is less than S3), then the sub-routine
+ * will raise the cpwm to be greater than or equal to S3.
+ *
+ * Calling Context: Passive
+ *
+ * Return Value:
+ *	 _SUCCESS	rtw_xmit_thread can write fifo/txcmd afterwards.
+ *	 _FAIL		rtw_xmit_thread can not do anything.
+ */
+s32 rtw_register_tx_alive(struct rtw_adapter *padapter)
+{
+	s32 res;
+	struct pwrctrl_priv *pwrctrl;
+
+	res = _SUCCESS;
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, XMIT_ALIVE);
+
+	if (pwrctrl->bFwCurrentInPSMode == true) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,
+			 ("rtw_register_tx_alive: cpwm=0x%02x alives=0x%08x\n",
+			  pwrctrl->cpwm, pwrctrl->alives));
+
+		if (pwrctrl->cpwm < PS_STATE_S2) {
+			if (pwrctrl->rpwm < PS_STATE_S2)
+				rtw_set_rpwm(padapter, PS_STATE_S2);
+			res = _FAIL;
+		}
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+	return res;
+}
+
+/*
+ * Caller: rtw_cmd_thread
+ *
+ * Check if the fw_pwrstate is okay for issuing cmd.
+ * If not (cpwm should be is less than S2), then the sub-routine
+ * will raise the cpwm to be greater than or equal to S2.
+ *
+ * Calling Context: Passive
+ *
+ * Return Value:
+ *	_SUCCESS	rtw_cmd_thread can issue cmds to firmware afterwards.
+ *	_FAIL		rtw_cmd_thread can not do anything.
+ */
+s32 rtw_register_cmd_alive(struct rtw_adapter *padapter)
+{
+	s32 res;
+	struct pwrctrl_priv *pwrctrl;
+
+	res = _SUCCESS;
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, CMD_ALIVE);
+
+	if (pwrctrl->bFwCurrentInPSMode == true) {
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+			 ("rtw_register_cmd_alive: cpwm=0x%02x alives=0x%08x\n",
+			  pwrctrl->cpwm, pwrctrl->alives));
+
+		if (pwrctrl->cpwm < PS_STATE_S2) {
+			if (pwrctrl->rpwm < PS_STATE_S2)
+				rtw_set_rpwm(padapter, PS_STATE_S2);
+			res = _FAIL;
+		}
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+	return res;
+}
+
+/*
+ * Caller: rx_isr
+ *
+ * Calling Context: Dispatch/ISR
+ *
+ * Return Value:
+ *	_SUCCESS
+ *	_FAIL
+ */
+s32 rtw_register_rx_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, RECV_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("rtw_register_rx_alive: cpwm=0x%02x alives=0x%08x\n",
+		  pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+	return _SUCCESS;
+}
+
+/*
+ * Caller: evt_isr or evt_thread
+ *
+ * Calling Context: Dispatch/ISR or Passive
+ *
+ * Return Value:
+ *	_SUCCESS
+ *	_FAIL
+ */
+s32 rtw_register_evt_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	register_task_alive(pwrctrl, EVT_ALIVE);
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("rtw_register_evt_alive: cpwm=0x%02x alives=0x%08x\n",
+		  pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+	return _SUCCESS;
+}
+
+/*
+ * Caller: ISR
+ *
+ * If ISR's txdone,
+ * No more pkts for TX,
+ * Then driver shall call this fun. to power down firmware again.
+ */
+void rtw_unregister_tx_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, XMIT_ALIVE);
+
+	if ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) &&
+	    (pwrctrl->bFwCurrentInPSMode == true)) {
+		if ((pwrctrl->alives == 0) && (pwrctrl->cpwm > PS_STATE_S0))
+			rtw_set_rpwm(padapter, PS_STATE_S0);
+
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+			 ("rtw_unregister_tx_alive: cpwm=0x%02x alives=0x%08x\n",
+			  pwrctrl->cpwm, pwrctrl->alives));
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+}
+
+/*
+ * Caller: ISR
+ *
+ * If all commands have been done,
+ * and no more command to do,
+ * then driver shall call this fun. to power down firmware again.
+ */
+void rtw_unregister_cmd_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, CMD_ALIVE);
+
+	if ((pwrctrl->pwr_mode != PS_MODE_ACTIVE) &&
+	    (pwrctrl->bFwCurrentInPSMode == true)) {
+		if ((pwrctrl->alives == 0) && (pwrctrl->cpwm > PS_STATE_S0))
+			rtw_set_rpwm(padapter, PS_STATE_S0);
+
+		RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+			 ("rtw_unregister_cmd_alive: cpwm=0x%02x alives=0x%08x\n",
+			  pwrctrl->cpwm, pwrctrl->alives));
+	}
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+}
+
+/*
+ * Caller: ISR
+ */
+void rtw_unregister_rx_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	_enter_pwrlock(&pwrctrl->lock);
+
+	unregister_task_alive(pwrctrl, RECV_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("rtw_unregister_rx_alive: cpwm=0x%02x alives=0x%08x\n",
+		  pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+}
+
+void rtw_unregister_evt_alive(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrl;
+
+	pwrctrl = &padapter->pwrctrlpriv;
+
+	unregister_task_alive(pwrctrl, EVT_ALIVE);
+
+	RT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,
+		 ("rtw_unregister_evt_alive: cpwm=0x%02x alives=0x%08x\n",
+		  pwrctrl->cpwm, pwrctrl->alives));
+
+	_exit_pwrlock(&pwrctrl->lock);
+
+}
+#endif /* CONFIG_LPS_LCLK */
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+static void resume_workitem_callback(struct work_struct *work);
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+void rtw_init_pwrctrl_priv(struct rtw_adapter *padapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	_init_pwrlock(&pwrctrlpriv->lock);
+	pwrctrlpriv->rf_pwrstate = rf_on;
+	pwrctrlpriv->ips_enter_cnts = 0;
+	pwrctrlpriv->ips_leave_cnts = 0;
+
+	pwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;
+	pwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;
+
+	pwrctrlpriv->pwr_state_check_interval = RTW_PWR_STATE_CHK_INTERVAL;
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+	pwrctrlpriv->bInternalAutoSuspend = false;
+	pwrctrlpriv->bInSuspend = false;
+	pwrctrlpriv->bkeepfwalive = false;
+
+	pwrctrlpriv->LpsIdleCount = 0;
+	pwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;	/*  PS_MODE_MIN; */
+	pwrctrlpriv->bLeisurePs =
+	    (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt) ? true : false;
+
+	pwrctrlpriv->bFwCurrentInPSMode = false;
+
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+
+	pwrctrlpriv->smart_ps = 0;
+
+	pwrctrlpriv->tog = 0x80;
+
+	_init_timer(&(pwrctrlpriv->pwr_state_check_timer), padapter->pnetdev,
+		    pwr_state_check_handler, (u8 *)padapter);
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	_init_workitem(&pwrctrlpriv->resume_work, resume_workitem_callback,
+		       NULL);
+	pwrctrlpriv->rtw_workqueue =
+	    create_singlethread_workqueue("rtw_workqueue");
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+	pwrctrlpriv->early_suspend.suspend = NULL;
+	rtw_register_early_suspend(pwrctrlpriv);
+#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
+
+}
+
+void rtw_free_pwrctrl_priv(struct rtw_adapter *adapter)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &adapter->pwrctrlpriv;
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	if (pwrctrlpriv->rtw_workqueue) {
+		flush_workqueue(pwrctrlpriv->rtw_workqueue);
+		destroy_workqueue(pwrctrlpriv->rtw_workqueue);
+	}
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+	rtw_unregister_early_suspend(pwrctrlpriv);
+#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
+
+	_free_pwrlock(&pwrctrlpriv->lock);
+
+}
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+extern int rtw_resume_process(struct rtw_adapter *padapter);
+static void resume_workitem_callback(struct work_struct *work)
+{
+	struct pwrctrl_priv *pwrpriv =
+	    container_of(work, struct pwrctrl_priv, resume_work);
+	struct rtw_adapter *adapter =
+	    container_of(pwrpriv, _adapter, pwrctrlpriv);
+
+	DBG_8192D("%s\n", __func__);
+	rtw_resume_process(adapter);
+}
+
+void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv)
+{
+	/*  accquire system's suspend lock preventing from falliing
+	 * asleep while resume in workqueue */
+	rtw_lock_suspend();
+	queue_work(pwrpriv->rtw_workqueue, &pwrpriv->resume_work);
+}
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+inline bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv)
+{
+	return (pwrpriv->early_suspend.suspend) ? true : false;
+}
+
+inline bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv)
+{
+	return (pwrpriv->do_late_resume) ? true : false;
+}
+
+inline void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable)
+{
+	pwrpriv->do_late_resume = enable;
+}
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+extern int rtw_resume_process(struct rtw_adapter *padapter);
+static void rtw_early_suspend(struct early_suspend *h)
+{
+	struct pwrctrl_priv *pwrpriv =
+	    container_of(h, struct pwrctrl_priv, early_suspend);
+	DBG_8192D("%s\n", __func__);
+
+	rtw_set_do_late_resume(pwrpriv, false);
+}
+
+static void rtw_late_resume(struct early_suspend *h)
+{
+	struct pwrctrl_priv *pwrpriv =
+	    container_of(h, struct pwrctrl_priv, early_suspend);
+	struct rtw_adapter *adapter =
+	    container_of(pwrpriv, struct rtw_adapter, pwrctrlpriv);
+
+	DBG_8192D("%s\n", __func__);
+	if (pwrpriv->do_late_resume) {
+		rtw_set_do_late_resume(pwrpriv, false);
+		rtw_resume_process(adapter);
+	}
+}
+
+void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv)
+{
+	DBG_8192D("%s\n", __func__);
+
+	/* jeff: set the early suspend level before blank screen,
+	 * so we wll do late resume after scree is lit */
+	pwrpriv->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+	pwrpriv->early_suspend.suspend = rtw_early_suspend;
+	pwrpriv->early_suspend.resume = rtw_late_resume;
+	register_early_suspend(&pwrpriv->early_suspend);
+}
+
+void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
+{
+	DBG_8192D("%s\n", __func__);
+
+	rtw_set_do_late_resume(pwrpriv, false);
+
+	if (pwrpriv->early_suspend.suspend)
+		unregister_early_suspend(&pwrpriv->early_suspend);
+
+	pwrpriv->early_suspend.suspend = NULL;
+	pwrpriv->early_suspend.resume = NULL;
+}
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+#ifdef CONFIG_ANDROID_POWER
+extern int rtw_resume_process(struct rtw_adapter *padapter);
+static void rtw_early_suspend(android_early_suspend_t *h)
+{
+	struct pwrctrl_priv *pwrpriv =
+	    container_of(h, struct pwrctrl_priv, early_suspend);
+	DBG_8192D("%s\n", __func__);
+
+	rtw_set_do_late_resume(pwrpriv, false);
+}
+
+static void rtw_late_resume(android_early_suspend_t *h)
+{
+	struct pwrctrl_priv *pwrpriv =
+	    container_of(h, struct pwrctrl_priv, early_suspend);
+	struct rtw_adapter *adapter =
+	    container_of(pwrpriv, _adapter, pwrctrlpriv);
+
+	DBG_8192D("%s\n", __func__);
+	if (pwrpriv->do_late_resume) {
+		rtw_set_do_late_resume(pwrpriv, false);
+		rtw_resume_process(adapter);
+	}
+}
+
+void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv)
+{
+	DBG_8192D("%s\n", __func__);
+
+	/* jeff: set the early suspend level before blank screen,
+	 * so we wll do late resume after screen is lit */
+	pwrpriv->early_suspend.level =
+	    ANDROID_EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+	pwrpriv->early_suspend.suspend = rtw_early_suspend;
+	pwrpriv->early_suspend.resume = rtw_late_resume;
+	android_register_early_suspend(&pwrpriv->early_suspend);
+}
+
+void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv)
+{
+	DBG_8192D("%s\n", __func__);
+
+	rtw_set_do_late_resume(pwrpriv, false);
+
+	if (pwrpriv->early_suspend.suspend)
+		android_unregister_early_suspend(&pwrpriv->early_suspend);
+
+	pwrpriv->early_suspend.suspend = NULL;
+	pwrpriv->early_suspend.resume = NULL;
+}
+#endif /* CONFIG_ANDROID_POWER */
+
+u8 rtw_interface_ps_func(struct rtw_adapter *padapter,
+			 enum HAL_INTF_PS_FUNC efunc_id, u8 *val)
+{
+	rtw_hal_intf_ps_func(padapter, efunc_id, val);
+	return true;
+}
+
+inline void rtw_set_ips_deny(struct rtw_adapter *padapter, u32 ms)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	pwrpriv->ips_deny_time = rtw_get_current_time() + rtw_ms_to_systime(ms);
+}
+
+/*
+* rtw_pwr_wakeup - Wake the NIC up from: 1)IPS. 2)USB autosuspend
+* @adapter: pointer to _adapter structure
+* @ips_deffer_ms: the ms wiil prevent from falling into IPS after wakeup
+* Return _SUCCESS or _FAIL
+*/
+int _rtw_pwr_wakeup(struct rtw_adapter *padapter, u32 ips_deffer_ms,
+		    const char *caller)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	int ret = _SUCCESS;
+	u32 start = rtw_get_current_time();
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->pbuddy_adapter)
+		LeaveAllPowerSaveMode(padapter->pbuddy_adapter);
+
+	if ((padapter->isprimary == false) && padapter->pbuddy_adapter) {
+		padapter = padapter->pbuddy_adapter;
+		pwrpriv = &padapter->pwrctrlpriv;
+		pmlmepriv = &padapter->mlmepriv;
+	}
+#endif
+
+	if (pwrpriv->ips_deny_time <
+	    rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms))
+		pwrpriv->ips_deny_time =
+		    rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms);
+
+	if (pwrpriv->ps_processing) {
+		DBG_8192D("%s wait ps_processing...\n", __func__);
+		while (pwrpriv->ps_processing &&
+		       rtw_get_passing_time_ms(start) <= 3000)
+			rtw_msleep_os(10);
+		if (pwrpriv->ps_processing)
+			DBG_8192D("%s wait ps_processing timeout\n", __func__);
+		else
+			DBG_8192D("%s wait ps_processing done\n", __func__);
+	}
+
+	if (pwrpriv->bInternalAutoSuspend == false && pwrpriv->bInSuspend) {
+		DBG_8192D("%s wait bInSuspend...\n", __func__);
+		while (pwrpriv->bInSuspend &&
+		       ((rtw_get_passing_time_ms(start) <= 3000 &&
+		       !rtw_is_do_late_resume(pwrpriv)) ||
+		       (rtw_get_passing_time_ms(start) <= 500 &&
+		       rtw_is_do_late_resume(pwrpriv)))) {
+			rtw_msleep_os(10);
+		}
+		if (pwrpriv->bInSuspend)
+			DBG_8192D("%s wait bInSuspend timeout\n", __func__);
+		else
+			DBG_8192D("%s wait bInSuspend done\n", __func__);
+	}
+
+	/* System suspend is not allowed to wakeup */
+	if ((pwrpriv->bInternalAutoSuspend == false) &&
+	    (true == pwrpriv->bInSuspend)) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	/* block??? */
+	if ((pwrpriv->bInternalAutoSuspend == true) &&
+	    (padapter->net_closed == true)) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	/* I think this should be check in IPS, LPS, autosuspend functions... */
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		ret = _SUCCESS;
+		goto exit;
+	}
+
+	if (rf_off == pwrpriv->rf_pwrstate) {
+#ifdef CONFIG_AUTOSUSPEND
+		if (pwrpriv->brfoffbyhw == true) {
+			DBG_8192D("hw still in rf_off state ...........\n");
+			ret = _FAIL;
+			goto exit;
+		} else if (padapter->registrypriv.usbss_enable) {
+			DBG_8192D("%s call autoresume_enter....\n", __func__);
+			if (_FAIL == autoresume_enter(padapter)) {
+				DBG_8192D
+				    ("======> autoresume fail.............\n");
+				ret = _FAIL;
+				goto exit;
+			}
+		} else
+#endif
+		{
+#ifdef CONFIG_IPS
+			DBG_8192D("%s call ips_leave....\n", __func__);
+			if (_FAIL == ips_leave(padapter)) {
+				DBG_8192D
+				    ("======> ips_leave fail.............\n");
+				ret = _FAIL;
+				goto exit;
+			}
+#endif
+		}
+	}
+
+	/* TODO: the following checking need to be merged... */
+	if (padapter->bDriverStopped || !padapter->bup ||
+	    !padapter->hw_init_completed) {
+		DBG_8192D
+		    ("%s: bDriverStopped=%d, bup=%d, hw_init_completed=%u\n",
+		     caller, padapter->bDriverStopped, padapter->bup,
+		     padapter->hw_init_completed);
+		ret = false;
+		goto exit;
+	}
+
+exit:
+	if (pwrpriv->ips_deny_time <
+	    rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms))
+		pwrpriv->ips_deny_time =
+		    rtw_get_current_time() + rtw_ms_to_systime(ips_deffer_ms);
+	return ret;
+}
+
+int rtw_pm_set_lps(struct rtw_adapter *padapter, u8 mode)
+{
+	int ret = 0;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	if (mode < PS_MODE_NUM) {
+		if (pwrctrlpriv->power_mgnt != mode) {
+			if (PS_MODE_ACTIVE == mode)
+				LeaveAllPowerSaveMode(padapter);
+			else
+				pwrctrlpriv->LpsIdleCount = 2;
+			pwrctrlpriv->power_mgnt = mode;
+			pwrctrlpriv->bLeisurePs =
+			    (PS_MODE_ACTIVE !=
+			     pwrctrlpriv->power_mgnt) ? true : false;
+		}
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+int rtw_pm_set_ips(struct rtw_adapter *padapter, u8 mode)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	if (mode == IPS_NORMAL || mode == IPS_LEVEL_2) {
+		rtw_ips_mode_req(pwrctrlpriv, mode);
+		DBG_8192D("%s %s\n", __func__,
+			  mode == IPS_NORMAL ? "IPS_NORMAL" : "IPS_LEVEL_2");
+		return 0;
+	} else if (mode == IPS_NONE) {
+		rtw_ips_mode_req(pwrctrlpriv, mode);
+		DBG_8192D("%s %s\n", __func__, "IPS_NONE");
+		if ((padapter->bSurpriseRemoved == 0) &&
+		    (_FAIL == rtw_pwr_wakeup(padapter)))
+			return -EFAULT;
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_recv.c b/drivers/net/wireless/rtl8192du/core/rtw_recv.c
new file mode 100644
index 0000000..aaeadd4
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_recv.c
@@ -0,0 +1,2585 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <linux/ip.h>
+#include <linux/if_ether.h>
+#include <ethernet.h>
+#include <usb_ops.h>
+#include <wifi.h>
+#include <usb_osintf.h>
+#include <linux/vmalloc.h>
+
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
+
+void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{
+
+	memset((u8 *)psta_recvpriv, 0, sizeof(struct sta_recv_priv));
+
+	_rtw_spinlock_init(&psta_recvpriv->lock);
+
+	/* for (i=0; i<MAX_RX_NUMBLKS; i++) */
+	/*      _rtw_init_queue(&psta_recvpriv->blk_strms[i]); */
+
+	_rtw_init_queue(&psta_recvpriv->defrag_q);
+
+}
+
+int _rtw_init_recv_priv(struct recv_priv *precvpriv,
+			struct rtw_adapter *padapter)
+{
+	int i;
+
+	struct recv_frame_hdr *precvframe;
+
+	int res = _SUCCESS;
+
+	_rtw_spinlock_init(&precvpriv->lock);
+
+	_rtw_init_queue(&precvpriv->free_recv_queue);
+	_rtw_init_queue(&precvpriv->recv_pending_queue);
+	_rtw_init_queue(&precvpriv->uc_swdec_pending_queue);
+
+	precvpriv->adapter = padapter;
+
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+
+	precvpriv->pallocated_frame_buf =
+	    vzalloc(NR_RECVFRAME * sizeof(struct recv_frame_hdr) +
+			 RXFRAME_ALIGN_SZ);
+
+	if (precvpriv->pallocated_frame_buf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	precvpriv->precv_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_frame_buf), RXFRAME_ALIGN_SZ);
+
+	precvframe = (struct recv_frame_hdr *)precvpriv->precv_frame_buf;
+
+	for (i = 0; i < NR_RECVFRAME; i++) {
+		INIT_LIST_HEAD(&(precvframe->list));
+
+		rtw_list_insert_tail(&(precvframe->list),
+				     &(precvpriv->free_recv_queue.queue));
+
+		res = rtw_os_recv_resource_alloc(padapter, precvframe);
+
+		precvframe->adapter = padapter;
+		precvframe++;
+	}
+	precvpriv->rx_pending_cnt = 1;
+
+	_rtw_init_sema(&precvpriv->allrxreturnevt, 0);
+	res = rtw_hal_init_recv_priv(padapter);
+
+	precvpriv->recvbuf_skb_alloc_fail_cnt = 0;
+	precvpriv->recvbuf_null_cnt = 0;
+	precvpriv->read_port_complete_EINPROGRESS_cnt = 0;
+	precvpriv->read_port_complete_other_urb_err_cnt = 0;
+
+	_init_timer(&precvpriv->signal_stat_timer, padapter->pnetdev,
+		    RTW_TIMER_HDL_NAME(signal_stat), padapter);
+
+	precvpriv->signal_stat_sampling_interval = 1000;	/* ms */
+
+	rtw_set_signal_stat_timer(precvpriv);
+
+exit:
+	return res;
+}
+
+static void rtw_mfree_recv_priv_lock(struct recv_priv *precvpriv)
+{
+	_rtw_spinlock_free(&precvpriv->lock);
+	_rtw_spinlock_free(&precvpriv->free_recv_queue.lock);
+	_rtw_spinlock_free(&precvpriv->recv_pending_queue.lock);
+	_rtw_spinlock_free(&precvpriv->free_recv_buf_queue.lock);
+}
+
+void _rtw_free_recv_priv(struct recv_priv *precvpriv)
+{
+	struct rtw_adapter *padapter = precvpriv->adapter;
+
+	rtw_free_uc_swdec_pending_queue(padapter);
+
+	rtw_mfree_recv_priv_lock(precvpriv);
+
+	rtw_os_recv_resource_free(precvpriv);
+
+	if (precvpriv->pallocated_frame_buf)
+		vfree(precvpriv->pallocated_frame_buf);
+
+	rtw_hal_free_recv_priv(padapter);
+
+}
+
+struct recv_frame_hdr *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue)
+{
+	struct recv_frame_hdr *hdr;
+	struct list_head *plist, *phead;
+	struct rtw_adapter *padapter;
+	struct recv_priv *precvpriv;
+
+	if (_rtw_queue_empty(pfree_recv_queue) == true) {
+		hdr = NULL;
+	} else {
+		phead = get_list_head(pfree_recv_queue);
+
+		plist = phead->next;
+
+		hdr = container_of(plist, struct recv_frame_hdr, list);
+
+		list_del_init(&hdr->list);
+		padapter = hdr->adapter;
+		if (padapter != NULL) {
+			precvpriv = &padapter->recvpriv;
+			if (pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+
+	return hdr;
+}
+
+struct recv_frame_hdr *rtw_alloc_recvframe(struct __queue *pfree_recv_queue)
+{
+	struct recv_frame_hdr *precvframe;
+
+	spin_lock_bh(&pfree_recv_queue->lock);
+
+	precvframe = _rtw_alloc_recvframe(pfree_recv_queue);
+
+	spin_unlock_bh(&pfree_recv_queue->lock);
+
+	return precvframe;
+}
+
+void rtw_init_recvframe(struct recv_frame_hdr *precvframe,
+			struct recv_priv *precvpriv)
+{
+	/* Perry: This can be removed */
+	INIT_LIST_HEAD(&precvframe->list);
+
+	precvframe->len = 0;
+}
+
+int rtw_free_recvframe(struct recv_frame_hdr *precvframe,
+		       struct __queue *pfree_recv_queue)
+{
+	struct rtw_adapter *padapter = precvframe->adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type > PRIMARY_ADAPTER) {
+		padapter = padapter->pbuddy_adapter;	/* get primary_padapter */
+		precvpriv = &padapter->recvpriv;
+		pfree_recv_queue = &precvpriv->free_recv_queue;
+		precvframe->adapter = padapter;
+	}
+#endif
+	if (precvframe->pkt) {
+		dev_kfree_skb_any(precvframe->pkt);	/* free skb by driver */
+		precvframe->pkt = NULL;
+	}
+
+	spin_lock_bh(&pfree_recv_queue->lock);
+
+	list_del_init(&(precvframe->list));
+
+	rtw_list_insert_tail(&(precvframe->list),
+			     get_list_head(pfree_recv_queue));
+
+	if (padapter != NULL) {
+		if (pfree_recv_queue == &precvpriv->free_recv_queue)
+			precvpriv->free_recvframe_cnt++;
+	}
+
+	spin_unlock_bh(&pfree_recv_queue->lock);
+
+	return _SUCCESS;
+}
+
+int _rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue)
+{
+	struct rtw_adapter *padapter = precvframe->adapter;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	/* INIT_LIST_HEAD(&(precvframe->list)); */
+	list_del_init(&(precvframe->list));
+
+	rtw_list_insert_tail(&(precvframe->list), get_list_head(queue));
+
+	if (padapter != NULL) {
+		if (queue == &precvpriv->free_recv_queue)
+			precvpriv->free_recvframe_cnt++;
+	}
+
+	return _SUCCESS;
+}
+
+int rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe, struct __queue *queue)
+{
+	int ret;
+
+	spin_lock_bh(&queue->lock);
+	ret = _rtw_enqueue_recvframe(precvframe, queue);
+	spin_unlock_bh(&queue->lock);
+
+	return ret;
+}
+
+/*
+caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spinlock to protect
+
+*/
+
+void rtw_free_recvframe_queue(struct __queue *pframequeue,
+			      struct __queue *pfree_recv_queue)
+{
+	struct recv_frame_hdr *precvframe;
+	struct list_head *plist, *phead;
+
+	_rtw_spinlock(&pframequeue->lock);
+
+	phead = get_list_head(pframequeue);
+	plist = phead->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		precvframe = container_of(plist, struct recv_frame_hdr, list);
+
+		plist = plist->next;
+
+		rtw_free_recvframe(precvframe, pfree_recv_queue);
+	}
+
+	_rtw_spinunlock(&pframequeue->lock);
+
+}
+
+u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter)
+{
+	u32 cnt = 0;
+	struct recv_frame_hdr *pending_frame;
+	while ((pending_frame =
+		rtw_alloc_recvframe(&adapter->recvpriv.
+				    uc_swdec_pending_queue))) {
+		rtw_free_recvframe(pending_frame,
+				   &adapter->recvpriv.free_recv_queue);
+		DBG_8192D("%s: dequeue uc_swdec_pending_queue\n", __func__);
+		cnt++;
+	}
+
+	return cnt;
+}
+
+int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf,
+				struct __queue *queue)
+{
+	long unsigned int irqL;
+
+	spin_lock_irqsave(&queue->lock, irqL);
+
+	list_del_init(&precvbuf->list);
+	rtw_list_insert_head(&precvbuf->list, get_list_head(queue));
+
+	spin_unlock_irqrestore(&queue->lock, irqL);
+
+	return _SUCCESS;
+}
+
+int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue)
+{
+	long unsigned int irqL;
+
+	spin_lock_irqsave(&queue->lock, irqL);
+
+	list_del_init(&precvbuf->list);
+
+	rtw_list_insert_tail(&precvbuf->list, get_list_head(queue));
+
+	spin_unlock_irqrestore(&queue->lock, irqL);
+
+	return _SUCCESS;
+}
+
+struct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue)
+{
+	long unsigned int irqL;
+	struct recv_buf *precvbuf;
+	struct list_head *plist, *phead;
+
+	spin_lock_irqsave(&queue->lock, irqL);
+
+	if (_rtw_queue_empty(queue) == true) {
+		precvbuf = NULL;
+	} else {
+		phead = get_list_head(queue);
+
+		plist = phead->next;
+
+		precvbuf = container_of(plist, struct recv_buf, list);
+
+		list_del_init(&precvbuf->list);
+	}
+	spin_unlock_irqrestore(&queue->lock, irqL);
+	return precvbuf;
+}
+
+static int recvframe_chkmic(struct rtw_adapter *adapter, struct recv_frame_hdr *precvframe)
+{
+	int i, res = _SUCCESS;
+	u32 datalen;
+	u8 miccode[8];
+	u8 bmic_err = false, brpt_micerror = true;
+	u8 *pframe, *payload, *pframemic;
+	u8 *mickey;
+	/* u8   *iv,rxdata_key_idx=0; */
+	struct sta_info *stainfo;
+	struct rx_pkt_attrib *prxattrib = &precvframe->attrib;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+
+	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	stainfo = rtw_get_stainfo(&adapter->stapriv, &prxattrib->ta[0]);
+
+	if (prxattrib->encrypt == _TKIP_) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("\n recvframe_chkmic:prxattrib->encrypt ==_TKIP_\n"));
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("\n recvframe_chkmic:da=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+			  prxattrib->ra[0], prxattrib->ra[1], prxattrib->ra[2],
+			  prxattrib->ra[3], prxattrib->ra[4],
+			  prxattrib->ra[5]));
+
+		/* calculate mic code */
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				/* mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0]; */
+				/* iv = precvframe->rx_data+prxattrib->hdrlen; */
+				/* rxdata_key_idx =(((iv[3])>>6)&0x3) ; */
+				mickey =
+				    &psecuritypriv->
+				    dot118021XGrprxmickey[prxattrib->key_index].
+				    skey[0];
+
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+					 ("\n recvframe_chkmic: bcmc key\n"));
+				/* DBG_8192D("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n", */
+				/*                                                              psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx); */
+
+				if (psecuritypriv->binstallGrpkey == false) {
+					res = _FAIL;
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 ("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n"));
+					DBG_8192D
+					    ("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n");
+					goto exit;
+				}
+			} else {
+				mickey = &stainfo->dot11tkiprxmickey.skey[0];
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("\n recvframe_chkmic: unicast key\n"));
+			}
+
+			datalen = precvframe->len - prxattrib->hdrlen - prxattrib->iv_len - prxattrib->icv_len - 8;	/* icv_len included the mic code */
+			pframe = precvframe->rx_data;
+			payload =
+			    pframe + prxattrib->hdrlen + prxattrib->iv_len;
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("\n prxattrib->iv_len=%d prxattrib->icv_len=%d\n",
+				  prxattrib->iv_len, prxattrib->icv_len));
+
+			rtw_seccalctkipmic(mickey, pframe, payload, datalen, &miccode[0], (unsigned char)prxattrib->priority);	/* care the length of the data */
+
+			pframemic = payload + datalen;
+
+			bmic_err = false;
+
+			for (i = 0; i < 8; i++) {
+				if (miccode[i] != *(pframemic + i)) {
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 ("recvframe_chkmic:miccode[%d](%02x) != *(pframemic+%d)(%02x) ",
+						  i, miccode[i], i,
+						  *(pframemic + i)));
+					bmic_err = true;
+				}
+			}
+
+			if (bmic_err == true) {
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("\n *(pframemic-8)-*(pframemic-1)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					  *(pframemic - 8), *(pframemic - 7),
+					  *(pframemic - 6), *(pframemic - 5),
+					  *(pframemic - 4), *(pframemic - 3),
+					  *(pframemic - 2), *(pframemic - 1)));
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("\n *(pframemic-16)-*(pframemic-9)=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
+					  *(pframemic - 16), *(pframemic - 15),
+					  *(pframemic - 14), *(pframemic - 13),
+					  *(pframemic - 12), *(pframemic - 11),
+					  *(pframemic - 10), *(pframemic - 9)));
+
+				{
+					uint i;
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 ("\n ======demp packet (len=%d)======\n",
+						  precvframe->len));
+					for (i = 0; i < precvframe->len;
+					     i = i + 8) {
+						RT_TRACE
+						    (_module_rtl871x_recv_c_,
+						     _drv_err_,
+						     ("0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x",
+						      *(precvframe->
+							rx_data + i),
+						      *(precvframe->
+							rx_data + i + 1),
+						      *(precvframe->
+							rx_data + i + 2),
+						      *(precvframe->
+							rx_data + i + 3),
+						      *(precvframe->
+							rx_data + i + 4),
+						      *(precvframe->
+							rx_data + i + 5),
+						      *(precvframe->
+							rx_data + i + 6),
+						      *(precvframe->
+							rx_data + i + 7)));
+					}
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 ("\n ======demp packet end [len=%d]======\n",
+						  precvframe->len));
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_, ("\n hrdlen=%d,\n",
+							     prxattrib->
+							     hdrlen));
+				}
+
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("ra=0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x psecuritypriv->binstallGrpkey=%d ",
+					  prxattrib->ra[0], prxattrib->ra[1],
+					  prxattrib->ra[2], prxattrib->ra[3],
+					  prxattrib->ra[4], prxattrib->ra[5],
+					  psecuritypriv->binstallGrpkey));
+
+				/*  double check key_index for some timing issue , */
+				/*  cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue */
+				if ((IS_MCAST(prxattrib->ra) == true) &&
+				    (prxattrib->key_index != pmlmeinfo->key_index))
+					brpt_micerror = false;
+
+				if (brpt_micerror == true) {
+					rtw_handle_tkip_mic_err(adapter,
+								(u8)
+								IS_MCAST
+								(prxattrib->
+								 ra));
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 (" mic error :prxattrib->bdecrypted=%d\n",
+						  brpt_micerror));
+					DBG_8192D
+					    (" mic error :brpt_micerror=%d\n",
+					     brpt_micerror);
+				}
+
+				res = _FAIL;
+
+			} else {
+				/* mic checked ok */
+				if ((psecuritypriv->bcheck_grpkey == false) &&
+				    (IS_MCAST(prxattrib->ra) == true)) {
+					psecuritypriv->bcheck_grpkey = true;
+					RT_TRACE(_module_rtl871x_recv_c_,
+						 _drv_err_,
+						 ("psecuritypriv->bcheck_grpkey =true"));
+				}
+			}
+
+		} else {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("recvframe_chkmic: rtw_get_stainfo==NULL!!!\n"));
+		}
+
+		recvframe_pull_tail(precvframe, 8);
+	}
+exit:
+
+	return res;
+}
+
+/* decrypt and set the ivlen,icvlen of the recv_frame */
+static struct recv_frame_hdr *decryptor(struct rtw_adapter *padapter,
+				   struct recv_frame_hdr *precv_frame)
+{
+	struct rx_pkt_attrib *prxattrib = &precv_frame->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct recv_frame_hdr *return_packet = precv_frame;
+	u32 res = _SUCCESS;
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+		 ("prxstat->decrypted=%x prxattrib->encrypt = 0x%03x\n",
+		  prxattrib->bdecrypted, prxattrib->encrypt));
+
+	if (prxattrib->encrypt > 0) {
+		u8 *iv = precv_frame->rx_data + prxattrib->hdrlen;
+		prxattrib->key_index = (((iv[3]) >> 6) & 0x3);
+
+		if (prxattrib->key_index > WEP_KEYS) {
+			DBG_8192D("prxattrib->key_index(%d) > WEP_KEYS\n",
+				  prxattrib->key_index);
+
+			switch (prxattrib->encrypt) {
+			case _WEP40_:
+			case _WEP104_:
+				prxattrib->key_index =
+				    psecuritypriv->dot11PrivacyKeyIndex;
+				break;
+			case _TKIP_:
+			case _AES_:
+			default:
+				prxattrib->key_index =
+				    psecuritypriv->dot118021XGrpKeyid;
+				break;
+			}
+		}
+	}
+
+	if ((prxattrib->encrypt > 0) &&
+	    ((prxattrib->bdecrypted == 0) ||
+	     (psecuritypriv->sw_decrypt == true))) {
+#ifdef CONFIG_CONCURRENT_MODE
+		if (!IS_MCAST(prxattrib->ra))	/* bc/mc packets use sw decryption for concurrent mode */
+#endif
+			psecuritypriv->hw_decrypted = false;
+
+#ifdef DBG_RX_DECRYPTOR
+		DBG_8192D
+		    ("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n",
+		     prxattrib->bdecrypted, prxattrib->encrypt,
+		     psecuritypriv->hw_decrypted);
+#endif
+
+		switch (prxattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			rtw_wep_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _TKIP_:
+			res = rtw_tkip_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		case _AES_:
+			res = rtw_aes_decrypt(padapter, (u8 *)precv_frame);
+			break;
+		default:
+			break;
+		}
+	} else if (prxattrib->bdecrypted == 1 && prxattrib->encrypt > 0 &&
+		   (psecuritypriv->busetkipkey == 1 ||
+		   prxattrib->encrypt != _TKIP_)) {
+		psecuritypriv->hw_decrypted = true;
+#ifdef DBG_RX_DECRYPTOR
+		DBG_8192D
+		    ("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n",
+		     prxattrib->bdecrypted, prxattrib->encrypt,
+		     psecuritypriv->hw_decrypted);
+#endif
+
+	} else {
+#ifdef DBG_RX_DECRYPTOR
+		DBG_8192D
+		    ("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  psecuritypriv->hw_decrypted:%d\n",
+		     prxattrib->bdecrypted, prxattrib->encrypt,
+		     psecuritypriv->hw_decrypted);
+#endif
+	}
+
+	if (res == _FAIL) {
+		rtw_free_recvframe(return_packet,
+				   &padapter->recvpriv.free_recv_queue);
+		return_packet = NULL;
+	}
+
+	return return_packet;
+}
+
+/* set the security information in the recv_frame */
+static struct recv_frame_hdr *portctrl(struct rtw_adapter *adapter,
+				  struct recv_frame_hdr *precv_frame)
+{
+	u8 *psta_addr, *ptr;
+	uint auth_alg;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct sta_priv *pstapriv;
+	struct recv_frame_hdr *prtnframe;
+	u16 ether_type = 0;
+	u16 eapol_type = 0x888e;	/* for Funia BD's WPA issue */
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	__be16 be_tmp;
+
+	pstapriv = &adapter->stapriv;
+	ptr = get_recvframe_data(precv_frame);
+	pfhdr = precv_frame;
+	psta_addr = pfhdr->attrib.ta;
+	psta = rtw_get_stainfo(pstapriv, psta_addr);
+
+	auth_alg = adapter->securitypriv.dot11AuthAlgrthm;
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+		 ("########portctrl:adapter->securitypriv.dot11AuthAlgrthm= 0x%d\n",
+		  adapter->securitypriv.dot11AuthAlgrthm));
+
+	if (auth_alg == 2) {
+		if ((psta != NULL) && (psta->ieee8021x_blocked)) {
+			/* blocked */
+			/* only accept EAPOL frame */
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("########portctrl:psta->ieee8021x_blocked==1\n"));
+
+			prtnframe = precv_frame;
+
+			/* get ether_type */
+			ptr =
+			    ptr + pfhdr->attrib.hdrlen + pfhdr->attrib.iv_len +
+			    LLC_HEADER_SIZE;
+			memcpy(&be_tmp, ptr, 2);
+			ether_type = ntohs(be_tmp);
+
+			if (ether_type == eapol_type) {
+				prtnframe = precv_frame;
+			} else {
+				/* free this frame */
+				rtw_free_recvframe(precv_frame,
+						   &adapter->recvpriv.
+						   free_recv_queue);
+				prtnframe = NULL;
+			}
+		} else {
+			/* allowed */
+			/* check decryption status, and decrypt the frame if needed */
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("########portctrl:psta->ieee8021x_blocked==0\n"));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("portctrl:precv_frame->hdr.attrib.privacy=%x\n",
+				  precv_frame->attrib.privacy));
+
+			if (pattrib->bdecrypted == 0)
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+					 ("portctrl:prxstat->decrypted=%x\n",
+					  pattrib->bdecrypted));
+
+			prtnframe = precv_frame;
+			/* check is the EAPOL frame or not (Rekey) */
+			if (ether_type == eapol_type) {
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("########portctrl:ether_type == 0x888e\n"));
+				/* check Rekey */
+
+				prtnframe = precv_frame;
+			} else {
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+					 ("########portctrl:ether_type = 0x%.4x\n",
+					  ether_type));
+			}
+		}
+	} else {
+		prtnframe = precv_frame;
+	}
+
+	return prtnframe;
+}
+
+static int recv_decache(struct recv_frame_hdr *precv_frame, u8 bretry,
+			struct stainfo_rxcache *prxcache)
+{
+	int tid = precv_frame->attrib.priority;
+
+	u16 seq_ctrl = ((precv_frame->attrib.seq_num & 0xffff) << 4) |
+	    (precv_frame->attrib.frag_num & 0xf);
+
+	if (tid > 15) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+			 ("recv_decache, (tid>15)! seq_ctrl=0x%x, tid=0x%x\n",
+			  seq_ctrl, tid));
+
+		return _FAIL;
+	}
+
+	if (1) {		/* if (bretry) */
+		if (seq_ctrl == prxcache->tid_rxseq[tid]) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("recv_decache, seq_ctrl=0x%x, tid=0x%x, tid_rxseq=0x%x\n",
+				  seq_ctrl, tid, prxcache->tid_rxseq[tid]));
+
+			return _FAIL;
+		}
+	}
+
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+
+	return _SUCCESS;
+}
+
+static void process_pwrbit_data(struct rtw_adapter *padapter,
+			        struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_92D_AP_MODE
+	unsigned char pwrbit;
+	u8 *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *psta = NULL;
+
+	psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+	pwrbit = GetPwrMgt(ptr);
+
+	if (psta) {
+		if (pwrbit) {
+			if (!(psta->state & WIFI_SLEEP_STATE))
+				stop_sta_xmit(padapter, psta);
+		} else {
+			if (psta->state & WIFI_SLEEP_STATE)
+				wakeup_sta_to_xmit(padapter, psta);
+		}
+	}
+#endif
+}
+
+void process_wmmps_data(struct rtw_adapter *padapter,
+			struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_92D_AP_MODE
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *psta = NULL;
+
+	psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+	if (!psta)
+		return;
+
+	if (!psta->qos_option)
+		return;
+
+	if (!(psta->qos_info & 0xf))
+		return;
+
+	if (psta->state & WIFI_SLEEP_STATE) {
+		u8 wmmps_ac = 0;
+
+		switch (pattrib->priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk & BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi & BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo & BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be & BIT(1);
+			break;
+		}
+
+		if (wmmps_ac) {
+			if (psta->sleepq_ac_len > 0) {
+				/* process received triggered frame */
+				xmit_delivery_enabled_frames(padapter, psta);
+			} else {
+				/* issue one qos null frame with More data bit = 0 and the EOSP bit set (=1) */
+				issue_qos_nulldata(padapter, psta->hwaddr,
+						   (u16) pattrib->priority, 0,
+						   0);
+			}
+		}
+	}
+
+#endif
+}
+
+static void count_rx_stats(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe,
+			   struct sta_info *sta)
+{
+	int sz;
+	struct sta_info *psta = NULL;
+	struct stainfo_stats *pstats = NULL;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	sz = prframe->len;
+	precvpriv->rx_bytes += sz;
+
+	padapter->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
+
+	if ((!MacAddr_isBcst(pattrib->dst)) && (!IS_MCAST(pattrib->dst)))
+		padapter->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;
+
+	if (sta)
+		psta = sta;
+	else
+		psta = prframe->psta;
+
+	if (psta) {
+		pstats = &psta->sta_stats;
+
+		pstats->rx_data_pkts++;
+		pstats->rx_bytes += sz;
+	}
+}
+
+static int sta2sta_data_frame(struct rtw_adapter *adapter,
+		       struct recv_frame_hdr *precv_frame, struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->rx_data;
+	int ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	u8 *sta_addr = NULL;
+	int bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+	    (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		/*  filter packets that SA is myself or multicast or broadcast */
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 (" SA==myself\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast)) {
+			ret = _FAIL;
+			goto exit;
+		}
+
+		if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {
+			ret = _FAIL;
+			goto exit;
+		}
+
+		sta_addr = pattrib->src;
+
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		/*  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address */
+		if (!_rtw_memcmp
+		    (pattrib->bssid, pattrib->src, ETH_ALEN)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("bssid != TA under STATION_MODE; drop pkt\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+		sta_addr = pattrib->bssid;
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		if (bmcast) {
+			/*  For AP mode, if DA == MCAST, then BSSID should be also MCAST */
+			if (!IS_MCAST(pattrib->bssid)) {
+				ret = _FAIL;
+				goto exit;
+			}
+		} else {	/*  not mc-frame */
+
+			/*  For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID */
+			if (!_rtw_memcmp
+			    (pattrib->bssid, pattrib->dst, ETH_ALEN)) {
+				ret = _FAIL;
+				goto exit;
+			}
+
+			sta_addr = pattrib->src;
+		}
+
+	} else if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		sta_addr = mybssid;
+	} else {
+		ret = _FAIL;
+	}
+
+	if (bmcast)
+		*psta = rtw_get_bcmc_stainfo(adapter);
+	else
+		*psta = rtw_get_stainfo(pstapriv, sta_addr);	/*  get ap_info */
+
+	if (*psta == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("can't get psta under sta2sta_data_frame ; drop pkt\n"));
+		ret = _FAIL;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int ap2sta_data_frame(struct rtw_adapter *adapter,
+			     struct recv_frame_hdr *precv_frame, struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	int ret = _SUCCESS;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	u8 *mybssid = get_bssid(pmlmepriv);
+	u8 *myhwaddr = myid(&adapter->eeprompriv);
+	int bmcast = IS_MCAST(pattrib->dst);
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) &&
+	    (check_fwstate(pmlmepriv, _FW_LINKED) == true ||
+	    check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true)) {
+		/*  filter packets that SA is myself or multicast or broadcast */
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 (" SA==myself\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  da should be for me */
+		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)) && (!bmcast)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 (" ap2sta_data_frame:  compare DA fail; DA=%pM\n",
+				  pattrib->dst));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		/*  check BSSID */
+		if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		    (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 (" ap2sta_data_frame:  compare BSSID fail ; BSSID=%pM\n",
+				  pattrib->bssid));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("mybssid=%pM\n", mybssid));
+			if (!bmcast) {
+				DBG_8192D
+				    ("issue_deauth to the nonassociated ap=%pM for the reason(7)\n",
+				     pattrib->bssid);
+				issue_deauth(adapter, pattrib->bssid,
+					     WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+			}
+
+			ret = _FAIL;
+			goto exit;
+		}
+
+		if (bmcast)
+			*psta = rtw_get_bcmc_stainfo(adapter);
+		else
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);	/*  get ap_info */
+
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+		if (GetFrameSubType(ptr) & BIT(6)) {
+			/* No data, will not indicate to upper layer, temporily count it here */
+			count_rx_stats(adapter, precv_frame, *psta);
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+
+	} else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) &&
+		   (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		/*  */
+		memcpy(pattrib->bssid, mybssid, ETH_ALEN);
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);	/*  get sta_info */
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("can't get psta under MP_MODE ; drop pkt\n"));
+			ret = _FAIL;
+			goto exit;
+		}
+
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		/* Special case */
+		ret = RTW_RX_HANDLED;
+		goto exit;
+	} else {
+		if (_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN) && (!bmcast)) {
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid);	/*  get sta_info */
+			if (*psta == NULL) {
+				DBG_8192D
+				    ("issue_deauth to the ap=%pM for the reason(7)\n",
+				     pattrib->bssid);
+
+				issue_deauth(adapter, pattrib->bssid,
+					     WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+			}
+		}
+
+		ret = _FAIL;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int sta2ap_data_frame(struct rtw_adapter *adapter,
+			     struct recv_frame_hdr *precv_frame, struct sta_info **psta)
+{
+	u8 *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &adapter->stapriv;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+	unsigned char *mybssid = get_bssid(pmlmepriv);
+	int ret = _SUCCESS;
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		/* For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
+		if (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) {
+			ret = _FAIL;
+			goto exit;
+		}
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->src);
+		if (*psta == NULL) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("can't get psta under AP_MODE; drop pkt\n"));
+			DBG_8192D("issue_deauth to sta=%pM for the reason(7)\n",
+				  pattrib->src);
+
+			issue_deauth(adapter, pattrib->src,
+				     WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+
+		process_pwrbit_data(adapter, precv_frame);
+
+		if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) ==
+		    WIFI_QOS_DATA_TYPE) {
+			process_wmmps_data(adapter, precv_frame);
+		}
+
+		if (GetFrameSubType(ptr) & BIT(6)) {
+			/* No data, will not indicate to upper layer, temporily count it here */
+			count_rx_stats(adapter, precv_frame, *psta);
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+	} else {
+		u8 *myhwaddr = myid(&adapter->eeprompriv);
+		if (!_rtw_memcmp(pattrib->ra, myhwaddr, ETH_ALEN)) {
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+		DBG_8192D("issue_deauth to sta=%pM for the reason(7)\n",
+			  pattrib->src);
+		issue_deauth(adapter, pattrib->src,
+			     WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+		ret = RTW_RX_HANDLED;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int validate_recv_ctrl_frame(struct rtw_adapter *padapter,
+			     struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_92D_AP_MODE
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	u8 *pframe = precv_frame->rx_data;
+	/* uint len = precv_frame->len; */
+
+	/* DBG_8192D("+validate_recv_ctrl_frame\n"); */
+
+	if (GetFrameType(pframe) != WIFI_CTRL_TYPE) {
+		return _FAIL;
+	}
+
+	/* receive the frames that ra(a1) is my address */
+	if (!_rtw_memcmp
+	    (GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN))
+		return _FAIL;
+
+	/* only handle ps-poll */
+	if (GetFrameSubType(pframe) == WIFI_PSPOLL) {
+		u16 aid;
+		u8 wmmps_ac = 0;
+		struct sta_info *psta = NULL;
+
+		aid = GetAid(pframe);
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+
+		if ((psta == NULL) || (psta->aid != aid))
+			return _FAIL;
+
+		/* for rx pkt statistics */
+		psta->sta_stats.rx_ctrl_pkts++;
+
+		switch (pattrib->priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk & BIT(0);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi & BIT(0);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo & BIT(0);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be & BIT(0);
+			break;
+		}
+
+		if (wmmps_ac)
+			return _FAIL;
+
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE) {
+			DBG_8192D("%s alive check-rx ps-poll\n", __func__);
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		if ((psta->state & WIFI_SLEEP_STATE) && (pstapriv->sta_dz_bitmap & BIT(psta->aid))) {
+			struct list_head *xmitframe_plist, *xmitframe_phead;
+			struct xmit_frame *pxmitframe = NULL;
+
+			spin_lock_bh(&psta->sleep_q.lock);
+
+			xmitframe_phead = get_list_head(&psta->sleep_q);
+			xmitframe_plist = xmitframe_phead->next;
+
+			if ((rtw_end_of_queue_search
+			     (xmitframe_phead, xmitframe_plist)) == false) {
+				pxmitframe =
+				    container_of(xmitframe_plist,
+						   struct xmit_frame, list);
+
+				xmitframe_plist = xmitframe_plist->next;
+
+				list_del_init(&pxmitframe->list);
+
+				psta->sleepq_len--;
+
+				if (psta->sleepq_len > 0)
+					pxmitframe->attrib.mdata = 1;
+				else
+					pxmitframe->attrib.mdata = 0;
+
+				pxmitframe->attrib.triggered = 1;
+
+				/* DBG_8192D("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap); */
+
+				spin_unlock_bh(&psta->sleep_q.lock);
+				if (rtw_hal_xmit(padapter, pxmitframe) == true)
+					rtw_os_xmit_complete(padapter, pxmitframe);
+				spin_lock_bh(&psta->sleep_q.lock);
+
+				if (psta->sleepq_len == 0) {
+					pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+					/* upate BCN for TIM IE */
+					update_beacon(padapter, _TIM_IE_, NULL,
+						      false);
+				}
+			} else {
+				if (pstapriv->tim_bitmap & BIT(psta->aid)) {
+					if (psta->sleepq_len == 0) {
+						DBG_8192D
+						    ("no buffered packets to xmit\n");
+
+						/* issue nulldata with More data bit = 0 to indicate we have no buffered packets */
+						issue_nulldata(padapter,
+							       psta->hwaddr, 0,
+							       0, 0);
+					} else {
+						DBG_8192D
+						    ("error!psta->sleepq_len=%d\n",
+						     psta->sleepq_len);
+						psta->sleepq_len = 0;
+					}
+					pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+					/* upate BCN for TIM IE */
+					/* update_BCNTIM(padapter); */
+					update_beacon(padapter, _TIM_IE_, NULL,
+						      false);
+				}
+			}
+			spin_unlock_bh(&psta->sleep_q.lock);
+		}
+	}
+#endif
+
+	return _FAIL;
+}
+
+struct recv_frame_hdr *recvframe_chk_defrag(struct rtw_adapter *padapter,
+				       struct recv_frame_hdr *precv_frame);
+static int validate_recv_mgnt_frame(struct rtw_adapter *padapter,
+			     struct recv_frame_hdr *precv_frame)
+{
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+		 ("+validate_recv_mgnt_frame\n"));
+
+	precv_frame = recvframe_chk_defrag(padapter, precv_frame);
+	if (precv_frame == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+			 ("%s: fragment packet\n", __func__));
+		return _SUCCESS;
+	}
+
+	{
+		/* for rx pkt statistics */
+		struct sta_info *psta =
+		    rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(precv_frame->rx_data));
+		if (psta) {
+			psta->sta_stats.rx_mgnt_pkts++;
+			if (GetFrameSubType(precv_frame->rx_data) == WIFI_BEACON) {
+				psta->sta_stats.rx_beacon_pkts++;
+			} else if (GetFrameSubType(precv_frame->rx_data) == WIFI_PROBEREQ) {
+				psta->sta_stats.rx_probereq_pkts++;
+			} else if (GetFrameSubType(precv_frame->rx_data) == WIFI_PROBERSP) {
+				if (_rtw_memcmp(padapter->eeprompriv.mac_addr, GetAddr1Ptr(precv_frame->rx_data), ETH_ALEN) == true)
+					psta->sta_stats.rx_probersp_pkts++;
+				else if (is_broadcast_mac_addr(GetAddr1Ptr(precv_frame->rx_data)) ||
+					 is_multicast_mac_addr(GetAddr1Ptr(precv_frame->rx_data)))
+					psta->sta_stats.rx_probersp_bm_pkts++;
+				else
+					psta->sta_stats.rx_probersp_uo_pkts++;
+			}
+		}
+	}
+
+	mgt_dispatcher(padapter, precv_frame);
+
+	return _SUCCESS;
+}
+
+static int validate_recv_data_frame(struct rtw_adapter *adapter,
+			     struct recv_frame_hdr *precv_frame)
+{
+	u8 bretry;
+	u8 *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+	u8 *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct security_priv *psecuritypriv = &adapter->securitypriv;
+	int ret = _SUCCESS;
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+
+	if (pbssid == NULL) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	memcpy(pattrib->dst, pda, ETH_ALEN);
+	memcpy(pattrib->src, psa, ETH_ALEN);
+
+	memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+
+	switch (pattrib->to_fr_ds) {
+	case 0:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		ret = sta2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 1:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, pbssid, ETH_ALEN);
+		ret = ap2sta_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 2:
+		memcpy(pattrib->ra, pbssid, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		ret = sta2ap_data_frame(adapter, precv_frame, &psta);
+		break;
+	case 3:
+		memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+		ret = _FAIL;
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, (" case 3\n"));
+		break;
+	default:
+		ret = _FAIL;
+		break;
+	}
+
+	if (ret == _FAIL) {
+		goto exit;
+	} else if (ret == RTW_RX_HANDLED) {
+		goto exit;
+	}
+
+	if (psta == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 (" after to_fr_ds_chk; psta==NULL\n"));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	/* psta->rssi = prxcmd->rssi; */
+	/* psta->signal_quality= prxcmd->sq; */
+	precv_frame->psta = psta;
+
+	pattrib->amsdu = 0;
+	pattrib->ack_policy = 0;
+	/* parsing QC field */
+	if (pattrib->qos == 1) {
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy = GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));
+		pattrib->hdrlen = pattrib->to_fr_ds == 3 ? 32 : 26;
+
+		if (pattrib->priority != 0 && pattrib->priority != 3)
+			adapter->recvpriv.bIsAnyNonBEPkts = true;
+	} else {
+		pattrib->priority = 0;
+		pattrib->hdrlen = pattrib->to_fr_ds == 3 ? 30 : 24;
+	}
+
+	if (pattrib->order) {	/* HT-CTRL 11n */
+		pattrib->hdrlen += 4;
+	}
+
+	precv_frame->preorder_ctrl =
+	    &psta->recvreorder_ctrl[pattrib->priority];
+
+	/*  decache, drop duplicate recv packets */
+	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) ==
+	    _FAIL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("decache : drop pkt\n"));
+		ret = _FAIL;
+		goto exit;
+	}
+
+	if (pattrib->privacy) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("validate_recv_data_frame:pattrib->privacy=%x\n",
+			  pattrib->privacy));
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("\n ^^^^^^^^^^^IS_MCAST(pattrib->ra(0x%02x))=%d^^^^^^^^^^^^^^^6\n",
+			  pattrib->ra[0], IS_MCAST(pattrib->ra)));
+
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt,
+			       IS_MCAST(pattrib->ra));
+
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("\n pattrib->encrypt=%d\n", pattrib->encrypt));
+
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len,
+			       pattrib->encrypt);
+	} else {
+		pattrib->encrypt = 0;
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int validate_recv_frame(struct rtw_adapter *adapter,
+			struct recv_frame_hdr *precv_frame)
+{
+	/* shall check frame subtype, to / from ds, da, bssid 
+	 * then call check if rx seq/frag. duplicated. */
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sk_buff *skb = precv_frame->pkt;
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
+#endif
+	u8 type;
+	u8 subtype;
+	int retval = _SUCCESS;
+	u16 seq_ctrl, fctl;
+	u8 ver;
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
+		int ch_set_idx =
+		    rtw_ch_set_search_ch(pmlmeext->channel_set,
+					 rtw_get_oper_ch(adapter));
+		if (ch_set_idx >= 0)
+			pmlmeext->channel_set[ch_set_idx].rx_count++;
+	}
+#endif
+
+	fctl = le16_to_cpu(hdr->frame_control);
+	ver = fctl & IEEE80211_FCTL_VERS;
+	type = fctl & IEEE80211_FCTL_FTYPE;
+	subtype = fctl & IEEE80211_FCTL_STYPE;
+
+	/* add version chk */
+	if (ver != 0) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("validate_recv_data_frame fail! (ver!=0)\n"));
+		retval = _FAIL;
+		goto exit;
+	}
+
+	seq_ctrl = le16_to_cpu(hdr->seq_ctrl);
+	pattrib->frag_num = seq_ctrl & IEEE80211_SCTL_FRAG;
+	pattrib->seq_num = seq_ctrl >> 4;
+
+	pattrib->to_fr_ds = get_tofr_ds(precv_frame->rx_data);
+
+	pattrib->pw_save = ieee80211_has_pm(hdr->frame_control);
+	pattrib->mfrag = ieee80211_has_morefrags(hdr->frame_control);
+	pattrib->mdata = ieee80211_has_moredata(hdr->frame_control);
+	pattrib->privacy = ieee80211_has_protected(hdr->frame_control);
+	pattrib->order = ieee80211_has_order(hdr->frame_control);
+
+	switch (type) {
+	case IEEE80211_FTYPE_MGMT:
+		retval = validate_recv_mgnt_frame(adapter, precv_frame);
+		if (retval == _FAIL)
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("validate_recv_mgnt_frame fail\n"));
+		retval = _FAIL;	/*  only data frame return _SUCCESS */
+		break;
+	case IEEE80211_FTYPE_CTL:
+		retval = validate_recv_ctrl_frame(adapter, precv_frame);
+		if (retval == _FAIL)
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("validate_recv_ctrl_frame fail\n"));
+		retval = _FAIL;	/*  only data frame return _SUCCESS */
+		break;
+	case IEEE80211_FTYPE_DATA:
+		rtw_led_control(adapter, LED_CTL_RX);
+		pattrib->qos = (subtype & BIT(7)) ? 1 : 0;
+		retval = validate_recv_data_frame(adapter, precv_frame);
+		if (retval == _FAIL) {
+			struct recv_priv *precvpriv = &adapter->recvpriv;
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("validate_recv_data_frame fail\n"));
+			precvpriv->rx_drop++;
+		}
+		break;
+	default:
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("validate_recv_data_frame fail! type=0x%x\n", type));
+		retval = _FAIL;
+		break;
+	}
+
+exit:
+
+	return retval;
+}
+
+/* remove the wlanhdr and add the eth_hdr */
+
+static int wlanhdr_to_ethhdr(struct recv_frame_hdr *precvframe)
+{
+	int rmv_len;
+	u16 eth_type, len;
+	u8 bsnaphdr;
+	u8 *psnap_type;
+	struct ieee80211_snap_hdr *psnap;
+	__be16 be_tmp;
+
+	int ret = _SUCCESS;
+	struct rtw_adapter *adapter = precvframe->adapter;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	u8 *ptr = get_recvframe_data(precvframe);	/*  point to frame_ctrl field */
+	struct rx_pkt_attrib *pattrib = &precvframe->attrib;
+
+	if (pattrib->encrypt)
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+
+	psnap =
+	    (struct ieee80211_snap_hdr *)(ptr + pattrib->hdrlen +
+					  pattrib->iv_len);
+	psnap_type = ptr + pattrib->hdrlen + pattrib->iv_len + SNAP_SIZE;
+	/* convert hdr + possible LLC headers into Ethernet header */
+	/* eth_type = (psnap_type[0] << 8) | psnap_type[1]; */
+	if ((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
+	     (_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
+	     (_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2) ==
+	      false)) ||
+	    /* eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) || */
+	    _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		bsnaphdr = true;
+	} else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = false;
+	}
+
+	rmv_len =
+	    pattrib->hdrlen + pattrib->iv_len + (bsnaphdr ? SNAP_SIZE : 0);
+	len = precvframe->len - rmv_len;
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+		 ("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n",
+		  pattrib->hdrlen, pattrib->iv_len));
+
+	memcpy(&be_tmp, ptr + rmv_len, 2);
+	eth_type = ntohs(be_tmp);	/* pattrib->ether_type */
+	pattrib->eth_type = eth_type;
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		ptr += rmv_len;
+		*ptr = 0x87;
+		*(ptr + 1) = 0x12;
+
+		eth_type = 0x8712;
+		/*  append rx status for mp test packets */
+		ptr =
+		    recvframe_pull(precvframe,
+				   (rmv_len - sizeof(struct ethhdr) + 2) - 24);
+		memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr += 24;
+	} else {
+		ptr =
+		    recvframe_pull(precvframe,
+				   (rmv_len - sizeof(struct ethhdr) +
+				    (bsnaphdr ? 2 : 0)));
+	}
+
+	memcpy(ptr, pattrib->dst, ETH_ALEN);
+	memcpy(ptr + ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	if (!bsnaphdr) {
+		be_tmp = htons(len);
+		memcpy(ptr + 12, &be_tmp, 2);
+	}
+
+	return ret;
+}
+
+/* perform defrag */
+static struct recv_frame_hdr *recvframe_defrag(struct rtw_adapter *adapter,
+				   struct __queue *defrag_q)
+{
+	struct list_head *plist, *phead;
+	u8 wlanhdr_offset;
+	u8 curfragnum;
+	struct recv_frame_hdr *pfhdr, *pnfhdr;
+	struct recv_frame_hdr *prframe, *pnextrframe;
+	struct __queue *pfree_recv_queue;
+
+	curfragnum = 0;
+	pfree_recv_queue = &adapter->recvpriv.free_recv_queue;
+
+	phead = get_list_head(defrag_q);
+	plist = phead->next;
+	prframe = container_of(plist, struct recv_frame_hdr, list);
+	pfhdr = prframe;
+	list_del_init(&(prframe->list));
+
+	if (curfragnum != pfhdr->attrib.frag_num) {
+		/* the first fragment number must be 0 */
+		/* free the whole queue */
+		rtw_free_recvframe(prframe, pfree_recv_queue);
+		rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+		return NULL;
+	}
+
+	curfragnum++;
+
+	plist = get_list_head(defrag_q);
+
+	plist = plist->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnextrframe = container_of(plist, struct recv_frame_hdr, list);
+		pnfhdr = pnextrframe;
+
+		/* check the fragment sequence  (2nd ~n fragment frame) */
+
+		if (curfragnum != pnfhdr->attrib.frag_num) {
+			/* the fragment number must be increasing  (after decache) */
+			/* release the defrag_q & prframe */
+			rtw_free_recvframe(prframe, pfree_recv_queue);
+			rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+			return NULL;
+		}
+
+		curfragnum++;
+
+		/* copy the 2nd~n fragment frame's payload to the first fragment */
+		/* get the 2nd~last fragment frame's payload */
+
+		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
+
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+
+		/* append  to first fragment frame's tail (if privacy frame, pull the ICV) */
+		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
+
+		/* memcpy */
+		memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
+
+		recvframe_put(prframe, pnfhdr->len);
+
+		pfhdr->attrib.icv_len = pnfhdr->attrib.icv_len;
+		plist = plist->next;
+
+	};
+
+	/* free the defrag_q queue and return the prframe */
+	rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+		 ("Performance defrag!!!!!\n"));
+
+	return prframe;
+}
+
+/* check if need to defrag, if needed queue the frame to defrag_q */
+struct recv_frame_hdr *recvframe_chk_defrag(struct rtw_adapter *padapter,
+				       struct recv_frame_hdr *precv_frame)
+{
+	u8 ismfrag;
+	u8 fragnum;
+	u8 *psta_addr;
+	struct recv_frame_hdr *pfhdr;
+	struct sta_info *psta;
+	struct sta_priv *pstapriv;
+	struct list_head *phead;
+	struct recv_frame_hdr *prtnframe = NULL;
+	struct __queue *pfree_recv_queue, *pdefrag_q;
+
+	pstapriv = &padapter->stapriv;
+
+	pfhdr = precv_frame;
+
+	pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+
+	/* need to define struct of wlan header frame ctrl */
+	ismfrag = pfhdr->attrib.mfrag;
+	fragnum = pfhdr->attrib.frag_num;
+
+	psta_addr = pfhdr->attrib.ta;
+	psta = rtw_get_stainfo(pstapriv, psta_addr);
+	if (psta == NULL) {
+		u8 type = GetFrameType(pfhdr->rx_data);
+		if (type != WIFI_DATA_TYPE) {
+			psta = rtw_get_bcmc_stainfo(padapter);
+			pdefrag_q = &psta->sta_recvpriv.defrag_q;
+		} else {
+			pdefrag_q = NULL;
+		}
+	} else {
+		pdefrag_q = &psta->sta_recvpriv.defrag_q;
+	}
+
+	if ((ismfrag == 0) && (fragnum == 0))
+		prtnframe = precv_frame;	/* isn't a fragment frame */
+
+	if (ismfrag == 1) {
+		/* 0~(n-1) fragment frame */
+		/* enqueue to defraf_g */
+		if (pdefrag_q != NULL) {
+			if (fragnum == 0) {
+				/* the first fragment */
+				if (_rtw_queue_empty(pdefrag_q) == false) {
+					/* free current defrag_q */
+					rtw_free_recvframe_queue(pdefrag_q,
+								 pfree_recv_queue);
+				}
+			}
+
+			/* Then enqueue the 0~(n-1) fragment into the defrag_q */
+
+			/* _rtw_spinlock(&pdefrag_q->lock); */
+			phead = get_list_head(pdefrag_q);
+			rtw_list_insert_tail(&pfhdr->list, phead);
+			/* _rtw_spinunlock(&pdefrag_q->lock); */
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("Enqueuq: ismfrag = %d, fragnum= %d\n",
+				  ismfrag, fragnum));
+
+			prtnframe = NULL;
+
+		} else {
+			/* can't find this ta's defrag_queue, so free this recv_frame */
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n",
+				  ismfrag, fragnum));
+		}
+	}
+
+	if ((ismfrag == 0) && (fragnum != 0)) {
+		/* the last fragment frame */
+		/* enqueue the last fragment */
+		if (pdefrag_q != NULL) {
+			/* _rtw_spinlock(&pdefrag_q->lock); */
+			phead = get_list_head(pdefrag_q);
+			rtw_list_insert_tail(&pfhdr->list, phead);
+			/* _rtw_spinunlock(&pdefrag_q->lock); */
+
+			/* call recvframe_defrag to defrag */
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+				 ("defrag: ismfrag = %d, fragnum= %d\n",
+				  ismfrag, fragnum));
+			precv_frame = recvframe_defrag(padapter, pdefrag_q);
+			prtnframe = precv_frame;
+
+		} else {
+			/* can't find this ta's defrag_queue, so free this recv_frame */
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe = NULL;
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n",
+				  ismfrag, fragnum));
+		}
+	}
+	if ((prtnframe != NULL) && (prtnframe->attrib.privacy)) {
+		/* after defrag we must check tkip mic code */
+		if (recvframe_chkmic(padapter, prtnframe) == _FAIL) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("recvframe_chkmic(padapter,  prtnframe)==_FAIL\n"));
+			rtw_free_recvframe(prtnframe, pfree_recv_queue);
+			prtnframe = NULL;
+		}
+	}
+
+	return prtnframe;
+}
+
+static int amsdu_to_msdu(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
+{
+	int a_len, padding_len;
+	u16 eth_type, nSubframe_Length;
+	u8 nr_subframes, i;
+	unsigned char *pdata;
+	struct rx_pkt_attrib *pattrib;
+	unsigned char *data_ptr;
+	struct sk_buff *sub_skb, *subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int ret = _SUCCESS;
+	nr_subframes = 0;
+
+	pattrib = &prframe->attrib;
+
+	recvframe_pull(prframe, prframe->attrib.hdrlen);
+
+	if (prframe->attrib.iv_len > 0)
+		recvframe_pull(prframe, prframe->attrib.iv_len);
+
+	a_len = prframe->len;
+
+	pdata = prframe->rx_data;
+
+	while (a_len > ETH_HLEN) {
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = *((u16 *)(pdata + 12));
+		/* m==>change the length order */
+		nSubframe_Length =
+		    (nSubframe_Length >> 8) + (nSubframe_Length << 8);
+
+		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
+			DBG_8192D
+			    ("nRemain_Length is %d and nSubframe_Length is : %d\n",
+			     a_len, nSubframe_Length);
+			goto exit;
+		}
+
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+
+		/* Allocate new skb for releasing to upper layer */
+		sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+		if (sub_skb) {
+			skb_reserve(sub_skb, 12);
+			data_ptr = (u8 *)skb_put(sub_skb, nSubframe_Length);
+			memcpy(data_ptr, pdata, nSubframe_Length);
+		} else {
+			sub_skb = skb_clone(prframe->pkt, GFP_ATOMIC);
+			if (sub_skb) {
+				sub_skb->data = pdata;
+				sub_skb->len = nSubframe_Length;
+				skb_set_tail_pointer(sub_skb, nSubframe_Length);
+			} else {
+				DBG_8192D
+				    ("skb_clone() Fail!!! , nr_subframes = %d\n",
+				     nr_subframes);
+				break;
+			}
+		}
+
+		subframes[nr_subframes++] = sub_skb;
+		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
+			DBG_8192D
+			    ("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			break;
+		}
+
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if (a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4 - 1));
+			if (padding_len == 4)
+				padding_len = 0;
+
+			if (a_len < padding_len)
+				goto exit;
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+
+	for (i = 0; i < nr_subframes; i++) {
+		sub_skb = subframes[i];
+		/* convert hdr + possible LLC headers into Ethernet header */
+		eth_type = RTW_GET_BE16(&sub_skb->data[6]);
+		if (sub_skb->len >= 8 &&
+		    ((_rtw_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
+		     eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		     _rtw_memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE))) {
+			/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+			skb_pull(sub_skb, SNAP_SIZE);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+			       ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+			       ETH_ALEN);
+		} else {
+			__be16 len;
+			/* Leave Ethernet header part of hdr and full payload */
+			len = htons(sub_skb->len);
+			memcpy(skb_push(sub_skb, 2), &len, 2);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src,
+			       ETH_ALEN);
+			memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst,
+			       ETH_ALEN);
+		}
+
+		/* Indicat the packets to upper layer */
+		sub_skb->protocol =
+		    eth_type_trans(sub_skb, padapter->pnetdev);
+		sub_skb->dev = padapter->pnetdev;
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+		if ((pattrib->tcpchk_valid == 1) &&
+		    (pattrib->tcp_chkrpt == 1))
+			sub_skb->ip_summed = CHECKSUM_UNNECESSARY;
+		else
+			sub_skb->ip_summed = CHECKSUM_NONE;
+#else /* !CONFIG_TCP_CSUM_OFFLOAD_RX */
+		sub_skb->ip_summed = CHECKSUM_NONE;
+#endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
+
+		netif_rx(sub_skb);
+	}
+
+exit:
+
+	prframe->len = 0;
+	rtw_free_recvframe(prframe, pfree_recv_queue);	/* free this recv_frame */
+
+	return ret;
+}
+
+static int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
+{
+	u8 wsize = preorder_ctrl->wsize_b;
+	u16 wend = (preorder_ctrl->indicate_seq + wsize - 1) & 0xFFF;	/*  4096; */
+
+	/*  Rx Reorder initialize condition. */
+	if (preorder_ctrl->indicate_seq == 0xFFFF) {
+		preorder_ctrl->indicate_seq = seq_num;
+#ifdef DBG_RX_SEQ
+		DBG_8192D("DBG_RX_SEQ %s:%d init IndicateSeq: %d, NewSeq: %d\n",
+			  __func__, __LINE__, preorder_ctrl->indicate_seq,
+			  seq_num);
+#endif
+	}
+
+	/*  Drop out the packet which SeqNum is smaller than WinStart */
+	if (SN_LESS(seq_num, preorder_ctrl->indicate_seq))
+		return false;
+
+	/*  */
+	/*  Sliding window manipulation. Conditions includes: */
+	/*  1. Incoming SeqNum is equal to WinStart =>Window shift 1 */
+	/*  2. Incoming SeqNum is larger than the WinEnd => Window shift N */
+	/*  */
+	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq)) {
+		preorder_ctrl->indicate_seq =
+		    (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+#ifdef DBG_RX_SEQ
+		DBG_8192D
+		    ("DBG_RX_SEQ %s:%d SN_EQUAL IndicateSeq: %d, NewSeq: %d\n",
+		     __func__, __LINE__, preorder_ctrl->indicate_seq, seq_num);
+#endif
+	} else if (SN_LESS(wend, seq_num)) {
+		/*  boundary situation, when seq_num cross 0xFFF */
+		if (seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 - wsize;
+		else
+			preorder_ctrl->indicate_seq =
+			    0xFFF - (wsize - (seq_num + 1)) + 1;
+
+#ifdef DBG_RX_SEQ
+		DBG_8192D
+		    ("DBG_RX_SEQ %s:%d SN_LESS(wend, seq_num) IndicateSeq: %d, NewSeq: %d\n",
+		     __func__, __LINE__, preorder_ctrl->indicate_seq, seq_num);
+#endif
+	}
+	return true;
+}
+
+static int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl,
+				     struct recv_frame_hdr *prframe)
+{
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct __queue *ppending_recvframe_queue =
+	    &preorder_ctrl->pending_recvframe_queue;
+	struct list_head *phead, *plist;
+	struct recv_frame_hdr *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = phead->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnextrframe = container_of(plist, struct recv_frame_hdr, list);
+		pnextattrib = &pnextrframe->attrib;
+
+		if (SN_LESS(pnextattrib->seq_num, pattrib->seq_num))
+			plist = plist->next;
+		else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
+			return false;
+		else
+			break;
+	}
+	list_del_init(&(prframe->list));
+	rtw_list_insert_tail(&(prframe->list), plist);
+	return true;
+}
+
+static int recv_indicatepkts_in_order(struct rtw_adapter *padapter,
+			       struct recv_reorder_ctrl *preorder_ctrl,
+			       int bforced)
+{
+	struct list_head *phead, *plist;
+	struct recv_frame_hdr *prframe;
+	struct rx_pkt_attrib *pattrib;
+	int bPktInBuf = false;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct __queue *ppending_recvframe_queue =
+	    &preorder_ctrl->pending_recvframe_queue;
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = phead->next;
+
+	/*  Handling some condition for forced indicate case. */
+	if (bforced == true) {
+		if (rtw_is_list_empty(phead)) {
+			/*  spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
+			/* _rtw_spinunlock_ex(&ppending_recvframe_queue->lock); */
+			return true;
+		}
+
+		prframe = container_of(plist, struct recv_frame_hdr, list);
+		pattrib = &prframe->attrib;
+		preorder_ctrl->indicate_seq = pattrib->seq_num;
+#ifdef DBG_RX_SEQ
+		DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+			  __func__, __LINE__, preorder_ctrl->indicate_seq,
+			  pattrib->seq_num);
+#endif
+	}
+
+	/*  Prepare indication list and indication. */
+	/*  Check if there is any packet need indicate. */
+	while (!rtw_is_list_empty(phead)) {
+		prframe = container_of(plist, struct recv_frame_hdr, list);
+		pattrib = &prframe->attrib;
+
+		if (!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("recv_indicatepkts_in_order: indicate=%d seq=%d amsdu=%d\n",
+				  preorder_ctrl->indicate_seq, pattrib->seq_num,
+				  pattrib->amsdu));
+
+			plist = plist->next;
+			list_del_init(&(prframe->list));
+
+			if (SN_EQUAL
+			    (preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+				preorder_ctrl->indicate_seq =
+				    (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+#ifdef DBG_RX_SEQ
+				DBG_8192D
+				    ("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+				     __func__, __LINE__,
+				     preorder_ctrl->indicate_seq,
+				     pattrib->seq_num);
+#endif
+			}
+
+			/* indicate this recv_frame */
+			if (!pattrib->amsdu) {
+				if ((padapter->bDriverStopped == false) &&
+				    (padapter->bSurpriseRemoved == false))
+
+					rtw_recv_indicatepkt(padapter, prframe);	/* indicate this recv_frame */
+
+			} else if (pattrib->amsdu == 1) {
+				if (amsdu_to_msdu(padapter, prframe) !=
+				    _SUCCESS) {
+					rtw_free_recvframe(prframe,
+							   &precvpriv->
+							   free_recv_queue);
+				}
+			} else {
+				/* error condition; */
+			}
+
+			/* Update local variables. */
+			bPktInBuf = false;
+
+		} else {
+			bPktInBuf = true;
+			break;
+		}
+	}
+	return bPktInBuf;
+}
+
+static int recv_indicatepkt_reorder(struct rtw_adapter *padapter,
+				    struct recv_frame_hdr *prframe)
+{
+	int retval = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->preorder_ctrl;
+	struct __queue *ppending_recvframe_queue =
+	    &preorder_ctrl->pending_recvframe_queue;
+
+	if (!pattrib->amsdu) {
+		/* s1. */
+		wlanhdr_to_ethhdr(prframe);
+
+		if ((pattrib->qos != 1) || (pattrib->eth_type == 0x0806) ||
+		    (pattrib->ack_policy != 0)) {
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false)) {
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_,
+					 ("@@@@  recv_indicatepkt_reorder -recv_func recv_indicatepkt\n"));
+				rtw_recv_indicatepkt(padapter, prframe);
+				return _SUCCESS;
+			}
+			DBG_8192D("DBG_RX_DROP_FRAME %s pattrib->qos !=1\n",
+				  __func__);
+			return _FAIL;
+		}
+
+		if (preorder_ctrl->enable == false) {
+			/* indicate this recv_frame */
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+#ifdef DBG_RX_SEQ
+			DBG_8192D
+			    ("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+			     __func__, __LINE__, preorder_ctrl->indicate_seq,
+			     pattrib->seq_num);
+#endif
+
+			rtw_recv_indicatepkt(padapter, prframe);
+
+			preorder_ctrl->indicate_seq =
+			    (preorder_ctrl->indicate_seq + 1) % 4096;
+#ifdef DBG_RX_SEQ
+			DBG_8192D
+			    ("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+			     __func__, __LINE__, preorder_ctrl->indicate_seq,
+			     pattrib->seq_num);
+#endif
+
+			return _SUCCESS;
+		}
+#ifndef CONFIG_RECV_REORDERING_CTRL
+		/* indicate this recv_frame */
+		rtw_recv_indicatepkt(padapter, prframe);
+		return _SUCCESS;
+#endif
+
+	} else if (pattrib->amsdu == 1) {	/* temp filter -> means didn't support A-MSDUs in a A-MPDU */
+		if (preorder_ctrl->enable == false) {
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+			DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+				 __func__, __LINE__, preorder_ctrl->indicate_seq,
+				 pattrib->seq_num);
+
+			retval = amsdu_to_msdu(padapter, prframe);
+
+			preorder_ctrl->indicate_seq =
+			    (preorder_ctrl->indicate_seq + 1) % 4096;
+			DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n",
+				 __func__, __LINE__, preorder_ctrl->indicate_seq,
+				 pattrib->seq_num);
+
+			if (retval != _SUCCESS) {
+				DBG_8192D("DBG_RX_DROP_FRAME %s amsdu_to_msdu fail\n",
+					 __func__);
+			}
+
+			return retval;
+		}
+	}
+
+	spin_lock_bh(&ppending_recvframe_queue->lock);
+
+	RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+		 ("recv_indicatepkt_reorder: indicate=%d seq=%d\n",
+		  preorder_ctrl->indicate_seq, pattrib->seq_num));
+
+	/* s2. check if winstart_b(indicate_seq) needs to been updated */
+	if (!check_indicate_seq(preorder_ctrl, pattrib->seq_num)) {
+		DBG_8192D("DBG_RX_DROP_FRAME %s check_indicate_seq fail\n",
+			  __func__);
+		goto _err_exit;
+	}
+
+	/* s3. Insert all packet into Reorder Queue to maintain its ordering. */
+	if (!enqueue_reorder_recvframe(preorder_ctrl, prframe)) {
+		DBG_8192D("DBG_RX_DROP_FRAME %s enqueue_reorder_recvframe fail\n",
+			 __func__);
+		goto _err_exit;
+	}
+
+	/* s4. */
+	/*  Indication process. */
+	/*  After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets */
+	/*  with the SeqNum smaller than latest WinStart and buffer other packets. */
+	/*  */
+	/*  For Rx Reorder condition: */
+	/*  1. All packets with SeqNum smaller than WinStart => Indicate */
+	/*  2. All packets with SeqNum larger than or equal to WinStart => Buffer it. */
+	/*  */
+
+	/* recv_indicatepkts_in_order(padapter, preorder_ctrl, true); */
+	if (recv_indicatepkts_in_order(padapter, preorder_ctrl, false) == true) {
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer,
+			   REORDER_WAIT_TIME);
+	} else {
+		_cancel_timer_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
+	return _SUCCESS;
+_err_exit:
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
+	return _FAIL;
+}
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl =
+	    (struct recv_reorder_ctrl *)pcontext;
+	struct rtw_adapter *padapter = preorder_ctrl->padapter;
+	struct __queue *ppending_recvframe_queue =
+	    &preorder_ctrl->pending_recvframe_queue;
+
+	if (padapter->bDriverStopped || padapter->bSurpriseRemoved)
+		return;
+
+	/* DBG_8192D("+rtw_reordering_ctrl_timeout_handler()=>\n"); */
+
+	spin_lock_bh(&ppending_recvframe_queue->lock);
+
+	if (recv_indicatepkts_in_order(padapter, preorder_ctrl, true) == true) {
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer,
+			   REORDER_WAIT_TIME);
+	}
+
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
+}
+
+static int process_recv_indicatepkts(struct rtw_adapter *padapter,
+				     struct recv_frame_hdr *prframe)
+{
+	int retval = _SUCCESS;
+	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
+	/* struct rx_pkt_attrib *pattrib = &prframe->attrib; */
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+#ifdef CONFIG_80211N_HT
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+
+	if (phtpriv->ht_option == true)	/* B/G/N Mode */
+	{
+		if (recv_indicatepkt_reorder(padapter, prframe) != _SUCCESS) {	/*  including perform A-MPDU Rx Ordering Buffer Control */
+			if ((padapter->bDriverStopped == false) &&
+			    (padapter->bSurpriseRemoved == false)) {
+				retval = _FAIL;
+				return retval;
+			}
+		}
+	} else			/* B/G mode */
+#endif
+	{
+		retval = wlanhdr_to_ethhdr(prframe);
+		if (retval != _SUCCESS) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("wlanhdr_to_ethhdr: drop pkt\n"));
+			return retval;
+		}
+
+		if ((padapter->bDriverStopped == false) &&
+		    (padapter->bSurpriseRemoved == false)) {
+			/* indicate this recv_frame */
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n"));
+			rtw_recv_indicatepkt(padapter, prframe);
+
+		} else {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("@@@@ process_recv_indicatepkts- recv_func free_indicatepkt\n"));
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_,
+				 ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+				  padapter->bDriverStopped,
+				  padapter->bSurpriseRemoved));
+			retval = _FAIL;
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int recv_func_prehandle(struct rtw_adapter *padapter, struct recv_frame_hdr *rframe)
+{
+	int ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &rframe->attrib;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+
+	/* check the frame crtl field and decache */
+	ret = validate_recv_frame(padapter, rframe);
+	if (ret != _SUCCESS) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("recv_func: validate_recv_frame fail! drop pkt\n"));
+		rtw_free_recvframe(rframe, pfree_recv_queue);	/* free this recv_frame */
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+static int recv_func_posthandle(struct rtw_adapter *padapter,
+			 struct recv_frame_hdr *prframe)
+{
+	int ret = _SUCCESS;
+	struct recv_frame_hdr *orig_prframe = prframe;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+	struct __queue *pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
+
+	/*  DATA FRAME */
+	rtw_led_control(padapter, LED_CTL_RX);
+
+	prframe = decryptor(padapter, prframe);
+	if (prframe == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("decryptor: drop pkt\n"));
+		ret = _FAIL;
+		goto _recv_data_drop;
+	}
+	prframe = recvframe_chk_defrag(padapter, prframe);
+	if (prframe == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("recvframe_chk_defrag: drop pkt\n"));
+		goto _recv_data_drop;
+	}
+
+	prframe = portctrl(padapter, prframe);
+	if (prframe == NULL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("portctrl: drop pkt\n"));
+		ret = _FAIL;
+		goto _recv_data_drop;
+	}
+	count_rx_stats(padapter, prframe, NULL);
+
+#ifdef CONFIG_80211N_HT
+
+	ret = process_recv_indicatepkts(padapter, prframe);
+	if (ret != _SUCCESS) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+			 ("recv_func: process_recv_indicatepkts fail!\n"));
+		rtw_free_recvframe(orig_prframe, pfree_recv_queue);	/* free this recv_frame */
+		goto _recv_data_drop;
+	}
+#else /*  CONFIG_80211N_HT */
+
+	if (!pattrib->amsdu) {
+		ret = wlanhdr_to_ethhdr(prframe);
+		if (ret != _SUCCESS) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_,
+				 ("wlanhdr_to_ethhdr: drop pkt\n"));
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);	/* free this recv_frame */
+			goto _recv_data_drop;
+		}
+
+		if ((padapter->bDriverStopped == false) &&
+		    (padapter->bSurpriseRemoved == false)) {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_,
+				 ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n"));
+			/* indicate this recv_frame */
+			ret = rtw_recv_indicatepkt(padapter, prframe);
+			if (ret != _SUCCESS)
+				goto _recv_data_drop;
+		} else {
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_,
+				 ("@@@@  recv_func: rtw_free_recvframe\n"));
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_debug_,
+				 ("recv_func:bDriverStopped(%d) OR bSurpriseRemoved(%d)",
+				  padapter->bDriverStopped,
+				  padapter->bSurpriseRemoved));
+			ret = _FAIL;
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);	/* free this recv_frame */
+		}
+
+	} else if (pattrib->amsdu == 1) {
+		ret = amsdu_to_msdu(padapter, prframe);
+		if (ret != _SUCCESS) {
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);
+			goto _recv_data_drop;
+		}
+	} else {
+		goto _recv_data_drop;
+	}
+#endif /*  CONFIG_80211N_HT */
+
+_exit_recv_func:
+	return ret;
+
+_recv_data_drop:
+	precvpriv->rx_drop++;
+	return ret;
+}
+
+static int recv_func(struct rtw_adapter *padapter, struct recv_frame_hdr *rframe)
+{
+	int ret;
+	struct rx_pkt_attrib *prxattrib = &rframe->attrib;
+	struct recv_priv *recvpriv = &padapter->recvpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *mlmepriv = &padapter->mlmepriv;
+
+	/* check if need to handle uc_swdec_pending_queue */
+	if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
+	    psecuritypriv->busetkipkey) {
+		struct recv_frame_hdr *pending_frame;
+
+		while ((pending_frame =
+			rtw_alloc_recvframe(&padapter->recvpriv.
+					    uc_swdec_pending_queue))) {
+			if (recv_func_posthandle(padapter, pending_frame) ==
+			    _SUCCESS)
+				DBG_8192D
+				    ("%s: dequeue uc_swdec_pending_queue\n",
+				     __func__);
+		}
+	}
+
+	ret = recv_func_prehandle(padapter, rframe);
+
+	if (ret == _SUCCESS) {
+		/* check if need to enqueue into uc_swdec_pending_queue */
+		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
+		    !IS_MCAST(prxattrib->ra) && prxattrib->encrypt > 0 &&
+		    (prxattrib->bdecrypted == 0 ||
+		     psecuritypriv->sw_decrypt == true) &&
+		     !is_wep_enc(psecuritypriv->dot11PrivacyAlgrthm) &&
+		     !psecuritypriv->busetkipkey) {
+			rtw_enqueue_recvframe(rframe,
+					      &padapter->recvpriv.
+					      uc_swdec_pending_queue);
+			DBG_8192D
+			    ("%s: no key, enqueue uc_swdec_pending_queue\n",
+			     __func__);
+			goto exit;
+		}
+
+		ret = recv_func_posthandle(padapter, rframe);
+	}
+
+exit:
+	return ret;
+}
+
+s32 rtw_recv_entry(struct recv_frame_hdr *precvframe)
+{
+	struct rtw_adapter *padapter;
+	struct recv_priv *precvpriv;
+	s32 ret = _SUCCESS;
+
+	padapter = precvframe->adapter;
+
+	precvpriv = &padapter->recvpriv;
+
+	ret = recv_func(padapter, precvframe);
+	if (ret == _FAIL) {
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("rtw_recv_entry: recv_func return fail!!!\n"));
+		goto _recv_entry_drop;
+	}
+
+	precvpriv->rx_pkts++;
+
+	return ret;
+
+_recv_entry_drop:
+
+	return ret;
+}
+
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+	struct recv_priv *recvpriv = &adapter->recvpriv;
+
+	u32 tmp_s, tmp_q;
+	u8 avg_signal_strength = 0;
+	u8 avg_signal_qual = 0;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
+	u32 num_signal_strength = 0;
+	u32 num_signal_qual = 0;
+#endif
+	u8 _alpha = 3;		/*  this value is based on converging_constant = 5000 and sampling_interval = 1000 */
+
+	if (adapter->recvpriv.is_signal_dbg) {
+		/* update the user specific value, signal_strength_dbg, to signal_strength, rssi */
+		adapter->recvpriv.signal_strength =
+		    adapter->recvpriv.signal_strength_dbg;
+		adapter->recvpriv.rssi =
+		    (s8) translate_percentage_to_dbm((u8) adapter->recvpriv.
+						     signal_strength_dbg);
+	} else {
+		if (recvpriv->signal_strength_data.update_req == 0) {	/*  update_req is clear, means we got rx */
+			avg_signal_strength =
+			    recvpriv->signal_strength_data.avg_val;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
+			num_signal_strength =
+			    recvpriv->signal_strength_data.total_num;
+#endif
+			/*  after avg_vals are accquired, we can re-stat the signal values */
+			recvpriv->signal_strength_data.update_req = 1;
+		}
+
+		if (recvpriv->signal_qual_data.update_req == 0) {	/*  update_req is clear, means we got rx */
+			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
+			num_signal_qual = recvpriv->signal_qual_data.total_num;
+#endif
+			/*  after avg_vals are accquired, we can re-stat the signal values */
+			recvpriv->signal_qual_data.update_req = 1;
+		}
+
+		/* update value of signal_strength, rssi, signal_qual */
+		if (check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) ==
+		    false) {
+			tmp_s =
+			    (avg_signal_strength +
+			     (_alpha - 1) * recvpriv->signal_strength);
+			if (tmp_s % _alpha)
+				tmp_s = tmp_s / _alpha + 1;
+			else
+				tmp_s = tmp_s / _alpha;
+			if (tmp_s > 100)
+				tmp_s = 100;
+
+			tmp_q =
+			    (avg_signal_qual +
+			     (_alpha - 1) * recvpriv->signal_qual);
+			if (tmp_q % _alpha)
+				tmp_q = tmp_q / _alpha + 1;
+			else
+				tmp_q = tmp_q / _alpha;
+			if (tmp_q > 100)
+				tmp_q = 100;
+
+			recvpriv->signal_strength = tmp_s;
+			recvpriv->rssi =
+			    (s8) translate_percentage_to_dbm(tmp_s);
+			recvpriv->signal_qual = tmp_q;
+
+#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING)
+			DBG_8192D("%s signal_strength:%3u, rssi:%3d, signal_qual:%3u, num_signal_strength:%u, num_signal_qual:%u\n",
+				  __func__, recvpriv->signal_strength,
+				  recvpriv->rssi, recvpriv->signal_qual,
+				  num_signal_strength, num_signal_qual);
+#endif
+		}
+	}
+	rtw_set_signal_stat_timer(recvpriv);
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_rf.c b/drivers/net/wireless/rtl8192du/core/rtw_rf.c
new file mode 100644
index 0000000..4afb90f
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_rf.c
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_RF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+
+struct ch_freq {
+	u32 channel;
+	u32 frequency;
+};
+
+static struct ch_freq ch_freq_map[] = {
+	{1, 2412}, {2, 2417}, {3, 2422}, {4, 2427}, {5, 2432},
+	{6, 2437}, {7, 2442}, {8, 2447}, {9, 2452}, {10, 2457},
+	{11, 2462}, {12, 2467}, {13, 2472}, {14, 2484},
+	/*  UNII */
+	{36, 5180}, {40, 5200}, {44, 5220}, {48, 5240}, {52, 5260},
+	{56, 5280}, {60, 5300}, {64, 5320}, {149, 5745}, {153, 5765},
+	{157, 5785}, {161, 5805}, {165, 5825}, {167, 5835}, {169, 5845},
+	{171, 5855}, {173, 5865},
+	/* HiperLAN2 */
+	{100, 5500}, {104, 5520}, {108, 5540}, {112, 5560}, {116, 5580},
+	{120, 5600}, {124, 5620}, {128, 5640}, {132, 5660}, {136, 5680},
+	{140, 5700},
+	/* Japan MMAC */
+	{34, 5170}, {38, 5190}, {42, 5210}, {46, 5230},
+	/*  Japan */
+	{184, 4920}, {188, 4940}, {192, 4960}, {196, 4980},
+	{208, 5040},		/* Japan, means J08 */
+	{212, 5060},		/* Japan, means J12 */
+	{216, 5080},		/* Japan, means J16 */
+};
+
+static int ch_freq_map_num = (sizeof(ch_freq_map) / sizeof(struct ch_freq));
+
+u32 rtw_ch2freq(u32 channel)
+{
+	u8 i;
+	u32 freq = 0;
+
+	for (i = 0; i < ch_freq_map_num; i++) {
+		if (channel == ch_freq_map[i].channel) {
+			freq = ch_freq_map[i].frequency;
+			break;
+		}
+	}
+	if (i == ch_freq_map_num)
+		freq = 2412;
+
+	return freq;
+}
+
+u32 rtw_freq2ch(u32 freq)
+{
+	u8 i;
+	u32 ch = 0;
+
+	for (i = 0; i < ch_freq_map_num; i++) {
+		if (freq == ch_freq_map[i].frequency) {
+			ch = ch_freq_map[i].channel;
+			break;
+		}
+	}
+	if (i == ch_freq_map_num)
+		ch = 1;
+
+	return ch;
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_security.c b/drivers/net/wireless/rtl8192du/core/rtw_security.c
new file mode 100644
index 0000000..3290d10
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_security.c
@@ -0,0 +1,2446 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define  _RTW_SECURITY_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+
+/* WEP related ===== */
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context {
+	u32 x;
+	u32 y;
+	u8 state[256];
+};
+
+static void arcfour_init(struct arc4context *parc4ctx, u8 *key, u32 key_len)
+{
+	u32 t, u;
+	u32 keyindex;
+	u32 stateindex;
+	u8 *state;
+	u32 counter;
+
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (u8) counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++) {
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (u8) t;
+		state[counter] = (u8) u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+
+}
+
+static u32 arcfour_byte(struct arc4context *parc4ctx)
+{
+	u32 x;
+	u32 y;
+	u32 sx, sy;
+	u8 *state;
+
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (u8) sx;
+	state[x] = (u8) sy;
+
+	return state[(sx + sy) & 0xff];
+}
+
+static void arcfour_encrypt(struct arc4context *parc4ctx, u8 *dest,
+			    u8 *src, u32 len)
+{
+	u32 i;
+
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+
+}
+
+static int bcrc32initialized;
+static u32 crc32_table[256];
+
+static u8 crc32_reverseBit(u8 data)
+{
+	return (u8) ((data << 7) & 0x80) | ((data << 5) & 0x40) | ((data << 3) &
+								   0x20) |
+	    ((data << 1) & 0x10) | ((data >> 1) & 0x08) | ((data >> 3) & 0x04) |
+	    ((data >> 5) & 0x02) | ((data >> 7) & 0x01);
+}
+
+static void crc32_init(void)
+{
+
+	if (bcrc32initialized == 1) {
+		return;
+	} else {
+		int i, j;
+		u32 c;
+		u8 *p = (u8 *)&c, *p1;
+		u8 k;
+
+		c = 0x12340000;
+
+		for (i = 0; i < 256; ++i) {
+			k = crc32_reverseBit((u8) i);
+			for (c = ((u32)k) << 24, j = 8; j > 0; --j) {
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY :
+				    (c << 1);
+			}
+			p1 = (u8 *)&crc32_table[i];
+
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized = 1;
+	}
+}
+
+static __le32 getcrc32(u8 *buf, int len)
+{
+	u8 *p;
+	u32 crc;
+
+	if (bcrc32initialized == 0)
+		crc32_init();
+
+	crc = 0xffffffff;	/* preload shift register, per CRC-32 spec */
+
+	for (p = buf; len > 0; ++p, --len)
+		crc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);
+
+	return cpu_to_le32(~crc);	/* transmit complement, per CRC-32 spec */
+}
+
+/*
+	Need to consider the fragment  situation
+*/
+void rtw_wep_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
+{				/*  exclude ICV */
+
+	unsigned char crc[4];
+	struct arc4context mycontext;
+	int curfragnum, length;
+	u32 keylength;
+	u8 *pframe, *payload, *iv;	/* wepkey */
+	u8 wepkey[16];
+	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return;
+
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_SIZE +
+		 (((struct xmit_frame *)pxmitframe)->pkt_offset *
+		  PACKET_OFFSET_SZ);
+
+	/* start to encrypt each fragment */
+	if ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {
+		keylength =
+		    psecuritypriv->dot11DefKeylen[psecuritypriv->
+						  dot11PrivacyKeyIndex];
+
+		for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+		     curfragnum++) {
+			iv = pframe + pattrib->hdrlen;
+			memcpy(&wepkey[0], iv, 3);
+			memcpy(&wepkey[3],
+			       &psecuritypriv->dot11DefKey[psecuritypriv->
+							   dot11PrivacyKeyIndex].
+			       skey[0], keylength);
+			payload = pframe + pattrib->iv_len + pattrib->hdrlen;
+
+			if ((curfragnum + 1) == pattrib->nr_frags) {	/* the last fragment */
+
+				length =
+				    pattrib->last_txcmdsz - pattrib->hdrlen -
+				    pattrib->iv_len - pattrib->icv_len;
+
+				*((__le32 *)crc) = getcrc32(payload, length);
+
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload + length,
+						crc, 4);
+			} else {
+				length =
+				    pxmitpriv->frag_len - pattrib->hdrlen -
+				    pattrib->iv_len - pattrib->icv_len;
+				*((__le32 *)crc) = getcrc32(payload, length);
+				arcfour_init(&mycontext, wepkey, 3 + keylength);
+				arcfour_encrypt(&mycontext, payload, payload,
+						length);
+				arcfour_encrypt(&mycontext, payload + length,
+						crc, 4);
+
+				pframe += pxmitpriv->frag_len;
+				pframe = (u8 *)RND4((SIZE_PTR)(pframe));
+			}
+		}
+	}
+
+}
+
+void rtw_wep_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
+{
+	/*  exclude ICV */
+	u8 crc[4];
+	struct arc4context mycontext;
+	int length;
+	u32 keylength;
+	u8 *pframe, *payload, *iv, wepkey[16];
+	u8 keyindex;
+	struct rx_pkt_attrib *prxattrib =
+	    &(((struct recv_frame_hdr *)precvframe)->attrib);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	pframe =
+	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
+
+	/* start to decrypt recvframe */
+	if ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt == _WEP104_)) {
+		iv = pframe + prxattrib->hdrlen;
+		/* keyindex = (iv[3]&0x3); */
+		keyindex = prxattrib->key_index;
+		keylength = psecuritypriv->dot11DefKeylen[keyindex];
+		memcpy(&wepkey[0], iv, 3);
+		/* memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0], keylength); */
+		memcpy(&wepkey[3],
+		       &psecuritypriv->dot11DefKey[keyindex].skey[0],
+		       keylength);
+		length =
+		    ((struct recv_frame_hdr *)precvframe)->len -
+		    prxattrib->hdrlen - prxattrib->iv_len;
+
+		payload = pframe + prxattrib->iv_len + prxattrib->hdrlen;
+
+		/* decrypt payload include icv */
+		arcfour_init(&mycontext, wepkey, 3 + keylength);
+		arcfour_encrypt(&mycontext, payload, payload, length);
+
+		/* calculate icv and compare the icv */
+		*((__le32 *)crc) = getcrc32(payload, length - 4);
+
+		if (crc[3] != payload[length - 1] ||
+		    crc[2] != payload[length - 2] ||
+		    crc[1] != payload[length - 3] ||
+		    crc[0] != payload[length - 4]) {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_wep_decrypt:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
+				  crc[3], payload[length - 1], crc[2],
+				  payload[length - 2], crc[1],
+				  payload[length - 3], crc[0],
+				  payload[length - 4]));
+		}
+	}
+
+	return;
+}
+
+/* 3		===== TKIP related ===== */
+
+static u32 secmicgetuint32(u8 *p)
+/*  Convert from Byte[] to Us4Byte32 in a portable way */
+{
+	s32 i;
+	u32 res = 0;
+
+	for (i = 0; i < 4; i++)
+		res |= ((u32) (*p++)) << (8 * i);
+
+	return res;
+}
+
+static void secmicputuint32(u8 *p, u32 val)
+/*  Convert from Us4Byte32 to Byte[] in a portable way */
+{
+	long i;
+
+	for (i = 0; i < 4; i++) {
+		*p++ = (u8) (val & 0xff);
+		val >>= 8;
+	}
+
+}
+
+static void secmicclear(struct mic_data *pmicdata)
+{
+/*  Reset the state to the empty message. */
+
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+
+}
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key)
+{
+	/*  Set the key */
+
+	pmicdata->K0 = secmicgetuint32(key);
+	pmicdata->K1 = secmicgetuint32(key + 4);
+	/*  and reset the message */
+	secmicclear(pmicdata);
+
+}
+
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b)
+{
+
+	/*  Append the byte to our word-sized buffer */
+	pmicdata->M |= ((unsigned long)b) << (8 * pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	/*  Process the word if it is full. */
+	if (pmicdata->nBytesInM >= 4) {
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32(pmicdata->L, 17);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^=
+		    ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->
+							  L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32(pmicdata->L, 3);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32(pmicdata->L, 2);
+		pmicdata->L += pmicdata->R;
+		/*  Clear the buffer */
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+
+}
+
+void rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes)
+{
+
+	/*  This is simple */
+	while (nbytes > 0) {
+		rtw_secmicappendbyte(pmicdata, *src++);
+		nbytes--;
+	}
+
+}
+
+void rtw_secgetmic(struct mic_data *pmicdata, u8 *dst)
+{
+
+	/*  Append the minimum padding */
+	rtw_secmicappendbyte(pmicdata, 0x5a);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
+	rtw_secmicappendbyte(pmicdata, 0);
+	/*  and then zeroes until the length is a multiple of 4 */
+	while (pmicdata->nBytesInM != 0)
+		rtw_secmicappendbyte(pmicdata, 0);
+	/*  The appendByte function has already computed the result. */
+	secmicputuint32(dst, pmicdata->L);
+	secmicputuint32(dst + 4, pmicdata->R);
+	/*  Reset to the empty message. */
+	secmicclear(pmicdata);
+
+}
+
+void rtw_seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len,
+			u8 *mic_code, u8 pri)
+{
+	struct mic_data micdata;
+	u8 priority[4] = { 0x0, 0x0, 0x0, 0x0 };
+
+	rtw_secmicsetkey(&micdata, key);
+	priority[0] = pri;
+
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if (header[1] & 1) {	/* ToDS == 1 */
+		rtw_secmicappend(&micdata, &header[16], 6);	/* DA */
+		if (header[1] & 2)	/* From Ds == 1 */
+			rtw_secmicappend(&micdata, &header[24], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);
+	} else {		/* ToDS == 0 */
+		rtw_secmicappend(&micdata, &header[4], 6);	/* DA */
+		if (header[1] & 2)	/* From Ds == 1 */
+			rtw_secmicappend(&micdata, &header[16], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);
+	}
+	rtw_secmicappend(&micdata, &priority[0], 4);
+
+	rtw_secmicappend(&micdata, data, data_len);
+
+	rtw_secgetmic(&micdata, mic_code);
+
+}
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((u8)((v16)       & 0x00FF))
+#define   Hi8(v16)   ((u8)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)((v32)       & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >> 16) & 0xFFFF))
+#define  Mk16(hi, lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)     Mk16(tk[2*(N)+1], tk[2*(N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)     (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8	/* this needs to be "big enough"     */
+#define TA_SIZE           6	/*  48-bit transmitter address       */
+#define TK_SIZE          16	/* 128-bit temporal key              */
+#define P1K_SIZE         10	/*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16	/* 128-bit RC4KEY (104 bits unknown) */
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+static const unsigned short Sbox1[2][256] = {	/* Sbox for hash (can be in ROM)     */
+{
+	0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,
+	0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,
+	0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,
+	0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,
+	0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,
+	0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,
+	0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,
+	0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,
+	0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,
+	0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,
+	0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,
+	0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,
+	0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,
+	0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,
+	0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,
+	0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,
+	0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,
+	0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,
+	0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,
+	0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,
+	0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,
+	0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,
+	0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,
+	0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,
+	0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,
+	0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,
+	0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,
+	0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,
+	0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,
+	0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,
+	0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,
+	0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,
+},
+
+{				/* second half of table is unsigned char-reversed version of first! */
+	0xA5C6, 0x84F8, 0x99EE, 0x8DF6, 0x0DFF, 0xBDD6, 0xB1DE, 0x5491,
+	0x5060, 0x0302, 0xA9CE, 0x7D56, 0x19E7, 0x62B5, 0xE64D, 0x9AEC,
+	0x458F, 0x9D1F, 0x4089, 0x87FA, 0x15EF, 0xEBB2, 0xC98E, 0x0BFB,
+	0xEC41, 0x67B3, 0xFD5F, 0xEA45, 0xBF23, 0xF753, 0x96E4, 0x5B9B,
+	0xC275, 0x1CE1, 0xAE3D, 0x6A4C, 0x5A6C, 0x417E, 0x02F5, 0x4F83,
+	0x5C68, 0xF451, 0x34D1, 0x08F9, 0x93E2, 0x73AB, 0x5362, 0x3F2A,
+	0x0C08, 0x5295, 0x6546, 0x5E9D, 0x2830, 0xA137, 0x0F0A, 0xB52F,
+	0x090E, 0x3624, 0x9B1B, 0x3DDF, 0x26CD, 0x694E, 0xCD7F, 0x9FEA,
+	0x1B12, 0x9E1D, 0x7458, 0x2E34, 0x2D36, 0xB2DC, 0xEEB4, 0xFB5B,
+	0xF6A4, 0x4D76, 0x61B7, 0xCE7D, 0x7B52, 0x3EDD, 0x715E, 0x9713,
+	0xF5A6, 0x68B9, 0x0000, 0x2CC1, 0x6040, 0x1FE3, 0xC879, 0xEDB6,
+	0xBED4, 0x468D, 0xD967, 0x4B72, 0xDE94, 0xD498, 0xE8B0, 0x4A85,
+	0x6BBB, 0x2AC5, 0xE54F, 0x16ED, 0xC586, 0xD79A, 0x5566, 0x9411,
+	0xCF8A, 0x10E9, 0x0604, 0x81FE, 0xF0A0, 0x4478, 0xBA25, 0xE34B,
+	0xF3A2, 0xFE5D, 0xC080, 0x8A05, 0xAD3F, 0xBC21, 0x4870, 0x04F1,
+	0xDF63, 0xC177, 0x75AF, 0x6342, 0x3020, 0x1AE5, 0x0EFD, 0x6DBF,
+	0x4C81, 0x1418, 0x3526, 0x2FC3, 0xE1BE, 0xA235, 0xCC88, 0x392E,
+	0x5793, 0xF255, 0x82FC, 0x477A, 0xACC8, 0xE7BA, 0x2B32, 0x95E6,
+	0xA0C0, 0x9819, 0xD19E, 0x7FA3, 0x6644, 0x7E54, 0xAB3B, 0x830B,
+	0xCA8C, 0x29C7, 0xD36B, 0x3C28, 0x79A7, 0xE2BC, 0x1D16, 0x76AD,
+	0x3BDB, 0x5664, 0x4E74, 0x1E14, 0xDB92, 0x0A0C, 0x6C48, 0xE4B8,
+	0x5D9F, 0x6EBD, 0xEF43, 0xA6C4, 0xA839, 0xA431, 0x37D3, 0x8BF2,
+	0x32D5, 0x438B, 0x596E, 0xB7DA, 0x8C01, 0x64B1, 0xD29C, 0xE049,
+	0xB4D8, 0xFAAC, 0x07F3, 0x25CF, 0xAFCA, 0x8EF4, 0xE947, 0x1810,
+	0xD56F, 0x88F0, 0x6F4A, 0x725C, 0x2438, 0xF157, 0xC773, 0x5197,
+	0x23CB, 0x7CA1, 0x9CE8, 0x213E, 0xDD96, 0xDC61, 0x860D, 0x850F,
+	0x90E0, 0x427C, 0xC471, 0xAACC, 0xD890, 0x0506, 0x01F7, 0x121C,
+	0xA3C2, 0x5F6A, 0xF9AE, 0xD069, 0x9117, 0x5899, 0x273A, 0xB927,
+	0x38D9, 0x13EB, 0xB32B, 0x3322, 0xBBD2, 0x70A9, 0x8907, 0xA733,
+	0xB62D, 0x223C, 0x9215, 0x20C9, 0x4987, 0xFFAA, 0x7850, 0x7AA5,
+	0x8F03, 0xF859, 0x8009, 0x171A, 0xDA65, 0x31D7, 0xC684, 0xB8D0,
+	0xC382, 0xB029, 0x775A, 0x111E, 0xCB7B, 0xFCA8, 0xD66D, 0x3A2C,
+}
+};
+
+ /*
+  **********************************************************************
+  * Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+  *
+  * Inputs:
+  *     tk[]      = temporal key                         [128 bits]
+  *     ta[]      = transmitter's MAC address            [48 bits]
+  *     iv32      = upper 32 bits of IV                  [32 bits]
+  * Output:
+  *     p1k[]     = Phase 1 key                          [80 bits]
+  *
+  * Note:
+  *     This function only needs to be called every 2**16 packets,
+  *     although in theory it could be called every packet.
+  *
+  **********************************************************************
+  */
+static void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)
+{
+	int i;
+
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0] = Lo16(iv32);
+	p1k[1] = Hi16(iv32);
+	p1k[2] = Mk16(ta[1], ta[0]);	/* use TA[] as little-endian */
+	p1k[3] = Mk16(ta[3], ta[2]);
+	p1k[4] = Mk16(ta[5], ta[4]);
+
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i = 0; i < PHASE1_LOOP_CNT; i++) {	/* Each add operation here is mod 2**16 */
+		p1k[0] += _S_(p1k[4] ^ TK16((i & 1) + 0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i & 1) + 2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i & 1) + 4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i & 1) + 6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i & 1) + 0));
+		p1k[4] += (unsigned short)i;	/* avoid "slide attacks" */
+	}
+
+}
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [80 bits]
+*     iv16      = low 16 bits of IV counter            [16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA, IV32, IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+static void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)
+{
+	int i;
+	u16 PPK[6];		/* temporary key for mixing    */
+
+	/* Note: all adds in the PPK[] equations below are mod 2**16         */
+	for (i = 0; i < 5; i++)
+		PPK[i] = p1k[i];	/* first, copy P1K to PPK      */
+	PPK[5] = p1k[4] + iv16;	/* next,  add in IV16          */
+
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5]           */
+	PPK[0] += _S_(PPK[5] ^ TK16(0));	/* Mix key in each "round"     */
+	PPK[1] += _S_(PPK[0] ^ TK16(1));
+	PPK[2] += _S_(PPK[1] ^ TK16(2));
+	PPK[3] += _S_(PPK[2] ^ TK16(3));
+	PPK[4] += _S_(PPK[3] ^ TK16(4));
+	PPK[5] += _S_(PPK[4] ^ TK16(5));	/* Total # S-box lookups == 6  */
+
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] += RotR1(PPK[5] ^ TK16(6));
+	PPK[1] += RotR1(PPK[0] ^ TK16(7));	/* Use all of TK[] in Phase2   */
+	PPK[2] += RotR1(PPK[1]);
+	PPK[3] += RotR1(PPK[2]);
+	PPK[4] += RotR1(PPK[3]);
+	PPK[5] += RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/*       value PPK[0..5] is guaranteed to be unique, as a function   */
+	/*       of the 96-bit "input" value   {TA, IV32, IV16}. That is, P1K  */
+	/*       is now a keyed permutation of {TA, IV32, IV16}.               */
+
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16);	/* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] = (Hi8(iv16) | 0x20) & 0x7F;	/* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
+	for (i = 0; i < 6; i++) {
+		rc4key[4 + 2 * i] = Lo8(PPK[i]);
+		rc4key[5 + 2 * i] = Hi8(PPK[i]);
+	}
+
+}
+
+/* The hlen isn't include the IV */
+u32 rtw_tkip_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
+{				/*  exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	int curfragnum, length;
+	u8 *pframe, *payload, *iv, *prwskey;
+	union pn48 dot11txpn;
+	struct sta_info *stainfo;
+	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_SIZE +
+	    (((struct xmit_frame *)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+
+	/* 4 start to encrypt each fragment */
+	if (pattrib->encrypt == _TKIP_) {
+		if (pattrib->psta)
+			stainfo = pattrib->psta;
+		else
+			stainfo =
+			    rtw_get_stainfo(&padapter->stapriv,
+					    &pattrib->ra[0]);
+
+		if (stainfo != NULL) {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_tkip_encrypt: stainfo!= NULL!!!\n"));
+
+			if (IS_MCAST(pattrib->ra))
+				prwskey =
+				    psecuritypriv->
+				    dot118021XGrpKey[psecuritypriv->
+						     dot118021XGrpKeyid].skey;
+			else
+				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
+
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				iv = pframe + pattrib->hdrlen;
+				payload =
+				    pframe + pattrib->iv_len + pattrib->hdrlen;
+
+				GET_TKIP_PN(iv, dot11txpn);
+
+				pnl = (u16) (dot11txpn.val);
+				pnh = (u32) (dot11txpn.val >> 16);
+
+				phase1((u16 *)&ttkey[0], prwskey,
+				       &pattrib->ta[0], pnh);
+
+				phase2(&rc4key[0], prwskey, (u16 *)&ttkey[0],
+				       pnl);
+
+				if ((curfragnum + 1) == pattrib->nr_frags) {	/* 4 the last fragment */
+					length =
+					    pattrib->last_txcmdsz -
+					    pattrib->hdrlen - pattrib->iv_len -
+					    pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_security_c_,
+						 _drv_info_,
+						 ("pattrib->iv_len =%x, pattrib->icv_len =%x\n",
+						  pattrib->iv_len,
+						  pattrib->icv_len));
+					*((__le32 *)crc) = getcrc32(payload, length);	/* modified by Amy */
+
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							payload, length);
+					arcfour_encrypt(&mycontext,
+							payload + length, crc,
+							4);
+				} else {
+					length =
+					    pxmitpriv->frag_len -
+					    pattrib->hdrlen - pattrib->iv_len -
+					    pattrib->icv_len;
+					*((__le32 *)crc) = getcrc32(payload, length);	/* modified by Amy */
+					arcfour_init(&mycontext, rc4key, 16);
+					arcfour_encrypt(&mycontext, payload,
+							payload, length);
+					arcfour_encrypt(&mycontext,
+							payload + length, crc,
+							4);
+
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((SIZE_PTR)(pframe));
+				}
+			}
+		} else {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_tkip_encrypt: stainfo == NULL!!!\n"));
+			res = _FAIL;
+		}
+	}
+
+	return res;
+}
+
+/* The hlen doesn't include the IV */
+u32 rtw_tkip_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
+{				/*  exclude ICV */
+	u16 pnl;
+	u32 pnh;
+	u8 rc4key[16];
+	u8 ttkey[16];
+	u8 crc[4];
+	struct arc4context mycontext;
+	int length;
+
+	u8 *pframe, *payload, *iv, *prwskey;
+	union pn48 dot11txpn;
+	struct sta_info *stainfo;
+	struct rx_pkt_attrib *prxattrib =
+	    &((struct recv_frame_hdr *)precvframe)->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u32 res = _SUCCESS;
+
+	pframe =
+	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
+
+	/* 4 start to decrypt recvframe */
+	if (prxattrib->encrypt == _TKIP_) {
+		stainfo =
+		    rtw_get_stainfo(&padapter->stapriv, &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			if (IS_MCAST(prxattrib->ra)) {
+				if (psecuritypriv->binstallGrpkey == false) {
+					res = _FAIL;
+					DBG_8192D
+					    ("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n",
+					     __func__);
+					goto exit;
+				}
+				prwskey =
+				    psecuritypriv->dot118021XGrpKey[prxattrib->
+								    key_index].
+				    skey;
+			} else {
+				RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+					 ("rtw_tkip_decrypt: stainfo!= NULL!!!\n"));
+				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
+			}
+
+			iv = pframe + prxattrib->hdrlen;
+			payload =
+			    pframe + prxattrib->iv_len + prxattrib->hdrlen;
+			length =
+			    ((struct recv_frame_hdr *)precvframe)->len -
+			    prxattrib->hdrlen - prxattrib->iv_len;
+
+			GET_TKIP_PN(iv, dot11txpn);
+
+			pnl = (u16) (dot11txpn.val);
+			pnh = (u32) (dot11txpn.val >> 16);
+
+			phase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0],
+			       pnh);
+			phase2(&rc4key[0], prwskey, (unsigned short *)&ttkey[0],
+			       pnl);
+
+			/* 4 decrypt payload include icv */
+
+			arcfour_init(&mycontext, rc4key, 16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+
+			*((__le32 *)crc) = getcrc32(payload, length - 4);
+
+			if (crc[3] != payload[length - 1] ||
+			    crc[2] != payload[length - 2] ||
+			    crc[1] != payload[length - 3] ||
+			    crc[0] != payload[length - 4]) {
+				RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+					 ("rtw_wep_decrypt:icv error crc[3](%x)!= payload[length-1](%x) || crc[2](%x)!= payload[length-2](%x) || crc[1](%x)!= payload[length-3](%x) || crc[0](%x)!= payload[length-4](%x)\n",
+					  crc[3], payload[length - 1], crc[2],
+					  payload[length - 2], crc[1],
+					  payload[length - 3], crc[0],
+					  payload[length - 4]));
+				res = _FAIL;
+			}
+		} else {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_tkip_decrypt: stainfo == NULL!!!\n"));
+			res = _FAIL;
+		}
+	}
+
+exit:
+	return res;
+}
+
+/* 3			===== AES related ===== */
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+static u8 sbox_table[256] = {
+	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+};
+
+/*****************************/
+/**** Function Prototypes ****/
+/*****************************/
+
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out);
+static void construct_mic_iv(u8 *mic_header1,
+			     int qc_exists,
+			     int a4_exists,
+			     u8 *mpdu, uint payload_length, u8 *pn_vector);
+static void construct_mic_header1(u8 *mic_header1,
+				  int header_length, u8 *mpdu);
+static void construct_mic_header2(u8 *mic_header2,
+				  u8 *mpdu, int a4_exists, int qc_exists);
+static void construct_ctr_preload(u8 *ctr_preload,
+				  int a4_exists,
+				  int qc_exists,
+				  u8 *mpdu, u8 *pn_vector, int c);
+static void xor_128(u8 *a, u8 *b, u8 *out);
+static void xor_32(u8 *a, u8 *b, u8 *out);
+static u8 sbox(u8 a);
+static void next_key(u8 *key, int round);
+static void byte_sub(u8 *in, u8 *out);
+static void shift_row(u8 *in, u8 *out);
+static void mix_column(u8 *in, u8 *out);
+static void add_round_key(u8 *shiftrow_in,
+			  u8 *mcol_in, u8 *block_in, int round, u8 *out);
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext);
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+static void xor_128(u8 *a, u8 *b, u8 *out)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = a[i] ^ b[i];
+
+}
+
+static void xor_32(u8 *a, u8 *b, u8 *out)
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		out[i] = a[i] ^ b[i];
+
+}
+
+static u8 sbox(u8 a)
+{
+	return sbox_table[(int)a];
+}
+
+static void next_key(u8 *key, int round)
+{
+	u8 rcon;
+	u8 sbox_key[4];
+	u8 rcon_table[12] = {
+		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+		0x1b, 0x36, 0x36, 0x36
+	};
+
+	sbox_key[0] = sbox(key[13]);
+	sbox_key[1] = sbox(key[14]);
+	sbox_key[2] = sbox(key[15]);
+	sbox_key[3] = sbox(key[12]);
+
+	rcon = rcon_table[round];
+
+	xor_32(&key[0], sbox_key, &key[0]);
+	key[0] = key[0] ^ rcon;
+
+	xor_32(&key[4], &key[0], &key[4]);
+	xor_32(&key[8], &key[4], &key[8]);
+	xor_32(&key[12], &key[8], &key[12]);
+
+}
+
+static void byte_sub(u8 *in, u8 *out)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = sbox(in[i]);
+
+}
+
+static void shift_row(u8 *in, u8 *out)
+{
+
+	out[0] = in[0];
+	out[1] = in[5];
+	out[2] = in[10];
+	out[3] = in[15];
+	out[4] = in[4];
+	out[5] = in[9];
+	out[6] = in[14];
+	out[7] = in[3];
+	out[8] = in[8];
+	out[9] = in[13];
+	out[10] = in[2];
+	out[11] = in[7];
+	out[12] = in[12];
+	out[13] = in[1];
+	out[14] = in[6];
+	out[15] = in[11];
+
+}
+
+static void mix_column(u8 *in, u8 *out)
+{
+	int i;
+	u8 add1b[4];
+	u8 add1bf7[4];
+	u8 rotl[4];
+	u8 swap_halfs[4];
+	u8 andf7[4];
+	u8 rotr[4];
+	u8 temp[4];
+	u8 tempb[4];
+
+	for (i = 0; i < 4; i++) {
+		if ((in[i] & 0x80) == 0x80)
+			add1b[i] = 0x1b;
+		else
+			add1b[i] = 0x00;
+	}
+
+	swap_halfs[0] = in[2];	/* Swap halfs */
+	swap_halfs[1] = in[3];
+	swap_halfs[2] = in[0];
+	swap_halfs[3] = in[1];
+
+	rotl[0] = in[3];	/* Rotate left 8 bits */
+	rotl[1] = in[0];
+	rotl[2] = in[1];
+	rotl[3] = in[2];
+
+	andf7[0] = in[0] & 0x7f;
+	andf7[1] = in[1] & 0x7f;
+	andf7[2] = in[2] & 0x7f;
+	andf7[3] = in[3] & 0x7f;
+
+	for (i = 3; i > 0; i--) {	/* logical shift left 1 bit */
+		andf7[i] = andf7[i] << 1;
+		if ((andf7[i - 1] & 0x80) == 0x80)
+			andf7[i] = (andf7[i] | 0x01);
+	}
+	andf7[0] = andf7[0] << 1;
+	andf7[0] = andf7[0] & 0xfe;
+
+	xor_32(add1b, andf7, add1bf7);
+
+	xor_32(in, add1bf7, rotr);
+
+	temp[0] = rotr[0];	/* Rotate right 8 bits */
+	rotr[0] = rotr[1];
+	rotr[1] = rotr[2];
+	rotr[2] = rotr[3];
+	rotr[3] = temp[0];
+
+	xor_32(add1bf7, rotr, temp);
+	xor_32(swap_halfs, rotl, tempb);
+	xor_32(temp, tempb, out);
+
+}
+
+static void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)
+{
+	int round;
+	int i;
+	u8 intermediatea[16];
+	u8 intermediateb[16];
+	u8 round_key[16];
+
+	for (i = 0; i < 16; i++)
+		round_key[i] = key[i];
+
+	for (round = 0; round < 11; round++) {
+		if (round == 0) {
+			xor_128(round_key, data, ciphertext);
+			next_key(round_key, round);
+		} else if (round == 10) {
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			xor_128(intermediateb, round_key, ciphertext);
+		} else {	/* 1 - 9 */
+
+			byte_sub(ciphertext, intermediatea);
+			shift_row(intermediatea, intermediateb);
+			mix_column(&intermediateb[0], &intermediatea[0]);
+			mix_column(&intermediateb[4], &intermediatea[4]);
+			mix_column(&intermediateb[8], &intermediatea[8]);
+			mix_column(&intermediateb[12], &intermediatea[12]);
+			xor_128(intermediatea, round_key, ciphertext);
+			next_key(round_key, round);
+		}
+	}
+
+}
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+static void construct_mic_iv(u8 *mic_iv,
+			     int qc_exists,
+			     int a4_exists,
+			     u8 *mpdu, uint payload_length, u8 *pn_vector)
+{
+	int i;
+
+	mic_iv[0] = 0x59;
+	if (qc_exists && a4_exists)
+		mic_iv[1] = mpdu[30] & 0x0f;	/* QoS_TC           */
+	if (qc_exists && !a4_exists)
+		mic_iv[1] = mpdu[24] & 0x0f;	/* mute bits 7-4    */
+	if (!qc_exists)
+		mic_iv[1] = 0x00;
+	for (i = 2; i < 8; i++)
+		mic_iv[i] = mpdu[i + 8];	/* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
+#ifdef CONSISTENT_PN_ORDER
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[i - 8];	/* mic_iv[8:13] = PN[0:5] */
+#else
+	for (i = 8; i < 14; i++)
+		mic_iv[i] = pn_vector[13 - i];	/* mic_iv[8:13] = PN[5:0] */
+#endif
+	mic_iv[14] = (unsigned char)(payload_length / 256);
+	mic_iv[15] = (unsigned char)(payload_length % 256);
+
+}
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header1(u8 *mic_header1,
+				  int header_length, u8 *mpdu)
+{
+
+	mic_header1[0] = (u8) ((header_length - 2) / 256);
+	mic_header1[1] = (u8) ((header_length - 2) % 256);
+	mic_header1[2] = mpdu[0] & 0xcf;	/* Mute CF poll & CF ack bits */
+	mic_header1[3] = mpdu[1] & 0xc7;	/* Mute retry, more data and pwr mgt bits */
+	mic_header1[4] = mpdu[4];	/* A1 */
+	mic_header1[5] = mpdu[5];
+	mic_header1[6] = mpdu[6];
+	mic_header1[7] = mpdu[7];
+	mic_header1[8] = mpdu[8];
+	mic_header1[9] = mpdu[9];
+	mic_header1[10] = mpdu[10];	/* A2 */
+	mic_header1[11] = mpdu[11];
+	mic_header1[12] = mpdu[12];
+	mic_header1[13] = mpdu[13];
+	mic_header1[14] = mpdu[14];
+	mic_header1[15] = mpdu[15];
+
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header2(u8 *mic_header2,
+				  u8 *mpdu, int a4_exists, int qc_exists)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		mic_header2[i] = 0x00;
+
+	mic_header2[0] = mpdu[16];	/* A3 */
+	mic_header2[1] = mpdu[17];
+	mic_header2[2] = mpdu[18];
+	mic_header2[3] = mpdu[19];
+	mic_header2[4] = mpdu[20];
+	mic_header2[5] = mpdu[21];
+
+	mic_header2[6] = 0x00;
+	mic_header2[7] = 0x00;	/* mpdu[23]; */
+
+	if (!qc_exists && a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
+	}
+
+	if (qc_exists && !a4_exists) {
+		mic_header2[8] = mpdu[24] & 0x0f;	/* mute bits 15 - 4 */
+		mic_header2[9] = mpdu[25] & 0x00;
+	}
+
+	if (qc_exists && a4_exists) {
+		for (i = 0; i < 6; i++)
+			mic_header2[8 + i] = mpdu[24 + i];	/* A4 */
+
+		mic_header2[14] = mpdu[30] & 0x0f;
+		mic_header2[15] = mpdu[31] & 0x00;
+	}
+
+}
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_ctr_preload(u8 *ctr_preload,
+				  int a4_exists,
+				  int qc_exists,
+				  u8 *mpdu, u8 *pn_vector, int c)
+{
+	int i = 0;
+
+	for (i = 0; i < 16; i++)
+		ctr_preload[i] = 0x00;
+	i = 0;
+
+	ctr_preload[0] = 0x01;	/* flag */
+	if (qc_exists && a4_exists)
+		ctr_preload[1] = mpdu[30] & 0x0f;	/* QoC_Control */
+	if (qc_exists && !a4_exists)
+		ctr_preload[1] = mpdu[24] & 0x0f;
+
+	for (i = 2; i < 8; i++)
+		ctr_preload[i] = mpdu[i + 8];	/* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
+#ifdef CONSISTENT_PN_ORDER
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[i - 8];	/* ctr_preload[8:13] = PN[0:5] */
+#else
+	for (i = 8; i < 14; i++)
+		ctr_preload[i] = pn_vector[13 - i];	/* ctr_preload[8:13] = PN[5:0] */
+#endif
+	ctr_preload[14] = (unsigned char)(c / 256);	/* Ctr */
+	ctr_preload[15] = (unsigned char)(c % 256);
+
+}
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+static void bitwise_xor(u8 *ina, u8 *inb, u8 *out)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		out[i] = ina[i] ^ inb[i];
+
+}
+
+static int aes_cipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)
+{
+	uint qc_exists, a4_exists, i, j, payload_remainder;
+	uint num_blocks, payload_index;
+
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint frtype = GetFrameType(pframe);
+	uint frsubtype = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if ((frtype == WIFI_DATA_CFACK) ||
+	    (frtype == WIFI_DATA_CFPOLL) || (frtype == WIFI_DATA_CFACKPOLL)) {
+		qc_exists = 1;
+		if (hdrlen != WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+	} else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) || (frsubtype == 0x0b)) {
+		if (hdrlen != WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+		qc_exists = 1;
+	} else {
+		qc_exists = 0;
+	}
+
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen + 1];
+	pn_vector[2] = pframe[hdrlen + 4];
+	pn_vector[3] = pframe[hdrlen + 5];
+	pn_vector[4] = pframe[hdrlen + 6];
+	pn_vector[5] = pframe[hdrlen + 7];
+
+	construct_mic_iv(mic_iv, qc_exists, a4_exists, pframe,	/* message, */
+			 plen, pn_vector);
+
+	construct_mic_header1(mic_header1, hdrlen, pframe	/* message */
+	    );
+	construct_mic_header2(mic_header2, pframe,	/* message, */
+			      a4_exists, qc_exists);
+
+	payload_remainder = plen % 16;
+	num_blocks = plen / 16;
+
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+
+	for (j = 0; j < 8; j++)
+		mic[j] = aes_out[j];
+
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		pframe[payload_index + j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,
+				      pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+
+	if (payload_remainder > 0) {
+		/* If there is a short final block, then pad it, encrypt it
+		 * and copy the unpadded part back   */
+		construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,
+				      pn_vector, num_blocks + 1);
+
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = pframe[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload, a4_exists, qc_exists, pframe,
+			      pn_vector, 0);
+
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = pframe[j + hdrlen + 8 + plen];
+
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		pframe[payload_index++] = chain_buffer[j];
+
+	return _SUCCESS;
+}
+
+u32 rtw_aes_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
+{				/*  exclude ICV */
+
+	/*static */
+
+	/* Intermediate Buffers */
+	int curfragnum, length;
+	u8 *pframe, *prwskey;	/*  *payload,*iv */
+	struct sta_info *stainfo;
+	struct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u32 res = _SUCCESS;
+
+	if (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)
+		return _FAIL;
+
+	pframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_SIZE +
+		 (((struct xmit_frame *)pxmitframe)->pkt_offset *
+		  PACKET_OFFSET_SZ);
+
+	/* 4 start to encrypt each fragment */
+	if ((pattrib->encrypt == _AES_)) {
+		if (pattrib->psta) {
+			stainfo = pattrib->psta;
+		} else {
+			stainfo =
+			    rtw_get_stainfo(&padapter->stapriv,
+					    &pattrib->ra[0]);
+		}
+
+		if (stainfo != NULL) {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_aes_encrypt: stainfo!= NULL!!!\n"));
+
+			if (IS_MCAST(pattrib->ra)) {
+				prwskey =
+				    psecuritypriv->
+				    dot118021XGrpKey[psecuritypriv->
+						     dot118021XGrpKeyid].skey;
+			} else {
+				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
+			}
+
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags;
+			     curfragnum++) {
+				if ((curfragnum + 1) == pattrib->nr_frags) {	/* 4 the last fragment */
+					length =
+					    pattrib->last_txcmdsz -
+					    pattrib->hdrlen - pattrib->iv_len -
+					    pattrib->icv_len;
+
+					aes_cipher(prwskey, pattrib->hdrlen,
+						   pframe, length);
+				} else {
+					length =
+					    pxmitpriv->frag_len -
+					    pattrib->hdrlen - pattrib->iv_len -
+					    pattrib->icv_len;
+
+					aes_cipher(prwskey, pattrib->hdrlen,
+						   pframe, length);
+					pframe += pxmitpriv->frag_len;
+					pframe = (u8 *)RND4((SIZE_PTR) (pframe));
+				}
+			}
+		} else {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_aes_encrypt: stainfo == NULL!!!\n"));
+			res = _FAIL;
+		}
+	}
+
+	return res;
+}
+
+static int aes_decipher(u8 *key, uint hdrlen, u8 *pframe, uint plen)
+{
+	static u8 message[MAX_MSG_SIZE];
+	uint qc_exists, a4_exists, i, j, payload_remainder,
+	    num_blocks, payload_index;
+	int res = _SUCCESS;
+	u8 pn_vector[6];
+	u8 mic_iv[16];
+	u8 mic_header1[16];
+	u8 mic_header2[16];
+	u8 ctr_preload[16];
+
+	/* Intermediate Buffers */
+	u8 chain_buffer[16];
+	u8 aes_out[16];
+	u8 padded_buffer[16];
+	u8 mic[8];
+	uint frtype = GetFrameType(pframe);
+	uint frsubtype = GetFrameSubType(pframe);
+
+	frsubtype = frsubtype >> 4;
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	/* start to decrypt the payload */
+
+	num_blocks = (plen - 8) / 16;	/* plen including llc, payload_length and mic) */
+
+	payload_remainder = (plen - 8) % 16;
+
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen + 1];
+	pn_vector[2] = pframe[hdrlen + 4];
+	pn_vector[3] = pframe[hdrlen + 5];
+	pn_vector[4] = pframe[hdrlen + 6];
+	pn_vector[5] = pframe[hdrlen + 7];
+
+	if ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if ((frtype == WIFI_DATA_CFACK) ||
+	    (frtype == WIFI_DATA_CFPOLL) || (frtype == WIFI_DATA_CFACKPOLL)) {
+		qc_exists = 1;
+		if (hdrlen != WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+	} else if ((frsubtype == 0x08) ||
+		   (frsubtype == 0x09) ||
+		   (frsubtype == 0x0a) || (frsubtype == 0x0b)) {
+		if (hdrlen != WLAN_HDR_A3_QOS_LEN)
+			hdrlen += 2;
+		qc_exists = 1;
+	} else {
+		qc_exists = 0;
+	}
+
+	/*  now, decrypt pframe with hdrlen offset and plen long */
+
+	payload_index = hdrlen + 8;	/*  8 is for extiv */
+
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload,
+				      a4_exists,
+				      qc_exists, pframe, pn_vector, i + 1);
+
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+
+		for (j = 0; j < 16; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+
+	if (payload_remainder > 0) {
+		/* If there is a short final block, then pad it,
+		 * encrypt it and copy the unpadded part back */
+		construct_ctr_preload(ctr_preload,
+				      a4_exists,
+				      qc_exists,
+				      pframe, pn_vector, num_blocks + 1);
+
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++) {
+			padded_buffer[j] = pframe[payload_index + j];
+		}
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			pframe[payload_index++] = chain_buffer[j];
+	}
+
+	/* start to calculate the mic */
+
+	memcpy((void *)message, pframe, (hdrlen + plen + 8));	/* 8 is for ext iv len */
+
+	pn_vector[0] = pframe[hdrlen];
+	pn_vector[1] = pframe[hdrlen + 1];
+	pn_vector[2] = pframe[hdrlen + 4];
+	pn_vector[3] = pframe[hdrlen + 5];
+	pn_vector[4] = pframe[hdrlen + 6];
+	pn_vector[5] = pframe[hdrlen + 7];
+
+	construct_mic_iv(mic_iv,
+			 qc_exists, a4_exists, message, plen - 8, pn_vector);
+
+	construct_mic_header1(mic_header1, hdrlen, message);
+	construct_mic_header2(mic_header2, message, a4_exists, qc_exists);
+
+	payload_remainder = (plen - 8) % 16;
+	num_blocks = (plen - 8) / 16;
+
+	/* Find start of payload */
+	payload_index = (hdrlen + 8);
+
+	/* Calculate MIC */
+	aes128k128d(key, mic_iv, aes_out);
+	bitwise_xor(aes_out, mic_header1, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+	bitwise_xor(aes_out, mic_header2, chain_buffer);
+	aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++) {
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+		payload_index += 16;
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+
+	/* Add on the final payload block if it needs padding */
+	if (payload_remainder > 0) {
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index++];
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		aes128k128d(key, chain_buffer, aes_out);
+	}
+
+	for (j = 0; j < 8; j++)
+		mic[j] = aes_out[j];
+
+	/* Insert MIC into payload */
+	for (j = 0; j < 8; j++)
+		message[payload_index + j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i = 0; i < num_blocks; i++) {
+		construct_ctr_preload(ctr_preload,
+				      a4_exists,
+				      qc_exists, message, pn_vector, i + 1);
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+		for (j = 0; j < 16; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+
+	if (payload_remainder > 0) {
+		/* If there is a short final block, then pad it,
+		 * encrypt it and copy the unpadded part back */
+		construct_ctr_preload(ctr_preload,
+				      a4_exists,
+				      qc_exists,
+				      message, pn_vector, num_blocks + 1);
+
+		for (j = 0; j < 16; j++)
+			padded_buffer[j] = 0x00;
+		for (j = 0; j < payload_remainder; j++)
+			padded_buffer[j] = message[payload_index + j];
+		aes128k128d(key, ctr_preload, aes_out);
+		bitwise_xor(aes_out, padded_buffer, chain_buffer);
+		for (j = 0; j < payload_remainder; j++)
+			message[payload_index++] = chain_buffer[j];
+	}
+
+	/* Encrypt the MIC */
+	construct_ctr_preload(ctr_preload,
+			      a4_exists, qc_exists, message, pn_vector, 0);
+
+	for (j = 0; j < 16; j++)
+		padded_buffer[j] = 0x00;
+	for (j = 0; j < 8; j++)
+		padded_buffer[j] = message[j + hdrlen + 8 + plen - 8];
+
+	aes128k128d(key, ctr_preload, aes_out);
+	bitwise_xor(aes_out, padded_buffer, chain_buffer);
+	for (j = 0; j < 8; j++)
+		message[payload_index++] = chain_buffer[j];
+
+	/* compare the mic */
+	for (i = 0; i < 8; i++) {
+		if (pframe[hdrlen + 8 + plen - 8 + i] !=
+		    message[hdrlen + 8 + plen - 8 + i]) {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
+				  i, pframe[hdrlen + 8 + plen - 8 + i],
+				  message[hdrlen + 8 + plen - 8 + i]));
+			DBG_8192D
+			    ("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x)\n",
+			     i, pframe[hdrlen + 8 + plen - 8 + i],
+			     message[hdrlen + 8 + plen - 8 + i]);
+			res = _FAIL;
+		}
+	}
+
+	if (res == _FAIL) {
+		int gg = 0;
+		for (gg = 0; gg < 32; gg++)
+			DBG_8192D(" [%d]=%02x ", gg, pframe[gg]);
+		DBG_8192D("error packet header\n");
+	}
+
+	return res;
+}
+
+u32 rtw_aes_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
+{				/*  exclude ICV */
+
+	/* Intermediate Buffers */
+
+	int length;
+	u8 *pframe, *prwskey;	/*  *payload,*iv */
+	struct sta_info *stainfo;
+	struct rx_pkt_attrib *prxattrib =
+	    &((struct recv_frame_hdr *)precvframe)->attrib;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	u32 res = _SUCCESS;
+
+	pframe =
+	    (unsigned char *)((struct recv_frame_hdr *)precvframe)->rx_data;
+	/* 4 start to encrypt each fragment */
+	if ((prxattrib->encrypt == _AES_)) {
+		stainfo =
+		    rtw_get_stainfo(&padapter->stapriv, &prxattrib->ta[0]);
+		if (stainfo != NULL) {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_aes_decrypt: stainfo!= NULL!!!\n"));
+
+			if (IS_MCAST(prxattrib->ra)) {
+				/* in concurrent we should use sw descrypt in group key, so we remove this message */
+				if (psecuritypriv->binstallGrpkey == false) {
+					res = _FAIL;
+					DBG_8192D
+					    ("%s:rx bc/mc packets, but didn't install group key!!!!!!!!!!\n",
+					     __func__);
+					goto exit;
+				}
+				prwskey =
+				    psecuritypriv->dot118021XGrpKey[prxattrib->
+								    key_index].
+				    skey;
+
+				if (psecuritypriv->dot118021XGrpKeyid !=
+				    prxattrib->key_index) {
+					DBG_8192D
+					    ("not match packet_index =%d, install_index =%d\n",
+					     prxattrib->key_index,
+					     psecuritypriv->dot118021XGrpKeyid);
+					res = _FAIL;
+					goto exit;
+				}
+			} else {
+				prwskey = &stainfo->dot118021x_UncstKey.skey[0];
+			}
+
+			length =
+			    ((struct recv_frame_hdr *)precvframe)->len -
+			    prxattrib->hdrlen - prxattrib->iv_len;
+
+			res =
+			    aes_decipher(prwskey, prxattrib->hdrlen, pframe,
+					 length);
+		} else {
+			RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+				 ("rtw_aes_encrypt: stainfo == NULL!!!\n"));
+			res = _FAIL;
+		}
+	}
+
+exit:
+	return res;
+}
+
+/* compress 512-bits */
+static int sha256_compress(struct sha256_state *md, unsigned char *buf)
+{
+	u32 S[8], W[64], t0, t1;
+	u32 t;
+	int i;
+
+	/* copy state into S */
+	for (i = 0; i < 8; i++)
+		S[i] = md->state[i];
+
+	/* copy the state into 512-bits into W[0..15] */
+	for (i = 0; i < 16; i++)
+		W[i] = WPA_GET_BE32(buf + (4 * i));
+
+	/* fill W[16..63] */
+	for (i = 16; i < 64; i++) {
+		W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
+		    W[i - 16];
+	}
+
+	/* Compress */
+#define RND(a, b, c, d, e, f, g, h, i)			\
+do {							\
+	t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\
+	t1 = Sigma0(a) + Maj(a, b, c);			\
+	d += t0;					\
+	h  = t0 + t1;					\
+} while (0)
+
+	for (i = 0; i < 64; ++i) {
+		RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
+		t = S[7];
+		S[7] = S[6];
+		S[6] = S[5];
+		S[5] = S[4];
+		S[4] = S[3];
+		S[3] = S[2];
+		S[2] = S[1];
+		S[1] = S[0];
+		S[0] = t;
+	}
+
+	/* feedback */
+	for (i = 0; i < 8; i++)
+		md->state[i] = md->state[i] + S[i];
+	return 0;
+}
+
+/* Initialize the hash state */
+static void sha256_init(struct sha256_state *md)
+{
+	md->curlen = 0;
+	md->length = 0;
+	md->state[0] = 0x6A09E667UL;
+	md->state[1] = 0xBB67AE85UL;
+	md->state[2] = 0x3C6EF372UL;
+	md->state[3] = 0xA54FF53AUL;
+	md->state[4] = 0x510E527FUL;
+	md->state[5] = 0x9B05688CUL;
+	md->state[6] = 0x1F83D9ABUL;
+	md->state[7] = 0x5BE0CD19UL;
+}
+
+/**
+   Process a block of memory though the hash
+   @param md     The hash state
+   @param in     The data to hash
+   @param inlen  The length of the data (octets)
+   @return CRYPT_OK if successful
+*/
+static int sha256_process(struct sha256_state *md, unsigned char *in,
+			  unsigned long inlen)
+{
+	unsigned long n;
+#define block_size 64
+
+	if (md->curlen > sizeof(md->buf))
+		return -1;
+
+	while (inlen > 0) {
+		if (md->curlen == 0 && inlen >= block_size) {
+			if (sha256_compress(md, (unsigned char *)in) < 0)
+				return -1;
+			md->length += block_size * 8;
+			in += block_size;
+			inlen -= block_size;
+		} else {
+			n = MIN(inlen, (block_size - md->curlen));
+			memcpy(md->buf + md->curlen, in, n);
+			md->curlen += n;
+			in += n;
+			inlen -= n;
+			if (md->curlen == block_size) {
+				if (sha256_compress(md, md->buf) < 0)
+					return -1;
+				md->length += 8 * block_size;
+				md->curlen = 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/**
+   Terminate the hash to get the digest
+   @param md  The hash state
+   @param out [out] The destination of the hash (32 bytes)
+   @return CRYPT_OK if successful
+*/
+static int sha256_done(struct sha256_state *md, unsigned char *out)
+{
+	int i;
+
+	if (md->curlen >= sizeof(md->buf))
+		return -1;
+
+	/* increase the length of the message */
+	md->length += md->curlen * 8;
+
+	/* append the '1' bit */
+	md->buf[md->curlen++] = (unsigned char)0x80;
+
+	/* if the length is currently above 56 bytes we append zeros
+	 * then compress.  Then we can fall back to padding zeros and length
+	 * encoding like normal.
+	 */
+	if (md->curlen > 56) {
+		while (md->curlen < 64)
+			md->buf[md->curlen++] = (unsigned char)0;
+		sha256_compress(md, md->buf);
+		md->curlen = 0;
+	}
+
+	/* pad upto 56 bytes of zeroes */
+	while (md->curlen < 56)
+		md->buf[md->curlen++] = (unsigned char)0;
+
+	/* store length */
+	WPA_PUT_BE64(md->buf + 56, md->length);
+	sha256_compress(md, md->buf);
+
+	/* copy output */
+	for (i = 0; i < 8; i++)
+		WPA_PUT_BE32(out + (4 * i), md->state[i]);
+
+	return 0;
+}
+
+/**
+ * sha256_vector - SHA256 hash for data vector
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for the hash
+ * Returns: 0 on success, -1 of failure
+ */
+static int sha256_vector(size_t num_elem, u8 *addr[], size_t *len, u8 *mac)
+{
+	struct sha256_state ctx;
+	size_t i;
+
+	sha256_init(&ctx);
+	for (i = 0; i < num_elem; i++)
+		if (sha256_process(&ctx, addr[i], len[i]))
+			return -1;
+	if (sha256_done(&ctx, mac))
+		return -1;
+	return 0;
+}
+
+static u8 os_strlen(const char *s)
+{
+	const char *p = s;
+	while (*p)
+		p++;
+	return p - s;
+}
+
+static int os_memcmp(void *s1, void *s2, u8 n)
+{
+	unsigned char *p1 = s1, *p2 = s2;
+
+	if (n == 0)
+		return 0;
+
+	while (*p1 == *p2) {
+		p1++;
+		p2++;
+		n--;
+		if (n == 0)
+			return 0;
+	}
+
+	return *p1 - *p2;
+}
+
+/**
+ * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)
+ * @key: Key for HMAC operations
+ * @key_len: Length of the key in bytes
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for the hash (32 bytes)
+ */
+static void hmac_sha256_vector(u8 *key, size_t key_len, size_t num_elem,
+			       u8 *addr[], size_t *len, u8 *mac)
+{
+	unsigned char k_pad[64];	/* padding - key XORd with ipad/opad */
+	unsigned char tk[32];
+	u8 *_addr[6];
+	size_t _len[6], i;
+
+	if (num_elem > 5) {
+		/*
+		 * Fixed limit on the number of fragments to avoid having to
+		 * allocate memory (which could fail).
+		 */
+		return;
+	}
+
+	/* if key is longer than 64 bytes reset it to key = SHA256(key) */
+	if (key_len > 64) {
+		sha256_vector(1, &key, &key_len, tk);
+		key = tk;
+		key_len = 32;
+	}
+
+	/* the HMAC_SHA256 transform looks like:
+	 *
+	 * SHA256(K XOR opad, SHA256(K XOR ipad, text))
+	 *
+	 * where K is an n byte key
+	 * ipad is the byte 0x36 repeated 64 times
+	 * opad is the byte 0x5c repeated 64 times
+	 * and text is the data being protected */
+
+	/* start out by storing key in ipad */
+	memset(k_pad, 0, sizeof(k_pad));
+	memcpy(k_pad, key, key_len);
+	/* XOR key with ipad values */
+	for (i = 0; i < 64; i++)
+		k_pad[i] ^= 0x36;
+
+	/* perform inner SHA256 */
+	_addr[0] = k_pad;
+	_len[0] = 64;
+	for (i = 0; i < num_elem; i++) {
+		_addr[i + 1] = addr[i];
+		_len[i + 1] = len[i];
+	}
+	sha256_vector(1 + num_elem, _addr, _len, mac);
+
+	memset(k_pad, 0, sizeof(k_pad));
+	memcpy(k_pad, key, key_len);
+	/* XOR key with opad values */
+	for (i = 0; i < 64; i++)
+		k_pad[i] ^= 0x5c;
+
+	/* perform outer SHA256 */
+	_addr[0] = k_pad;
+	_len[0] = 64;
+	_addr[1] = mac;
+	_len[1] = 32;
+	sha256_vector(2, _addr, _len, mac);
+}
+
+/**
+ * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5.1.5.2)
+ * @key: Key for PRF
+ * @key_len: Length of the key in bytes
+ * @label: A unique label for each purpose of the PRF
+ * @data: Extra data to bind into the key
+ * @data_len: Length of the data
+ * @buf: Buffer for the generated pseudo-random key
+ * @buf_len: Number of bytes of key to generate
+ *
+ * This function is used to derive new, cryptographically separate keys from a
+ * given key.
+ */
+static void sha256_prf(u8 *key, size_t key_len, char *label,
+		       u8 *data, size_t data_len, u8 *buf, size_t buf_len)
+{
+	u16 counter = 1;
+	size_t pos, plen;
+	u8 hash[SHA256_MAC_LEN];
+	u8 *addr[4];
+	size_t len[4];
+	u8 counter_le[2], length_le[2];
+
+	addr[0] = counter_le;
+	len[0] = 2;
+	addr[1] = (u8 *)label;
+	len[1] = os_strlen(label);
+	addr[2] = data;
+	len[2] = data_len;
+	addr[3] = length_le;
+	len[3] = sizeof(length_le);
+
+	WPA_PUT_LE16(length_le, buf_len * 8);
+	pos = 0;
+	while (pos < buf_len) {
+		plen = buf_len - pos;
+		WPA_PUT_LE16(counter_le, counter);
+		if (plen >= SHA256_MAC_LEN) {
+			hmac_sha256_vector(key, key_len, 4, addr, len,
+					   &buf[pos]);
+			pos += SHA256_MAC_LEN;
+		} else {
+			hmac_sha256_vector(key, key_len, 4, addr, len, hash);
+			memcpy(&buf[pos], hash, plen);
+			break;
+		}
+		counter++;
+	}
+}
+
+/* AES tables*/
+const u32 Te0[256] = {
+	0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
+	0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
+	0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
+	0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
+	0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
+	0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
+	0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
+	0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
+	0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
+	0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
+	0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
+	0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
+	0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
+	0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
+	0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
+	0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
+	0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
+	0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
+	0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
+	0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
+	0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
+	0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
+	0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
+	0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
+	0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
+	0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
+	0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
+	0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
+	0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
+	0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
+	0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
+	0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
+	0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
+	0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
+	0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
+	0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
+	0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
+	0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
+	0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
+	0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
+	0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
+	0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
+	0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
+	0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
+	0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
+	0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
+	0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
+	0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
+	0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
+	0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
+	0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
+	0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
+	0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
+	0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
+	0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
+	0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
+	0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
+	0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
+	0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
+	0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
+	0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
+	0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
+	0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
+	0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
+};
+
+const u32 Td0[256] = {
+	0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
+	0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
+	0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
+	0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
+	0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
+	0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
+	0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
+	0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
+	0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
+	0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
+	0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
+	0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
+	0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
+	0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
+	0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
+	0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
+	0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
+	0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
+	0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
+	0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
+	0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
+	0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
+	0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
+	0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
+	0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
+	0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
+	0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
+	0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
+	0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
+	0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
+	0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
+	0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
+	0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
+	0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
+	0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
+	0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
+	0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
+	0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
+	0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
+	0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
+	0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
+	0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
+	0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
+	0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
+	0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
+	0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
+	0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
+	0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
+	0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
+	0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
+	0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
+	0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
+	0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
+	0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
+	0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
+	0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
+	0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
+	0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
+	0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
+	0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
+	0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
+	0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
+	0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
+	0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
+};
+
+const u8 Td4s[256] = {
+	0x52U, 0x09U, 0x6aU, 0xd5U, 0x30U, 0x36U, 0xa5U, 0x38U,
+	0xbfU, 0x40U, 0xa3U, 0x9eU, 0x81U, 0xf3U, 0xd7U, 0xfbU,
+	0x7cU, 0xe3U, 0x39U, 0x82U, 0x9bU, 0x2fU, 0xffU, 0x87U,
+	0x34U, 0x8eU, 0x43U, 0x44U, 0xc4U, 0xdeU, 0xe9U, 0xcbU,
+	0x54U, 0x7bU, 0x94U, 0x32U, 0xa6U, 0xc2U, 0x23U, 0x3dU,
+	0xeeU, 0x4cU, 0x95U, 0x0bU, 0x42U, 0xfaU, 0xc3U, 0x4eU,
+	0x08U, 0x2eU, 0xa1U, 0x66U, 0x28U, 0xd9U, 0x24U, 0xb2U,
+	0x76U, 0x5bU, 0xa2U, 0x49U, 0x6dU, 0x8bU, 0xd1U, 0x25U,
+	0x72U, 0xf8U, 0xf6U, 0x64U, 0x86U, 0x68U, 0x98U, 0x16U,
+	0xd4U, 0xa4U, 0x5cU, 0xccU, 0x5dU, 0x65U, 0xb6U, 0x92U,
+	0x6cU, 0x70U, 0x48U, 0x50U, 0xfdU, 0xedU, 0xb9U, 0xdaU,
+	0x5eU, 0x15U, 0x46U, 0x57U, 0xa7U, 0x8dU, 0x9dU, 0x84U,
+	0x90U, 0xd8U, 0xabU, 0x00U, 0x8cU, 0xbcU, 0xd3U, 0x0aU,
+	0xf7U, 0xe4U, 0x58U, 0x05U, 0xb8U, 0xb3U, 0x45U, 0x06U,
+	0xd0U, 0x2cU, 0x1eU, 0x8fU, 0xcaU, 0x3fU, 0x0fU, 0x02U,
+	0xc1U, 0xafU, 0xbdU, 0x03U, 0x01U, 0x13U, 0x8aU, 0x6bU,
+	0x3aU, 0x91U, 0x11U, 0x41U, 0x4fU, 0x67U, 0xdcU, 0xeaU,
+	0x97U, 0xf2U, 0xcfU, 0xceU, 0xf0U, 0xb4U, 0xe6U, 0x73U,
+	0x96U, 0xacU, 0x74U, 0x22U, 0xe7U, 0xadU, 0x35U, 0x85U,
+	0xe2U, 0xf9U, 0x37U, 0xe8U, 0x1cU, 0x75U, 0xdfU, 0x6eU,
+	0x47U, 0xf1U, 0x1aU, 0x71U, 0x1dU, 0x29U, 0xc5U, 0x89U,
+	0x6fU, 0xb7U, 0x62U, 0x0eU, 0xaaU, 0x18U, 0xbeU, 0x1bU,
+	0xfcU, 0x56U, 0x3eU, 0x4bU, 0xc6U, 0xd2U, 0x79U, 0x20U,
+	0x9aU, 0xdbU, 0xc0U, 0xfeU, 0x78U, 0xcdU, 0x5aU, 0xf4U,
+	0x1fU, 0xddU, 0xa8U, 0x33U, 0x88U, 0x07U, 0xc7U, 0x31U,
+	0xb1U, 0x12U, 0x10U, 0x59U, 0x27U, 0x80U, 0xecU, 0x5fU,
+	0x60U, 0x51U, 0x7fU, 0xa9U, 0x19U, 0xb5U, 0x4aU, 0x0dU,
+	0x2dU, 0xe5U, 0x7aU, 0x9fU, 0x93U, 0xc9U, 0x9cU, 0xefU,
+	0xa0U, 0xe0U, 0x3bU, 0x4dU, 0xaeU, 0x2aU, 0xf5U, 0xb0U,
+	0xc8U, 0xebU, 0xbbU, 0x3cU, 0x83U, 0x53U, 0x99U, 0x61U,
+	0x17U, 0x2bU, 0x04U, 0x7eU, 0xbaU, 0x77U, 0xd6U, 0x26U,
+	0xe1U, 0x69U, 0x14U, 0x63U, 0x55U, 0x21U, 0x0cU, 0x7dU,
+};
+
+const u8 rcons[] = {
+	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36
+	    /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+};
+
+/**
+ * Expand the cipher key into the encryption key schedule.
+ *
+ * @return	the number of rounds for the given cipher key size.
+ */
+static void rijndaelKeySetupEnc(u32 rk[/*44 */], const u8 cipherKey[])
+{
+	int i;
+	u32 temp;
+
+	rk[0] = GETU32(cipherKey);
+	rk[1] = GETU32(cipherKey + 4);
+	rk[2] = GETU32(cipherKey + 8);
+	rk[3] = GETU32(cipherKey + 12);
+	for (i = 0; i < 10; i++) {
+		temp = rk[3];
+		rk[4] = rk[0] ^
+		    TE421(temp) ^ TE432(temp) ^ TE443(temp) ^ TE414(temp) ^
+		    RCON(i);
+		rk[5] = rk[1] ^ rk[4];
+		rk[6] = rk[2] ^ rk[5];
+		rk[7] = rk[3] ^ rk[6];
+		rk = rk + 4;
+	}
+}
+
+static void rijndaelEncrypt(u32 rk[/*44 */], u8 pt[16], u8 ct[16])
+{
+	u32 s0, s1, s2, s3, t0, t1, t2, t3;
+	int Nr = 10;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+	s0 = GETU32(pt) ^ rk[0];
+	s1 = GETU32(pt + 4) ^ rk[1];
+	s2 = GETU32(pt + 8) ^ rk[2];
+	s3 = GETU32(pt + 12) ^ rk[3];
+
+#define ROUND(i, d, s)							\
+do {									\
+	d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
+	d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
+	d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
+	d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]; \
+} while (0)
+
+#ifdef FULL_UNROLL
+
+	ROUND(1, t, s);
+	ROUND(2, s, t);
+	ROUND(3, t, s);
+	ROUND(4, s, t);
+	ROUND(5, t, s);
+	ROUND(6, s, t);
+	ROUND(7, t, s);
+	ROUND(8, s, t);
+	ROUND(9, t, s);
+
+	rk += Nr << 2;
+
+#else /* !FULL_UNROLL */
+
+	/* Nr - 1 full rounds: */
+	r = Nr >> 1;
+	for (;;) {
+		ROUND(1, t, s);
+		rk = rk + 8;
+		if (--r == 0)
+			break;
+		ROUND(0, s, t);
+	}
+
+#endif /* ?FULL_UNROLL */
+
+#undef ROUND
+
+	/*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+	s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
+	PUTU32(ct, s0);
+	s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
+	PUTU32(ct + 4, s1);
+	s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
+	PUTU32(ct + 8, s2);
+	s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
+	PUTU32(ct + 12, s3);
+}
+
+static void *aes_encrypt_init(u8 *key, size_t len)
+{
+	u32 *rk;
+	if (len != 16)
+		return NULL;
+	rk = (u32 *)kmalloc(AES_PRIV_SIZE, GFP_KERNEL);
+	if (rk == NULL)
+		return NULL;
+	rijndaelKeySetupEnc(rk, key);
+	return rk;
+}
+
+static void aes_128_encrypt(void *ctx, u8 *plain, u8 *crypt)
+{
+	rijndaelEncrypt(ctx, plain, crypt);
+}
+
+static void gf_mulx(u8 *pad)
+{
+	int i, carry;
+
+	carry = pad[0] & 0x80;
+	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
+		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
+	pad[AES_BLOCK_SIZE - 1] <<= 1;
+	if (carry)
+		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
+}
+
+static void aes_encrypt_deinit(void *ctx)
+{
+	memset(ctx, 0, AES_PRIV_SIZE);
+	kfree(ctx);
+}
+
+/**
+ * omac1_aes_128_vector - One-Key CBC MAC (OMAC1) hash with AES-128
+ * @key: 128-bit key for the hash operation
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
+ * Returns: 0 on success, -1 on failure
+ *
+ * This is a mode for using block cipher (AES in this case) for authentication.
+ * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
+ * (SP) 800-38B.
+ */
+static int omac1_aes_128_vector(u8 *key, size_t num_elem,
+				u8 *addr[], size_t *len, u8 *mac)
+{
+	void *ctx;
+	u8 cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
+	u8 *pos, *end;
+	size_t i, e, left, total_len;
+
+	ctx = aes_encrypt_init(key, 16);
+	if (ctx == NULL)
+		return -1;
+	memset(cbc, 0, AES_BLOCK_SIZE);
+
+	total_len = 0;
+	for (e = 0; e < num_elem; e++)
+		total_len += len[e];
+	left = total_len;
+
+	e = 0;
+	pos = addr[0];
+	end = pos + len[0];
+
+	while (left >= AES_BLOCK_SIZE) {
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		if (left > AES_BLOCK_SIZE)
+			aes_128_encrypt(ctx, cbc, cbc);
+		left -= AES_BLOCK_SIZE;
+	}
+
+	memset(pad, 0, AES_BLOCK_SIZE);
+	aes_128_encrypt(ctx, pad, pad);
+	gf_mulx(pad);
+
+	if (left || total_len == 0) {
+		for (i = 0; i < left; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		cbc[left] ^= 0x80;
+		gf_mulx(pad);
+	}
+
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		pad[i] ^= cbc[i];
+	aes_128_encrypt(ctx, pad, mac);
+	aes_encrypt_deinit(ctx);
+	return 0;
+}
+
+/**
+ * omac1_aes_128 - One-Key CBC MAC (OMAC1) hash with AES-128 (aka AES-CMAC)
+ * @key: 128-bit key for the hash operation
+ * @data: Data buffer for which a MAC is determined
+ * @data_len: Length of data buffer in bytes
+ * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
+ * Returns: 0 on success, -1 on failure
+ *
+ * This is a mode for using block cipher (AES in this case) for authentication.
+ * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
+ * (SP) 800-38B.
+ */
+static int omac1_aes_128(u8 *key, u8 *data, size_t data_len, u8 *mac)
+{
+	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
+}
+
+void rtw_use_tkipkey_handler(void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+
+	RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+		 ("^^^rtw_use_tkipkey_handler ^^^\n"));
+
+	padapter->securitypriv.busetkipkey = true;
+
+	RT_TRACE(_module_rtl871x_security_c_, _drv_err_,
+		 ("^^^rtw_use_tkipkey_handler padapter->securitypriv.busetkipkey =%d^^^\n",
+		  padapter->securitypriv.busetkipkey));
+
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_sreset.c b/drivers/net/wireless/rtl8192du/core/rtw_sreset.c
new file mode 100644
index 0000000..290a6b8
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_sreset.c
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#include<rtw_sreset.h>
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+void sreset_init_value(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+
+	_rtw_mutex_init(&psrtpriv->silentreset_mutex);
+	psrtpriv->silent_reset_inprogress = false;
+	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+	psrtpriv->last_tx_time = 0;
+	psrtpriv->last_tx_complete_time = 0;
+}
+
+void sreset_reset_value(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+
+	psrtpriv->silent_reset_inprogress = false;
+	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+	psrtpriv->last_tx_time = 0;
+	psrtpriv->last_tx_complete_time = 0;
+}
+
+u8 sreset_get_wifi_status(_adapter *padapter)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	struct sreset_priv *psrtpriv = &pHalData->srestpriv;
+
+	u8 status = WIFI_STATUS_SUCCESS;
+	u32 val32 = 0;
+	if (psrtpriv->silent_reset_inprogress == true)
+		return status;
+	val32 = rtw_read32(padapter, REG_TXDMA_STATUS);
+	if (val32 == 0xeaeaeaea) {
+		psrtpriv->Wifi_Error_Status = WIFI_IF_NOT_EXIST;
+	} else if (val32 != 0) {
+		DBG_8192C("txdmastatu(%x)\n", val32);
+		psrtpriv->Wifi_Error_Status = WIFI_MAC_TXDMA_ERROR;
+	}
+
+	if (WIFI_STATUS_SUCCESS != psrtpriv->Wifi_Error_Status) {
+		DBG_8192C("==>%s error_status(0x%x)\n", __func__,
+			  psrtpriv->Wifi_Error_Status);
+		status = (psrtpriv->Wifi_Error_Status &
+			  (~(USB_READ_PORT_FAIL | USB_WRITE_PORT_FAIL)));
+	}
+	DBG_8192C("==> %s wifi_status(0x%x)\n", __func__, status);
+
+	/* status restore */
+	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
+
+	return status;
+}
+
+void sreset_set_wifi_error_status(_adapter *padapter, u32 status)
+{
+	HAL_DATA_TYPE	*pHalData = GET_HAL_DATA(padapter);
+	pHalData->srestpriv.Wifi_Error_Status = status;
+}
+#endif /* defined(DBG_CONFIG_ERROR_DETECT) */
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_sta_mgt.c b/drivers/net/wireless/rtl8192du/core/rtw_sta_mgt.c
new file mode 100644
index 0000000..4111d69
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_sta_mgt.c
@@ -0,0 +1,635 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_STA_MGT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <mlme_osdep.h>
+#include <sta_info.h>
+#include <linux/vmalloc.h>
+
+static void _rtw_init_stainfo(struct sta_info *psta)
+{
+
+	memset((u8 *)psta, 0, sizeof(struct sta_info));
+
+	 _rtw_spinlock_init(&psta->lock);
+	INIT_LIST_HEAD(&psta->list);
+	INIT_LIST_HEAD(&psta->hash_list);
+
+	_rtw_init_queue(&psta->sleep_q);
+	psta->sleepq_len = 0;
+
+	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+
+#ifdef CONFIG_92D_AP_MODE
+
+	INIT_LIST_HEAD(&psta->asoc_list);
+
+	INIT_LIST_HEAD(&psta->auth_list);
+
+	psta->expire_to = 0;
+
+	psta->flags = 0;
+
+	psta->capability = 0;
+
+	psta->bpairwise_key_installed = false;
+
+#ifdef CONFIG_NATIVEAP_MLME
+	psta->nonerp_set = 0;
+	psta->no_short_slot_time_set = 0;
+	psta->no_short_preamble_set = 0;
+	psta->no_ht_gf_set = 0;
+	psta->no_ht_set = 0;
+	psta->ht_20mhz_set = 0;
+#endif
+
+	psta->under_exist_checking = 0;
+	psta->keep_alive_trycnt = 0;
+#endif	/*  CONFIG_92D_AP_MODE */
+
+}
+
+u32	_rtw_init_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	s32 i;
+
+	pstapriv->pallocated_stainfo_buf = vzalloc(sizeof(struct sta_info) *
+						   NUM_STA + 4);
+
+	if (!pstapriv->pallocated_stainfo_buf)
+		return _FAIL;
+
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
+		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf) & 3);
+
+	_rtw_init_queue(&pstapriv->free_sta_queue);
+
+	_rtw_spinlock_init(&pstapriv->sta_hash_lock);
+
+	pstapriv->asoc_sta_count = 0;
+	_rtw_init_queue(&pstapriv->sleep_q);
+	_rtw_init_queue(&pstapriv->wakeup_q);
+
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+
+	for (i = 0; i < NUM_STA; i++) {
+		_rtw_init_stainfo(psta);
+
+		INIT_LIST_HEAD(&(pstapriv->sta_hash[i]));
+
+		rtw_list_insert_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
+
+		psta++;
+	}
+
+#ifdef CONFIG_92D_AP_MODE
+
+	pstapriv->sta_dz_bitmap = 0;
+	pstapriv->tim_bitmap = 0;
+
+	INIT_LIST_HEAD(&pstapriv->asoc_list);
+	INIT_LIST_HEAD(&pstapriv->auth_list);
+	_rtw_spinlock_init(&pstapriv->asoc_list_lock);
+	_rtw_spinlock_init(&pstapriv->auth_list_lock);
+	pstapriv->asoc_list_cnt = 0;
+	pstapriv->auth_list_cnt = 0;
+
+	pstapriv->auth_to = 3; /*  3*2 = 6 sec */
+	pstapriv->assoc_to = 3;
+	pstapriv->expire_to = 3; /*  3*2 = 6 sec */
+	pstapriv->max_num_sta = NUM_STA;
+
+#endif
+
+	return _SUCCESS;
+}
+
+inline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)
+{
+	int offset = (((u8 *)sta) - stapriv->pstainfo_buf) /
+		      sizeof(struct sta_info);
+
+	if (!stainfo_offset_valid(offset))
+		DBG_8192D("%s invalid offset(%d), out of range!!!",
+			  __func__, offset);
+	return offset;
+}
+
+inline struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv,
+						  int offset)
+{
+	if (!stainfo_offset_valid(offset))
+		DBG_8192D("%s invalid offset(%d), out of range!!!",
+			  __func__, offset);
+
+	return (struct sta_info *)(stapriv->pstainfo_buf + offset *
+				   sizeof(struct sta_info));
+}
+
+static void _rtw_free_sta_xmit_priv_lock(struct sta_xmit_priv *psta_xmitpriv)
+{
+
+	_rtw_spinlock_free(&psta_xmitpriv->lock);
+
+	_rtw_spinlock_free(&(psta_xmitpriv->be_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->bk_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->vi_q.sta_pending.lock));
+	_rtw_spinlock_free(&(psta_xmitpriv->vo_q.sta_pending.lock));
+
+}
+
+static void _rtw_free_sta_recv_priv_lock(struct sta_recv_priv *psta_recvpriv)
+{
+
+	_rtw_spinlock_free(&psta_recvpriv->lock);
+	_rtw_spinlock_free(&(psta_recvpriv->defrag_q.lock));
+
+}
+
+static void rtw_mfree_stainfo(struct sta_info *psta)
+{
+
+	if (&psta->lock != NULL)
+		_rtw_spinlock_free(&psta->lock);
+
+	_rtw_free_sta_xmit_priv_lock(&psta->sta_xmitpriv);
+	_rtw_free_sta_recv_priv_lock(&psta->sta_recvpriv);
+
+}
+
+/*  this function is used to free the memory of lock || sema for all stainfos */
+static void rtw_mfree_all_stainfo(struct sta_priv *pstapriv)
+{
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = phead->next;
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, list);
+		plist = plist->next;
+
+		rtw_mfree_stainfo(psta);
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+}
+
+static void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+#ifdef CONFIG_92D_AP_MODE
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+#endif
+
+	 rtw_mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
+
+	_rtw_spinlock_free(&pstapriv->free_sta_queue.lock);
+
+	_rtw_spinlock_free(&pstapriv->sta_hash_lock);
+	_rtw_spinlock_free(&pstapriv->wakeup_q.lock);
+	_rtw_spinlock_free(&pstapriv->sleep_q.lock);
+
+#ifdef CONFIG_92D_AP_MODE
+	_rtw_spinlock_free(&pstapriv->asoc_list_lock);
+	_rtw_spinlock_free(&pstapriv->auth_list_lock);
+	_rtw_spinlock_free(&pacl_list->acl_node_q.lock);
+#endif
+}
+
+u32	_rtw_free_sta_priv(struct	sta_priv *pstapriv)
+{
+	struct list_head *phead, *plist;
+	struct sta_info *psta = NULL;
+	struct recv_reorder_ctrl *reorder;
+	int	index;
+
+	if (pstapriv) {
+		/*	delete all reordering_ctrl_timer		*/
+		spin_lock_bh(&pstapriv->sta_hash_lock);
+		for (index = 0; index < NUM_STA; index++) {
+			phead = &(pstapriv->sta_hash[index]);
+			plist = phead->next;
+
+			while ((rtw_end_of_queue_search(phead, plist)) == false) {
+				int i;
+				psta = container_of(plist, struct sta_info, hash_list);
+				plist = plist->next;
+
+				for (i = 0; i < 16; i++) {
+					reorder = &psta->recvreorder_ctrl[i];
+					_cancel_timer_ex(&reorder->reordering_ctrl_timer);
+				}
+			}
+		}
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
+		/*===============================*/
+
+		rtw_mfree_sta_priv_lock(pstapriv);
+
+		if (pstapriv->pallocated_stainfo_buf)
+			vfree(pstapriv->pallocated_stainfo_buf);
+	}
+
+	return _SUCCESS;
+}
+
+struct	sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	s32	index;
+	struct list_head *phash_list;
+	struct sta_info	*psta;
+	struct __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *reorder;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+	spin_lock_bh(&(pfree_sta_queue->lock));
+
+	if (_rtw_queue_empty(pfree_sta_queue) == true) {
+		spin_unlock_bh(&(pfree_sta_queue->lock));
+		psta = NULL;
+	} else {
+		psta = container_of((&pfree_sta_queue->queue)->next,
+				    struct sta_info, list);
+
+		list_del_init(&(psta->list));
+
+		spin_unlock_bh(&(pfree_sta_queue->lock));
+
+		_rtw_init_stainfo(psta);
+
+		memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+
+		index = wifi_mac_hash(hwaddr);
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_info_,
+			 ("rtw_alloc_stainfo: index  = %x", index));
+
+		if (index >= NUM_STA) {
+			RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_,
+				 ("ERROR => rtw_alloc_stainfo: index >= NUM_STA"));
+			psta = NULL;
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+
+		rtw_list_insert_tail(&psta->hash_list, phash_list);
+
+		pstapriv->asoc_sta_count++;
+
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+/*  Commented by Albert 2009/08/13
+ *  For the SMC router, the sequence number of first packet of WPS handshake
+ * will be 0. In this case, this packet will be dropped by recv_decache function
+ * if we use the 0x00 as the default value for tid_rxseq variable.
+ *  So, we initialize the tid_rxseq variable as 0xffff. */
+
+		for (i = 0; i < 16; i++)
+			memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[i],
+			       &wRxSeqInitialValue, 2);
+
+		RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_info_,
+			 ("alloc number_%d stainfo  with hwaddr = %x %x %x %x %x %x\n",
+			 pstapriv->asoc_sta_count, hwaddr[0], hwaddr[1],
+			 hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]));
+
+		init_addba_retry_timer(pstapriv->padapter, psta);
+
+		/* for A-MPDU Rx reordering buffer control */
+		for (i = 0; i < 16; i++) {
+			reorder = &psta->recvreorder_ctrl[i];
+
+			reorder->padapter = pstapriv->padapter;
+
+			reorder->enable = false;
+
+			reorder->indicate_seq = 0xffff;
+			#ifdef DBG_RX_SEQ
+			DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d\n",
+				  __func__, __LINE__, reorder->indicate_seq);
+			#endif
+			reorder->wend_b = 0xffff;
+			reorder->wsize_b = 64;/* 64; */
+			_rtw_init_queue(&reorder->pending_recvframe_queue);
+			rtw_init_recv_timer(reorder);
+		}
+
+		/* init for DM */
+		psta->rssi_stat.UndecoratedSmoothedPWDB = 0;
+		psta->rssi_stat.UndecoratedSmoothedCCK = (-1);
+
+		/* init for the sequence number of received management frame */
+		psta->RxMgmtFrameSeqNum = 0xffff;
+	}
+
+exit:
+
+	return psta;
+}
+
+/*  using pstapriv->sta_hash_lock to protect */
+u32	rtw_free_stainfo(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	int i;
+	struct __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *reorder;
+	struct	sta_xmit_priv	*pstaxmitpriv;
+	struct	xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	if (psta == NULL)
+		goto exit;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
+	psta->sleepq_len = 0;
+
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
+
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
+
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
+
+	rtw_free_xmitframe_queue(pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	list_del_init(&psta->hash_list);
+	RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_,
+		 ("\n free number_%d stainfo  with hwaddr = 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
+		 pstapriv->asoc_sta_count, psta->hwaddr[0], psta->hwaddr[1],
+		 psta->hwaddr[2], psta->hwaddr[3], psta->hwaddr[4],
+		 psta->hwaddr[5]));
+	pstapriv->asoc_sta_count--;
+
+	/*  re-init sta_info; 20061114 */
+	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+
+	_cancel_timer_ex(&psta->addba_retry_timer);
+
+	/* for A-MPDU Rx reordering buffer control, cancel reorder_ctrl_timer */
+	for (i = 0; i < 16; i++) {
+		struct list_head *phead, *plist;
+		struct recv_frame_hdr *prframe;
+		struct __queue *ppending_recvframe_queue;
+		struct __queue *free_recv_q = &padapter->recvpriv.free_recv_queue;
+
+		reorder = &psta->recvreorder_ctrl[i];
+
+		_cancel_timer_ex(&reorder->reordering_ctrl_timer);
+
+		ppending_recvframe_queue = &reorder->pending_recvframe_queue;
+
+		spin_lock_bh(&ppending_recvframe_queue->lock);
+
+		phead =		get_list_head(ppending_recvframe_queue);
+		plist = phead->next;
+
+		while (!rtw_is_list_empty(phead)) {
+			prframe = container_of(plist, struct recv_frame_hdr, list);
+
+			plist = plist->next;
+
+			list_del_init(&(prframe->list));
+
+			rtw_free_recvframe(prframe, free_recv_q);
+		}
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
+	}
+
+#ifdef CONFIG_92D_AP_MODE
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!rtw_is_list_empty(&psta->auth_list)) {
+		list_del_init(&psta->auth_list);
+		pstapriv->auth_list_cnt--;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	psta->expire_to = 0;
+
+	psta->sleepq_ac_len = 0;
+	psta->qos_info = 0;
+
+	psta->max_sp_len = 0;
+	psta->uapsd_bk = 0;
+	psta->uapsd_be = 0;
+	psta->uapsd_vi = 0;
+	psta->uapsd_vo = 0;
+
+	psta->has_legacy_ac = 0;
+
+#ifdef CONFIG_NATIVEAP_MLME
+
+	pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+	pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+	if ((psta->aid > 0) && (pstapriv->sta_aid[psta->aid - 1] == psta)) {
+		pstapriv->sta_aid[psta->aid - 1] = NULL;
+		psta->aid = 0;
+	}
+
+#endif	/*  CONFIG_NATIVEAP_MLME */
+
+	psta->under_exist_checking = 0;
+
+#endif	/*  CONFIG_92D_AP_MODE */
+
+	spin_lock_bh(&(pfree_sta_queue->lock));
+	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
+	spin_unlock_bh(&(pfree_sta_queue->lock));
+
+exit:
+
+	return _SUCCESS;
+}
+
+/*  free all stainfo which in sta_hash[all] */
+void rtw_free_all_stainfo(struct rtw_adapter *padapter)
+{
+	struct list_head *plist, *phead;
+	s32	index;
+	struct sta_info *psta = NULL;
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct sta_info *pbcmc_stainfo = rtw_get_bcmc_stainfo(padapter);
+
+	if (pstapriv->asoc_sta_count == 1)
+		return;
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	for (index = 0; index < NUM_STA; index++) {
+		phead = &(pstapriv->sta_hash[index]);
+		plist = phead->next;
+
+		while ((rtw_end_of_queue_search(phead, plist)) == false) {
+			psta = container_of(plist, struct sta_info,
+					      hash_list);
+
+			plist = plist->next;
+
+			if (pbcmc_stainfo != psta)
+				rtw_free_stainfo(padapter, psta);
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr)
+{
+	struct list_head *plist, *phead;
+	struct sta_info *psta = NULL;
+	u32	index;
+	u8 *addr;
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	if (hwaddr == NULL)
+		return NULL;
+
+	if (IS_MCAST(hwaddr))
+		addr = bc_addr;
+	else
+		addr = hwaddr;
+
+	index = wifi_mac_hash(addr);
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	phead = &(pstapriv->sta_hash[index]);
+	plist = phead->next;
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, hash_list);
+
+		if (_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN) == true) {
+			/*  if found the matched address */
+			break;
+		}
+		psta = NULL;
+		plist = plist->next;
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+	return psta;
+}
+
+u32 rtw_init_bcmc_stainfo(struct rtw_adapter *padapter)
+{
+	struct sta_info		*psta;
+	u32 res = _SUCCESS;
+	unsigned char bcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+
+	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
+
+	if (psta == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_sta_mgt_c_, _drv_err_,
+			 ("rtw_alloc_stainfo fail"));
+		goto exit;
+	}
+
+	/*  default broadcast & multicast use macid 1 */
+	psta->mac_id = 1;
+
+exit:
+
+	return res;
+}
+
+struct sta_info *rtw_get_bcmc_stainfo(struct rtw_adapter *padapter)
+{
+	struct sta_info		*psta;
+	struct sta_priv		*pstapriv = &padapter->stapriv;
+	u8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	 psta = rtw_get_stainfo(pstapriv, bc_addr);
+
+	return psta;
+}
+
+u8 rtw_access_ctrl(struct rtw_adapter *padapter, u8 *mac_addr)
+{
+	u8 res = true;
+#ifdef CONFIG_92D_AP_MODE
+	struct list_head *plist, *phead;
+	struct rtw_wlan_acl_node *paclnode;
+	u8 match = false;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue *pacl_node_q = &pacl_list->acl_node_q;
+
+	spin_lock_bh(&(pacl_node_q->lock));
+	phead = get_list_head(pacl_node_q);
+	plist = phead->next;
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node,
+					  list);
+		plist = plist->next;
+
+		if (_rtw_memcmp(paclnode->addr, mac_addr, ETH_ALEN)) {
+			if (paclnode->valid == true) {
+				match = true;
+				break;
+			}
+		}
+	}
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	if (pacl_list->mode == 1)/* accept unless in deny list */
+		res = (match == true) ? false : true;
+	else if (pacl_list->mode == 2)/* deny unless in accept list */
+		res = (match == true) ? true : false;
+	else
+		 res = true;
+
+#endif
+	return res;
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_wlan_util.c b/drivers/net/wireless/rtl8192du/core/rtw_wlan_util.c
new file mode 100644
index 0000000..2f20a93
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_wlan_util.c
@@ -0,0 +1,1563 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_WLAN_UTIL_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+static unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
+static unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
+
+static unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
+static unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
+static unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
+
+static unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
+static unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
+static unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};
+static unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};
+static unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};
+
+unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};
+
+#define R2T_PHY_DELAY	(0)
+
+/* define WAIT_FOR_BCN_TO_MIN	(3000) */
+#define WAIT_FOR_BCN_TO_MIN	(6000)
+#define WAIT_FOR_BCN_TO_MAX	(20000)
+
+static u8 rtw_basic_rate_cck[4] = {
+	IEEE80211_CCK_RATE_1MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_2MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_CCK_RATE_5MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_11MB|IEEE80211_BASIC_RATE_MASK
+};
+
+static u8 rtw_basic_rate_ofdm[3] = {
+	IEEE80211_OFDM_RATE_6MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_OFDM_RATE_12MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
+};
+
+static u8 rtw_basic_rate_mix[7] = {
+	IEEE80211_CCK_RATE_1MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_2MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_CCK_RATE_5MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_11MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_6MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_OFDM_RATE_12MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
+};
+
+int cckrates_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+
+	for (i = 0; i < ratelen; i++) {
+		if ((((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+		    (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22))
+			return true;
+	}
+
+	return false;
+}
+
+int cckratesonly_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+
+	for (i = 0; i < ratelen; i++) {
+		if ((((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+		    (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22))
+			return false;
+	}
+
+	return true;
+}
+
+unsigned char networktype_to_raid(unsigned char network_type)
+{
+	unsigned char raid;
+
+	switch (network_type) {
+	case WIRELESS_11B:
+		raid = 6;
+		break;
+	case WIRELESS_11A:
+	case WIRELESS_11G:
+		raid = 5;
+		break;
+	case WIRELESS_11BG:
+		raid = 4;
+		break;
+	case WIRELESS_11_24N:
+	case WIRELESS_11_5N:
+		raid = 3;
+		break;
+	case WIRELESS_11A_5N:
+	case WIRELESS_11G_24N:
+		raid = 1;
+		break;
+	case WIRELESS_11BG_24N:
+		raid = 0;
+		break;
+	default:
+		raid = 4;
+		break;
+	}
+
+	return raid;
+}
+
+int judge_network_type(struct rtw_adapter *padapter, unsigned char *rate, int ratelen)
+{
+	int network_type = 0;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmeext->cur_channel > 14) {
+		if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_5N;
+
+		network_type |= WIRELESS_11A;
+	} else {
+		if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_24N;
+
+		if ((cckratesonly_included(rate, ratelen)) == true)
+			network_type |= WIRELESS_11B;
+		else if ((cckrates_included(rate, ratelen)) == true)
+			network_type |= WIRELESS_11BG;
+		else
+			network_type |= WIRELESS_11G;
+	}
+	return	network_type;
+}
+
+static unsigned char ratetbl_val_2wifirate(unsigned char rate)
+{
+	unsigned char val = 0;
+
+	switch (rate & 0x7f) {
+	case 0:
+		val = IEEE80211_CCK_RATE_1MB;
+		break;
+	case 1:
+		val = IEEE80211_CCK_RATE_2MB;
+		break;
+	case 2:
+		val = IEEE80211_CCK_RATE_5MB;
+		break;
+	case 3:
+		val = IEEE80211_CCK_RATE_11MB;
+		break;
+	case 4:
+		val = IEEE80211_OFDM_RATE_6MB;
+		break;
+	case 5:
+		val = IEEE80211_OFDM_RATE_9MB;
+		break;
+	case 6:
+		val = IEEE80211_OFDM_RATE_12MB;
+		break;
+	case 7:
+		val = IEEE80211_OFDM_RATE_18MB;
+		break;
+	case 8:
+		val = IEEE80211_OFDM_RATE_24MB;
+		break;
+	case 9:
+		val = IEEE80211_OFDM_RATE_36MB;
+		break;
+	case 10:
+		val = IEEE80211_OFDM_RATE_48MB;
+		break;
+	case 11:
+		val = IEEE80211_OFDM_RATE_54MB;
+		break;
+	}
+	return val;
+}
+
+static int is_basicrate(struct rtw_adapter *padapter, unsigned char rate)
+{
+	int i;
+	unsigned char val;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	for (i = 0; i < NUMRATES; i++) {
+		val = pmlmeext->basicrate[i];
+
+		if ((val != 0xff) && (val != 0xfe)) {
+			if (rate == ratetbl_val_2wifirate(val))
+				return true;
+		}
+	}
+
+	return false;
+}
+
+static unsigned int ratetbl2rateset(struct rtw_adapter *padapter, unsigned char *rateset)
+{
+	int i;
+	unsigned char rate;
+	unsigned int	len = 0;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	for (i = 0; i < NUMRATES; i++) {
+		rate = pmlmeext->datarate[i];
+
+		switch (rate) {
+		case 0xff:
+			return len;
+		case 0xfe:
+			continue;
+		default:
+			rate = ratetbl_val_2wifirate(rate);
+			if (is_basicrate(padapter, rate) == true)
+				rate |= IEEE80211_BASIC_RATE_MASK;
+			rateset[len] = rate;
+			len++;
+			break;
+		}
+	}
+	return len;
+}
+
+void get_rate_set(struct rtw_adapter *padapter, unsigned char *pbssrate, int *bssrate_len)
+{
+	unsigned char supportedrates[NUMRATES];
+
+	memset(supportedrates, 0, NUMRATES);
+	*bssrate_len = ratetbl2rateset(padapter, supportedrates);
+	memcpy(pbssrate, supportedrates, *bssrate_len);
+}
+
+void UpdateBrateTbl(
+	struct rtw_adapter *adapter,
+	u8			*mBratesOS
+)
+{
+	u8	i;
+	u8	rate;
+
+	/*  1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory. */
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		rate = mBratesOS[i] & 0x7f;
+		switch (rate) {
+		case IEEE80211_CCK_RATE_1MB:
+		case IEEE80211_CCK_RATE_2MB:
+		case IEEE80211_CCK_RATE_5MB:
+		case IEEE80211_CCK_RATE_11MB:
+		case IEEE80211_OFDM_RATE_6MB:
+		case IEEE80211_OFDM_RATE_12MB:
+		case IEEE80211_OFDM_RATE_24MB:
+			mBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;
+			break;
+		}
+	}
+}
+
+void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen)
+{
+	u8	i;
+	u8	rate;
+
+	for (i = 0; i < bssratelen; i++) {
+		rate = bssrateset[i] & 0x7f;
+		switch (rate) {
+		case IEEE80211_CCK_RATE_1MB:
+		case IEEE80211_CCK_RATE_2MB:
+		case IEEE80211_CCK_RATE_5MB:
+		case IEEE80211_CCK_RATE_11MB:
+			bssrateset[i] |= IEEE80211_BASIC_RATE_MASK;
+			break;
+		}
+	}
+}
+
+void Save_DM_Func_Flag(struct rtw_adapter *padapter)
+{
+	u8	bSaveFlag = true;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+	if (pbuddy_adapter)
+	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
+#endif
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
+}
+
+void Restore_DM_Func_Flag(struct rtw_adapter *padapter)
+{
+	u8	bSaveFlag = false;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+	if (pbuddy_adapter)
+	rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
+#endif
+	rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_OP, (u8 *)(&bSaveFlag));
+}
+
+void Switch_DM_Func(struct rtw_adapter *padapter, u8 mode, u8 enable)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+#endif
+
+	if (enable == true) {
+#ifdef CONFIG_CONCURRENT_MODE
+		if (pbuddy_adapter)
+		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
+#endif
+		rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_SET, (u8 *)(&mode));
+	} else {
+#ifdef CONFIG_CONCURRENT_MODE
+		if (pbuddy_adapter)
+		rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));
+#endif
+		rtw_hal_set_hwreg(padapter, HW_VAR_DM_FUNC_CLR, (u8 *)(&mode));
+	}
+}
+
+static void Set_NETYPE1_MSR(struct rtw_adapter *padapter, u8 type)
+{
+	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS1, (u8 *)(&type));
+}
+
+static void Set_NETYPE0_MSR(struct rtw_adapter *padapter, u8 type)
+{
+	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&type));
+}
+
+void Set_MSR(struct rtw_adapter *padapter, u8 type)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type == IFACE_PORT1)
+		Set_NETYPE1_MSR(padapter, type);
+	else
+#endif
+		Set_NETYPE0_MSR(padapter, type);
+}
+
+inline u8 rtw_get_oper_ch(struct rtw_adapter *adapter)
+{
+	return adapter_to_dvobj(adapter)->oper_channel;
+}
+
+inline void rtw_set_oper_ch(struct rtw_adapter *adapter, u8 ch)
+{
+	adapter_to_dvobj(adapter)->oper_channel = ch;
+}
+
+inline u8 rtw_get_oper_bw(struct rtw_adapter *adapter)
+{
+	return adapter_to_dvobj(adapter)->oper_bwmode;
+}
+
+inline void rtw_set_oper_bw(struct rtw_adapter *adapter, u8 bw)
+{
+	adapter_to_dvobj(adapter)->oper_bwmode = bw;
+}
+
+inline u8 rtw_get_oper_choffset(struct rtw_adapter *adapter)
+{
+	return adapter_to_dvobj(adapter)->oper_ch_offset;
+}
+
+inline void rtw_set_oper_choffset(struct rtw_adapter *adapter, u8 offset)
+{
+	adapter_to_dvobj(adapter)->oper_ch_offset = offset;
+}
+
+void SelectChannel(struct rtw_adapter *padapter, unsigned char channel)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	/* saved channel info */
+	rtw_set_oper_ch(padapter, channel);
+	dc_SelectChannel(padapter, channel);
+#else /* CONFIG_DUALMAC_CONCURRENT */
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
+
+	/* saved channel info */
+	rtw_set_oper_ch(padapter, channel);
+
+	rtw_hal_set_chan(padapter, channel);
+
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
+
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
+}
+
+void SetBWMode(struct rtw_adapter *padapter, unsigned short bwmode, unsigned char channel_offset)
+{
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	/* saved bw info */
+	rtw_set_oper_bw(padapter, bwmode);
+	rtw_set_oper_choffset(padapter, channel_offset);
+	dc_SetBWMode(padapter, bwmode, channel_offset);
+#else /* CONFIG_DUALMAC_CONCURRENT */
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex));
+
+	/* saved bw info */
+	rtw_set_oper_bw(padapter, bwmode);
+	rtw_set_oper_choffset(padapter, channel_offset);
+
+	rtw_hal_set_bwmode(padapter, (enum HT_CHANNEL_WIDTH)bwmode, channel_offset);
+
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex));
+
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
+}
+
+void set_channel_bwmode(struct rtw_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
+{
+	u8 center_ch;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	if (padapter->bNotifyChannelChange)
+		DBG_8192D("[%s] ch = %d, offset = %d, bwmode = %d\n", __func__, channel, channel_offset, bwmode);
+
+	if ((bwmode == HT_CHANNEL_WIDTH_20) ||
+	    (channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)) {
+		/* SelectChannel(padapter, channel); */
+		center_ch = channel;
+	} else {
+		/* switch to the proper channel */
+		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER) {
+			/* SelectChannel(padapter, channel + 2); */
+			center_ch = channel + 2;
+		} else {
+			/* SelectChannel(padapter, channel - 2); */
+			center_ch = channel - 2;
+		}
+	}
+
+	/* set Channel , must be independant for correct co_ch value/ */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	/* saved channel/bw info */
+	rtw_set_oper_ch(padapter, channel);
+	rtw_set_oper_bw(padapter, bwmode);
+	rtw_set_oper_choffset(padapter, channel_offset);
+	dc_SelectChannel(padapter, center_ch);/*  set center channel */
+#else /* CONFIG_DUALMAC_CONCURRENT */
+
+	if (!mutex_is_locked(&(adapter_to_dvobj(padapter)->hw_init_mutex)))
+		_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
+
+	/* saved channel/bw info */
+	rtw_set_oper_ch(padapter, channel);
+	rtw_set_oper_bw(padapter, bwmode);
+	rtw_set_oper_choffset(padapter, channel_offset);
+
+	rtw_hal_set_chan(padapter, center_ch);
+
+	if (!mutex_is_locked(&(adapter_to_dvobj(padapter)->hw_init_mutex)))
+		_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
+
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
+
+	/* set BandWidth */
+	SetBWMode(padapter, bwmode, channel_offset);
+}
+
+int get_bsstype(unsigned short capability)
+{
+	if (capability & BIT(0))
+		return WIFI_FW_AP_STATE;
+	else if (capability & BIT(1))
+		return WIFI_FW_ADHOC_STATE;
+	else
+		return 0;
+}
+
+inline u8 *get_my_bssid(struct wlan_bssid_ex *pnetwork)
+{
+	return pnetwork->MacAddress;
+}
+
+u16 get_beacon_interval(struct wlan_bssid_ex *bss)
+{
+	__le16 val;
+	memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
+
+	return le16_to_cpu(val);
+}
+
+int is_client_associated_to_ap(struct rtw_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext;
+	struct mlme_ext_info	*pmlmeinfo;
+
+	if (!padapter)
+		return _FAIL;
+
+	pmlmeext = &padapter->mlmeextpriv;
+	pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
+		return true;
+	else
+		return _FAIL;
+}
+
+int is_client_associated_to_ibss(struct rtw_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
+		return true;
+	else
+		return _FAIL;
+}
+
+int is_IBSS_empty(struct rtw_adapter *padapter)
+{
+	unsigned int i;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++) {
+		if (pmlmeinfo->FW_sta_info[i].status == 1)
+			return _FAIL;
+	}
+	return true;
+}
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
+{
+	if ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)
+		return WAIT_FOR_BCN_TO_MIN;
+	else if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)
+		return WAIT_FOR_BCN_TO_MAX;
+	else
+		return bcn_interval << 2;
+}
+
+void CAM_empty_entry(struct rtw_adapter *adapter, u8 ucIndex)
+{
+	rtw_hal_set_hwreg(adapter, HW_VAR_CAM_EMPTY_ENTRY, (u8 *)(&ucIndex));
+}
+
+void invalidate_cam_all(struct rtw_adapter *padapter)
+{
+	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
+}
+
+void write_cam(struct rtw_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
+{
+	unsigned int	i, val, addr;
+	/* unsigned int    cmd; */
+	int j;
+	u32	cam_val[2];
+
+	addr = entry << 3;
+
+	for (j = 5; j >= 0; j--) {
+		switch (j) {
+		case 0:
+			val = (ctrl | (mac[0] << 16) | (mac[1] << 24));
+			break;
+		case 1:
+			val = (mac[2] | (mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+			break;
+		default:
+			i = (j - 2) << 2;
+			val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
+			break;
+		}
+
+		cam_val[0] = val;
+		cam_val[1] = addr + (unsigned int)j;
+
+		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
+	}
+}
+
+void clear_cam_entry(struct rtw_adapter *padapter, u8 entry)
+{
+	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	write_cam(padapter, entry, 0, null_sta, null_key);
+}
+
+int allocate_fw_sta_entry(struct rtw_adapter *padapter)
+{
+	unsigned int mac_id;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	for (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++) {
+		if (pmlmeinfo->FW_sta_info[mac_id].status == 0) {
+			pmlmeinfo->FW_sta_info[mac_id].status = 1;
+			pmlmeinfo->FW_sta_info[mac_id].retry = 0;
+			break;
+		}
+	}
+
+	return mac_id;
+}
+
+void flush_all_cam_entry(struct rtw_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+#ifdef CONFIG_CONCURRENT_MODE
+
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	/* if (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_)) */
+	if (check_buddy_fwstate(padapter, _FW_LINKED) == false) {
+		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
+	} else {
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+			struct sta_priv	*pstapriv = &padapter->stapriv;
+			struct sta_info	*psta;
+			u8 cam_id;/* cam_entry */
+
+			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
+			if (psta) {
+				if (psta->state & WIFI_AP_STATE) {
+					/* clear cam when ap free per sta_info */
+				} else {
+					if (psta->mac_id == 2)
+						cam_id = 5;
+					else
+						cam_id = 4;
+				}
+				/* clear_cam_entry(padapter, cam_id); */
+				rtw_clearstakey_cmd(padapter, (u8 *)psta, cam_id, false);
+			}
+		} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+			/* clear cam when ap free per sta_info */
+		}
+	}
+#else /* CONFIG_CONCURRENT_MODE */
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, NULL);
+
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
+}
+
+int WMM_param_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
+{
+	/* struct registry_priv	*pregpriv = &padapter->registrypriv; */
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmepriv->qospriv.qos_option == 0) {
+		pmlmeinfo->WMM_enable = 0;
+		return _FAIL;
+	}
+
+	pmlmeinfo->WMM_enable = 1;
+	memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
+	return true;
+}
+
+void WMMOnAssocRsp(struct rtw_adapter *padapter)
+{
+	u8	ACI, ACM, AIFS, ECWMin, ECWMax, aSifsTime;
+	u8	acm_mask;
+	u16	TXOP;
+	u32	acParm, i;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmeinfo->WMM_enable == 0) {
+		padapter->mlmepriv.acm_mask = 0;
+		return;
+	}
+
+	acm_mask = 0;
+
+	if (pmlmeext->cur_wireless_mode == WIRELESS_11B)
+		aSifsTime = 10;
+	else
+		aSifsTime = 16;
+
+	for (i = 0; i < 4; i++) {
+		ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
+		ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
+
+		/* AIFS = AIFSN * slot time + SIFS - r2t phy delay */
+		AIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * pmlmeinfo->slotTime + aSifsTime;
+
+		ECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);
+		ECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;
+		TXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);
+
+		acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
+
+		switch (ACI) {
+		case 0x0:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BE, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(1) : 0);
+			break;
+		case 0x1:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));
+			break;
+		case 0x2:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VI, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(2) : 0);
+			break;
+		case 0x3:
+			rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_VO, (u8 *)(&acParm));
+			acm_mask |= (ACM ? BIT(3) : 0);
+			break;
+		}
+
+		DBG_8192D("WMM(%x): %x, %x\n", ACI, ACM, acParm);
+	}
+
+	if (padapter->registrypriv.acm_method == 1)
+		rtw_hal_set_hwreg(padapter, HW_VAR_ACM_CTRL, (u8 *)(&acm_mask));
+	else
+		padapter->mlmepriv.acm_mask = acm_mask;
+
+	return;
+}
+
+static void bwmode_update_check(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
+{
+	unsigned char	 new_bwmode;
+	unsigned char  new_ch_offset;
+	struct HT_info_element	 *pHT_info;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	u8 cbw40_enable = 0;
+
+	if (!pIE)
+		return;
+
+	if (phtpriv->ht_option == false)
+		return;
+
+	if (pIE->Length > sizeof(struct HT_info_element))
+		return;
+
+	pHT_info = (struct HT_info_element *)pIE->data;
+
+	if (pmlmeext->cur_channel > 14) {
+		if (pregistrypriv->cbw40_enable & BIT(1))
+			cbw40_enable = 1;
+	} else {
+		if (pregistrypriv->cbw40_enable & BIT(0))
+			cbw40_enable = 1;
+	}
+
+	if ((pHT_info->infos[0] & BIT(2)) && cbw40_enable) {
+		new_bwmode = HT_CHANNEL_WIDTH_40;
+
+		switch (pHT_info->infos[0] & 0x3) {
+		case 1:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+			break;
+		case 3:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+			break;
+		default:
+			new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			break;
+		}
+	} else {
+		new_bwmode = HT_CHANNEL_WIDTH_20;
+		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+	if ((new_bwmode != pmlmeext->cur_bwmode) ||
+	    (new_ch_offset != pmlmeext->cur_ch_offset)) {
+		pmlmeinfo->bwmode_updated = true;
+
+		pmlmeext->cur_bwmode = new_bwmode;
+		pmlmeext->cur_ch_offset = new_ch_offset;
+
+		/* update HT info also */
+		HT_info_handler(padapter, pIE);
+	} else {
+		pmlmeinfo->bwmode_updated = false;
+	}
+
+	if (true == pmlmeinfo->bwmode_updated) {
+		struct sta_info *psta;
+		struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+		struct sta_priv	*pstapriv = &padapter->stapriv;
+
+		/* update ap's stainfo */
+		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+		if (psta) {
+			struct ht_priv	*phtpriv_sta = &psta->htpriv;
+
+			if (phtpriv_sta->ht_option) {
+				/*  bwmode */
+				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+			} else {
+				phtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;
+				phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			}
+		}
+	}
+}
+
+void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
+{
+	unsigned int	i;
+	u8	rf_type;
+	u8	max_AMPDU_len, min_MPDU_spacing;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+
+	if (pIE == NULL)
+		return;
+
+	if (phtpriv->ht_option == false)
+		return;
+
+	pmlmeinfo->HT_caps_enable = 1;
+
+	for (i = 0; i < (pIE->Length); i++) {
+		if (i != 2) {
+			/*	Commented by Albert 2010/07/12 */
+			/*	Got the endian issue here. */
+			pmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);
+		} else {
+			/* modify from  fw by Thomas 2010/11/17 */
+			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
+				max_AMPDU_len = (pIE->data[i] & 0x3);
+			else
+				max_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);
+
+			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
+				min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);
+			else
+				min_MPDU_spacing = (pIE->data[i] & 0x1c);
+
+			pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = max_AMPDU_len | min_MPDU_spacing;
+		}
+	}
+
+	/*	Commented by Albert 2010/07/12 */
+	/*	Have to handle the endian issue after copying. */
+	/*	HT_ext_caps didn't be used yet. */
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info;
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+	/* update the MCS rates */
+	for (i = 0; i < 16; i++) {
+		if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		else
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+		if (pregistrypriv->special_rf_path)
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+	}
+	return;
+}
+
+void HT_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+
+	if (pIE == NULL)
+		return;
+
+	if (phtpriv->ht_option == false)
+		return;
+
+	if (pIE->Length > sizeof(struct HT_info_element))
+		return;
+
+	pmlmeinfo->HT_info_enable = 1;
+	memcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->Length);
+
+	return;
+}
+
+void HTOnAssocRsp(struct rtw_adapter *padapter)
+{
+	unsigned char		max_AMPDU_len;
+	unsigned char		min_MPDU_spacing;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_8192D("%s\n", __func__);
+
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable)) {
+		pmlmeinfo->HT_enable = 1;
+	} else {
+		pmlmeinfo->HT_enable = 0;
+		return;
+	}
+
+	/* handle A-MPDU parameter field */
+	/*
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing
+	*/
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_MIN_SPACE, (u8 *)(&min_MPDU_spacing));
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_AMPDU_FACTOR, (u8 *)(&max_AMPDU_len));
+}
+
+void ERP_IE_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pIE->Length > 1)
+		return;
+
+	pmlmeinfo->ERP_enable = 1;
+	memcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->Length);
+}
+
+void VCS_update(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	switch (pregpriv->vrtl_carrier_sense) { /* 0:off 1:on 2:auto */
+	case 0: /* off */
+		psta->rtsen = 0;
+		psta->cts2self = 0;
+		break;
+	case 1: /* on */
+		if (pregpriv->vcs_type == 1) { /* 1:RTS/CTS 2:CTS to self */
+			psta->rtsen = 1;
+			psta->cts2self = 0;
+		} else {
+			psta->rtsen = 0;
+			psta->cts2self = 1;
+		}
+		break;
+	case 2: /* auto */
+	default:
+		if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1))) {
+			if (pregpriv->vcs_type == 1) {
+				psta->rtsen = 1;
+				psta->cts2self = 0;
+			} else {
+				psta->rtsen = 0;
+				psta->cts2self = 1;
+			}
+		} else {
+			psta->rtsen = 0;
+			psta->cts2self = 0;
+		}
+		break;
+	}
+}
+
+void update_beacon_info(struct rtw_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
+{
+	unsigned int i;
+	unsigned int len;
+	struct ndis_802_11_variable_ies *pIE;
+
+	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
+
+	for (i = 0; i < len;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
+
+		switch (pIE->ElementID) {
+		case _HT_EXTRA_INFO_IE_:	/* HT info */
+			bwmode_update_check(padapter, pIE);
+			break;
+		case _ERPINFO_IE_:
+			ERP_IE_handler(padapter, pIE);
+			VCS_update(padapter, psta);
+			break;
+		default:
+			break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+}
+
+#ifdef CONFIG_DFS
+void process_csa_ie(struct rtw_adapter *padapter, u8 *pframe, uint pkt_len)
+{
+	unsigned int i;
+	unsigned int len;
+	struct ndis_802_11_variable_ies *pIE;
+	u8 new_ch_no = 0;
+
+	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
+
+	for (i = 0; i < len;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
+
+		switch (pIE->ElementID) {
+		case _CH_SWTICH_ANNOUNCE_:
+			memcpy(&new_ch_no, pIE->data+1, 1);
+			rtw_set_csa_cmd(padapter, new_ch_no);
+			break;
+		default:
+			break;
+		}
+		i += (pIE->Length + 2);
+	}
+}
+#endif /* CONFIG_DFS */
+
+unsigned int is_ap_in_tkip(struct rtw_adapter *padapter)
+{
+	u32 i;
+	struct ndis_802_11_variable_ies *pIE;
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex		*cur_network = &(pmlmeinfo->network);
+
+	if (rtw_get_capability((struct wlan_bssid_ex *)cur_network) & WLAN_CAPABILITY_PRIVACY) {
+		for (i = sizeof(struct ndis_802_11_fixed_ies); i < pmlmeinfo->network.IELength;) {
+			pIE = (struct ndis_802_11_variable_ies *)(pmlmeinfo->network.IEs + i);
+
+			switch (pIE->ElementID) {
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
+					return true;
+				break;
+			case _RSN_IE_2_:
+				if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
+					return true;
+			default:
+				break;
+			}
+
+			i += (pIE->Length + 2);
+		}
+
+		return false;
+	} else {
+		return false;
+	}
+}
+
+static int wifirate2_ratetbl_inx(unsigned char rate)
+{
+	int	inx = 0;
+	rate = rate & 0x7f;
+
+	switch (rate) {
+	case 54*2:
+		inx = 11;
+		break;
+	case 48*2:
+		inx = 10;
+		break;
+	case 36*2:
+		inx = 9;
+		break;
+	case 24*2:
+		inx = 8;
+		break;
+	case 18*2:
+		inx = 7;
+		break;
+	case 12*2:
+		inx = 6;
+		break;
+	case 9*2:
+		inx = 5;
+		break;
+	case 6*2:
+		inx = 4;
+		break;
+	case 11*2:
+		inx = 3;
+		break;
+	case 11:
+		inx = 2;
+		break;
+	case 2*2:
+		inx = 1;
+		break;
+	case 1*2:
+		inx = 0;
+		break;
+	}
+	return inx;
+}
+
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+
+	num_of_rate = (ptn_sz > NUMRATES) ? NUMRATES : ptn_sz;
+
+	for (i = 0; i < num_of_rate; i++) {
+		if ((*(ptn + i)) & 0x80)
+			mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+	}
+	return mask;
+}
+
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+
+	num_of_rate = (ptn_sz > NUMRATES) ? NUMRATES : ptn_sz;
+
+	for (i = 0; i < num_of_rate; i++)
+		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+
+	return mask;
+}
+
+unsigned int update_MSC_rate(struct HT_caps_element *pHT_caps)
+{
+	unsigned int mask = 0;
+
+	mask = ((pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
+
+	return mask;
+}
+
+int support_short_GI(struct rtw_adapter *padapter, struct HT_caps_element *pHT_caps)
+{
+	unsigned char					bit_offset;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (!(pmlmeinfo->HT_enable))
+		return _FAIL;
+
+	if ((pmlmeinfo->assoc_AP_vendor == ralinkAP))
+		return _FAIL;
+
+	bit_offset = (pmlmeext->cur_bwmode & HT_CHANNEL_WIDTH_40) ? 6 : 5;
+
+	if (le16_to_cpu(pHT_caps->u.HT_cap_element.HT_caps_info) & (0x1 << bit_offset))
+		return _SUCCESS;
+	else
+		return _FAIL;
+}
+
+unsigned char get_highest_rate_idx(u32 mask)
+{
+	int i;
+	unsigned char rate_idx = 0;
+
+	for (i = 27; i >= 0; i--) {
+		if (mask & BIT(i)) {
+			rate_idx = i;
+			break;
+		}
+	}
+
+	return rate_idx;
+}
+
+static unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
+{
+	int i, mcs_rate;
+
+	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
+
+	for (i = 15; i >= 0; i--) {
+		if (mcs_rate & (0x1 << i))
+			break;
+	}
+	return i;
+}
+
+void Update_RA_Entry(struct rtw_adapter *padapter, u32 mac_id)
+{
+	rtw_hal_update_ra_mask(padapter, mac_id);
+}
+
+static void enable_rate_adaptive(struct rtw_adapter *padapter, u32 mac_id)
+{
+	Update_RA_Entry(padapter, mac_id);
+}
+
+void set_sta_rate(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	/* rate adaptive */
+	enable_rate_adaptive(padapter, psta->mac_id);
+}
+
+/*  Update RRSR and Rate for USERATE */
+void update_tx_basic_rate(struct rtw_adapter *padapter, u8 wirelessmode)
+{
+	unsigned char supported_rates[NDIS_802_11_LENGTH_RATES_EX];
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	/* clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band. */
+	if (pmlmeext->cur_channel > 14)
+		wirelessmode &= ~(WIRELESS_11B);
+
+	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B))
+		memcpy(supported_rates, rtw_basic_rate_cck, 4);
+	else if (wirelessmode & WIRELESS_11B)
+		memcpy(supported_rates, rtw_basic_rate_mix, 7);
+	else
+		memcpy(supported_rates, rtw_basic_rate_ofdm, 3);
+
+	if (wirelessmode & WIRELESS_11B)
+		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
+	else
+		update_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, supported_rates);
+}
+
+unsigned char check_assoc_AP(u8 *pframe, uint len)
+{
+	unsigned int	i;
+	struct ndis_802_11_variable_ies *pIE;
+
+	for (i = sizeof(struct ndis_802_11_fixed_ies); i < len;) {
+		pIE = (struct ndis_802_11_variable_ies *)(pframe + i);
+
+		switch (pIE->ElementID) {
+		case _VENDOR_SPECIFIC_IE_:
+			if ((_rtw_memcmp(pIE->data, ARTHEROS_OUI1, 3)) ||
+			    (_rtw_memcmp(pIE->data, ARTHEROS_OUI2, 3))) {
+				DBG_8192D("link to Artheros AP\n");
+				return atherosAP;
+			} else if ((_rtw_memcmp(pIE->data, BROADCOM_OUI1, 3)) ||
+				   (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3)) ||
+				   (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3))) {
+				DBG_8192D("link to Broadcom AP\n");
+				return broadcomAP;
+			} else if (_rtw_memcmp(pIE->data, MARVELL_OUI, 3)) {
+				DBG_8192D("link to Marvell AP\n");
+				return marvellAP;
+			} else if (_rtw_memcmp(pIE->data, RALINK_OUI, 3)) {
+				DBG_8192D("link to Ralink AP\n");
+				return ralinkAP;
+			} else if (_rtw_memcmp(pIE->data, CISCO_OUI, 3)) {
+				DBG_8192D("link to Cisco AP\n");
+				return ciscoAP;
+			} else if (_rtw_memcmp(pIE->data, REALTEK_OUI, 3)) {
+				DBG_8192D("link to Realtek 96B\n");
+				return realtekAP;
+			} else if (_rtw_memcmp(pIE->data, AIRGOCAP_OUI, 3)) {
+				DBG_8192D("link to Airgo Cap\n");
+				return airgocapAP;
+			} else {
+				break;
+			}
+
+		default:
+			break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	DBG_8192D("link to new AP\n");
+	return unknownAP;
+}
+
+void update_IOT_info(struct rtw_adapter *padapter)
+{
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	switch (pmlmeinfo->assoc_AP_vendor) {
+	case marvellAP:
+		pmlmeinfo->turboMode_cts2self = 1;
+		pmlmeinfo->turboMode_rtsen = 0;
+		break;
+	case ralinkAP:
+		pmlmeinfo->turboMode_cts2self = 0;
+		pmlmeinfo->turboMode_rtsen = 1;
+		/* disable high power */
+		Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
+		break;
+	case realtekAP:
+		/* rtw_write16(padapter, 0x4cc, 0xffff); */
+		/* rtw_write16(padapter, 0x546, 0x01c0); */
+		/* disable high power */
+		Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
+		break;
+	default:
+		pmlmeinfo->turboMode_cts2self = 0;
+		pmlmeinfo->turboMode_rtsen = 1;
+		break;
+	}
+}
+
+void update_capinfo(struct rtw_adapter *adapter, u16 updateCap)
+{
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	bool		shortpreamble;
+
+	/*  Check preamble mode, 2005.01.06, by rcnjko. */
+	/*  Mark to update preamble value forever, 2008.03.18 by lanhsin */
+	/* if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO) */
+	if (updateCap && shortpreamble) { /*  Short Preamble */
+		if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) { /*  PREAMBLE_LONG or PREAMBLE_AUTO */
+			shortpreamble = true;
+			pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
+			rtw_hal_set_hwreg(adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
+		}
+	} else { /*  Long Preamble */
+		if (pmlmeinfo->preamble_mode != PREAMBLE_LONG) {  /*  PREAMBLE_SHORT or PREAMBLE_AUTO */
+			shortpreamble = false;
+			pmlmeinfo->preamble_mode = PREAMBLE_LONG;
+			rtw_hal_set_hwreg(adapter, HW_VAR_ACK_PREAMBLE, (u8 *)&shortpreamble);
+		}
+	}
+
+	if (updateCap & cIBSS) {
+		/* Filen: See 802.11-2007 p.91 */
+		pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+	} else {
+		/* Filen: See 802.11-2007 p.90 */
+		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N)) {
+			if ((updateCap & cShortSlotTime)) { /*  Short Slot Time */
+				if (pmlmeinfo->slotTime != SHORT_SLOT_TIME)
+					pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+			} else { /*  Long Slot Time */
+				if (pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)
+					pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+			}
+		} else if (pmlmeext->cur_wireless_mode & (WIRELESS_11A | WIRELESS_11_5N)) {
+			pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+		} else {
+			/* B Mode */
+			pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+		}
+	}
+
+	rtw_hal_set_hwreg(adapter, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime);
+}
+
+void update_wireless_mode(struct rtw_adapter *padapter)
+{
+	u8	init_rate = 0;
+	int	ratelen, network_type = 0;
+	u32	SIFS_Timer, mask;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex		*cur_network = &(pmlmeinfo->network);
+	unsigned char			*rate = cur_network->SupportedRates;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	ratelen = rtw_get_rateset_len(cur_network->SupportedRates);
+
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
+		pmlmeinfo->HT_enable = 1;
+
+	if (pmlmeext->cur_channel > 14) {
+		if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_5N;
+
+		network_type |= WIRELESS_11A;
+	} else {
+		if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_24N;
+
+		if ((cckratesonly_included(rate, ratelen)) == true)
+			network_type |= WIRELESS_11B;
+		else if ((cckrates_included(rate, ratelen)) == true)
+			network_type |= WIRELESS_11BG;
+		else
+			network_type |= WIRELESS_11G;
+	}
+
+	pmlmeext->cur_wireless_mode = network_type & padapter->registrypriv.wireless_mode;
+
+	/* For STA mode, driver need to modify initial data rate, or MAC will use wrong tx rate. */
+	/* Modified by Thomas 2012-12-3 */
+	mask = update_supported_rate(cur_network->SupportedRates, ratelen);
+	init_rate = get_highest_rate_idx(mask)&0x3f;
+	rtw_hal_set_hwreg(padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
+
+	SIFS_Timer = 0x0a0a0808; /* 0x0808 -> for CCK, 0x0a0a -> for OFDM */
+				/* change this value if having IOT issues. */
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
+
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
+		update_mgnt_tx_rate(padapter, IEEE80211_CCK_RATE_1MB);
+	} else {
+		update_mgnt_tx_rate(padapter, IEEE80211_OFDM_RATE_6MB);
+#ifdef CONFIG_CONCURRENT_MODE
+		if (pbuddy_adapter && (pmlmeext->cur_wireless_mode & WIRELESS_11A))
+			update_mgnt_tx_rate(pbuddy_adapter, IEEE80211_OFDM_RATE_6MB);
+#endif /* CONFIG_CONCURRENT_MODE */
+	}
+}
+
+void update_bmc_sta_support_rate(struct rtw_adapter *padapter, u32 mac_id)
+{
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
+		/*  Only B, B/G, and B/G/N AP could use CCK rate */
+		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_cck, 4);
+	} else {
+		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_ofdm, 3);
+	}
+}
+
+int update_sta_support_rate(struct rtw_adapter *padapter, u8 *pvar_ie, uint var_ie_len, int cam_idx)
+{
+	unsigned int	ie_len;
+	struct ndis_802_11_variable_ies *pIE;
+	int	supportRateNum = 0;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pIE = (struct ndis_802_11_variable_ies *)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE == NULL)
+		return _FAIL;
+
+	memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
+	supportRateNum = ie_len;
+
+	pIE = (struct ndis_802_11_variable_ies *)rtw_get_ie(pvar_ie, _EXT_SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE)
+		memcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);
+
+	return _SUCCESS;
+}
+
+void process_addba_req(struct rtw_adapter *padapter, u8 *paddba_req, u8 *addr)
+{
+	struct sta_info *psta;
+	u16 tid;
+	u16 param;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct ADDBA_request	*preq = (struct ADDBA_request *)paddba_req;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if (psta) {
+		param = le16_to_cpu(preq->BA_para_set);
+		tid = (param>>2)&0x0f;
+
+		preorder_ctrl = &psta->recvreorder_ctrl[tid];
+		preorder_ctrl->indicate_seq = 0xffff;
+		preorder_ctrl->enable = (pmlmeinfo->bAcceptAddbaReq == true) ? true : false;
+	}
+}
+
+void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len)
+{
+	u8 *pIE;
+	__le32 *pbuf;
+
+	pIE = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	pbuf = (__le32 *)pIE;
+	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
+	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
+	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
+}
+
+void correct_TSF(struct rtw_adapter *padapter, struct mlme_ext_priv *pmlmeext)
+{
+	rtw_hal_set_hwreg(padapter, HW_VAR_CORRECT_TSF, NULL);
+}
+
+void beacon_timing_control(struct rtw_adapter *padapter)
+{
+	rtw_hal_bcn_related_reg_setting(padapter);
+}
+
+static struct rtw_adapter *pbuddy_padapter;
+
+int rtw_handle_dualmac(struct rtw_adapter *adapter, bool init)
+{
+	int status = _SUCCESS;
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+
+	if (init) {
+		if ((dvobj->NumInterfaces == 2) && (adapter->registrypriv.mac_phy_mode != 1)) {
+			dvobj->DualMacMode = true;
+			/*  temply disable IPS For 92D-VC */
+			adapter->registrypriv.ips_mode = IPS_NONE;
+		}
+
+		/* For SMSP on 92DU-VC, driver do not probe another Interface. */
+		if ((dvobj->DualMacMode != true) && (dvobj->InterfaceNumber != 0)) {
+			DBG_8192D("%s(): Do not init another USB Interface because SMSP\n", __func__);
+			status = _FAIL;
+			goto exit;
+		}
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (pbuddy_padapter == NULL) {
+			pbuddy_padapter = adapter;
+			DBG_8192D("%s(): pbuddy_padapter == NULL, Set pbuddy_padapter\n", __func__);
+		} else {
+			adapter->pbuddy_adapter = pbuddy_padapter;
+			pbuddy_padapter->pbuddy_adapter = adapter;
+			/*  clear global value */
+			pbuddy_padapter = NULL;
+			DBG_8192D("%s(): pbuddy_padapter exist, Exchange Information\n", __func__);
+		}
+
+		if (dvobj->InterfaceNumber == 0) {
+			/* set adapter_type/iface type */
+			adapter->isprimary = true;
+			adapter->adapter_type = PRIMARY_ADAPTER;
+			adapter->iface_type = IFACE_PORT0;
+			DBG_8192D("%s(): PRIMARY_ADAPTER\n", __func__);
+		} else {
+			/* set adapter_type/iface type */
+			adapter->isprimary = false;
+			adapter->adapter_type = SECONDARY_ADAPTER;
+			adapter->iface_type = IFACE_PORT1;
+			DBG_8192D("%s(): SECONDARY_ADAPTER\n", __func__);
+		}
+#endif
+	} else {
+		pbuddy_padapter = NULL;
+	}
+exit:
+	return status;
+}
diff --git a/drivers/net/wireless/rtl8192du/core/rtw_xmit.c b/drivers/net/wireless/rtl8192du/core/rtw_xmit.c
new file mode 100644
index 0000000..b9d0541
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/core/rtw_xmit.c
@@ -0,0 +1,2247 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTW_XMIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <linux/ip.h>
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#include <linux/vmalloc.h>
+
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+static void _init_txservq(struct tx_servq *ptxservq)
+{
+
+	INIT_LIST_HEAD(&ptxservq->tx_pending);
+	_rtw_init_queue(&ptxservq->sta_pending);
+	ptxservq->qcnt = 0;
+
+}
+
+void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{
+
+	memset((unsigned char *)psta_xmitpriv, 0, sizeof(struct sta_xmit_priv));
+
+	_rtw_spinlock_init(&psta_xmitpriv->lock);
+
+	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
+	/*	_init_txservq(&(psta_xmitpriv->blk_q[i])); */
+
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	INIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);
+	INIT_LIST_HEAD(&psta_xmitpriv->apsd);
+
+}
+
+s32	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtw_adapter *padapter)
+{
+	int i;
+	struct xmit_buf *pxmitbuf;
+	struct xmit_frame *pxframe;
+	int	res = _SUCCESS;
+
+	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by vzalloc(). */
+	/* memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv)); */
+
+	_rtw_spinlock_init(&pxmitpriv->lock);
+	_rtw_init_sema(&pxmitpriv->xmit_sema, 0);
+	_rtw_init_sema(&pxmitpriv->terminate_xmitthread_sema, 0);
+
+	/*
+	Please insert all the queue initializaiton using _rtw_init_queue below
+	*/
+
+	pxmitpriv->adapter = padapter;
+
+	_rtw_init_queue(&pxmitpriv->be_pending);
+	_rtw_init_queue(&pxmitpriv->bk_pending);
+	_rtw_init_queue(&pxmitpriv->vi_pending);
+	_rtw_init_queue(&pxmitpriv->vo_pending);
+	_rtw_init_queue(&pxmitpriv->bm_pending);
+
+	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
+
+	/*
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+
+	pxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+
+	if (pxmitpriv->pallocated_frame_buf  == NULL) {
+		pxmitpriv->pxmit_frame_buf = NULL;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_frame fail!\n"));
+		res = _FAIL;
+		goto exit;
+	}
+	pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);
+
+	pxframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
+
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		INIT_LIST_HEAD(&(pxframe->list));
+
+		pxframe->padapter = padapter;
+		pxframe->frame_tag = NULL_FRAMETAG;
+
+		pxframe->pkt = NULL;
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		rtw_list_insert_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.queue));
+
+		pxframe++;
+	}
+
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+
+	/* init xmit_buf */
+	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+
+	pxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+
+	if (pxmitpriv->pallocated_xmitbuf  == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_buf fail!\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmitbuf), 4);
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		INIT_LIST_HEAD(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->padapter = padapter;
+		pxmitbuf->ext_tag = false;
+
+		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
+		if (res == _FAIL)
+			goto exit;
+
+		pxmitbuf->flags = XMIT_VO_QUEUE;
+
+		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.queue));
+		#ifdef DBG_XMIT_BUF
+		pxmitbuf->no = i;
+		#endif
+
+		pxmitbuf++;
+	}
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+
+	/*  Init xmit extension buff */
+	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
+
+	pxmitpriv->pallocated_xmit_extbuf = vzalloc(NR_XMIT_EXTBUFF *
+						    sizeof(struct xmit_buf)+4);
+
+	if (pxmitpriv->pallocated_xmit_extbuf  == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_extbuf fail!\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmit_extbuf), 4);
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
+
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+		INIT_LIST_HEAD(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->padapter = padapter;
+		pxmitbuf->ext_tag = true;
+
+		res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ);
+		if (res == _FAIL)
+			goto exit;
+
+		rtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));
+		#ifdef DBG_XMIT_BUF
+		pxmitbuf->no = i;
+		#endif
+		pxmitbuf++;
+	}
+
+	pxmitpriv->free_xmit_extbuf_cnt = NR_XMIT_EXTBUFF;
+
+	rtw_alloc_hwxmits(padapter);
+	rtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+
+	pxmitpriv->txirp_cnt = 1;
+
+	_rtw_init_sema(&(pxmitpriv->tx_retevt), 0);
+
+	/* per AC pending irp */
+	pxmitpriv->beq_cnt = 0;
+	pxmitpriv->bkq_cnt = 0;
+	pxmitpriv->viq_cnt = 0;
+	pxmitpriv->voq_cnt = 0;
+
+	pxmitpriv->ack_tx = false;
+	_rtw_mutex_init(&pxmitpriv->ack_tx_mutex);
+	rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0);
+	rtw_hal_init_xmit_priv(padapter);
+exit:
+	return res;
+}
+
+static void  rtw_mfree_xmit_priv_lock(struct xmit_priv *pxmitpriv)
+{
+	_rtw_spinlock_free(&pxmitpriv->lock);
+	_rtw_free_sema(&pxmitpriv->xmit_sema);
+	_rtw_free_sema(&pxmitpriv->terminate_xmitthread_sema);
+
+	_rtw_spinlock_free(&pxmitpriv->be_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->bk_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->vi_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->vo_pending.lock);
+	_rtw_spinlock_free(&pxmitpriv->bm_pending.lock);
+
+	_rtw_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
+	_rtw_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
+	_rtw_spinlock_free(&pxmitpriv->pending_xmitbuf_queue.lock);
+}
+
+void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv)
+{
+	int i;
+	struct rtw_adapter *padapter = pxmitpriv->adapter;
+	struct xmit_frame	*pxmitframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+	rtw_hal_free_xmit_priv(padapter);
+	rtw_mfree_xmit_priv_lock(pxmitpriv);
+	if (pxmitpriv->pxmit_frame_buf == NULL)
+		return;
+
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		rtw_os_xmit_complete(padapter, pxmitframe);
+		pxmitframe++;
+	}
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		rtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ));
+		pxmitbuf++;
+	}
+	if (pxmitpriv->pallocated_frame_buf)
+		vfree(pxmitpriv->pallocated_frame_buf);
+	if (pxmitpriv->pallocated_xmitbuf)
+		vfree(pxmitpriv->pallocated_xmitbuf);
+
+	/*  free xmit extension buff */
+	_rtw_spinlock_free(&pxmitpriv->free_xmit_extbuf_queue.lock);
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+		rtw_os_xmit_resource_free(padapter, pxmitbuf, (MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ));
+
+		pxmitbuf++;
+	}
+
+	if (pxmitpriv->pallocated_xmit_extbuf)
+		vfree(pxmitpriv->pallocated_xmit_extbuf);
+
+	rtw_free_hwxmits(padapter);
+
+	_rtw_mutex_free(&pxmitpriv->ack_tx_mutex);
+}
+
+static void update_attrib_vcs_info(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u32	sz;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct sta_info	*psta = pattrib->psta;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pattrib->nr_frags != 1)
+		sz = padapter->xmitpriv.frag_len;
+	else /* no frag */
+		sz = pattrib->last_txcmdsz;
+
+	/*  (1) RTS_Threshold is compared to the MPDU, not MSDU. */
+	/*  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame. */
+	/*		Other fragments are protected by previous fragment. */
+	/*		So we only need to check the length of first fragment. */
+	if (pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec) {
+		if (sz > padapter->registrypriv.rts_thresh) {
+			pattrib->vcs_mode = RTS_CTS;
+		} else {
+			if (psta->rtsen)
+				pattrib->vcs_mode = RTS_CTS;
+			else if (psta->cts2self)
+				pattrib->vcs_mode = CTS_TO_SELF;
+			else
+				pattrib->vcs_mode = NONE_VCS;
+		}
+	} else {
+		while (true) {
+			/* IOT action */
+			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en == true) &&
+			    (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)) {
+				pattrib->vcs_mode = CTS_TO_SELF;
+				break;
+			}
+
+			/* check ERP protection */
+			if (psta->rtsen || psta->cts2self) {
+				if (psta->rtsen)
+					pattrib->vcs_mode = RTS_CTS;
+				else if (psta->cts2self)
+					pattrib->vcs_mode = CTS_TO_SELF;
+
+				break;
+			}
+
+			/* check HT op mode */
+			if (pattrib->ht_en) {
+				u8 ht_op_mode = pmlmeinfo->HT_protection;
+				if ((pmlmeext->cur_bwmode && (ht_op_mode == 2 || ht_op_mode == 3)) ||
+				    (!pmlmeext->cur_bwmode && ht_op_mode == 3)) {
+					pattrib->vcs_mode = RTS_CTS;
+					break;
+				}
+			}
+
+			/* check rts */
+			if (sz > padapter->registrypriv.rts_thresh) {
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+
+			/* to do list: check MIMO power save condition. */
+
+			/* check AMPDU aggregation for TXOP */
+			if (pattrib->ampdu_en == true) {
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+
+			pattrib->vcs_mode = NONE_VCS;
+			break;
+		}
+	}
+}
+
+static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
+{
+	pattrib->mdata = 0;
+	pattrib->eosp = 0;
+	pattrib->triggered = 0;
+
+	/* qos_en, ht_en, init rate, , bw, ch_offset, sgi */
+	pattrib->qos_en = psta->qos_option;
+	pattrib->ht_en = psta->htpriv.ht_option;
+	pattrib->raid = psta->raid;
+	pattrib->bwmode = psta->htpriv.bwmode;
+	pattrib->ch_offset = psta->htpriv.ch_offset;
+	pattrib->sgi = psta->htpriv.sgi;
+	pattrib->ampdu_en = false;
+
+	pattrib->retry_ctrl = false;
+}
+
+u8	qos_acm(u8 acm_mask, u8 priority)
+{
+	u8	change_priority = priority;
+
+	switch (priority) {
+	case 0:
+	case 3:
+		if (acm_mask & BIT(1))
+			change_priority = 1;
+		break;
+	case 1:
+	case 2:
+		break;
+	case 4:
+	case 5:
+		if (acm_mask & BIT(2))
+			change_priority = 0;
+		break;
+	case 6:
+	case 7:
+		if (acm_mask & BIT(3))
+			change_priority = 5;
+		break;
+	default:
+		DBG_8192D("qos_acm(): invalid pattrib->priority: %d!!!\n", priority);
+		break;
+	}
+
+	return change_priority;
+}
+
+static void set_qos(struct sk_buff *skb, struct pkt_attrib *pattrib)
+{
+	u8 *pframe = skb->data;
+	struct iphdr *ip_hdr;
+	u8 userpriority = 0;
+
+	/*  get userpriority from IP hdr */
+	if (pattrib->ether_type == ETH_P_IP) {
+		ip_hdr = (struct iphdr *)(pframe + ETH_HLEN);
+		userpriority = ip_hdr->tos >> 5;
+	} else if (pattrib->ether_type == ETH_P_PAE) {
+		/*  "When priority processing of data frames is supported, */
+		/*  a STA's SME should send EAPOL-Key frames at the highest
+		    priority." */
+		userpriority = 7;
+	}
+
+	pattrib->priority = userpriority;
+	pattrib->hdrlen = sizeof(struct ieee80211_qos_hdr);
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+static int update_attrib(struct rtw_adapter *padapter,
+			 struct sk_buff *skb, struct pkt_attrib *pattrib)
+{
+	struct sta_info *psta = NULL;
+	int bmcast;
+	struct sta_priv	*pstapriv = &padapter->stapriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	int res = _SUCCESS;
+	struct ethhdr *ehdr = (struct ethhdr *) skb->data;
+
+	pattrib->ether_type = ntohs(ehdr->h_proto);
+
+	ether_addr_copy(pattrib->dst, ehdr->h_dest);
+	ether_addr_copy(pattrib->src, ehdr->h_source);
+
+	pattrib->pctrl = 0;
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) ||
+	    check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {
+		ether_addr_copy(pattrib->ra, pattrib->dst);
+		ether_addr_copy(pattrib->ta, pattrib->src);
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		ether_addr_copy(pattrib->ra, get_bssid(pmlmepriv));
+		ether_addr_copy(pattrib->ta, pattrib->src);
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ether_addr_copy(pattrib->ra, pattrib->dst);
+		ether_addr_copy(pattrib->ta, get_bssid(pmlmepriv));
+	}
+
+	pattrib->pktlen = skb->len - ETH_HLEN;
+
+	if (pattrib->ether_type == ETH_P_IP) {
+		/*  The following is for DHCP and ARP packet, we use cck1M
+		    to tx these packets and let LPS awake some time */
+		/*  to prevent DHCP protocol fail */
+		pattrib->dhcp_pkt = 0;
+		/* MINIMUM_DHCP_PACKET_SIZE) { */
+		if (pattrib->pktlen > 282 + 24) {
+			if (pattrib->ether_type == ETH_P_IP) {/*  IP header */
+				u8 *pframe = skb->data;
+				pframe += ETH_HLEN;
+
+				if ((pframe[21] == 68 && pframe[23] == 67) ||
+				    (pframe[21] == 67 && pframe[23] == 68)) {
+					/*  68 : UDP BOOTP client */
+					/*  67 : UDP BOOTP server */
+					RT_TRACE(_module_rtl871x_xmit_c_,
+						 _drv_err_,
+						 ("======================"
+						  "update_attrib: get DHCP "
+						  "Packet\n"));
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	}
+
+	if ((pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1)) {
+		rtw_set_scan_deny(padapter, 3000);
+	}
+
+#ifdef CONFIG_LPS
+	/*  If EAPOL , ARP , OR DHCP packet, driver must be in active mode. */
+	if ((pattrib->ether_type == ETH_P_ARP) ||
+	    (pattrib->ether_type == ETH_P_PAE) || (pattrib->dhcp_pkt == 1)) {
+		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
+	}
+#endif
+
+	bmcast = is_multicast_ether_addr(pattrib->ra);
+
+	/*  get sta_info */
+	if (bmcast) {
+		psta = rtw_get_bcmc_stainfo(padapter);
+	} else {
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+		if (psta == NULL) { /*  if we cannot get psta => drop the pkt */
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+				 ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
+			res = _FAIL;
+			goto exit;
+		} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) &&
+			   (!(psta->state & _FW_LINKED))) {
+			res = _FAIL;
+			goto exit;
+		}
+	}
+
+	if (psta) {
+		pattrib->mac_id = psta->mac_id;
+		pattrib->psta = psta;
+	} else {
+		/*  if we cannot get psta => drop the pkt */
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_,
+			 ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pattrib->ack_policy = 0;
+	/*  get ether_hdr_len */
+
+	/* pattrib->ether_type == 0x8100) ? (14 + 4): 14; vlan tag */
+	pattrib->pkt_hdrlen = ETH_HLEN;
+
+	pattrib->hdrlen = sizeof(struct ieee80211_hdr_3addr);
+	pattrib->subtype = WIFI_DATA_TYPE;
+	pattrib->priority = 0;
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE | WIFI_ADHOC_STATE |
+			  WIFI_ADHOC_MASTER_STATE)) {
+		if (psta->qos_option)
+			set_qos(skb, pattrib);
+	} else {
+		if (psta->qos_option) {
+			set_qos(skb, pattrib);
+
+			if (pmlmepriv->acm_mask != 0) {
+				pattrib->priority = qos_acm(pmlmepriv->acm_mask,
+							    pattrib->priority);
+			}
+		}
+	}
+
+	if (psta->ieee8021x_blocked == true) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+			 ("\n psta->ieee8021x_blocked == true\n"));
+
+		pattrib->encrypt = 0;
+
+		if ((pattrib->ether_type != ETH_P_PAE) &&
+		    !check_fwstate(pmlmepriv, WIFI_MP_STATE)) {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("\npsta->ieee8021x_blocked == true,  "
+				  "pattrib->ether_type(%.4x) != 0x888e\n",
+				  pattrib->ether_type));
+			res = _FAIL;
+			goto exit;
+		}
+	} else {
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+
+		switch (psecuritypriv->dot11AuthAlgrthm) {
+		case dot11AuthAlgrthm_Open:
+		case dot11AuthAlgrthm_Shared:
+		case dot11AuthAlgrthm_Auto:
+			pattrib->key_idx =
+				(u8)psecuritypriv->dot11PrivacyKeyIndex;
+			break;
+		case dot11AuthAlgrthm_8021X:
+			if (bmcast)
+				pattrib->key_idx =
+					(u8)psecuritypriv->dot118021XGrpKeyid;
+			else
+				pattrib->key_idx = 0;
+			break;
+		default:
+			pattrib->key_idx = 0;
+			break;
+		}
+
+	}
+
+	switch (pattrib->encrypt) {
+	case _WEP40_:
+	case _WEP104_:
+		pattrib->iv_len = IEEE80211_WEP_IV_LEN;
+		pattrib->icv_len = IEEE80211_WEP_ICV_LEN;
+		break;
+
+	case _TKIP_:
+		pattrib->iv_len = IEEE80211_TKIP_IV_LEN;
+		pattrib->icv_len = IEEE80211_TKIP_ICV_LEN;
+
+		if (!padapter->securitypriv.busetkipkey) {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("\npadapter->securitypriv.busetkip"
+				  "key(%d) == false drop packet\n",
+				  padapter->securitypriv.busetkipkey));
+			res = _FAIL;
+			goto exit;
+		}
+		break;
+	case _AES_:
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+			 ("pattrib->encrypt =%d (WLAN_CIPHER_SUITE_CCMP)\n",
+			  pattrib->encrypt));
+		pattrib->iv_len = IEEE80211_CCMP_HDR_LEN;
+		pattrib->icv_len = IEEE80211_CCMP_MIC_LEN;
+		break;
+	default:
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+		break;
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+		 ("update_attrib: encrypt =%d\n", pattrib->encrypt));
+
+	if (pattrib->encrypt && !psecuritypriv->hw_decrypted) {
+		pattrib->bswenc = true;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+			 ("update_attrib: encrypt =%d bswenc = true\n",
+			  pattrib->encrypt));
+	} else {
+		pattrib->bswenc = false;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+			 ("update_attrib: bswenc = false\n"));
+	}
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((pattrib->encrypt && bmcast) || (pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_))
+		pattrib->bswenc = true;/* force using sw enc. */
+#endif
+
+	rtw_set_tx_chksum_offload(skb, pattrib);
+
+	update_attrib_phy_info(pattrib, psta);
+
+exit:
+	return res;
+}
+
+static s32 xmitframe_addmic(struct rtw_adapter *padapter,
+			    struct xmit_frame *pxmitframe)
+{
+	int curfragnum, length;
+	u8 *pframe, *payload, mic[8];
+	struct	mic_data micdata;
+	struct	sta_info *stainfo;
+	struct	qos_priv *pqospriv = &(padapter->mlmepriv.qospriv);
+	struct	pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct	security_priv *psecuritypriv = &padapter->securitypriv;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	u8 priority[4] = {0x0, 0x0, 0x0, 0x0};
+	int bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta)
+		stainfo = pattrib->psta;
+	else
+		stainfo = rtw_get_stainfo(&padapter->stapriv, &pattrib->ra[0]);
+
+	if (pattrib->encrypt == _TKIP_) {
+		/* encode mic code */
+		if (stainfo != NULL) {
+			u8 null_key[16] = {0};
+
+			pframe = pxmitframe->buf_addr + TXDESC_SIZE +
+				 (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
+
+			if (bmcst) {
+				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16) == true) {
+					return _FAIL;
+				}
+				/* start to calculate the mic code */
+				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
+			} else {
+				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0], null_key, 16) == true) {
+					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey == 0\n"); */
+					/* rtw_msleep_os(10); */
+					return _FAIL;
+				}
+				/* start to calculate the mic code */
+				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
+			}
+
+			if (pframe[1]&1) {   /* ToDS == 1 */
+				rtw_secmicappend(&micdata, &pframe[16], 6);  /* DA */
+				if (pframe[1]&2)  /* From Ds == 1 */
+					rtw_secmicappend(&micdata, &pframe[24], 6);
+				else
+				rtw_secmicappend(&micdata, &pframe[10], 6);
+			} else {	/* ToDS == 0 */
+				rtw_secmicappend(&micdata, &pframe[4], 6);   /* DA */
+				if (pframe[1]&2)  /* From Ds == 1 */
+					rtw_secmicappend(&micdata, &pframe[16], 6);
+				else
+					rtw_secmicappend(&micdata, &pframe[10], 6);
+			}
+			if (pattrib->qos_en)
+				priority[0] = (u8)pxmitframe->attrib.priority;
+			rtw_secmicappend(&micdata, &priority[0], 4);
+
+			payload = pframe;
+
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {
+				payload = (u8 *)RND4((SIZE_PTR)(payload));
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+					 ("=== curfragnum =%d, pframe = 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x, 0x%.2x,!!!\n",
+					 curfragnum, *payload, *(payload+1),
+					 *(payload+2), *(payload+3),
+					 *(payload+4), *(payload+5),
+					 *(payload+6), *(payload+7)));
+
+				payload = payload+pattrib->hdrlen+pattrib->iv_len;
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+					 ("curfragnum =%d pattrib->hdrlen =%d pattrib->iv_len =%d",
+					 curfragnum, pattrib->hdrlen,
+					 pattrib->iv_len));
+				if ((curfragnum+1) == pattrib->nr_frags) {
+					length = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload = payload+length;
+				} else {
+					length = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload = payload+length+pattrib->icv_len;
+					RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+						 ("curfragnum =%d length =%d pattrib->icv_len =%d",
+						 curfragnum, length, pattrib->icv_len));
+				}
+			}
+			rtw_secgetmic(&micdata, &(mic[0]));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: before add mic code!!!\n"));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: pattrib->last_txcmdsz =%d!!!\n",
+				 pattrib->last_txcmdsz));
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+				 ("xmitframe_addmic: mic[0]= 0x%.2x , mic[1]= 0x%.2x , mic[2]= 0x%.2x , mic[3]= 0x%.2x\nmic[4]= 0x%.2x , mic[5]= 0x%.2x , mic[6]= 0x%.2x , mic[7]= 0x%.2x !!!!\n",
+				 mic[0], mic[1], mic[2], mic[3], mic[4], mic[5],
+				 mic[6], mic[7]));
+			/* add mic code  and add the mic code length in last_txcmdsz */
+
+			memcpy(payload, &(mic[0]), 8);
+			pattrib->last_txcmdsz += 8;
+
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("\n ======== last pkt ========\n"));
+			payload = payload-pattrib->last_txcmdsz+8;
+			for (curfragnum = 0; curfragnum < pattrib->last_txcmdsz; curfragnum += 8)
+				RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,
+					 (" %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x,  %.2x ",
+					 *(payload+curfragnum),
+					 *(payload+curfragnum+1),
+					 *(payload+curfragnum+2),
+					 *(payload+curfragnum+3),
+					 *(payload+curfragnum+4),
+					 *(payload+curfragnum+5),
+					 *(payload+curfragnum+6),
+					 *(payload+curfragnum+7)));
+		} else {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic: rtw_get_stainfo == NULL!!!\n"));
+		}
+	}
+
+	return _SUCCESS;
+}
+
+static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
+
+	if (pattrib->bswenc) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("### xmitframe_swencrypt\n"));
+		switch (pattrib->encrypt) {
+		case _WEP40_:
+		case _WEP104_:
+			rtw_wep_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _TKIP_:
+			rtw_tkip_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		case _AES_:
+			rtw_aes_encrypt(padapter, (u8 *)pxmitframe);
+			break;
+		default:
+				break;
+		}
+
+	} else {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_, ("### xmitframe_hwencrypt\n"));
+	}
+
+	return _SUCCESS;
+}
+
+s32 rtw_make_wlanhdr (struct rtw_adapter *padapter , u8 *hdr, struct pkt_attrib *pattrib)
+{
+	u16 *qc;
+	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	u8 qos_option = false;
+	int res = _SUCCESS;
+	__le16 *fctrl = &pwlanhdr->frame_ctl;
+	struct sta_info *psta;
+	int bmcst = IS_MCAST(pattrib->ra);
+
+	if (pattrib->psta) {
+		psta = pattrib->psta;
+	} else {
+		if (bmcst)
+			psta = rtw_get_bcmc_stainfo(padapter);
+		else
+			psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+	}
+
+	memset(hdr, 0, WLANHDR_OFFSET);
+
+	SetFrameSubType(fctrl, pattrib->subtype);
+
+	if (pattrib->subtype & WIFI_DATA_TYPE) {
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
+			/* to_ds = 1, fr_ds = 0; */
+			/* Data transfer to AP */
+			SetToDs(fctrl);
+			memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+
+			if (pqospriv->qos_option)
+				qos_option = true;
+		} else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
+			/* to_ds = 0, fr_ds = 1; */
+			SetFrDs(fctrl);
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+
+			if (psta->qos_option)
+				qos_option = true;
+		} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+
+			if (psta->qos_option)
+				qos_option = true;
+		} else {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("fw_state:%x is not allowed to xmit frame\n", get_fwstate(pmlmepriv)));
+			res = _FAIL;
+			goto exit;
+		}
+
+		if (pattrib->mdata)
+			SetMData(fctrl);
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+
+		if (qos_option) {
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+
+			if (pattrib->priority)
+				SetPriority(qc, pattrib->priority);
+
+			SetEOSP(qc, pattrib->eosp);
+
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+
+		/* TODO: fill HT Control Field */
+
+		/* Update Seq Num will be handled by f/w */
+		if (psta) {
+			psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
+			psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
+
+			pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->priority];
+
+			SetSeqNum(hdr, pattrib->seqnum);
+
+			/* check if enable ampdu */
+			if (pattrib->ht_en && psta->htpriv.ampdu_enable) {
+				if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+					pattrib->ampdu_en = true;
+			}
+
+			/* re-check if enable ampdu by BA_starting_seqctrl */
+			if (pattrib->ampdu_en == true) {
+				u16 tx_seq;
+
+				tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
+
+				/* check BA_starting_seqctrl */
+				if (SN_LESS(pattrib->seqnum, tx_seq)) {
+					/* DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq); */
+					pattrib->ampdu_en = false;/* AGG BK */
+				} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {
+					psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
+
+					pattrib->ampdu_en = true;/* AGG EN */
+				} else {
+					/* DBG_8192D("tx ampdu over run\n"); */
+					psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
+					pattrib->ampdu_en = true;/* AGG EN */
+				}
+			}
+		}
+	}
+
+exit:
+
+	return res;
+}
+
+s32 rtw_txframes_pending(struct rtw_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	return ((_rtw_queue_empty(&pxmitpriv->be_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->bk_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->vi_pending) == false) ||
+			 (_rtw_queue_empty(&pxmitpriv->vo_pending) == false));
+}
+
+s32 rtw_txframes_sta_ac_pending(struct rtw_adapter *padapter, struct pkt_attrib *pattrib)
+{
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	int priority = pattrib->priority;
+
+	psta = pattrib->psta;
+
+	switch (priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+	break;
+	}
+
+	if (!ptxservq) {
+		pr_err("ptxservq is NULL for priority %d\n", priority);
+		return 0;
+	}
+	return ptxservq->qcnt;
+}
+
+/*
+ * Calculate wlan 802.11 packet MAX size from pkt_attrib
+ * This function doesn't consider fragment case
+ */
+u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib)
+{
+	u32	len = 0;
+
+	len = pattrib->hdrlen + pattrib->iv_len; /*  WLAN Header and IV */
+	len += SNAP_SIZE + sizeof(u16); /*  LLC */
+	len += pattrib->pktlen;
+	if (pattrib->encrypt == _TKIP_)
+		len += 8; /*  MIC */
+	len += pattrib->icv_len; /*  ICV */
+
+	return len;
+}
+
+/*
+
+This sub-routine will perform all the following:
+
+1. remove 802.3 header.
+2. create wlan_header, based on the info in pxmitframe
+3. append sta's iv/ext-iv
+4. append LLC
+5. move frag chunk from pframe to pxmitframe->mem
+6. apply sw-encrypt, if necessary.
+
+*/
+s32 rtw_xmitframe_coalesce(struct rtw_adapter *padapter, struct sk_buff *skb,
+			   struct xmit_frame *pxmitframe)
+{
+	struct sta_info *psta;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct ieee80211_hdr *hdr;
+	s32 frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;
+	u8 *pframe, *mem_start;
+	u8 hw_hdr_offset;
+	u8 *pbuf_start;
+	u8 *pdata = skb->data;
+	int data_len = skb->len;
+	s32 bmcst = is_multicast_ether_addr(pattrib->ra);
+	s32 res = _SUCCESS;
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else
+		psta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);
+
+	if (!psta)
+		return _FAIL;
+
+	if (!pxmitframe->buf_addr)
+		return _FAIL;
+
+	pbuf_start = pxmitframe->buf_addr;
+
+	mem_start = pbuf_start + TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
+
+	if (rtw_make_wlanhdr(padapter, mem_start, pattrib) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	pdata += pattrib->pkt_hdrlen;
+	data_len -= pattrib->pkt_hdrlen;
+
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;/* 2346-4 = 2342 */
+
+	while (1) {
+		llc_sz = 0;
+
+		mpdu_len = frg_len;
+
+		pframe = mem_start;
+
+		hdr = (struct ieee80211_hdr *)mem_start;
+
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+
+		/* adding icv, if necessary... */
+		if (pattrib->iv_len) {
+			if (psta) {
+				switch (pattrib->encrypt) {
+				case _WEP40_:
+				case _WEP104_:
+					WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					break;
+				case _TKIP_:
+					if (bmcst)
+						TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					else
+						TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+					break;
+				case _AES_:
+					if (bmcst)
+						AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+					else
+						AES_IV(pattrib->iv, psta->dot11txpn, 0);
+					break;
+				}
+			}
+
+			memcpy(pframe, pattrib->iv, pattrib->iv_len);
+
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_notice_,
+				 ("rtw_xmitframe_coalesce: keyid =%d pattrib->iv[3]=%.2x pframe =%.2x %.2x %.2x %.2x\n",
+				  padapter->securitypriv.dot11PrivacyKeyIndex, pattrib->iv[3], *pframe, *(pframe+1), *(pframe+2), *(pframe+3)));
+
+			pframe += pattrib->iv_len;
+
+			mpdu_len -= pattrib->iv_len;
+		}
+
+		if (frg_inx == 0) {
+			llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc))
+			mpdu_len -= pattrib->icv_len;
+
+		if (bmcst) {
+			/*  don't do fragment to broadcat/multicast packets */
+			mem_sz = min_t(s32, data_len, pattrib->pktlen);
+		} else {
+			mem_sz = min_t(s32, data_len, mpdu_len);
+		}
+
+		memcpy(pframe, pdata, mem_sz);
+
+		pframe += mem_sz;
+		pdata += mem_sz;
+		data_len -= mem_sz;
+
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
+			memcpy(pframe, pattrib->icv, pattrib->icv_len);
+			pframe += pattrib->icv_len;
+		}
+
+		frg_inx++;
+
+		if (bmcst || data_len <= 0) {
+			pattrib->nr_frags = frg_inx;
+
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags == 1) ? llc_sz : 0) +
+					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
+
+			hdr->frame_control &=
+				~cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);
+
+			break;
+		} else {
+			RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("%s: There're still something in packet!\n", __func__));
+		}
+		hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);
+
+		mem_start = PTR_ALIGN(pframe, 4) + hw_hdr_offset;
+		memcpy(mem_start, pbuf_start + hw_hdr_offset, pattrib->hdrlen);
+	}
+
+	if (xmitframe_addmic(padapter, pxmitframe) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("xmitframe_addmic(padapter, pxmitframe) == _FAIL\n"));
+		res = _FAIL;
+		goto exit;
+	}
+
+	xmitframe_swencrypt(padapter, pxmitframe);
+
+	if (bmcst == false)
+		update_attrib_vcs_info(padapter, pxmitframe);
+	else
+		pattrib->vcs_mode = NONE_VCS;
+exit:
+	return res;
+}
+
+/* Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
+ * IEEE LLC/SNAP header contains 8 octets
+ * First 3 octets comprise the LLC portion
+ * SNAP portion, 5 octets, is divided into two fields:
+ *	Organizationally Unique Identifier(OUI), 3 octets,
+ *	type, defined by that organization, 2 octets.
+ */
+s32 rtw_put_snap(u8 *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	u8 *oui;
+
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+
+	*(__be16 *)(data + SNAP_SIZE) = htons(h_proto);
+
+	return SNAP_SIZE + sizeof(u16);
+}
+
+void rtw_update_protection(struct rtw_adapter *padapter, u8 *ie, uint ie_len)
+{
+	uint	protection;
+	u8	*perp;
+	int	 erp_len;
+	struct	xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct	registry_priv *pregistrypriv = &padapter->registrypriv;
+
+	switch (pxmitpriv->vcs_setting) {
+	case DISABLE_VCS:
+		pxmitpriv->vcs = NONE_VCS;
+		break;
+	case ENABLE_VCS:
+		break;
+	case AUTO_VCS:
+	default:
+		perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+		if (perp == NULL) {
+			pxmitpriv->vcs = NONE_VCS;
+		} else {
+			protection = (*(perp + 2)) & BIT(1);
+			if (protection) {
+				if (pregistrypriv->vcs_type == RTS_CTS)
+					pxmitpriv->vcs = RTS_CTS;
+				else
+					pxmitpriv->vcs = CTS_TO_SELF;
+			} else {
+				pxmitpriv->vcs = NONE_VCS;
+			}
+		}
+		break;
+	}
+
+}
+
+void rtw_count_tx_stats(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, int sz)
+{
+	struct sta_info *psta = NULL;
+	struct stainfo_stats *pstats = NULL;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
+		pxmitpriv->tx_bytes += sz;
+		pmlmepriv->LinkDetectInfo.NumTxOkInPeriod += pxmitframe->agg_num;
+
+		psta = pxmitframe->attrib.psta;
+
+		if (psta) {
+			pstats = &psta->sta_stats;
+			pstats->tx_pkts += pxmitframe->agg_num;
+			pstats->tx_bytes += sz;
+		}
+	}
+}
+
+struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
+{
+	long unsigned int flags;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
+
+	spin_lock_irqsave(&pfree_queue->lock, flags);
+
+	if (_rtw_queue_empty(pfree_queue) == true) {
+		pxmitbuf = NULL;
+	} else {
+		phead = get_list_head(pfree_queue);
+
+		plist = phead->next;
+
+		pxmitbuf = container_of(plist, struct xmit_buf, list);
+
+		list_del_init(&(pxmitbuf->list));
+	}
+	if (pxmitbuf !=  NULL) {
+		pxmitpriv->free_xmit_extbuf_cnt--;
+		#ifdef DBG_XMIT_BUF
+		DBG_8192D("DBG_XMIT_BUF ALLOC no =%d,  free_xmit_extbuf_cnt =%d\n", pxmitbuf->no, pxmitpriv->free_xmit_extbuf_cnt);
+		#endif
+		pxmitbuf->priv_data = NULL;
+		if (pxmitbuf->sctx) {
+			DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
+		}
+	}
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
+
+	return pxmitbuf;
+}
+
+s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	long unsigned int flags;
+	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
+
+	if (pxmitbuf == NULL)
+		return _FAIL;
+
+	spin_lock_irqsave(&pfree_queue->lock, flags);
+
+	list_del_init(&pxmitbuf->list);
+
+	rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_queue));
+	pxmitpriv->free_xmit_extbuf_cnt++;
+	#ifdef DBG_XMIT_BUF
+	DBG_8192D("DBG_XMIT_BUF FREE no =%d, free_xmit_extbuf_cnt =%d\n", pxmitbuf->no , pxmitpriv->free_xmit_extbuf_cnt);
+	#endif
+
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
+
+	return _SUCCESS;
+}
+
+struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	long unsigned int flags;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	/* DBG_8192D("+rtw_alloc_xmitbuf\n"); */
+
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
+
+	if (_rtw_queue_empty(pfree_xmitbuf_queue) == true) {
+		pxmitbuf = NULL;
+	} else {
+		phead = get_list_head(pfree_xmitbuf_queue);
+
+		plist = phead->next;
+
+		pxmitbuf = container_of(plist, struct xmit_buf, list);
+
+		list_del_init(&(pxmitbuf->list));
+	}
+
+	if (pxmitbuf !=  NULL) {
+		pxmitpriv->free_xmitbuf_cnt--;
+		#ifdef DBG_XMIT_BUF
+		DBG_8192D("DBG_XMIT_BUF ALLOC no =%d,  free_xmitbuf_cnt =%d\n", pxmitbuf->no, pxmitpriv->free_xmitbuf_cnt);
+		#endif
+
+		pxmitbuf->priv_data = NULL;
+
+		if (pxmitbuf->sctx) {
+			DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
+		}
+	}
+	#ifdef DBG_XMIT_BUF
+	else {
+		DBG_8192D("DBG_XMIT_BUF rtw_alloc_xmitbuf return NULL\n");
+	}
+	#endif
+
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
+
+	return pxmitbuf;
+}
+
+s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	long unsigned int flags;
+	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	if (pxmitbuf == NULL)
+		return _FAIL;
+
+	if (pxmitbuf->sctx) {
+		DBG_8192D("%s pxmitbuf->sctx is not NULL\n", __func__);
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);
+	}
+
+	if (pxmitbuf->ext_tag) {
+		rtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);
+	} else {
+		spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
+
+		list_del_init(&pxmitbuf->list);
+
+		rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+
+		pxmitpriv->free_xmitbuf_cnt++;
+		/* DBG_8192D("FREE, free_xmitbuf_cnt =%d\n", pxmitpriv->free_xmitbuf_cnt); */
+		#ifdef DBG_XMIT_BUF
+		DBG_8192D("DBG_XMIT_BUF FREE no =%d, free_xmitbuf_cnt =%d\n", pxmitbuf->no , pxmitpriv->free_xmitbuf_cnt);
+		#endif
+		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
+	}
+
+	return _SUCCESS;
+}
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+
+struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect
+		pfree_xmit_queue
+	*/
+
+	struct xmit_frame *pxframe = NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+	struct rtw_adapter *padapter = pxmitpriv->adapter;
+
+	spin_lock_bh(&pfree_xmit_queue->lock);
+
+	if (_rtw_queue_empty(pfree_xmit_queue) == true) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe:%d\n", pxmitpriv->free_xmitframe_cnt));
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+
+		plist = phead->next;
+
+		pxframe = container_of(plist, struct xmit_frame, list);
+
+		list_del_init(&(pxframe->list));
+	}
+
+	if (pxframe !=  NULL) {
+		pxmitpriv->free_xmitframe_cnt--;
+
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_alloc_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt));
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		memset(&pxframe->attrib, 0, sizeof(struct pkt_attrib));
+		/* pxframe->attrib.psta = NULL; */
+
+		pxframe->frame_tag = DATA_FRAMETAG;
+
+		pxframe->pkt = NULL;
+		pxframe->pkt_offset = 1;/* default use pkt_offset to fill tx desc */
+
+		pxframe->agg_num = 1;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
+		if (pxmitpriv->free_xmitframe_cnt == 1) {
+			if (!rtw_netif_queue_stopped(padapter->pnetdev))
+				rtw_netif_stop_queue(padapter->pnetdev);
+		}
+#endif
+		pxframe->ack_report = 0;
+	}
+	spin_unlock_bh(&pfree_xmit_queue->lock);
+
+	return pxframe;
+}
+
+s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{
+	struct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+	struct rtw_adapter *padapter = pxmitpriv->adapter;
+	struct sk_buff *pndis_pkt = NULL;
+
+	if (pxmitframe == NULL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("====== rtw_free_xmitframe():pxmitframe == NULL!!!!!!!!!!\n"));
+		goto exit;
+	}
+
+	spin_lock_bh(&pfree_xmit_queue->lock);
+
+	list_del_init(&pxmitframe->list);
+
+	if (pxmitframe->pkt) {
+		pndis_pkt = pxmitframe->pkt;
+		pxmitframe->pkt = NULL;
+	}
+
+	rtw_list_insert_tail(&pxmitframe->list, get_list_head(pfree_xmit_queue));
+
+	pxmitpriv->free_xmitframe_cnt++;
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_debug_, ("rtw_free_xmitframe():free_xmitframe_cnt =%d\n", pxmitpriv->free_xmitframe_cnt));
+
+	spin_unlock_bh(&pfree_xmit_queue->lock);
+
+	if (pndis_pkt)
+		rtw_os_pkt_complete(padapter, pndis_pkt);
+
+exit:
+
+	return _SUCCESS;
+}
+
+void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue)
+{
+	struct list_head *plist, *phead;
+	struct	xmit_frame	*pxmitframe;
+
+	spin_lock_bh(&(pframequeue->lock));
+
+	phead = get_list_head(pframequeue);
+	plist = phead->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pxmitframe = container_of(plist, struct xmit_frame, list);
+		plist = plist->next;
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	}
+	spin_unlock_bh(&(pframequeue->lock));
+
+}
+
+s32 rtw_xmitframe_enqueue(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (rtw_xmit_classifier(padapter, pxmitframe) == _FAIL) {
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
+			 ("rtw_xmitframe_enqueue: drop xmit pkt for classifier fail\n"));
+		return _FAIL;
+	}
+
+	return _SUCCESS;
+}
+
+static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv,
+						struct hw_xmit *phwxmit,
+						struct tx_servq *ptxservq,
+						struct __queue *pframe_queue)
+{
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame	*pxmitframe = NULL;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = xmitframe_phead->next;
+
+	if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = xmitframe_plist->next;
+
+		list_del_init(&pxmitframe->list);
+
+		ptxservq->qcnt--;
+	}
+	return pxmitframe;
+}
+
+struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry)
+{
+	struct list_head *sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	struct __queue *pframe_queue = NULL;
+	struct xmit_frame *pxmitframe = NULL;
+	struct rtw_adapter *padapter = pxmitpriv->adapter;
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	int i, inx[4];
+
+	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
+
+	if (pregpriv->wifi_spec == 1) {
+		int j, tmp, acirp_cnt[4];
+		/* entry indx: 0->vo, 1->vi, 2->be, 3->bk. */
+		acirp_cnt[0] = pxmitpriv->voq_cnt;
+		acirp_cnt[1] = pxmitpriv->viq_cnt;
+		acirp_cnt[2] = pxmitpriv->beq_cnt;
+		acirp_cnt[3] = pxmitpriv->bkq_cnt;
+
+		for (i = 0; i < 4; i++) {
+			for (j = i+1; j < 4; j++) {
+				if (acirp_cnt[j] < acirp_cnt[i]) {
+					tmp = acirp_cnt[i];
+					acirp_cnt[i] = acirp_cnt[j];
+					acirp_cnt[j] = tmp;
+
+					tmp = inx[i];
+					inx[i] = inx[j];
+					inx[j] = tmp;
+				}
+			}
+		}
+	}
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	for (i = 0; i < entry; i++) {
+		phwxmit = phwxmit_i + inx[i];
+
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = sta_phead->next;
+
+		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false) {
+			ptxservq = container_of(sta_plist, struct tx_servq, tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+
+			if (pxmitframe) {
+				phwxmit->accnt--;
+
+				/* Remove sta node when there is no pending packets. */
+				if (_rtw_queue_empty(pframe_queue)) /* must be done after and before break */
+					list_del_init((&ptxservq->tx_pending)->next);
+				goto exit;
+			}
+			sta_plist = sta_plist->next;
+		}
+	}
+
+exit:
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	return pxmitframe;
+}
+
+struct tx_servq *rtw_get_sta_pending(struct rtw_adapter *padapter, struct sta_info *psta, int up, u8 *ac)
+{
+	struct tx_servq *ptxservq;
+
+	switch (up) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		*(ac) = 3;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BK\n"));
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		*(ac) = 1;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VI\n"));
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		*(ac) = 0;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : VO\n"));
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+		*(ac) = 2;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_get_sta_pending : BE\n"));
+	break;
+	}
+
+	return ptxservq;
+}
+
+/*
+ * Will enqueue pxmitframe to the proper queue,
+ * and indicate it to xx_pending list.....
+ */
+s32 rtw_xmit_classifier(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	u8	ac_index;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct sta_priv	*pstapriv = &padapter->stapriv;
+	struct hw_xmit	*phwxmits =  padapter->xmitpriv.hwxmits;
+	int res = _SUCCESS;
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+
+	if (psta == NULL) {
+		res = _FAIL;
+		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("rtw_xmit_classifier: psta == NULL\n"));
+		goto exit;
+	}
+
+	ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
+
+	if (rtw_is_list_empty(&ptxservq->tx_pending)) {
+		rtw_list_insert_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));
+	}
+
+	rtw_list_insert_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
+	ptxservq->qcnt++;
+	phwxmits[ac_index].accnt++;
+
+exit:
+
+	return res;
+}
+
+void rtw_alloc_hwxmits(struct rtw_adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pxmitpriv->hwxmit_entry = HWXMIT_ENTRY;
+
+	pxmitpriv->hwxmits = (struct hw_xmit *)kzalloc(sizeof(struct hw_xmit) * pxmitpriv->hwxmit_entry, GFP_KERNEL);
+
+	hwxmits = pxmitpriv->hwxmits;
+
+	if (pxmitpriv->hwxmit_entry == 5) {
+		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
+		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
+		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
+	} else if (pxmitpriv->hwxmit_entry == 4) {
+		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
+		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
+		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
+		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
+	}
+}
+
+void rtw_free_hwxmits(struct rtw_adapter *padapter)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	hwxmits = pxmitpriv->hwxmits;
+	kfree(hwxmits);
+}
+
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, int entry)
+{
+	int i;
+
+	for (i = 0; i < entry; i++, phwxmit++)
+		phwxmit->accnt = 0;
+
+}
+
+static void do_queue_select(struct rtw_adapter	*padapter, struct pkt_attrib *pattrib)
+{
+	u8 qsel;
+
+	qsel = pattrib->priority;
+	RT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("### do_queue_select priority =%d , qsel = %d\n", pattrib->priority , qsel));
+
+	pattrib->qsel = qsel;
+}
+
+/*
+ * The main transmit(tx) entry
+ *
+ * Return
+ *	1	enqueue
+ *	0	success, hardware will handle this xmit frame(packet)
+ *	<0	fail
+ */
+s32 rtw_xmit(struct rtw_adapter *padapter, struct sk_buff **ppkt)
+{
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct xmit_frame *pxmitframe = NULL;
+	s32 res;
+
+	pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
+	if (pxmitframe == NULL) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: no more pxmitframe\n"));
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_8192D("DBG_TX_DROP_FRAME %s no more pxmitframe\n", __func__);
+		#endif
+		return -1;
+	}
+
+	res = update_attrib(padapter, *ppkt, &pxmitframe->attrib);
+	if (res == _FAIL) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit: update attrib fail\n"));
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_8192D("DBG_TX_DROP_FRAME %s update attrib fail\n", __func__);
+		#endif
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+		return -1;
+	}
+	pxmitframe->pkt = *ppkt;
+
+	rtw_led_control(padapter, LED_CTL_TX);
+
+	do_queue_select(padapter, &pxmitframe->attrib);
+
+#if defined(CONFIG_92D_AP_MODE)
+	spin_lock_bh(&pxmitpriv->lock);
+	if (xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe) == true) {
+		spin_unlock_bh(&pxmitpriv->lock);
+		return 1;
+	}
+	spin_unlock_bh(&pxmitpriv->lock);
+#endif
+
+	if (rtw_hal_xmit(padapter, pxmitframe) == false)
+		return 1;
+	return 0;
+}
+
+#if defined(CONFIG_92D_AP_MODE)
+
+int xmitframe_enqueue_for_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	int ret = false;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	int bmcst = IS_MCAST(pattrib->ra);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
+	    return ret;
+
+	if (pattrib->psta)
+		psta = pattrib->psta;
+	else
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+
+	if (psta == NULL)
+		return ret;
+
+	if (pattrib->triggered == 1) {
+		if (bmcst)
+			pattrib->qsel = 0x11;/* HIQ */
+		return ret;
+	}
+	if (bmcst) {
+		spin_lock_bh(&psta->sleep_q.lock);
+
+		if (pstapriv->sta_dz_bitmap) {/* if anyone sta is in ps mode */
+			list_del_init(&pxmitframe->list);
+
+			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+
+			psta->sleepq_len++;
+
+			pstapriv->tim_bitmap |= BIT(0);/*  */
+			pstapriv->sta_dz_bitmap |= BIT(0);
+
+			update_beacon(padapter, _TIM_IE_, NULL, false);/* tx bc/mc packets after upate bcn */
+
+			ret = true;
+		}
+		spin_unlock_bh(&psta->sleep_q.lock);
+		return ret;
+	}
+	spin_lock_bh(&psta->sleep_q.lock);
+	if (psta->state&WIFI_SLEEP_STATE) {
+		u8 wmmps_ac = 0;
+
+		if (pstapriv->sta_dz_bitmap&BIT(psta->aid)) {
+			list_del_init(&pxmitframe->list);
+
+			rtw_list_insert_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+
+			psta->sleepq_len++;
+
+			switch (pattrib->priority) {
+			case 1:
+			case 2:
+				wmmps_ac = psta->uapsd_bk&BIT(0);
+				break;
+			case 4:
+			case 5:
+				wmmps_ac = psta->uapsd_vi&BIT(0);
+				break;
+			case 6:
+			case 7:
+				wmmps_ac = psta->uapsd_vo&BIT(0);
+				break;
+			case 0:
+			case 3:
+			default:
+				wmmps_ac = psta->uapsd_be&BIT(0);
+				break;
+			}
+
+			if (wmmps_ac)
+				psta->sleepq_ac_len++;
+
+			if (((psta->has_legacy_ac) && (!wmmps_ac)) || ((!psta->has_legacy_ac) && (wmmps_ac))) {
+				pstapriv->tim_bitmap |= BIT(psta->aid);
+
+				if (psta->sleepq_len == 1)
+					update_beacon(padapter, _TIM_IE_, NULL, false);
+			}
+
+			ret = true;
+		}
+	}
+	spin_unlock_bh(&psta->sleep_q.lock);
+	return ret;
+}
+
+static void dequeue_xmitframes_to_sleeping_queue(struct rtw_adapter *padapter, struct sta_info *psta, struct __queue *pframequeue)
+{
+	struct list_head *plist, *phead;
+	u8	ac_index;
+	struct tx_servq	*ptxservq;
+	struct pkt_attrib	*pattrib;
+	struct xmit_frame	*pxmitframe;
+	struct hw_xmit *phwxmits =  padapter->xmitpriv.hwxmits;
+
+	phead = get_list_head(pframequeue);
+	plist = phead->next;
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pxmitframe = container_of(plist, struct xmit_frame, list);
+
+		plist = plist->next;
+
+		xmitframe_enqueue_for_sleeping_sta(padapter, pxmitframe);
+
+		pattrib = &pxmitframe->attrib;
+
+		ptxservq = rtw_get_sta_pending(padapter, psta, pattrib->priority, (u8 *)(&ac_index));
+
+		ptxservq->qcnt--;
+		phwxmits[ac_index].accnt--;
+	}
+}
+
+void stop_sta_xmit(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	struct sta_info *psta_bmc;
+	struct sta_xmit_priv *pstaxmitpriv;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+
+	/* for BC/MC Frames */
+	psta_bmc = rtw_get_bcmc_stainfo(padapter);
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	psta->state |= WIFI_SLEEP_STATE;
+
+	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vo_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->vi_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta, &pstaxmitpriv->bk_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
+
+	/* for BC/MC Frames */
+	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
+	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+	spin_unlock_bh(&pxmitpriv->lock);
+}
+
+void wakeup_sta_to_xmit(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	u8 update_mask = 0, wmmps_ac = 0;
+	struct sta_info *psta_bmc;
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	spin_lock_bh(&psta->sleep_q.lock);
+
+	xmitframe_phead = get_list_head(&psta->sleep_q);
+	xmitframe_plist = xmitframe_phead->next;
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = xmitframe_plist->next;
+
+		list_del_init(&pxmitframe->list);
+
+		switch (pxmitframe->attrib.priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
+		}
+
+		psta->sleepq_len--;
+		if (psta->sleepq_len > 0)
+			pxmitframe->attrib.mdata = 1;
+		else
+			pxmitframe->attrib.mdata = 0;
+
+		if (wmmps_ac) {
+			psta->sleepq_ac_len--;
+			if (psta->sleepq_ac_len > 0) {
+				pxmitframe->attrib.mdata = 1;
+				pxmitframe->attrib.eosp = 0;
+			} else {
+				pxmitframe->attrib.mdata = 0;
+				pxmitframe->attrib.eosp = 1;
+			}
+		}
+
+		pxmitframe->attrib.triggered = 1;
+
+		spin_unlock_bh(&psta->sleep_q.lock);
+		if (rtw_hal_xmit(padapter, pxmitframe) == true)
+			rtw_os_xmit_complete(padapter, pxmitframe);
+		spin_lock_bh(&psta->sleep_q.lock);
+	}
+	if (psta->sleepq_len == 0) {
+		pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+		update_mask = BIT(0);
+
+		if (psta->state&WIFI_SLEEP_STATE)
+			psta->state ^= WIFI_SLEEP_STATE;
+
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE) {
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+	}
+
+	spin_unlock_bh(&psta->sleep_q.lock);
+
+	/* for BC/MC Frames */
+	psta_bmc = rtw_get_bcmc_stainfo(padapter);
+	if (!psta_bmc)
+		return;
+
+	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0) { /* no any sta in ps mode */
+		spin_lock_bh(&psta_bmc->sleep_q.lock);
+
+		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
+		xmitframe_plist = xmitframe_phead->next;
+
+		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+			pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+			xmitframe_plist = xmitframe_plist->next;
+
+			list_del_init(&pxmitframe->list);
+
+			psta_bmc->sleepq_len--;
+			if (psta_bmc->sleepq_len > 0)
+				pxmitframe->attrib.mdata = 1;
+			else
+				pxmitframe->attrib.mdata = 0;
+			pxmitframe->attrib.triggered = 1;
+			spin_unlock_bh(&psta_bmc->sleep_q.lock);
+			if (rtw_hal_xmit(padapter, pxmitframe) == true)
+				rtw_os_xmit_complete(padapter, pxmitframe);
+			spin_lock_bh(&psta_bmc->sleep_q.lock);
+		}
+		if (psta_bmc->sleepq_len == 0) {
+			pstapriv->tim_bitmap &= ~BIT(0);
+			pstapriv->sta_dz_bitmap &= ~BIT(0);
+			update_mask |= BIT(1);
+		}
+		spin_unlock_bh(&psta_bmc->sleep_q.lock);
+	}
+	if (update_mask)
+		update_beacon(padapter, _TIM_IE_, NULL, false);
+}
+
+void xmit_delivery_enabled_frames(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	u8 wmmps_ac = 0;
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	spin_lock_bh(&psta->sleep_q.lock);
+	xmitframe_phead = get_list_head(&psta->sleep_q);
+	xmitframe_plist = xmitframe_phead->next;
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = xmitframe_plist->next;
+
+		switch (pxmitframe->attrib.priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
+		}
+		if (!wmmps_ac)
+			continue;
+		list_del_init(&pxmitframe->list);
+		psta->sleepq_len--;
+		psta->sleepq_ac_len--;
+		if (psta->sleepq_ac_len > 0) {
+			pxmitframe->attrib.mdata = 1;
+			pxmitframe->attrib.eosp = 0;
+		} else {
+			pxmitframe->attrib.mdata = 0;
+			pxmitframe->attrib.eosp = 1;
+		}
+
+		pxmitframe->attrib.triggered = 1;
+
+		if (rtw_hal_xmit(padapter, pxmitframe) == true)
+			rtw_os_xmit_complete(padapter, pxmitframe);
+
+		if ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {
+			pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+			/* upate BCN for TIM IE */
+			update_beacon(padapter, _TIM_IE_, NULL, false);
+		}
+	}
+	spin_unlock_bh(&psta->sleep_q.lock);
+}
+#endif
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)
+{
+	sctx->timeout_ms = timeout_ms;
+	sctx->submit_time = rtw_get_current_time();
+	init_completion(&sctx->done);
+	sctx->status = RTW_SCTX_SUBMITTED;
+}
+
+int rtw_sctx_wait(struct submit_ctx *sctx)
+{
+	int ret = _FAIL;
+	unsigned long expire;
+	int status = 0;
+
+	expire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;
+	if (!wait_for_completion_timeout(&sctx->done, expire)) {
+		/* timeout, do something?? */
+		status = RTW_SCTX_DONE_TIMEOUT;
+		DBG_8192D("%s timeout\n", __func__);
+	} else {
+		status = sctx->status;
+	}
+
+	if (status == RTW_SCTX_DONE_SUCCESS)
+		ret = _SUCCESS;
+	return ret;
+}
+
+static bool rtw_sctx_chk_waring_status(int status)
+{
+	switch (status) {
+	case RTW_SCTX_DONE_UNKNOWN:
+	case RTW_SCTX_DONE_BUF_ALLOC:
+	case RTW_SCTX_DONE_BUF_FREE:
+	case RTW_SCTX_DONE_DRV_STOP:
+	case RTW_SCTX_DONE_DEV_REMOVE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status)
+{
+	if (*sctx) {
+		if (rtw_sctx_chk_waring_status(status))
+			DBG_8192D("%s status:%d\n", __func__, status);
+		(*sctx)->status = status;
+		complete(&((*sctx)->done));
+		*sctx = NULL;
+	}
+}
+
+void rtw_sctx_done(struct submit_ctx **sctx)
+{
+	rtw_sctx_done_err(sctx, RTW_SCTX_DONE_SUCCESS);
+}
+
+/**
+ * rtw_ack_tx_polling -
+ * @pxmitpriv: xmit_priv to address ack_tx_ops
+ * @timeout_ms: timeout msec
+ *
+ * Init ack_tx_ops and then do c2h_evt_hdl() and polling ack_tx_ops repeatedly
+ * till tx report or timeout
+ * Returns: _SUCCESS if TX report ok, _FAIL for others
+ */
+static int rtw_ack_tx_polling(struct xmit_priv *pxmitpriv, u32 timeout_ms)
+{
+	int ret = _FAIL;
+	struct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;
+	struct rtw_adapter *adapter = container_of(pxmitpriv, struct rtw_adapter, xmitpriv);
+
+	pack_tx_ops->submit_time = rtw_get_current_time();
+	pack_tx_ops->timeout_ms = timeout_ms;
+	pack_tx_ops->status = RTW_SCTX_SUBMITTED;
+
+	do {
+		c2h_evt_hdl(adapter, NULL, rtw_hal_c2h_id_filter_ccx(adapter));
+		if (pack_tx_ops->status != RTW_SCTX_SUBMITTED)
+			break;
+		if (adapter->bDriverStopped) {
+			pack_tx_ops->status = RTW_SCTX_DONE_DRV_STOP;
+			break;
+		}
+		if (adapter->bSurpriseRemoved) {
+			pack_tx_ops->status = RTW_SCTX_DONE_DEV_REMOVE;
+			break;
+		}
+
+		rtw_msleep_os(10);
+	} while (rtw_get_passing_time_ms(pack_tx_ops->submit_time) < timeout_ms);
+
+	if (pack_tx_ops->status == RTW_SCTX_SUBMITTED) {
+		pack_tx_ops->status = RTW_SCTX_DONE_TIMEOUT;
+		DBG_8192D("%s timeout\n", __func__);
+	}
+
+	if (pack_tx_ops->status == RTW_SCTX_DONE_SUCCESS)
+		ret = _SUCCESS;
+
+	return ret;
+}
+
+int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms)
+{
+	return rtw_ack_tx_polling(pxmitpriv, timeout_ms);
+}
+
+void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status)
+{
+	struct submit_ctx *pack_tx_ops = &pxmitpriv->ack_tx_ops;
+
+	if (pxmitpriv->ack_tx)
+		rtw_sctx_done_err(&pack_tx_ops, status);
+	else
+		DBG_8192D("%s ack_tx not set\n", __func__);
+}
diff --git a/drivers/net/wireless/rtl8192du/dkms.conf b/drivers/net/wireless/rtl8192du/dkms.conf
new file mode 100644
index 0000000..52ed9c6
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/dkms.conf
@@ -0,0 +1,7 @@
+MAKE="'make'"
+BUILT_MODULE_NAME=8192du
+BUILD_MODULE_NAME=8192du
+DEST_MODULE_LOCATION=/kernel/drivers/net/wireless/
+PACKAGE_NAME=8192du
+PACKAGE_VERSION=1.0
+REMAKE_INITRD=yes
diff --git a/drivers/net/wireless/rtl8192du/hal/hal8192duhwimg.c b/drivers/net/wireless/rtl8192du/hal/hal8192duhwimg.c
new file mode 100644
index 0000000..3efdbf3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/hal8192duhwimg.c
@@ -0,0 +1,1725 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*Created on  2011/11/11,  8: 8*/
+	
+#include <hal8192duhwimg.h>
+	
+const u8 Rtl8192DUFwMainArray[Rtl8192DUMainArrayLength] = {
+	0x0,
+};
+	
+const u8 Rtl8192DUFwDataArray[Rtl8192DUDataArrayLength] = {
+	0x0,
+};
+	
+const u32 Rtl8192DUPHY_REG_2TArray[Rtl8192DUPHY_REG_2TArrayLength] = {
+	0x800, 0x80040002,
+	0x804, 0x00000003,
+	0x808, 0x0000fc00,
+	0x80c, 0x0000000a,
+	0x810, 0x10001331,
+	0x814, 0x020c3d10,
+	0x818, 0x02200385,
+	0x81c, 0x00000000,
+	0x820, 0x01000100,
+	0x824, 0x00390004,
+	0x828, 0x01000100,
+	0x82c, 0x00390004,
+	0x830, 0x27272727,
+	0x834, 0x27272727,
+	0x838, 0x27272727,
+	0x83c, 0x27272727,
+	0x840, 0x00010000,
+	0x844, 0x00010000,
+	0x848, 0x27272727,
+	0x84c, 0x27272727,
+	0x850, 0x00000000,
+	0x854, 0x00000000,
+	0x858, 0x569a569a,
+	0x85c, 0x0c1b25a4,
+	0x860, 0x66e60250,
+	0x864, 0x061f0150,
+	0x868, 0x27272727,
+	0x86c, 0x272b2b2b,
+	0x870, 0x07000700,
+	0x874, 0x22188000,
+	0x878, 0x08080808,
+	0x87c, 0x0001fff8,
+	0x880, 0xc0083070,
+	0x884, 0x00000cd5,
+	0x888, 0x00000000,
+	0x88c, 0xcc0000c0,
+	0x890, 0x00000800,
+	0x894, 0xfffffffe,
+	0x898, 0x40302010,
+	0x89c, 0x00706050,
+	0x900, 0x00000000,
+	0x904, 0x00000023,
+	0x908, 0x00000000,
+	0x90c, 0x81121313,
+	0xa00, 0x00d047c8,
+	0xa04, 0x80ff000c,
+	0xa08, 0x8c8a8300,
+	0xa0c, 0x2e68120f,
+	0xa10, 0x9500bb78,
+	0xa14, 0x11144028,
+	0xa18, 0x00881117,
+	0xa1c, 0x89140f00,
+	0xa20, 0x1a1b0000,
+	0xa24, 0x090e1317,
+	0xa28, 0x00000204,
+	0xa2c, 0x00d30000,
+	0xa70, 0x101fff00,
+	0xa74, 0x00000007,
+	0xc00, 0x40071d40,
+	0xc04, 0x03a05633,
+	0xc08, 0x001000e4,
+	0xc0c, 0x6c6c6c6c,
+	0xc10, 0x08800000,
+	0xc14, 0x40000100,
+	0xc18, 0x08800000,
+	0xc1c, 0x40000100,
+	0xc20, 0x00000000,
+	0xc24, 0x00000000,
+	0xc28, 0x00000000,
+	0xc2c, 0x00000000,
+	0xc30, 0x69e9ac44,
+	0xc34, 0x469652af,
+	0xc38, 0x49795994,
+	0xc3c, 0x0a979718,
+	0xc40, 0x1f7c403f,
+	0xc44, 0x000100b7,
+	0xc48, 0xec020107,
+	0xc4c, 0x007f037f,
+	0xc50, 0x69543420,
+	0xc54, 0x43bc009e,
+	0xc58, 0x69543420,
+	0xc5c, 0x433c00a8,
+	0xc60, 0x00000000,
+	0xc64, 0x7112848b,
+	0xc68, 0x47c00bff,
+	0xc6c, 0x00000036,
+	0xc70, 0x2c7f000d,
+	0xc74, 0x258610db,
+	0xc78, 0x0000001f,
+	0xc7c, 0x40b95612,
+	0xc80, 0x40000100,
+	0xc84, 0x20f60000,
+	0xc88, 0x40000100,
+	0xc8c, 0xa0e40000,
+	0xc90, 0x00121820,
+	0xc94, 0x00000007,
+	0xc98, 0x00121820,
+	0xc9c, 0x00007f7f,
+	0xca0, 0x00000000,
+	0xca4, 0x00000080,
+	0xca8, 0x00000000,
+	0xcac, 0x00000000,
+	0xcb0, 0x00000000,
+	0xcb4, 0x00000000,
+	0xcb8, 0x00000000,
+	0xcbc, 0x28000000,
+	0xcc0, 0x00000000,
+	0xcc4, 0x00000000,
+	0xcc8, 0x00000000,
+	0xccc, 0x00000000,
+	0xcd0, 0x00000000,
+	0xcd4, 0x00000000,
+	0xcd8, 0x64b11e20,
+	0xcdc, 0xe0767533,
+	0xce0, 0x00222222,
+	0xce4, 0x00000000,
+	0xce8, 0x37644302,
+	0xcec, 0x2f97d40c,
+	0xd00, 0x00080740,
+	0xd04, 0x00020403,
+	0xd08, 0x0000907f,
+	0xd0c, 0x20010201,
+	0xd10, 0xa0633333,
+	0xd14, 0x3333bc43,
+	0xd18, 0x7a8f5b6b,
+	0xd2c, 0xcc979975,
+	0xd30, 0x00000000,
+	0xd34, 0x80608404,
+	0xd38, 0x00000000,
+	0xd3c, 0x00027353,
+	0xd40, 0x00000000,
+	0xd44, 0x00000000,
+	0xd48, 0x00000000,
+	0xd4c, 0x00000000,
+	0xd50, 0x6437140a,
+	0xd54, 0x00000000,
+	0xd58, 0x00000000,
+	0xd5c, 0x30032064,
+	0xd60, 0x4653de68,
+	0xd64, 0x04518a3c,
+	0xd68, 0x00002101,
+	0xd6c, 0x2a201c16,
+	0xd70, 0x1812362e,
+	0xd74, 0x322c2220,
+	0xd78, 0x000e3c24,
+	0xe00, 0x2a2a2a2a,
+	0xe04, 0x2a2a2a2a,
+	0xe08, 0x03902a2a,
+	0xe10, 0x2a2a2a2a,
+	0xe14, 0x2a2a2a2a,
+	0xe18, 0x2a2a2a2a,
+	0xe1c, 0x2a2a2a2a,
+	0xe28, 0x00000000,
+	0xe30, 0x1000dc1f,
+	0xe34, 0x10008c1f,
+	0xe38, 0x02140102,
+	0xe3c, 0x681604c2,
+	0xe40, 0x01007c00,
+	0xe44, 0x01004800,
+	0xe48, 0xfb000000,
+	0xe4c, 0x000028d1,
+	0xe50, 0x1000dc1f,
+	0xe54, 0x10008c1f,
+	0xe58, 0x02140102,
+	0xe5c, 0x28160d05,
+	0xe60, 0x00000010,
+	0xe68, 0x001b25a4,
+	0xe6c, 0x63db25a4,
+	0xe70, 0x63db25a4,
+	0xe74, 0x0c126da4,
+	0xe78, 0x0c126da4,
+	0xe7c, 0x0c126da4,
+	0xe80, 0x0c126da4,
+	0xe84, 0x63db25a4,
+	0xe88, 0x0c126da4,
+	0xe8c, 0x63db25a4,
+	0xed0, 0x63db25a4,
+	0xed4, 0x63db25a4,
+	0xed8, 0x63db25a4,
+	0xedc, 0x001b25a4,
+	0xee0, 0x001b25a4,
+	0xeec, 0x6fdb25a4,
+	0xf14, 0x00000003,
+	0xf1c, 0x00000064,
+	0xf4c, 0x00000004,
+	0xf00, 0x00000300,
+};
+	
+const u32 Rtl8192DUPHY_REG_1TArray[Rtl8192DUPHY_REG_1TArrayLength] = {
+	0x0,
+};
+	
+const u32 Rtl8192DUPHY_REG_Array_PG[Rtl8192DUPHY_REG_Array_PGLength] = {
+	0xe00, 0xffffffff, 0x07090c0c,
+	0xe04, 0xffffffff, 0x01020405,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x0b0c0c0e,
+	0xe14, 0xffffffff, 0x01030506,
+	0xe18, 0xffffffff, 0x0b0c0d0e,
+	0xe1c, 0xffffffff, 0x01030509,
+	0x830, 0xffffffff, 0x07090c0c,
+	0x834, 0xffffffff, 0x01020405,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x0b0c0c0e,
+	0x848, 0xffffffff, 0x01030506,
+	0x84c, 0xffffffff, 0x0b0c0d0e,
+	0x868, 0xffffffff, 0x01030509,
+	0xe00, 0xffffffff, 0x00000000,
+	0xe04, 0xffffffff, 0x00000000,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x00000000,
+	0xe14, 0xffffffff, 0x00000000,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x00000000,
+	0x834, 0xffffffff, 0x00000000,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x00000000,
+	0x848, 0xffffffff, 0x00000000,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x06060606,
+	0xe14, 0xffffffff, 0x00020406,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x06060606,
+	0x848, 0xffffffff, 0x00020406,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x00000000,
+	0xe04, 0xffffffff, 0x00000000,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x00000000,
+	0xe14, 0xffffffff, 0x00000000,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x00000000,
+	0x834, 0xffffffff, 0x00000000,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x00000000,
+	0x848, 0xffffffff, 0x00000000,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x00000000,
+	0xe04, 0xffffffff, 0x00000000,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x00000000,
+	0xe14, 0xffffffff, 0x00000000,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x00000000,
+	0x834, 0xffffffff, 0x00000000,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x00000000,
+	0x848, 0xffffffff, 0x00000000,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x00000000,
+	0xe14, 0xffffffff, 0x00000000,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x00000000,
+	0x848, 0xffffffff, 0x00000000,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x00000000,
+	0xe04, 0xffffffff, 0x00000000,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x00000000,
+	0xe14, 0xffffffff, 0x00000000,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x00000000,
+	0x834, 0xffffffff, 0x00000000,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x00000000,
+	0x848, 0xffffffff, 0x00000000,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+	0xe00, 0xffffffff, 0x04040404,
+	0xe04, 0xffffffff, 0x00020204,
+	0xe08, 0x0000ff00, 0x00000000,
+	0x86c, 0xffffff00, 0x00000000,
+	0xe10, 0xffffffff, 0x08080808,
+	0xe14, 0xffffffff, 0x00040408,
+	0xe18, 0xffffffff, 0x00000000,
+	0xe1c, 0xffffffff, 0x00000000,
+	0x830, 0xffffffff, 0x04040404,
+	0x834, 0xffffffff, 0x00020204,
+	0x838, 0xffffff00, 0x00000000,
+	0x86c, 0x000000ff, 0x00000000,
+	0x83c, 0xffffffff, 0x08080808,
+	0x848, 0xffffffff, 0x00040408,
+	0x84c, 0xffffffff, 0x00000000,
+	0x868, 0xffffffff, 0x00000000,
+};
+	
+const u32 Rtl8192DUPHY_REG_Array_MP[Rtl8192DUPHY_REG_Array_MPLength] = {
+	0xc64, 0x5116848b,
+	0xc30, 0x69e9ac4a,
+	0xd04, 0x80020403,
+	0xd14, 0x3333bc53,
+	0x840, 0x03cff456,
+	0x844, 0x03cff456,
+	0xc04, 0x03a07633,
+};
+	
+const u32 Rtl8192DURadioA_2TArray[Rtl8192DURadioA_2TArrayLength] = {
+	0x000, 0x00030000,
+	0x001, 0x00030000,
+	0x002, 0x00000000,
+	0x003, 0x00018c63,
+	0x004, 0x00018c63,
+	0x008, 0x00084000,
+	0x00b, 0x0001c000,
+	0x00e, 0x00018c67,
+	0x00f, 0x00000851,
+	0x014, 0x00021440,
+	0x018, 0x00017524,
+	0x019, 0x00000000,
+	0x01d, 0x000a1290,
+	0x023, 0x00001558,
+	0x01a, 0x00030a99,
+	0x01b, 0x00040b00,
+	0x01c, 0x000fc339,
+	0x03a, 0x000a57eb,
+	0x03b, 0x00020000,
+	0x03c, 0x000ff454,
+	0x020, 0x0000aa52,
+	0x021, 0x00054000,
+	0x040, 0x0000aa52,
+	0x041, 0x00014000,
+	0x025, 0x000803be,
+	0x026, 0x000fc638,
+	0x027, 0x00077c18,
+	0x028, 0x000de471,
+	0x029, 0x000d7110,
+	0x02a, 0x0008cb04,
+	0x02b, 0x0004128b,
+	0x02c, 0x00001840,
+	0x043, 0x0002444f,
+	0x044, 0x0001adb0,
+	0x045, 0x00056467,
+	0x046, 0x0008992c,
+	0x047, 0x0000452c,
+	0x048, 0x000f9c43,
+	0x049, 0x00002e0c,
+	0x04a, 0x000546eb,
+	0x04b, 0x0008966c,
+	0x04c, 0x0000dde9,
+	0x018, 0x00007401,
+	0x000, 0x00070000,
+	0x012, 0x000dc000,
+	0x012, 0x00090000,
+	0x012, 0x00051000,
+	0x012, 0x00012000,
+	0x013, 0x000287b7,
+	0x013, 0x000247ab,
+	0x013, 0x0002079f,
+	0x013, 0x0001c793,
+	0x013, 0x0001839b,
+	0x013, 0x00014392,
+	0x013, 0x0001019a,
+	0x013, 0x0000c191,
+	0x013, 0x00008194,
+	0x013, 0x000040a0,
+	0x013, 0x00000018,
+	0x015, 0x0000f424,
+	0x015, 0x0004f424,
+	0x015, 0x0008f424,
+	0x016, 0x000e1330,
+	0x016, 0x000a1330,
+	0x016, 0x00061330,
+	0x016, 0x00021330,
+	0x018, 0x00017524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x018, 0x00037524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x018, 0x00057568,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x030, 0x0004470f,
+	0x031, 0x00044ff0,
+	0x032, 0x00000070,
+	0x033, 0x000dd480,
+	0x034, 0x000ffac0,
+	0x035, 0x000b80c0,
+	0x036, 0x00077000,
+	0x037, 0x00064ff2,
+	0x038, 0x000e7661,
+	0x039, 0x00000e90,
+	0x000, 0x00030000,
+	0x018, 0x0000f401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088009,
+	0x01f, 0x00080003,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088001,
+	0x01f, 0x00080000,
+	0x0fe, 0x00000000,
+	0x018, 0x00097524,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x02b, 0x00041289,
+	0x0fe, 0x00000000,
+	0x02d, 0x0006aaaa,
+	0x02e, 0x000b4d01,
+	0x02d, 0x00080000,
+	0x02e, 0x00004d02,
+	0x02d, 0x00095555,
+	0x02e, 0x00054d03,
+	0x02d, 0x000aaaaa,
+	0x02e, 0x000b4d04,
+	0x02d, 0x000c0000,
+	0x02e, 0x00004d05,
+	0x02d, 0x000d5555,
+	0x02e, 0x00054d06,
+	0x02d, 0x000eaaaa,
+	0x02e, 0x000b4d07,
+	0x02d, 0x00000000,
+	0x02e, 0x00005108,
+	0x02d, 0x00015555,
+	0x02e, 0x00055109,
+	0x02d, 0x0002aaaa,
+	0x02e, 0x000b510a,
+	0x02d, 0x00040000,
+	0x02e, 0x0000510b,
+	0x02d, 0x00055555,
+	0x02e, 0x0005510c,
+};
+	
+const u32 Rtl8192DURadioB_2TArray[Rtl8192DURadioB_2TArrayLength] = {
+	0x000, 0x00030000,
+	0x001, 0x00030000,
+	0x002, 0x00000000,
+	0x003, 0x00018c63,
+	0x004, 0x00018c63,
+	0x008, 0x00084000,
+	0x00b, 0x0001c000,
+	0x00e, 0x00018c67,
+	0x00f, 0x00000851,
+	0x014, 0x00021440,
+	0x018, 0x00007401,
+	0x019, 0x00000060,
+	0x01d, 0x000a1290,
+	0x023, 0x00001558,
+	0x01a, 0x00030a99,
+	0x01b, 0x00040b00,
+	0x01c, 0x000fc339,
+	0x03a, 0x000a57eb,
+	0x03b, 0x00020000,
+	0x03c, 0x000ff454,
+	0x020, 0x0000aa52,
+	0x021, 0x00054000,
+	0x040, 0x0000aa52,
+	0x041, 0x00014000,
+	0x025, 0x000803be,
+	0x026, 0x000fc638,
+	0x027, 0x00077c18,
+	0x028, 0x000d1c31,
+	0x029, 0x000d7110,
+	0x02a, 0x000aeb04,
+	0x02b, 0x0004128b,
+	0x02c, 0x00001840,
+	0x043, 0x0002444f,
+	0x044, 0x0001adb0,
+	0x045, 0x00056467,
+	0x046, 0x0008992c,
+	0x047, 0x0000452c,
+	0x048, 0x000f9c43,
+	0x049, 0x00002e0c,
+	0x04a, 0x000546eb,
+	0x04b, 0x0008966c,
+	0x04c, 0x0000dde9,
+	0x018, 0x00007401,
+	0x000, 0x00070000,
+	0x012, 0x000dc000,
+	0x012, 0x00090000,
+	0x012, 0x00051000,
+	0x012, 0x00012000,
+	0x013, 0x000287b7,
+	0x013, 0x000247ab,
+	0x013, 0x0002079f,
+	0x013, 0x0001c793,
+	0x013, 0x0001839b,
+	0x013, 0x00014392,
+	0x013, 0x0001019a,
+	0x013, 0x0000c191,
+	0x013, 0x00008194,
+	0x013, 0x000040a0,
+	0x013, 0x00000018,
+	0x015, 0x0000f424,
+	0x015, 0x0004f424,
+	0x015, 0x0008f424,
+	0x016, 0x000e1330,
+	0x016, 0x000a1330,
+	0x016, 0x00061330,
+	0x016, 0x00021330,
+	0x018, 0x00017524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x018, 0x00037524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x018, 0x00057524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bc,
+	0x013, 0x000247b0,
+	0x013, 0x000203b4,
+	0x013, 0x0001c3a8,
+	0x013, 0x000181b4,
+	0x013, 0x000141a8,
+	0x013, 0x000100b4,
+	0x013, 0x0000c0a8,
+	0x013, 0x0000b030,
+	0x013, 0x00004024,
+	0x013, 0x00000018,
+	0x015, 0x0000f4c3,
+	0x015, 0x0004f4c3,
+	0x015, 0x0008f4c3,
+	0x016, 0x000e085f,
+	0x016, 0x000a085f,
+	0x016, 0x0006085f,
+	0x016, 0x0002085f,
+	0x030, 0x0004470f,
+	0x031, 0x00044ff0,
+	0x032, 0x00000070,
+	0x033, 0x000dd480,
+	0x034, 0x000ffac0,
+	0x035, 0x000b80c0,
+	0x036, 0x00077000,
+	0x037, 0x00064ff2,
+	0x038, 0x000e7661,
+	0x039, 0x00000e90,
+	0x000, 0x00030000,
+	0x018, 0x0000f401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088009,
+	0x01f, 0x00080003,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088001,
+	0x01f, 0x00080000,
+	0x0fe, 0x00000000,
+	0x018, 0x00087401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x02b, 0x00041289,
+	0x0fe, 0x00000000,
+	0x02d, 0x00066666,
+	0x02e, 0x00064001,
+	0x02d, 0x00091111,
+	0x02e, 0x00014002,
+	0x02d, 0x000bbbbb,
+	0x02e, 0x000b4003,
+	0x02d, 0x000e6666,
+	0x02e, 0x00064004,
+	0x02d, 0x00088888,
+	0x02e, 0x00084005,
+	0x02d, 0x0009dddd,
+	0x02e, 0x000d4006,
+	0x02d, 0x000b3333,
+	0x02e, 0x00034007,
+	0x02d, 0x00048888,
+	0x02e, 0x00084408,
+	0x02d, 0x000bbbbb,
+	0x02e, 0x000b4409,
+	0x02d, 0x000e6666,
+	0x02e, 0x0006440a,
+	0x02d, 0x00011111,
+	0x02e, 0x0001480b,
+	0x02d, 0x0003bbbb,
+	0x02e, 0x000b480c,
+	0x02d, 0x00066666,
+	0x02e, 0x0006480d,
+	0x02d, 0x000ccccc,
+	0x02e, 0x000c480e,
+};
+	
+const u32 Rtl8192DURadioA_1TArray[Rtl8192DURadioA_1TArrayLength] = {
+	0x0,
+};
+	
+const u32 Rtl8192DURadioB_1TArray[Rtl8192DURadioB_1TArrayLength] = {
+	0x0,
+};
+	
+const u32 Rtl8192DURadioA_2T_intPAArray[Rtl8192DURadioA_2T_intPAArrayLength] = {
+	0x000, 0x00030000,
+	0x001, 0x00030000,
+	0x002, 0x00000000,
+	0x003, 0x00018c63,
+	0x004, 0x00018c63,
+	0x008, 0x00084000,
+	0x00b, 0x0001c000,
+	0x00e, 0x00018c67,
+	0x00f, 0x00000851,
+	0x014, 0x00021440,
+	0x018, 0x00017524,
+	0x019, 0x00000000,
+	0x01d, 0x000a1290,
+	0x023, 0x00001558,
+	0x01a, 0x00030a99,
+	0x01b, 0x00040b00,
+	0x01c, 0x000fc339,
+	0x03a, 0x000a57eb,
+	0x03b, 0x00020000,
+	0x03c, 0x000ff455,
+	0x020, 0x0000aa52,
+	0x021, 0x00054000,
+	0x040, 0x0000aa52,
+	0x041, 0x00014000,
+	0x025, 0x000803be,
+	0x026, 0x000fc638,
+	0x027, 0x00077c18,
+	0x028, 0x000de471,
+	0x029, 0x000d7110,
+	0x02a, 0x0008eb04,
+	0x02b, 0x0004128b,
+	0x02c, 0x00001840,
+	0x043, 0x0002444f,
+	0x044, 0x0001adb0,
+	0x045, 0x00056467,
+	0x046, 0x0008992c,
+	0x047, 0x0000452c,
+	0x048, 0x000c0443,
+	0x049, 0x00000730,
+	0x04a, 0x00050f0f,
+	0x04b, 0x000896ef,
+	0x04c, 0x0000ddee,
+	0x018, 0x00007401,
+	0x000, 0x00070000,
+	0x012, 0x000dc000,
+	0x012, 0x00090000,
+	0x012, 0x00051000,
+	0x012, 0x00012000,
+	0x013, 0x000287b7,
+	0x013, 0x000247ab,
+	0x013, 0x0002079f,
+	0x013, 0x0001c793,
+	0x013, 0x0001839b,
+	0x013, 0x00014392,
+	0x013, 0x0001019a,
+	0x013, 0x0000c191,
+	0x013, 0x00008194,
+	0x013, 0x000040a0,
+	0x013, 0x00000018,
+	0x015, 0x0000f424,
+	0x015, 0x0004f424,
+	0x015, 0x0008f424,
+	0x016, 0x000e1330,
+	0x016, 0x000a1330,
+	0x016, 0x00061330,
+	0x016, 0x00021330,
+	0x018, 0x00017524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x018, 0x00037564,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x018, 0x00057595,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x030, 0x0004470f,
+	0x031, 0x00044ff0,
+	0x032, 0x00000070,
+	0x033, 0x000dd480,
+	0x034, 0x000ffac0,
+	0x035, 0x000b80c0,
+	0x036, 0x00077000,
+	0x037, 0x00064ff2,
+	0x038, 0x000e7661,
+	0x039, 0x00000e90,
+	0x000, 0x00030000,
+	0x018, 0x0000f401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088009,
+	0x01f, 0x00080003,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088001,
+	0x01f, 0x00080000,
+	0x0fe, 0x00000000,
+	0x018, 0x00097524,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x02b, 0x00041289,
+	0x0fe, 0x00000000,
+	0x02d, 0x0006aaaa,
+	0x02e, 0x000b4d01,
+	0x02d, 0x00080000,
+	0x02e, 0x00004d02,
+	0x02d, 0x00095555,
+	0x02e, 0x00054d03,
+	0x02d, 0x000aaaaa,
+	0x02e, 0x000b4d04,
+	0x02d, 0x000c0000,
+	0x02e, 0x00004d05,
+	0x02d, 0x000d5555,
+	0x02e, 0x00054d06,
+	0x02d, 0x000eaaaa,
+	0x02e, 0x000b4d07,
+	0x02d, 0x00000000,
+	0x02e, 0x00005108,
+	0x02d, 0x00015555,
+	0x02e, 0x00055109,
+	0x02d, 0x0002aaaa,
+	0x02e, 0x000b510a,
+	0x02d, 0x00040000,
+	0x02e, 0x0000510b,
+	0x02d, 0x00055555,
+	0x02e, 0x0005510c,
+};
+	
+const u32 Rtl8192DURadioB_2T_intPAArray[Rtl8192DURadioB_2T_intPAArrayLength] = {
+	0x000, 0x00030000,
+	0x001, 0x00030000,
+	0x002, 0x00000000,
+	0x003, 0x00018c63,
+	0x004, 0x00018c63,
+	0x008, 0x00084000,
+	0x00b, 0x0001c000,
+	0x00e, 0x00018c67,
+	0x00f, 0x00000851,
+	0x014, 0x00021440,
+	0x018, 0x00007401,
+	0x019, 0x00000060,
+	0x01d, 0x000a1290,
+	0x023, 0x00001558,
+	0x01a, 0x00030a99,
+	0x01b, 0x00040b00,
+	0x01c, 0x000fc339,
+	0x03a, 0x000a57eb,
+	0x03b, 0x00020000,
+	0x03c, 0x000ff455,
+	0x020, 0x0000aa52,
+	0x021, 0x00054000,
+	0x040, 0x0000aa52,
+	0x041, 0x00014000,
+	0x025, 0x000803be,
+	0x026, 0x000fc638,
+	0x027, 0x00077c18,
+	0x028, 0x000d1c31,
+	0x029, 0x000d7110,
+	0x02a, 0x000aeb04,
+	0x02b, 0x0004128b,
+	0x02c, 0x00001840,
+	0x043, 0x0002444f,
+	0x044, 0x0001adb0,
+	0x045, 0x00056467,
+	0x046, 0x0008992c,
+	0x047, 0x0000452c,
+	0x048, 0x000c0443,
+	0x049, 0x00000730,
+	0x04a, 0x00050f0f,
+	0x04b, 0x000896ef,
+	0x04c, 0x0000ddee,
+	0x018, 0x00007401,
+	0x000, 0x00070000,
+	0x012, 0x000dc000,
+	0x012, 0x00090000,
+	0x012, 0x00051000,
+	0x012, 0x00012000,
+	0x013, 0x000287b7,
+	0x013, 0x000247ab,
+	0x013, 0x0002079f,
+	0x013, 0x0001c793,
+	0x013, 0x0001839b,
+	0x013, 0x00014392,
+	0x013, 0x0001019a,
+	0x013, 0x0000c191,
+	0x013, 0x00008194,
+	0x013, 0x000040a0,
+	0x013, 0x00000018,
+	0x015, 0x0000f424,
+	0x015, 0x0004f424,
+	0x015, 0x0008f424,
+	0x016, 0x000e1330,
+	0x016, 0x000a1330,
+	0x016, 0x00061330,
+	0x016, 0x00021330,
+	0x018, 0x00017524,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x018, 0x00037564,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x018, 0x00057595,
+	0x000, 0x00070000,
+	0x012, 0x000cf000,
+	0x012, 0x000bc000,
+	0x012, 0x00078000,
+	0x012, 0x00000000,
+	0x013, 0x000287bf,
+	0x013, 0x000247b3,
+	0x013, 0x000207a7,
+	0x013, 0x0001c79b,
+	0x013, 0x0001839f,
+	0x013, 0x00014393,
+	0x013, 0x00010399,
+	0x013, 0x0000c38d,
+	0x013, 0x00008199,
+	0x013, 0x0000418d,
+	0x013, 0x00000099,
+	0x015, 0x0000f495,
+	0x015, 0x0004f495,
+	0x015, 0x0008f495,
+	0x016, 0x000e1874,
+	0x016, 0x000a1874,
+	0x016, 0x00061874,
+	0x016, 0x00021874,
+	0x030, 0x0004470f,
+	0x031, 0x00044ff0,
+	0x032, 0x00000070,
+	0x033, 0x000dd480,
+	0x034, 0x000ffac0,
+	0x035, 0x000b80c0,
+	0x036, 0x00077000,
+	0x037, 0x00064ff2,
+	0x038, 0x000e7661,
+	0x039, 0x00000e90,
+	0x000, 0x00030000,
+	0x018, 0x0000f401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088009,
+	0x01f, 0x00080003,
+	0x0fe, 0x00000000,
+	0x01e, 0x00088001,
+	0x01f, 0x00080000,
+	0x0fe, 0x00000000,
+	0x018, 0x00087401,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x0fe, 0x00000000,
+	0x02b, 0x00041289,
+	0x0fe, 0x00000000,
+	0x02d, 0x00066666,
+	0x02e, 0x00064001,
+	0x02d, 0x00091111,
+	0x02e, 0x00014002,
+	0x02d, 0x000bbbbb,
+	0x02e, 0x000b4003,
+	0x02d, 0x000e6666,
+	0x02e, 0x00064004,
+	0x02d, 0x00088888,
+	0x02e, 0x00084005,
+	0x02d, 0x0009dddd,
+	0x02e, 0x000d4006,
+	0x02d, 0x000b3333,
+	0x02e, 0x00034007,
+	0x02d, 0x00048888,
+	0x02e, 0x00084408,
+	0x02d, 0x000bbbbb,
+	0x02e, 0x000b4409,
+	0x02d, 0x000e6666,
+	0x02e, 0x0006440a,
+	0x02d, 0x00011111,
+	0x02e, 0x0001480b,
+	0x02d, 0x0003bbbb,
+	0x02e, 0x000b480c,
+	0x02d, 0x00066666,
+	0x02e, 0x0006480d,
+	0x02d, 0x000ccccc,
+	0x02e, 0x000c480e,
+};
+	
+const u32 Rtl8192DUMAC_2T_Array[Rtl8192DUMAC_2T_ArrayLength] = {
+	0x420, 0x00000080,
+	0x423, 0x00000000,
+	0x430, 0x00000000,
+	0x431, 0x00000000,
+	0x432, 0x00000000,
+	0x433, 0x00000001,
+	0x434, 0x00000004,
+	0x435, 0x00000005,
+	0x436, 0x00000006,
+	0x437, 0x00000007,
+	0x438, 0x00000000,
+	0x439, 0x00000000,
+	0x43a, 0x00000000,
+	0x43b, 0x00000001,
+	0x43c, 0x00000004,
+	0x43d, 0x00000005,
+	0x43e, 0x00000006,
+	0x43f, 0x00000007,
+	0x440, 0x00000050,
+	0x441, 0x00000001,
+	0x442, 0x00000000,
+	0x444, 0x00000015,
+	0x445, 0x000000f0,
+	0x446, 0x0000000f,
+	0x447, 0x00000000,
+	0x462, 0x00000008,
+	0x463, 0x00000003,
+	0x4c8, 0x000000ff,
+	0x4c9, 0x00000008,
+	0x4cc, 0x000000ff,
+	0x4cd, 0x000000ff,
+	0x4ce, 0x00000001,
+	0x500, 0x00000026,
+	0x501, 0x000000a2,
+	0x502, 0x0000002f,
+	0x503, 0x00000000,
+	0x504, 0x00000028,
+	0x505, 0x000000a3,
+	0x506, 0x0000005e,
+	0x507, 0x00000000,
+	0x508, 0x0000002b,
+	0x509, 0x000000a4,
+	0x50a, 0x0000005e,
+	0x50b, 0x00000000,
+	0x50c, 0x0000004f,
+	0x50d, 0x000000a4,
+	0x50e, 0x00000000,
+	0x50f, 0x00000000,
+	0x512, 0x0000001c,
+	0x514, 0x0000000a,
+	0x515, 0x00000010,
+	0x516, 0x0000000a,
+	0x517, 0x00000010,
+	0x51a, 0x00000016,
+	0x524, 0x0000000f,
+	0x525, 0x0000004f,
+	0x546, 0x00000040,
+	0x547, 0x00000000,
+	0x550, 0x00000010,
+	0x551, 0x00000010,
+	0x559, 0x00000002,
+	0x55a, 0x00000002,
+	0x55d, 0x000000ff,
+	0x605, 0x00000080,
+	0x608, 0x0000000e,
+	0x609, 0x0000002a,
+	0x652, 0x00000020,
+	0x63c, 0x0000000a,
+	0x63d, 0x0000000a,
+	0x63e, 0x0000000e,
+	0x63f, 0x0000000e,
+	0x66e, 0x00000005,
+	0x700, 0x00000021,
+	0x701, 0x00000043,
+	0x702, 0x00000065,
+	0x703, 0x00000087,
+	0x708, 0x00000021,
+	0x709, 0x00000043,
+	0x70a, 0x00000065,
+	0x70b, 0x00000087,
+	0x024, 0x0000000d,
+	0x025, 0x00000080,
+	0x026, 0x00000011,
+	0x027, 0x00000000,
+	0x028, 0x00000083,
+	0x029, 0x000000db,
+	0x02a, 0x000000ff,
+	0x02b, 0x00000000,
+	0x014, 0x00000055,
+	0x015, 0x000000a9,
+	0x016, 0x0000008b,
+	0x017, 0x00000008,
+	0x010, 0x00000003,
+	0x011, 0x0000002b,
+	0x012, 0x00000002,
+	0x013, 0x00000049,
+};
+	
+const u32 Rtl8192DUAGCTAB_Array[Rtl8192DUAGCTAB_ArrayLength] = {
+	0xc78, 0x7b000001,
+	0xc78, 0x7b010001,
+	0xc78, 0x7b020001,
+	0xc78, 0x7b030001,
+	0xc78, 0x7b040001,
+	0xc78, 0x7b050001,
+	0xc78, 0x7b060001,
+	0xc78, 0x7a070001,
+	0xc78, 0x79080001,
+	0xc78, 0x78090001,
+	0xc78, 0x770a0001,
+	0xc78, 0x760b0001,
+	0xc78, 0x750c0001,
+	0xc78, 0x740d0001,
+	0xc78, 0x730e0001,
+	0xc78, 0x720f0001,
+	0xc78, 0x71100001,
+	0xc78, 0x70110001,
+	0xc78, 0x6f120001,
+	0xc78, 0x6e130001,
+	0xc78, 0x6d140001,
+	0xc78, 0x6c150001,
+	0xc78, 0x6b160001,
+	0xc78, 0x6a170001,
+	0xc78, 0x69180001,
+	0xc78, 0x68190001,
+	0xc78, 0x671a0001,
+	0xc78, 0x661b0001,
+	0xc78, 0x651c0001,
+	0xc78, 0x641d0001,
+	0xc78, 0x631e0001,
+	0xc78, 0x621f0001,
+	0xc78, 0x61200001,
+	0xc78, 0x60210001,
+	0xc78, 0x49220001,
+	0xc78, 0x48230001,
+	0xc78, 0x47240001,
+	0xc78, 0x46250001,
+	0xc78, 0x45260001,
+	0xc78, 0x44270001,
+	0xc78, 0x43280001,
+	0xc78, 0x42290001,
+	0xc78, 0x412a0001,
+	0xc78, 0x402b0001,
+	0xc78, 0x262c0001,
+	0xc78, 0x252d0001,
+	0xc78, 0x242e0001,
+	0xc78, 0x232f0001,
+	0xc78, 0x22300001,
+	0xc78, 0x21310001,
+	0xc78, 0x20320001,
+	0xc78, 0x06330001,
+	0xc78, 0x05340001,
+	0xc78, 0x04350001,
+	0xc78, 0x03360001,
+	0xc78, 0x02370001,
+	0xc78, 0x01380001,
+	0xc78, 0x00390001,
+	0xc78, 0x003a0001,
+	0xc78, 0x003b0001,
+	0xc78, 0x003c0001,
+	0xc78, 0x003d0001,
+	0xc78, 0x003e0001,
+	0xc78, 0x003f0001,
+	0xc78, 0x7b400001,
+	0xc78, 0x7b410001,
+	0xc78, 0x7a420001,
+	0xc78, 0x79430001,
+	0xc78, 0x78440001,
+	0xc78, 0x77450001,
+	0xc78, 0x76460001,
+	0xc78, 0x75470001,
+	0xc78, 0x74480001,
+	0xc78, 0x73490001,
+	0xc78, 0x724a0001,
+	0xc78, 0x714b0001,
+	0xc78, 0x704c0001,
+	0xc78, 0x6f4d0001,
+	0xc78, 0x6e4e0001,
+	0xc78, 0x6d4f0001,
+	0xc78, 0x6c500001,
+	0xc78, 0x6b510001,
+	0xc78, 0x6a520001,
+	0xc78, 0x69530001,
+	0xc78, 0x68540001,
+	0xc78, 0x67550001,
+	0xc78, 0x66560001,
+	0xc78, 0x65570001,
+	0xc78, 0x64580001,
+	0xc78, 0x63590001,
+	0xc78, 0x625a0001,
+	0xc78, 0x615b0001,
+	0xc78, 0x605c0001,
+	0xc78, 0x485d0001,
+	0xc78, 0x475e0001,
+	0xc78, 0x465f0001,
+	0xc78, 0x45600001,
+	0xc78, 0x44610001,
+	0xc78, 0x43620001,
+	0xc78, 0x42630001,
+	0xc78, 0x41640001,
+	0xc78, 0x40650001,
+	0xc78, 0x27660001,
+	0xc78, 0x26670001,
+	0xc78, 0x25680001,
+	0xc78, 0x24690001,
+	0xc78, 0x236a0001,
+	0xc78, 0x226b0001,
+	0xc78, 0x216c0001,
+	0xc78, 0x206d0001,
+	0xc78, 0x206e0001,
+	0xc78, 0x206f0001,
+	0xc78, 0x20700001,
+	0xc78, 0x20710001,
+	0xc78, 0x20720001,
+	0xc78, 0x20730001,
+	0xc78, 0x20740001,
+	0xc78, 0x20750001,
+	0xc78, 0x20760001,
+	0xc78, 0x20770001,
+	0xc78, 0x20780001,
+	0xc78, 0x20790001,
+	0xc78, 0x207a0001,
+	0xc78, 0x207b0001,
+	0xc78, 0x207c0001,
+	0xc78, 0x207d0001,
+	0xc78, 0x207e0001,
+	0xc78, 0x207f0001,
+	0xc78, 0x38000002,
+	0xc78, 0x38010002,
+	0xc78, 0x38020002,
+	0xc78, 0x38030002,
+	0xc78, 0x38040002,
+	0xc78, 0x38050002,
+	0xc78, 0x38060002,
+	0xc78, 0x38070002,
+	0xc78, 0x38080002,
+	0xc78, 0x3c090002,
+	0xc78, 0x3e0a0002,
+	0xc78, 0x400b0002,
+	0xc78, 0x440c0002,
+	0xc78, 0x480d0002,
+	0xc78, 0x4c0e0002,
+	0xc78, 0x500f0002,
+	0xc78, 0x52100002,
+	0xc78, 0x56110002,
+	0xc78, 0x5a120002,
+	0xc78, 0x5e130002,
+	0xc78, 0x60140002,
+	0xc78, 0x60150002,
+	0xc78, 0x60160002,
+	0xc78, 0x62170002,
+	0xc78, 0x62180002,
+	0xc78, 0x62190002,
+	0xc78, 0x621a0002,
+	0xc78, 0x621b0002,
+	0xc78, 0x621c0002,
+	0xc78, 0x621d0002,
+	0xc78, 0x621e0002,
+	0xc78, 0x621f0002,
+	0xc78, 0x32000044,
+	0xc78, 0x32010044,
+	0xc78, 0x32020044,
+	0xc78, 0x32030044,
+	0xc78, 0x32040044,
+	0xc78, 0x32050044,
+	0xc78, 0x32060044,
+	0xc78, 0x34070044,
+	0xc78, 0x35080044,
+	0xc78, 0x36090044,
+	0xc78, 0x370a0044,
+	0xc78, 0x380b0044,
+	0xc78, 0x390c0044,
+	0xc78, 0x3a0d0044,
+	0xc78, 0x3e0e0044,
+	0xc78, 0x420f0044,
+	0xc78, 0x44100044,
+	0xc78, 0x46110044,
+	0xc78, 0x4a120044,
+	0xc78, 0x4e130044,
+	0xc78, 0x50140044,
+	0xc78, 0x55150044,
+	0xc78, 0x5a160044,
+	0xc78, 0x5e170044,
+	0xc78, 0x64180044,
+	0xc78, 0x6e190044,
+	0xc78, 0x6e1a0044,
+	0xc78, 0x6e1b0044,
+	0xc78, 0x6e1c0044,
+	0xc78, 0x6e1d0044,
+	0xc78, 0x6e1e0044,
+	0xc78, 0x6e1f0044,
+	0xc78, 0x6e1f0000,
+};
+	
+const u32 Rtl8192DUAGCTAB_5GArray[Rtl8192DUAGCTAB_5GArrayLength] = {
+	0xc78, 0x7b000001,
+	0xc78, 0x7b010001,
+	0xc78, 0x7a020001,
+	0xc78, 0x79030001,
+	0xc78, 0x78040001,
+	0xc78, 0x77050001,
+	0xc78, 0x76060001,
+	0xc78, 0x75070001,
+	0xc78, 0x74080001,
+	0xc78, 0x73090001,
+	0xc78, 0x720a0001,
+	0xc78, 0x710b0001,
+	0xc78, 0x700c0001,
+	0xc78, 0x6f0d0001,
+	0xc78, 0x6e0e0001,
+	0xc78, 0x6d0f0001,
+	0xc78, 0x6c100001,
+	0xc78, 0x6b110001,
+	0xc78, 0x6a120001,
+	0xc78, 0x69130001,
+	0xc78, 0x68140001,
+	0xc78, 0x67150001,
+	0xc78, 0x66160001,
+	0xc78, 0x65170001,
+	0xc78, 0x64180001,
+	0xc78, 0x63190001,
+	0xc78, 0x621a0001,
+	0xc78, 0x611b0001,
+	0xc78, 0x601c0001,
+	0xc78, 0x481d0001,
+	0xc78, 0x471e0001,
+	0xc78, 0x461f0001,
+	0xc78, 0x45200001,
+	0xc78, 0x44210001,
+	0xc78, 0x43220001,
+	0xc78, 0x42230001,
+	0xc78, 0x41240001,
+	0xc78, 0x40250001,
+	0xc78, 0x27260001,
+	0xc78, 0x26270001,
+	0xc78, 0x25280001,
+	0xc78, 0x24290001,
+	0xc78, 0x232a0001,
+	0xc78, 0x222b0001,
+	0xc78, 0x212c0001,
+	0xc78, 0x202d0001,
+	0xc78, 0x202e0001,
+	0xc78, 0x202f0001,
+	0xc78, 0x20300001,
+	0xc78, 0x20310001,
+	0xc78, 0x20320001,
+	0xc78, 0x20330001,
+	0xc78, 0x20340001,
+	0xc78, 0x20350001,
+	0xc78, 0x20360001,
+	0xc78, 0x20370001,
+	0xc78, 0x20380001,
+	0xc78, 0x20390001,
+	0xc78, 0x203a0001,
+	0xc78, 0x203b0001,
+	0xc78, 0x203c0001,
+	0xc78, 0x203d0001,
+	0xc78, 0x203e0001,
+	0xc78, 0x203f0001,
+	0xc78, 0x32000044,
+	0xc78, 0x32010044,
+	0xc78, 0x32020044,
+	0xc78, 0x32030044,
+	0xc78, 0x32040044,
+	0xc78, 0x32050044,
+	0xc78, 0x32060044,
+	0xc78, 0x34070044,
+	0xc78, 0x35080044,
+	0xc78, 0x36090044,
+	0xc78, 0x370a0044,
+	0xc78, 0x380b0044,
+	0xc78, 0x390c0044,
+	0xc78, 0x3a0d0044,
+	0xc78, 0x3e0e0044,
+	0xc78, 0x420f0044,
+	0xc78, 0x44100044,
+	0xc78, 0x46110044,
+	0xc78, 0x4a120044,
+	0xc78, 0x4e130044,
+	0xc78, 0x50140044,
+	0xc78, 0x55150044,
+	0xc78, 0x5a160044,
+	0xc78, 0x5e170044,
+	0xc78, 0x64180044,
+	0xc78, 0x6e190044,
+	0xc78, 0x6e1a0044,
+	0xc78, 0x6e1b0044,
+	0xc78, 0x6e1c0044,
+	0xc78, 0x6e1d0044,
+	0xc78, 0x6e1e0044,
+	0xc78, 0x6e1f0044,
+	0xc78, 0x6e1f0000,
+};
+	
+const u32 Rtl8192DUAGCTAB_2GArray[Rtl8192DUAGCTAB_2GArrayLength] = {
+	0xc78, 0x7b000001,
+	0xc78, 0x7b010001,
+	0xc78, 0x7b020001,
+	0xc78, 0x7b030001,
+	0xc78, 0x7b040001,
+	0xc78, 0x7b050001,
+	0xc78, 0x7b060001,
+	0xc78, 0x7a070001,
+	0xc78, 0x79080001,
+	0xc78, 0x78090001,
+	0xc78, 0x770a0001,
+	0xc78, 0x760b0001,
+	0xc78, 0x750c0001,
+	0xc78, 0x740d0001,
+	0xc78, 0x730e0001,
+	0xc78, 0x720f0001,
+	0xc78, 0x71100001,
+	0xc78, 0x70110001,
+	0xc78, 0x6f120001,
+	0xc78, 0x6e130001,
+	0xc78, 0x6d140001,
+	0xc78, 0x6c150001,
+	0xc78, 0x6b160001,
+	0xc78, 0x6a170001,
+	0xc78, 0x69180001,
+	0xc78, 0x68190001,
+	0xc78, 0x671a0001,
+	0xc78, 0x661b0001,
+	0xc78, 0x651c0001,
+	0xc78, 0x641d0001,
+	0xc78, 0x631e0001,
+	0xc78, 0x621f0001,
+	0xc78, 0x61200001,
+	0xc78, 0x60210001,
+	0xc78, 0x49220001,
+	0xc78, 0x48230001,
+	0xc78, 0x47240001,
+	0xc78, 0x46250001,
+	0xc78, 0x45260001,
+	0xc78, 0x44270001,
+	0xc78, 0x43280001,
+	0xc78, 0x42290001,
+	0xc78, 0x412a0001,
+	0xc78, 0x402b0001,
+	0xc78, 0x262c0001,
+	0xc78, 0x252d0001,
+	0xc78, 0x242e0001,
+	0xc78, 0x232f0001,
+	0xc78, 0x22300001,
+	0xc78, 0x21310001,
+	0xc78, 0x20320001,
+	0xc78, 0x06330001,
+	0xc78, 0x05340001,
+	0xc78, 0x04350001,
+	0xc78, 0x03360001,
+	0xc78, 0x02370001,
+	0xc78, 0x01380001,
+	0xc78, 0x00390001,
+	0xc78, 0x003a0001,
+	0xc78, 0x003b0001,
+	0xc78, 0x003c0001,
+	0xc78, 0x003d0001,
+	0xc78, 0x003e0001,
+	0xc78, 0x003f0001,
+	0xc78, 0x38000002,
+	0xc78, 0x38010002,
+	0xc78, 0x38020002,
+	0xc78, 0x38030002,
+	0xc78, 0x38040002,
+	0xc78, 0x38050002,
+	0xc78, 0x38060002,
+	0xc78, 0x38070002,
+	0xc78, 0x38080002,
+	0xc78, 0x3c090002,
+	0xc78, 0x3e0a0002,
+	0xc78, 0x400b0002,
+	0xc78, 0x440c0002,
+	0xc78, 0x480d0002,
+	0xc78, 0x4c0e0002,
+	0xc78, 0x500f0002,
+	0xc78, 0x52100002,
+	0xc78, 0x56110002,
+	0xc78, 0x5a120002,
+	0xc78, 0x5e130002,
+	0xc78, 0x60140002,
+	0xc78, 0x60150002,
+	0xc78, 0x60160002,
+	0xc78, 0x62170002,
+	0xc78, 0x62180002,
+	0xc78, 0x62190002,
+	0xc78, 0x621a0002,
+	0xc78, 0x621b0002,
+	0xc78, 0x621c0002,
+	0xc78, 0x621d0002,
+	0xc78, 0x621e0002,
+	0xc78, 0x621f0002,
+	0xc78, 0x6e1f0000,
+};
+	
+const u32 Rtl8192DUAGCTAB_2TArray[Rtl8192DUAGCTAB_2TArrayLength] = {
+	0x0,
+};
+	
+const u32 Rtl8192DUAGCTAB_1TArray[Rtl8192DUAGCTAB_1TArrayLength] = {
+	0x0,
+};
diff --git a/drivers/net/wireless/rtl8192du/hal/hal_com.c b/drivers/net/wireless/rtl8192du/hal/hal_com.c
new file mode 100644
index 0000000..2991cce
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/hal_com.c
@@ -0,0 +1,380 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <hal_intf.h>
+#include <hal_com.h>
+#include <rtl8192d_hal.h>
+
+#define _HAL_COM_C_
+
+/*  */
+/*  Global var */
+/*  */
+u32 OFDMSwingTable[OFDM_TABLE_SIZE_92D] = {
+	0x7f8001fe, /*  0, +6.0dB */
+	0x788001e2, /*  1, +5.5dB */
+	0x71c001c7, /*  2, +5.0dB */
+	0x6b8001ae, /*  3, +4.5dB */
+	0x65400195, /*  4, +4.0dB */
+	0x5fc0017f, /*  5, +3.5dB */
+	0x5a400169, /*  6, +3.0dB */
+	0x55400155, /*  7, +2.5dB */
+	0x50800142, /*  8, +2.0dB */
+	0x4c000130, /*  9, +1.5dB */
+	0x47c0011f, /*  10, +1.0dB */
+	0x43c0010f, /*  11, +0.5dB */
+	0x40000100, /*  12, +0dB */
+	0x3c8000f2, /*  13, -0.5dB */
+	0x390000e4, /*  14, -1.0dB */
+	0x35c000d7, /*  15, -1.5dB */
+	0x32c000cb, /*  16, -2.0dB */
+	0x300000c0, /*  17, -2.5dB */
+	0x2d4000b5, /*  18, -3.0dB */
+	0x2ac000ab, /*  19, -3.5dB */
+	0x288000a2, /*  20, -4.0dB */
+	0x26000098, /*  21, -4.5dB */
+	0x24000090, /*  22, -5.0dB */
+	0x22000088, /*  23, -5.5dB */
+	0x20000080, /*  24, -6.0dB */
+	0x1e400079, /*  25, -6.5dB */
+	0x1c800072, /*  26, -7.0dB */
+	0x1b00006c, /*  27. -7.5dB */
+	0x19800066, /*  28, -8.0dB */
+	0x18000060, /*  29, -8.5dB */
+	0x16c0005b, /*  30, -9.0dB */
+	0x15800056, /*  31, -9.5dB */
+	0x14400051, /*  32, -10.0dB */
+	0x1300004c, /*  33, -10.5dB */
+	0x12000048, /*  34, -11.0dB */
+	0x11000044, /*  35, -11.5dB */
+	0x10000040, /*  36, -12.0dB */
+	0x0f00003c,/*  37, -12.5dB */
+	0x0e400039,/*  38, -13.0dB */
+	0x0d800036,/*  39, -13.5dB */
+	0x0cc00033,/*  40, -14.0dB */
+	0x0c000030,/*  41, -14.5dB */
+	0x0b40002d,/*  42, -15.0dB */
+};
+
+u8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},/*  0, +0dB */
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},/*  1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},/*  2, -1.0dB */
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},/*  3, -1.5dB */
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},/*  4, -2.0dB */
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},/*  5, -2.5dB */
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},/*  6, -3.0dB */
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},/*  7, -3.5dB */
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},/*  8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},/*  9, -4.5dB */
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},/*  10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},/*  11, -5.5dB */
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},/*  12, -6.0dB */
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},/*  13, -6.5dB */
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},/*  14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},/*  15, -7.5dB */
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},/*  16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},/*  17, -8.5dB */
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},/*  18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},/*  19, -9.5dB */
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},/*  20, -10.0dB */
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},/*  21, -10.5dB */
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},/*  22, -11.0dB */
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},/*  23, -11.5dB */
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},/*  24, -12.0dB */
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},/*  25, -12.5dB */
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},/*  26, -13.0dB */
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},/*  27, -13.5dB */
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},/*  28, -14.0dB */
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},/*  29, -14.5dB */
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},/*  30, -15.0dB */
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},/*  31, -15.5dB */
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01} /*  32, -16.0dB */
+};
+
+u8 CCKSwingTable_Ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},/*  0, +0dB */
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},/*  1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},/*  2, -1.0dB */
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},/*  3, -1.5dB */
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},/*  4, -2.0dB */
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},/*  5, -2.5dB */
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},/*  6, -3.0dB */
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},/*  7, -3.5dB */
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},/*  8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},/*  9, -4.5dB */
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},/*  10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},/*  11, -5.5dB */
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},/*  12, -6.0dB */
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},/*  13, -6.5dB */
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},/*  14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},/*  15, -7.5dB */
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},/*  16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},/*  17, -8.5dB */
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},/*  18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},/*  19, -9.5dB */
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},/*  20, -10.0dB */
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},/*  21, -10.5dB */
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},/*  22, -11.0dB */
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},/*  23, -11.5dB */
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},/*  24, -12.0dB */
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},/*  25, -12.5dB */
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},/*  26, -13.0dB */
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},/*  27, -13.5dB */
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},/*  28, -14.0dB */
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},/*  29, -14.5dB */
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},/*  30, -15.0dB */
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},/*  31, -15.5dB */
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00} /*  32, -16.0dB */
+};
+
+#ifdef CONFIG_CHIP_VER_INTEGRATION
+void dump_chip_info(HAL_VERSION	chip_ver)
+{
+	if (IS_92D(chip_ver))
+		DBG_871X("Chip Version Info: CHIP_8192D_");
+
+	DBG_871X("%s_", IS_NORMAL_CHIP(chip_ver) ? "Normal_Chip" :
+		 "Test_Chip");
+	DBG_871X("%s_", IS_CHIP_VENDOR_TSMC(chip_ver) ? "TSMC" : "UMC");
+	if (IS_A_CUT(chip_ver))
+		DBG_871X("A_CUT_");
+	else if (IS_B_CUT(chip_ver))
+		DBG_871X("B_CUT_");
+	else if (IS_C_CUT(chip_ver))
+		DBG_871X("C_CUT_");
+	else if (IS_D_CUT(chip_ver))
+		DBG_871X("D_CUT_");
+	else if (IS_E_CUT(chip_ver))
+		DBG_871X("E_CUT_");
+	else
+		DBG_871X("UNKNOWN_CUT(%d)_", chip_ver.CUTVersion);
+
+	if (IS_1T1R(chip_ver))
+		DBG_871X("1T1R_");
+	else if (IS_1T2R(chip_ver))
+		DBG_871X("1T2R_");
+	else if (IS_2T2R(chip_ver))
+		DBG_871X("2T2R_");
+	else
+		DBG_871X("UNKNOWN_RFTYPE(%d)_", chip_ver.RFType);
+
+	DBG_871X("RomVer(%d)\n", chip_ver.ROMVer);
+}
+#endif
+
+#define	EEPROM_CHANNEL_PLAN_BY_HW_MASK	0x80
+
+u8	/* return the final channel plan decision */
+hal_com_get_channel_plan(
+	struct rtw_adapter *	padapter,
+	u8 hw_channel_plan, /* from HW (efuse/eeprom) */
+	u8 sw_channel_plan, /* from SW (registry/module param) */
+	u8 def_channel_plan, /* used when the former two are invalid */
+	bool		autoloadfail
+	)
+{
+	u8 swconfig;
+	u8 chnlplan;
+
+	swconfig = true;
+	if (!autoloadfail) {
+		if (!rtw_is_channel_plan_valid(sw_channel_plan))
+			swconfig = false;
+		if (hw_channel_plan & EEPROM_CHANNEL_PLAN_BY_HW_MASK)
+			swconfig = false;
+	}
+
+	if (swconfig == true)
+		chnlplan = sw_channel_plan;
+	else
+		chnlplan = hw_channel_plan & (~EEPROM_CHANNEL_PLAN_BY_HW_MASK);
+
+	if (!rtw_is_channel_plan_valid(chnlplan))
+		chnlplan = def_channel_plan;
+
+	return chnlplan;
+}
+
+u8	ratetohwrate(u8 rate)
+{
+	u8	ret = DESC_RATE1M;
+
+	switch (rate) {
+		/*  CCK and OFDM non-HT rates */
+	case IEEE80211_CCK_RATE_1MB:
+		ret = DESC_RATE1M;
+		break;
+	case IEEE80211_CCK_RATE_2MB:
+		ret = DESC_RATE2M;
+		break;
+	case IEEE80211_CCK_RATE_5MB:
+		ret = DESC_RATE5_5M;
+		break;
+	case IEEE80211_CCK_RATE_11MB:
+		ret = DESC_RATE11M;
+		break;
+	case IEEE80211_OFDM_RATE_6MB:
+		ret = DESC_RATE6M;
+		break;
+	case IEEE80211_OFDM_RATE_9MB:
+		ret = DESC_RATE9M;
+		break;
+	case IEEE80211_OFDM_RATE_12MB:
+		ret = DESC_RATE12M;
+		break;
+	case IEEE80211_OFDM_RATE_18MB:
+		ret = DESC_RATE18M;
+		break;
+	case IEEE80211_OFDM_RATE_24MB:
+		ret = DESC_RATE24M;
+		break;
+	case IEEE80211_OFDM_RATE_36MB:
+		ret = DESC_RATE36M;
+		break;
+	case IEEE80211_OFDM_RATE_48MB:
+		ret = DESC_RATE48M;
+		break;
+	case IEEE80211_OFDM_RATE_54MB:
+		ret = DESC_RATE54M;
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+void	halsetbratecfg(struct rtw_adapter * adapter, u8 *brates, u16 *bratecfg)
+{
+	u8	i, is_brate, brate;
+
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		is_brate = brates[i] & IEEE80211_BASIC_RATE_MASK;
+		brate = brates[i] & 0x7f;
+
+		if (is_brate) {
+			switch (brate) {
+			case IEEE80211_CCK_RATE_1MB:
+				*bratecfg |= RATE_1M;
+				break;
+			case IEEE80211_CCK_RATE_2MB:
+				*bratecfg |= RATE_2M;
+				break;
+			case IEEE80211_CCK_RATE_5MB:
+				*bratecfg |= RATE_5_5M;
+				break;
+			case IEEE80211_CCK_RATE_11MB:
+				*bratecfg |= RATE_11M;
+				break;
+			case IEEE80211_OFDM_RATE_6MB:
+				*bratecfg |= RATE_6M;
+				break;
+			case IEEE80211_OFDM_RATE_9MB:
+				*bratecfg |= RATE_9M;
+				break;
+			case IEEE80211_OFDM_RATE_12MB:
+				*bratecfg |= RATE_12M;
+				break;
+			case IEEE80211_OFDM_RATE_18MB:
+				*bratecfg |= RATE_18M;
+				break;
+			case IEEE80211_OFDM_RATE_24MB:
+				*bratecfg |= RATE_24M;
+				break;
+			case IEEE80211_OFDM_RATE_36MB:
+				*bratecfg |= RATE_36M;
+				break;
+			case IEEE80211_OFDM_RATE_48MB:
+				*bratecfg |= RATE_48M;
+				break;
+			case IEEE80211_OFDM_RATE_54MB:
+				*bratecfg |= RATE_54M;
+				break;
+			}
+		}
+	}
+}
+
+void hal_init_macaddr(struct rtw_adapter *adapter)
+{
+	rtw_hal_set_hwreg(adapter, HW_VAR_MAC_ADDR,
+			  adapter->eeprompriv.mac_addr);
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->pbuddy_adapter)
+		rtw_hal_set_hwreg(adapter->pbuddy_adapter, HW_VAR_MAC_ADDR,
+				  adapter->pbuddy_adapter->eeprompriv.mac_addr);
+#endif
+}
+
+/*
+* C2H event format:
+* Field	 TRIGGER		CONTENT	   CMD_SEQ	CMD_LEN		 CMD_ID
+* BITS	 [127:120]	[119:16]      [15:8]		  [7:4]		   [3:0]
+*/
+
+void c2h_evt_clear(struct rtw_adapter *adapter)
+{
+	rtw_write8(adapter, REG_C2HEVT_CLEAR, C2H_EVT_HOST_CLOSE);
+}
+
+s32 c2h_evt_read(struct rtw_adapter *adapter, u8 *buf)
+{
+	s32 ret = _FAIL;
+	struct c2h_evt_hdr *c2h_evt;
+	int i;
+	u8 trigger;
+
+	if (buf == NULL)
+		goto exit;
+
+	trigger = rtw_read8(adapter, REG_C2HEVT_CLEAR);
+
+	if (trigger == C2H_EVT_HOST_CLOSE)
+		goto exit; /* Not ready */
+	else if (trigger != C2H_EVT_FW_CLOSE)
+		goto clear_evt; /* Not a valid value */
+
+	c2h_evt = (struct c2h_evt_hdr *)buf;
+
+	memset(c2h_evt, 0, 16);
+
+	*buf = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL);
+	*(buf+1) = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL + 1);
+
+	RT_PRINT_DATA(_module_hal_init_c_, _drv_info_, "c2h_evt_read(): ",
+		      &c2h_evt , sizeof(c2h_evt));
+
+	/* Read the content */
+	for (i = 0; i < c2h_evt->plen; i++)
+		c2h_evt->payload[i] = rtw_read8(adapter, REG_C2HEVT_MSG_NORMAL +
+						sizeof(*c2h_evt) + i);
+
+	RT_PRINT_DATA(_module_hal_init_c_, _drv_info_,
+		      "c2h_evt_read(): Command Content:\n",
+		      c2h_evt->payload, c2h_evt->plen);
+	ret = _SUCCESS;
+clear_evt:
+	/*
+	* Clear event to notify FW we have read the command.
+	* If this field isn't clear, the FW won't update the next command
+	* message.
+	*/
+	c2h_evt_clear(adapter);
+exit:
+	return ret;
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/hal_intf.c b/drivers/net/wireless/rtl8192du/hal/hal_intf.c
new file mode 100644
index 0000000..87f7929
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/hal_intf.c
@@ -0,0 +1,415 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#define _HAL_INTF_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <hal_intf.h>
+#include <usb_hal.h>
+
+void rtw_hal_chip_configure(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.intf_chip_configure)
+		padapter->HalFunc.intf_chip_configure(padapter);
+}
+
+void rtw_hal_read_chip_info(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.read_adapter_info)
+		padapter->HalFunc.read_adapter_info(padapter);
+}
+
+void rtw_hal_read_chip_version(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.read_chip_version)
+		padapter->HalFunc.read_chip_version(padapter);
+}
+
+void rtw_hal_def_value_init(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.init_default_value)
+		padapter->HalFunc.init_default_value(padapter);
+}
+
+void rtw_hal_free_data(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.free_hal_data)
+		padapter->HalFunc.free_hal_data(padapter);
+}
+
+void rtw_hal_dm_init(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.dm_init)
+		padapter->HalFunc.dm_init(padapter);
+}
+
+void rtw_hal_dm_deinit(struct rtw_adapter *padapter)
+{
+	/*  cancel dm  timer */
+	if (padapter->HalFunc.dm_deinit)
+		padapter->HalFunc.dm_deinit(padapter);
+}
+
+void rtw_hal_sw_led_init(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.InitSwLeds)
+		padapter->HalFunc.InitSwLeds(padapter);
+}
+
+void rtw_hal_sw_led_deinit(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.DeInitSwLeds)
+		padapter->HalFunc.DeInitSwLeds(padapter);
+}
+
+uint	 rtw_hal_init(struct rtw_adapter *padapter)
+{
+	uint	status = _SUCCESS;
+
+	if (padapter->hw_init_completed == true) {
+		DBG_8192D("rtw_hal_init: hw_init_completed == true\n");
+		return status;
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	/*  before init mac0, driver must init mac1 first to avoid usb rx error. */
+	if ((padapter->pbuddy_adapter != NULL) &&
+	    (padapter->DualMacConcurrent == true) &&
+	    (padapter->adapter_type == PRIMARY_ADAPTER)) {
+		if (padapter->pbuddy_adapter->hw_init_completed == true) {
+			DBG_8192D("rtw_hal_init: pbuddy_adapter hw_init_completed == true\n");
+		} else {
+			status =	padapter->HalFunc.hal_init(padapter->pbuddy_adapter);
+			if (status == _SUCCESS) {
+				padapter->pbuddy_adapter->hw_init_completed = true;
+			} else {
+				padapter->pbuddy_adapter->hw_init_completed = false;
+				RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail(pbuddy_adapter)\n"));
+				return status;
+			}
+		}
+	}
+#endif
+
+	padapter->hw_init_completed=false;
+
+	status = padapter->HalFunc.hal_init(padapter);
+
+	if (status == _SUCCESS) {
+		padapter->hw_init_completed = true;
+
+		if (padapter->registrypriv.notch_filter == 1)
+			rtw_hal_notch_filter(padapter, 1);
+
+		rtw_hal_reset_security_engine(padapter);
+	} else {
+		padapter->hw_init_completed = false;
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("rtw_hal_init: hal__init fail\n"));
+	}
+
+	RT_TRACE(_module_hal_init_c_,_drv_err_,("-rtl871x_hal_init:status=0x%x\n",status));
+
+	return status;
+}
+
+uint rtw_hal_deinit(struct rtw_adapter *padapter)
+{
+	uint	status = _SUCCESS;
+
+	status = padapter->HalFunc.hal_deinit(padapter);
+
+	if (status == _SUCCESS)
+		padapter->hw_init_completed = false;
+	else
+		RT_TRACE(_module_hal_init_c_,_drv_err_,("\n rtw_hal_deinit: hal_init fail\n"));
+
+	return status;
+}
+
+void rtw_hal_set_hwreg(struct rtw_adapter *padapter, u8 variable, u8 *val)
+{
+	if (padapter->HalFunc.SetHwRegHandler)
+		padapter->HalFunc.SetHwRegHandler(padapter, variable, val);
+}
+
+void rtw_hal_get_hwreg(struct rtw_adapter *padapter, u8 variable, u8 *val)
+{
+	if (padapter->HalFunc.GetHwRegHandler)
+		padapter->HalFunc.GetHwRegHandler(padapter, variable, val);
+}
+
+u8 rtw_hal_set_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable, void * pValue)
+{
+	if (padapter->HalFunc.SetHalDefVarHandler)
+		return padapter->HalFunc.SetHalDefVarHandler(padapter,eVariable,pValue);
+	return _FAIL;
+}
+
+u8 rtw_hal_get_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable, void * pValue)
+{
+	if (padapter->HalFunc.GetHalDefVarHandler)
+		return padapter->HalFunc.GetHalDefVarHandler(padapter,eVariable,pValue);
+	return _FAIL;
+}
+
+void rtw_hal_enable_interrupt(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.enable_interrupt)
+		padapter->HalFunc.enable_interrupt(padapter);
+	else
+		DBG_8192D("%s: HalFunc.enable_interrupt is NULL!\n", __func__);
+}
+void rtw_hal_disable_interrupt(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.disable_interrupt)
+		padapter->HalFunc.disable_interrupt(padapter);
+	else
+		DBG_8192D("%s: HalFunc.disable_interrupt is NULL!\n", __func__);
+}
+
+u32	rtw_hal_inirp_init(struct rtw_adapter *padapter)
+{
+	u32 rst = _FAIL;
+	if (padapter->HalFunc.inirp_init)
+		rst = padapter->HalFunc.inirp_init(padapter);
+	else
+		DBG_8192D(" %s HalFunc.inirp_init is NULL!!!\n",__func__);
+	return rst;
+}
+
+u32	rtw_hal_inirp_deinit(struct rtw_adapter *padapter)
+{
+
+	if (padapter->HalFunc.inirp_deinit)
+		return padapter->HalFunc.inirp_deinit(padapter);
+
+	return _FAIL;
+}
+
+u8 rtw_hal_intf_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val)
+{
+	if (padapter->HalFunc.interface_ps_func)
+		return padapter->HalFunc.interface_ps_func(padapter,efunc_id,val);
+	return _FAIL;
+}
+
+s32 rtw_hal_xmit(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	if (padapter->HalFunc.hal_xmit)
+		return padapter->HalFunc.hal_xmit(padapter, pxmitframe);
+
+	return false;
+}
+
+s32	rtw_hal_mgnt_xmit(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
+{
+	s32 ret = _FAIL;
+	if (padapter->HalFunc.mgnt_xmit)
+		ret = padapter->HalFunc.mgnt_xmit(padapter, pmgntframe);
+	return ret;
+}
+
+s32 rtw_hal_init_xmit_priv(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.init_xmit_priv != NULL)
+		return padapter->HalFunc.init_xmit_priv(padapter);
+	return _FAIL;
+}
+
+void rtw_hal_free_xmit_priv(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.free_xmit_priv != NULL)
+		padapter->HalFunc.free_xmit_priv(padapter);
+}
+
+s32 rtw_hal_init_recv_priv(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.init_recv_priv)
+		return padapter->HalFunc.init_recv_priv(padapter);
+
+	return _FAIL;
+}
+
+void rtw_hal_free_recv_priv(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.free_recv_priv)
+		padapter->HalFunc.free_recv_priv(padapter);
+}
+
+void rtw_hal_update_ra_mask(struct rtw_adapter *padapter, u32 mac_id)
+{
+	if (padapter->HalFunc.UpdateRAMaskHandler)
+		padapter->HalFunc.UpdateRAMaskHandler(padapter,mac_id);
+}
+
+void rtw_hal_add_ra_tid(struct rtw_adapter *padapter, u32 bitmap, u8 arg)
+{
+	if (padapter->HalFunc.Add_RateATid)
+		padapter->HalFunc.Add_RateATid(padapter, bitmap, arg);
+}
+
+u32 rtw_hal_read_bbreg(struct rtw_adapter *padapter, u32 RegAddr, u32 BitMask)
+{
+	u32 data = 0;
+	if (padapter->HalFunc.read_bbreg)
+		data = padapter->HalFunc.read_bbreg(padapter, RegAddr, BitMask);
+	return data;
+}
+
+void rtw_hal_write_bbreg(struct rtw_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	if (padapter->HalFunc.write_bbreg)
+		padapter->HalFunc.write_bbreg(padapter, RegAddr, BitMask, Data);
+}
+
+u32 rtw_hal_read_rfreg(struct rtw_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask)
+{
+	u32 data = 0;
+	if (padapter->HalFunc.read_rfreg)
+		data = padapter->HalFunc.read_rfreg(padapter, eRFPath, RegAddr, BitMask);
+	return data;
+}
+
+void rtw_hal_write_rfreg(struct rtw_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	if (padapter->HalFunc.write_rfreg)
+		padapter->HalFunc.write_rfreg(padapter, eRFPath, RegAddr, BitMask, Data);
+}
+
+s32 rtw_hal_interrupt_handler(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.interrupt_handler)
+		return padapter->HalFunc.interrupt_handler(padapter);
+	return _FAIL;
+}
+
+void rtw_hal_set_bwmode(struct rtw_adapter *padapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset)
+{
+	if (padapter->HalFunc.set_bwmode_handler)
+		padapter->HalFunc.set_bwmode_handler(padapter, Bandwidth, Offset);
+}
+
+void rtw_hal_set_chan(struct rtw_adapter *padapter, u8 channel)
+{
+	if (padapter->HalFunc.set_channel_handler)
+		padapter->HalFunc.set_channel_handler(padapter, channel);
+}
+
+void rtw_hal_dm_watchdog(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.hal_dm_watchdog)
+		padapter->HalFunc.hal_dm_watchdog(padapter);
+}
+
+void rtw_hal_bcn_related_reg_setting(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.SetBeaconRelatedRegistersHandler)
+		padapter->HalFunc.SetBeaconRelatedRegistersHandler(padapter);
+}
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+u8 rtw_hal_antdiv_before_linked(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.AntDivBeforeLinkHandler)
+		return padapter->HalFunc.AntDivBeforeLinkHandler(padapter);
+	return false;
+}
+
+void rtw_hal_antdiv_rssi_compared(struct rtw_adapter *padapter, WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src)
+{
+	if (padapter->HalFunc.AntDivCompareHandler)
+		padapter->HalFunc.AntDivCompareHandler(padapter, dst, src);
+}
+#endif
+
+#ifdef CONFIG_HOSTAPD_MLME
+s32	rtw_hal_hostap_mgnt_xmit_entry(struct rtw_adapter *padapter, struct sk_buff *pkt)
+{
+	if (padapter->HalFunc.hostap_mgnt_xmit_entry)
+		return padapter->HalFunc.hostap_mgnt_xmit_entry(padapter, pkt);
+	return _FAIL;
+}
+#endif /* CONFIG_HOSTAPD_MLME */
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+void rtw_hal_sreset_init(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.sreset_init_value)
+		padapter->HalFunc.sreset_init_value(padapter);
+}
+
+void rtw_hal_sreset_reset(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.silentreset)
+		padapter->HalFunc.silentreset(padapter);
+}
+
+void rtw_hal_sreset_reset_value(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.sreset_reset_value)
+		padapter->HalFunc.sreset_reset_value(padapter);
+}
+
+void rtw_hal_sreset_xmit_status_check(struct rtw_adapter *padapter)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type != PRIMARY_ADAPTER)
+		return;
+#endif
+	if (padapter->HalFunc.sreset_xmit_status_check)
+		padapter->HalFunc.sreset_xmit_status_check(padapter);
+}
+
+void rtw_hal_sreset_linked_status_check(struct rtw_adapter *padapter)
+{
+	if (padapter->HalFunc.sreset_linked_status_check)
+		padapter->HalFunc.sreset_linked_status_check(padapter);
+}
+
+u8 rtw_hal_sreset_get_wifi_status(struct rtw_adapter *padapter)
+{
+	u8 status = 0;
+	if (padapter->HalFunc.sreset_get_wifi_status)
+		status = padapter->HalFunc.sreset_get_wifi_status(padapter);
+	return status;
+}
+#endif /* DBG_CONFIG_ERROR_DETECT */
+
+void rtw_hal_notch_filter(struct rtw_adapter *adapter, bool enable)
+{
+	if (adapter->HalFunc.hal_notch_filter)
+		adapter->HalFunc.hal_notch_filter(adapter,enable);
+}
+
+void rtw_hal_reset_security_engine(struct rtw_adapter * adapter)
+{
+	if (adapter->HalFunc.hal_reset_security_engine)
+		adapter->HalFunc.hal_reset_security_engine(adapter);
+}
+
+s32 rtw_hal_c2h_handler(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt)
+{
+	s32 ret = _FAIL;
+	if (adapter->HalFunc.c2h_handler)
+		ret = adapter->HalFunc.c2h_handler(adapter, c2h_evt);
+	return ret;
+}
+
+c2h_id_filter rtw_hal_c2h_id_filter_ccx(struct rtw_adapter *adapter)
+{
+	return adapter->HalFunc.c2h_id_filter_ccx;
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_cmd.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_cmd.c
new file mode 100644
index 0000000..a020eb3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_cmd.c
@@ -0,0 +1,953 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192D_CMD_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <cmd_osdep.h>
+#include <mlme_osdep.h>
+#include <rtw_ioctl_set.h>
+
+#include <rtl8192d_hal.h>
+
+static bool
+CheckWriteH2C(
+	struct rtw_adapter *		adapter,
+	u8		BoxNum
+)
+{
+	u8	valHMETFR;
+	bool	Result = false;
+
+	valHMETFR = rtw_read8(adapter, REG_HMETFR);
+
+	if (((valHMETFR>>BoxNum)&BIT0) == 1)
+		Result = true;
+
+	return Result;
+}
+
+static bool
+CheckFwReadLastH2C(
+	struct rtw_adapter *		adapter,
+	u8		BoxNum
+)
+{
+	u8	valHMETFR;
+	bool	 Result = false;
+
+	valHMETFR = rtw_read8(adapter, REG_HMETFR);
+
+	/*  Do not seperate to 91C and 88C, we use the same setting. Suggested by SD4 Filen. 2009.12.03. */
+	if (((valHMETFR>>BoxNum)&BIT0) == 0)
+		Result = true;
+
+	return Result;
+}
+
+/*  */
+/*  Description: */
+/*	Fill H2C command */
+/*	BOX_0-4 Format: */
+/*	bit [31-8]	|     7		|  [6-0] */
+/*	     RSVD	|  CMD_EXT	|  CMD_ID */
+/*  */
+/*	BOX Extension 0-4 format: */
+/*	bit 15-0: RSVD */
+/*  */
+
+/*****************************************
+* H2C Msg format :
+*| 31 - 8		|7		| 6 - 0	|
+*| h2c_msg	|Ext_bit	|CMD_ID	|
+*
+******************************************/
+static void _FillH2CCmd92D(struct rtw_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	u8	BoxNum;
+	u16	BOXReg=0, BOXExtReg=0;
+	u8	BoxContent[4], BoxExtContent[2];
+	u8	BufIndex=0;
+	u8	bWriteSucess = false;
+	u8	IsFwRead = false;
+	u8	WaitH2cLimmit = 100;
+	u8	WaitWriteH2cLimmit = 100;
+	u8	idx=0;
+
+	padapter = GET_PRIMARY_ADAPTER(padapter);
+	pHalData = GET_HAL_DATA(padapter);
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
+
+	while (!bWriteSucess)
+	{
+		WaitWriteH2cLimmit--;
+		if (WaitWriteH2cLimmit == 0)
+		{
+			DBG_8192D("FillH2CCmd92C():Write H2C fail because no trigger for FW INT!!!!!!!!\n");
+			break;
+		}
+
+		/*  2. Find the last BOX number which has been writen. */
+		BoxNum = pHalData->LastHMEBoxNum;
+		switch (BoxNum)
+		{
+			case 0:
+				BOXReg = REG_HMEBOX_0;
+				BOXExtReg = REG_HMEBOX_EXT_0;
+				break;
+			case 1:
+				BOXReg = REG_HMEBOX_1;
+				BOXExtReg = REG_HMEBOX_EXT_1;
+				break;
+			case 2:
+				BOXReg = REG_HMEBOX_2;
+				BOXExtReg = REG_HMEBOX_EXT_2;
+				break;
+			case 3:
+				BOXReg = REG_HMEBOX_3;
+				BOXExtReg = REG_HMEBOX_EXT_3;
+				break;
+			default:
+				break;
+		}
+
+		/*  3. Check if the box content is empty. */
+		IsFwRead = CheckFwReadLastH2C(padapter, BoxNum);
+		while (!IsFwRead)
+		{
+			/* wait until Fw read */
+			WaitH2cLimmit--;
+			if (WaitH2cLimmit == 0)
+			{
+				DBG_8192D("FillH2CCmd92C(): Wating too long for FW read clear HMEBox(%d)!!!\n", BoxNum);
+				break;
+			}
+			rtw_udelay_os(10); /* us */
+			IsFwRead = CheckFwReadLastH2C(padapter, BoxNum);
+		}
+
+		/*  If Fw has not read the last H2C cmd, break and give up this H2C. */
+		if (!IsFwRead)
+		{
+			DBG_8192D("FillH2CCmd92C():  Write H2C register BOX[%d] fail!!!!! Fw do not read.\n", BoxNum);
+			break;
+		}
+
+		/*  4. Fill the H2C cmd into box */
+		memset(BoxContent, 0, sizeof(BoxContent));
+		memset(BoxExtContent, 0, sizeof(BoxExtContent));
+
+		BoxContent[0] = ElementID; /*  Fill element ID */
+
+		switch (CmdLen)
+		{
+			case 1:
+			{
+				BoxContent[0] &= ~(BIT7);
+				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 1);
+				/* For Endian Free. */
+				for (idx= 0; idx < 4; idx++)
+				{
+					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
+				}
+				break;
+			}
+			case 2:
+			{
+				BoxContent[0] &= ~(BIT7);
+				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 2);
+				for (idx=0; idx < 4; idx++)
+				{
+					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
+				}
+				break;
+			}
+			case 3:
+			{
+				BoxContent[0] &= ~(BIT7);
+				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex, 3);
+				for (idx = 0; idx < 4 ; idx++)
+				{
+					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
+				}
+				break;
+			}
+			case 4:
+			{
+				BoxContent[0] |= (BIT7);
+				memcpy((u8 *)(BoxExtContent), pCmdBuffer+BufIndex, 2);
+				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex+2, 2);
+				for (idx = 0 ; idx < 2 ; idx ++)
+				{
+					rtw_write8(padapter, BOXExtReg+idx, BoxExtContent[idx]);
+				}
+				for (idx = 0 ; idx < 4 ; idx ++)
+				{
+					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
+				}
+				break;
+			}
+			case 5:
+			{
+				BoxContent[0] |= (BIT7);
+				memcpy((u8 *)(BoxExtContent), pCmdBuffer+BufIndex, 2);
+				memcpy((u8 *)(BoxContent)+1, pCmdBuffer+BufIndex+2, 3);
+				for (idx = 0 ; idx < 2 ; idx ++)
+				{
+					rtw_write8(padapter, BOXExtReg+idx, BoxExtContent[idx]);
+				}
+				for (idx = 0 ; idx < 4 ; idx ++)
+				{
+					rtw_write8(padapter, BOXReg+idx, BoxContent[idx]);
+				}
+				break;
+			}
+			default:
+				break;
+		}
+
+		/*  5. Normal chip does not need to check if the H2C cmd has be written successfully. */
+		/*  92D test chip does not need to check, */
+		bWriteSucess = true;
+
+		/*  Record the next BoxNum */
+		pHalData->LastHMEBoxNum = BoxNum+1;
+		if (pHalData->LastHMEBoxNum == 4) /*  loop to 0 */
+			pHalData->LastHMEBoxNum = 0;
+
+	}
+
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->h2c_fwcmd_mutex));
+
+}
+
+void
+FillH2CCmd92D(
+	struct rtw_adapter *	adapter,
+	u8	ElementID,
+	u32	CmdLen,
+	u8*	pCmdBuffer
+)
+{
+	u32	tmpCmdBuf[2];
+
+	/* adapter = ADJUST_TO_ADAPTIVE_ADAPTER(adapter, TRUE); */
+
+	if (adapter->bFWReady == false)
+	{
+		DBG_8192D("FillH2CCmd92D(): return H2C cmd because of Fw download fail!!!\n");
+		return;
+	}
+
+	memset(tmpCmdBuf, 0, 8);
+	memcpy(tmpCmdBuf, pCmdBuffer, CmdLen);
+
+	_FillH2CCmd92D(adapter, ElementID, CmdLen, (u8 *)&tmpCmdBuf);
+
+	return;
+}
+
+static u8 rtl8192d_h2c_msg_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
+{
+	u8 ElementID, CmdLen;
+	u8 *pCmdBuffer;
+	struct cmd_msg_parm  *pcmdmsg;
+
+	if (!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	pcmdmsg = (struct cmd_msg_parm*)pbuf;
+	ElementID = pcmdmsg->eid;
+	CmdLen = pcmdmsg->sz;
+	pCmdBuffer = pcmdmsg->buf;
+
+	FillH2CCmd92D(padapter, ElementID, CmdLen, pCmdBuffer);
+
+	return H2C_SUCCESS;
+}
+
+u8 rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg)
+{
+	u8	buf[5];
+	u8	res=_SUCCESS;
+	__le32	le_mask;
+
+	memset(buf, 0, 5);
+	le_mask = cpu_to_le32(mask);
+	memcpy(buf, &le_mask, 4);
+	buf[4]  = arg;
+
+	FillH2CCmd92D(padapter, H2C_RA_MASK, 5, buf);
+
+	return res;
+}
+
+/* bitmap[0:27] = tx_rate_bitmap */
+/* bitmap[28:31]= Rate Adaptive id */
+/* arg[0:4] = macid */
+/* arg[5] = Short GI */
+void rtl8192d_Add_RateATid(struct rtw_adapter * adapter, u32 bitmap, u8 arg)
+{
+
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (pHalData->fw_ractrl == true)
+	{
+		rtl8192d_set_raid_cmd(adapter, bitmap, arg);
+	}
+	else
+	{
+		u8 macid, init_rate, shortGIrate=false;
+
+		init_rate = get_highest_rate_idx(bitmap&0x0fffffff)&0x3f;
+
+		macid = arg&0x1f;
+
+		shortGIrate = (arg&BIT(5)) ? true:false;
+
+		if (shortGIrate==true)
+			init_rate |= BIT(6);
+
+		rtw_write8(adapter, (REG_INIDATA_RATE_SEL+macid), (u8)init_rate);
+	}
+}
+
+void rtl8192d_set_FwPwrMode_cmd(struct rtw_adapter*padapter, u8 Mode)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	u8	u1H2CSetPwrMode[3]={0};
+	u8	beacon_interval = 1;
+
+	DBG_8192D("%s(): Mode = %d, SmartPS = %d\n", __func__,Mode,pwrpriv->smart_ps);
+
+	SET_H2CCMD_PWRMODE_PARM_MODE(u1H2CSetPwrMode, Mode);
+	SET_H2CCMD_PWRMODE_PARM_SMART_PS(u1H2CSetPwrMode, pwrpriv->smart_ps);
+	SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1H2CSetPwrMode, beacon_interval);
+
+	FillH2CCmd92D(padapter, H2C_SETPWRMODE, 3, u1H2CSetPwrMode);
+
+}
+
+static void ConstructBeacon(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	__le16 *fctrl;
+	u32	rate_len, pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+
+	SetFrameSubType(pframe, WIFI_BEACON);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	/* timestamp will be inserted by hardware */
+	pframe += 8;
+	pktlen += 8;
+
+	/*  beacon interval: 2 bytes */
+	memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	/*  capability info: 2 bytes */
+	memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		DBG_8192D("ie len=%u\n", cur_network->IELength);
+		pktlen += cur_network->IELength - sizeof(struct ndis_802_11_fixed_ies);
+		memcpy(pframe, cur_network->IEs+sizeof(struct ndis_802_11_fixed_ies), pktlen);
+
+		goto _ConstructBeacon;
+	}
+
+	/* below for ad-hoc mode */
+
+	/*  SSID */
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
+
+	/*  supported rates... */
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pktlen);
+
+	/*  DS parameter set */
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
+
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		u32 ATIMWindow;
+		/*  IBSS Parameter Set... */
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
+	}
+
+	/* todo: ERP IE */
+
+	/*  EXTERNDED SUPPORTED RATE */
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
+	}
+
+	/* todo:HT for adhoc */
+
+_ConstructBeacon:
+
+	if ((pktlen + TXDESC_SIZE) > 512)
+	{
+		DBG_8192D("beacon frame too large\n");
+		return;
+	}
+
+	*pLength = pktlen;
+
+}
+
+static void ConstructPSPoll(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	__le16	*fctrl;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	/*  Frame control. */
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetPwrMgt(fctrl);
+	SetFrameSubType(pframe, WIFI_PSPOLL);
+
+	/*  AID. */
+	SetDuration(pframe, (pmlmeinfo->aid| 0xc000));
+
+	/*  BSSID. */
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	/*  TA. */
+	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+
+	*pLength = 16;
+}
+
+static void ConstructNullFunctionData(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, bool bForcePowerSave)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	__le16	*fctrl;
+	u32	pktlen;
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network	*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	if (bForcePowerSave)
+	{
+		SetPwrMgt(fctrl);
+	}
+
+	switch (cur_network->network.InfrastructureMode)
+	{
+		case NDIS802_11INFRA:
+			SetToDs(fctrl);
+			memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			memcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);
+			break;
+		case NDIS802_11APMODE:
+			SetFrDs(fctrl);
+			memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			break;
+		case NDIS802_11IBSS:
+		default:
+			memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+			break;
+	}
+
+	SetSeqNum(pwlanhdr, 0);
+
+	SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	*pLength = pktlen;
+}
+
+static void ConstructProbeRsp(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength, u8 *StaAddr, bool bHideSSID)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	__le16	*fctrl;
+	u8	*mac, *bssid;
+	u32	pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	mac = myid(&(padapter->eeprompriv));
+	bssid = cur_network->MacAddress;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, bssid, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0);
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+
+	pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pframe += pktlen;
+
+	if (cur_network->IELength>MAX_IE_SZ)
+		return;
+
+	memcpy(pframe, cur_network->IEs, cur_network->IELength);
+	pframe += cur_network->IELength;
+	pktlen += cur_network->IELength;
+
+	*pLength = pktlen;
+}
+
+/*  */
+/*  Description: In normal chip, we should send some packet to Hw which will be used by Fw */
+/*			in FW LPS mode. The function is to fill the Tx descriptor of this packets, then */
+/*			Fw can tell Hw to send these packet derectly. */
+/*  Added by tynli. 2009.10.15. */
+/*  */
+static void
+FillFakeTxDescriptor92D(
+	struct rtw_adapter *		adapter,
+	u8*			pDesc,
+	u32			BufferLen,
+	bool		IsPsPoll
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct tx_desc	*ptxdesc = (struct tx_desc *)pDesc;
+
+	/*  Clear all status */
+	memset(pDesc, 0, 32);
+
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG); /* own, bFirstSeg, bLastSeg; */
+
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000); /* 32 bytes for TX Desc */
+
+	ptxdesc->txdw0 |= cpu_to_le32(BufferLen&0x0000ffff); /*  Buffer size + command header */
+
+	/* offset 4 */
+	ptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT<<QSEL_SHT)&0x00001f00); /*  Fixed queue of Mgnt queue */
+
+	/* Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw. */
+	if (IsPsPoll)
+	{
+		ptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);
+	}
+	else
+	{
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
+	}
+
+	/* offset 16 */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+		ptxdesc->txdw5 |= cpu_to_le32(BIT(2));/*  use OFDM 6Mbps */
+
+	/*  USB interface drop packet if the checksum of descriptor isn't correct. */
+	/*  Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.). */
+	rtl8192du_cal_txdesc_chksum(ptxdesc);
+
+	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_, "FillFakeTxDescriptor92D(): H2C Tx Desc Content ----->\n", pDesc, TXDESC_SIZE);
+}
+
+/*  */
+/*  Description: Fill the reserved packets that FW will use to RSVD page. */
+/*			Now we just send 4 types packet to rsvd page. */
+/*			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp. */
+/*	Input: */
+/*	    dl_finish - FALSE: At the first time we will send all the packets as a large packet to Hw, */
+/*						so we need to set the packet length to total lengh. */
+/*			      TRUE: At the second time, we should send the first packet (default:beacon) */
+/*						to Hw again and set the lengh in descriptor to the real beacon lengh. */
+/*  2009.10.15 by tynli. */
+static void SetFwRsvdPagePkt(struct rtw_adapter * adapter, bool dl_finish)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct xmit_frame	*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	struct xmit_priv	*pxmitpriv = &(adapter->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u32	BeaconLength, ProbeRspLength, PSPollLength, NullFunctionDataLength;
+	u8	*reservedpagepacket;
+	u8	PageNum=0, U1bTmp, TxDescLen=0, TxDescOffset=0;
+	u16	BufIndex=0;
+	u32	TotalPacketLen;
+	u8	u1RsvdPageLoc[3]={0};
+	bool	dlok = false;
+
+	DBG_8192D("%s\n", __func__);
+
+	reservedpagepacket = (u8*)kmalloc(1000, GFP_KERNEL);
+	if (reservedpagepacket == NULL) {
+		DBG_8192D("%s(): alloc reservedpagepacket fail !!!\n", __func__);
+		return;
+	}
+
+	memset(reservedpagepacket, 0, 1000);
+
+	TxDescLen = 32;/* TX_DESC_SIZE; */
+
+	BufIndex = TXDESC_OFFSET;
+	TxDescOffset = TxDescLen+8; /* Shift index for 8 bytes because the dummy bytes in the first descipstor. */
+
+	/* 1) beacon */
+	ConstructBeacon(adapter,&reservedpagepacket[BufIndex],&BeaconLength);
+
+	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
+		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: BCN\n",
+		&reservedpagepacket[BufIndex], (BeaconLength+BufIndex));
+
+/*  */
+
+	/*  When we count the first page size, we need to reserve description size for the RSVD */
+	/*  packet, it will be filled in front of the packet in TXPKTBUF. */
+	U1bTmp = (u8)PageNum_128(BeaconLength+TxDescLen);
+	PageNum += U1bTmp;
+	/*  To reserved 2 pages for beacon buffer. 2010.06.24. */
+	if (PageNum == 1)
+		PageNum+=1;
+	pHalData->FwRsvdPageStartOffset = PageNum;
+
+	BufIndex = (PageNum*128) + TxDescOffset;
+
+	/* 2) ps-poll */
+	ConstructPSPoll(adapter, &reservedpagepacket[BufIndex],&PSPollLength);
+
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], PSPollLength, true);
+
+	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
+		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PS-POLL\n",
+		&reservedpagepacket[BufIndex-TxDescLen], (PSPollLength+TxDescLen));
+
+	SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1RsvdPageLoc, PageNum);
+
+/*  */
+
+	U1bTmp = (u8)PageNum_128(PSPollLength+TxDescLen);
+	PageNum += U1bTmp;
+
+	BufIndex = (PageNum*128) + TxDescOffset;
+
+	/* 3) null data */
+	ConstructNullFunctionData(
+		adapter,
+		&reservedpagepacket[BufIndex],
+		&NullFunctionDataLength,
+		get_my_bssid(&(pmlmeinfo->network)),
+		false);
+
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], NullFunctionDataLength, false);
+
+	SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1RsvdPageLoc, PageNum);
+
+	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
+		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: NULL DATA\n",
+		&reservedpagepacket[BufIndex-TxDescLen], (NullFunctionDataLength+TxDescLen));
+/*  */
+
+	U1bTmp = (u8)PageNum_128(NullFunctionDataLength+TxDescLen);
+	PageNum += U1bTmp;
+
+	BufIndex = (PageNum*128) + TxDescOffset;
+
+	/* 4) probe response */
+	ConstructProbeRsp(
+		adapter,
+		&reservedpagepacket[BufIndex],
+		&ProbeRspLength,
+		get_my_bssid(&(pmlmeinfo->network)),
+		false);
+
+	FillFakeTxDescriptor92D(adapter, &reservedpagepacket[BufIndex-TxDescLen], ProbeRspLength, false);
+
+	SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1RsvdPageLoc, PageNum);
+
+	RT_PRINT_DATA(_module_rtl8712_cmd_c_, _drv_info_,
+		"SetFwRsvdPagePkt(): HW_VAR_SET_TX_CMD: PROBE RSP\n",
+		&reservedpagepacket[BufIndex-TxDescLen], (ProbeRspLength-TxDescLen));
+
+/*  */
+
+	U1bTmp = (u8)PageNum_128(ProbeRspLength+TxDescLen);
+
+	PageNum += U1bTmp;
+
+	TotalPacketLen = (PageNum*128);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(adapter, pattrib);
+	pattrib->qsel = 0x10;
+	pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescLen;
+	memcpy(pmgntframe->buf_addr, reservedpagepacket, TotalPacketLen);
+
+	rtw_hal_mgnt_xmit(adapter, pmgntframe);
+
+	dlok = true;
+
+	if (dlok) {
+		DBG_8192D("Set RSVD page location to Fw.\n");
+		FillH2CCmd92D(adapter, H2C_RSVDPAGE, sizeof(u1RsvdPageLoc), u1RsvdPageLoc);
+	}
+
+	kfree(reservedpagepacket);
+}
+
+void rtl8192d_set_FwJoinBssReport_cmd(struct rtw_adapter* padapter, u8 mstatus)
+{
+	u8	u1JoinBssRptParm[1]={0};
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	bool	bRecover = false;
+
+	DBG_8192D("%s\n", __func__);
+
+	if (mstatus == 1)
+	{
+		/*  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C. */
+		/*  Suggested by filen. Added by tynli. */
+		rtw_write16(padapter, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
+		/*  Do not set TSF again here or vWiFi beacon DMA INT will not work. */
+		/* rtw_hal_set_hwreg(adapter, HW_VAR_CORRECT_TSF, (pu1Byte)(&bTypeIbss)); */
+		/*  Hw sequende enable by dedault. 2010.06.23. by tynli. */
+
+		/* set REG_CR bit 8 */
+		pHalData->RegCR_1 |= BIT0;
+		rtw_write8(padapter,  REG_CR+1, pHalData->RegCR_1);
+
+		/*  Disable Hw protection for a time which revserd for Hw sending beacon. */
+		/*  Fix download reserved page packet fail that access collision with the protection time. */
+		/*  2010.05.11. Added by tynli. */
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(3)));
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(4));
+
+		/*  Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame. */
+		if (pHalData->RegFwHwTxQCtrl&BIT6)
+			bRecover = true;
+		rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT6)));
+		pHalData->RegFwHwTxQCtrl &= (~BIT6);
+		SetFwRsvdPagePkt(padapter, 0);
+
+		/*  2010.05.11. Added by tynli. */
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(3));
+		rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)&(~BIT(4)));
+
+		/*  To make sure that if there exists an adapter which would like to send beacon. */
+		/*  If exists, the origianl value of 0x422[6] will be 1, we should check this to */
+		/*  prevent from setting 0x422[6] to 0 after download reserved page, or it will cause */
+		/*  the beacon cannot be sent by HW. */
+		/*  2010.06.23. Added by tynli. */
+		if (bRecover)
+		{
+			rtw_write8(padapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT6));
+			pHalData->RegFwHwTxQCtrl |= BIT6;
+		}
+
+		/*  Clear CR[8] or beacon packet will not be send to TxBuf anymore. */
+		pHalData->RegCR_1 &= (~BIT0);
+		rtw_write8(padapter,  REG_CR+1, pHalData->RegCR_1);
+	}
+
+	SET_H2CCMD_JOINBSSRPT_PARM_OPMODE(u1JoinBssRptParm, mstatus);
+
+	FillH2CCmd92D(padapter, H2C_JOINBSSRPT, 1, u1JoinBssRptParm);
+
+}
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+/*
+	ask FW to Reset sync register at Beacon early interrupt
+*/
+static u8 rtl8192d_reset_tsf(struct rtw_adapter *padapter, u8 reset_port)
+{
+	u8	buf[2];
+	u8	res=_SUCCESS;
+
+	if (IFACE_PORT0==reset_port) {
+		buf[0] = 0x1; buf[1] = 0;
+
+	} else {
+		buf[0] = 0x0; buf[1] = 0x1;
+	}
+	FillH2CCmd92D(padapter, H2C_92D_RESET_TSF, 2, buf);
+
+	return res;
+}
+
+int reset_tsf(struct rtw_adapter * adapter, u8 reset_port)
+{
+	u8 reset_cnt_before = 0, reset_cnt_after = 0, loop_cnt = 0;
+	u32 reg_reset_tsf_cnt = (IFACE_PORT0==reset_port) ?
+				REG_FW_RESET_TSF_CNT_0:REG_FW_RESET_TSF_CNT_1;
+
+	rtw_scan_abort(adapter->pbuddy_adapter);	/*	site survey will cause reset_tsf fail	*/
+	reset_cnt_after = reset_cnt_before = rtw_read8(adapter,reg_reset_tsf_cnt);
+	rtl8192d_reset_tsf(adapter, reset_port);
+
+	while ((reset_cnt_after == reset_cnt_before) && (loop_cnt < 10)) {
+		rtw_msleep_os(100);
+		loop_cnt++;
+		reset_cnt_after = rtw_read8(adapter, reg_reset_tsf_cnt);
+	}
+
+	return(loop_cnt >= 10) ? _FAIL : true;
+}
+
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
+
+#ifdef CONFIG_WOWLAN
+
+void rtl8192d_set_wowlan_cmd(struct rtw_adapter* padapter)
+{
+	u8	res=_SUCCESS;
+	u32 test=0;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	struct set_wowlan_parm pwowlan_parm;
+	struct pwrctrl_priv *pwrpriv=&padapter->pwrctrlpriv;
+
+	pwowlan_parm.mode =0;
+	pwowlan_parm.gpio_index=0;
+	pwowlan_parm.gpio_duration=0;
+	pwowlan_parm.second_mode =0;
+	pwowlan_parm.reserve=0;
+
+	if (pwrpriv->wowlan_mode ==true) {
+		/* pause RX DMA */
+		test = rtw_read8(padapter, REG_RXPKT_NUM+2);
+		test |= BIT(2);
+		rtw_write8(padapter, REG_RXPKT_NUM+2, test);
+		/* 286 BIT(1) , not 1(means idle) do rx urb */
+		test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
+		/* check DMA idle? */
+		while (test != BIT(1))
+		{
+			tasklet_schedule(&precvpriv->recv_tasklet);
+			test = rtw_read8(padapter, REG_RXPKT_NUM+2) & BIT(1);
+			rtw_msleep_os(10);
+		}
+		/* mask usb se0 reset by Alex and DD */
+		test = rtw_read8(padapter, 0xf8);
+		test &= ~(BIT(3)|BIT(4));
+		rtw_write8(padapter, 0xf8, test);
+
+		pwowlan_parm.mode |=FW_WOWLAN_FUN_EN;
+		if (pwrpriv->wowlan_pattern ==true) {
+			pwowlan_parm.mode |= FW_WOWLAN_PATTERN_MATCH;
+		}
+		if (pwrpriv->wowlan_magic ==true) {
+		}
+		if (pwrpriv->wowlan_unicast ==true) {
+			pwowlan_parm.mode |=FW_WOWLAN_UNICAST;
+		}
+
+		rtl8192d_set_FwJoinBssReport_cmd(padapter, 1);
+
+		/* WOWLAN_GPIO_ACTIVE means GPIO high active */
+		pwowlan_parm.mode |=FW_WOWLAN_REKEY_WAKEUP;
+		pwowlan_parm.mode |=FW_WOWLAN_DEAUTH_WAKEUP;
+
+		/* GPIO 0 */
+		pwowlan_parm.gpio_index=0;
+
+		/* duration unit is 64us */
+		pwowlan_parm.gpio_duration=0xff;
+
+		pwowlan_parm.second_mode|=FW_WOWLAN_GPIO_WAKEUP_EN;
+		pwowlan_parm.second_mode|=FW_FW_PARSE_MAGIC_PKT;
+		{	u8 *ptr=(u8 *)&pwowlan_parm;
+			printk("\n %s H2C_WO_WLAN=%x %02x:%02x:%02x:%02x:%02x\n",__func__,H2C_WO_WLAN_CMD,ptr[0],ptr[1],ptr[2],ptr[3],ptr[4]);
+		}
+		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
+
+		/* keep alive period = 3 * 10 BCN interval */
+		pwowlan_parm.mode =3;
+		pwowlan_parm.gpio_index=3;
+		FillH2CCmd92D(padapter, KEEP_ALIVE_CONTROL_CMD, 2, (u8 *)&pwowlan_parm);
+		printk("%s after KEEP_ALIVE_CONTROL_CMD register 0x81=%x\n",__func__,rtw_read8(padapter, 0x85));
+
+		pwowlan_parm.mode =1;
+		pwowlan_parm.gpio_index=0;
+		pwowlan_parm.gpio_duration=0;
+		FillH2CCmd92D(padapter, DISCONNECT_DECISION_CTRL_CMD, 3, (u8 *)&pwowlan_parm);
+		printk("%s after DISCONNECT_DECISION_CTRL_CMD register 0x81=%x\n",__func__,rtw_read8(padapter, 0x85));
+
+		/* enable GPIO wakeup */
+		pwowlan_parm.mode =1;
+		pwowlan_parm.gpio_index=0;
+		pwowlan_parm.gpio_duration=0;
+		FillH2CCmd92D(padapter, REMOTE_WAKE_CTRL_CMD, 1, (u8 *)&pwowlan_parm);
+		printk("%s after DISCONNECT_DECISION_CTRL_CMD register\n",__func__);
+
+	}
+	else
+		FillH2CCmd92D(padapter, H2C_WO_WLAN_CMD, 4, (u8 *)&pwowlan_parm);
+
+	return ;
+}
+
+#endif  /* CONFIG_WOWLAN */
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_dm.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_dm.c
new file mode 100644
index 0000000..ff2d5e7
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_dm.c
@@ -0,0 +1,2425 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*  */
+/*  Description: */
+/*  */
+/*  This file is for 92CE/92CU dynamic mechanism only */
+/*  */
+/*  */
+/*  */
+
+/*  */
+/*  include files */
+/*  */
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <hal_intf.h>
+
+#include <rtl8192d_hal.h>
+/* avoid to warn in FreeBSD */
+u32 EDCAParam[maxAP][3] =
+{          /*  UL			DL */
+	{0x5ea322, 0x00a630, 0x00a44f}, /* atheros AP */
+	{0x5ea32b, 0x5ea42b, 0x5e4322}, /* broadcom AP */
+	{0x3ea430, 0x00a630, 0x3ea44f}, /* cisco AP */
+	{0x5ea44f, 0x00a44f, 0x5ea42b}, /* marvell AP */
+	{0x5ea422, 0x00a44f, 0x00a44f}, /* ralink AP */
+	{0xa44f, 0x5ea44f, 0x5e431c}, /* realtek AP */
+	{0x5ea42b, 0xa630, 0x5e431c}, /* airgocap AP */
+	{0x5ea42b, 0x5ea42b, 0x5ea42b}, /* unknown AP */
+};
+
+/*-----------------------------------------------------------------------------
+ * Function:	dm_DIGInit()
+ *
+ * Overview:	Set DIG scheme init value.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *
+ *---------------------------------------------------------------------------*/
+static void dm_DIGInit(
+	struct rtw_adapter *	adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+
+	dm_digtable->dig_enable_flag = true;
+	dm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;
+
+	dm_digtable->curigvalue = 0x20;
+	dm_digtable->preigvalue = 0x0;
+
+	dm_digtable->curstaconnectstate = dm_digtable->prestaconnectstate = DIG_STA_DISCONNECT;
+	dm_digtable->curmultistaconnectstate = DIG_MultiSTA_DISCONNECT;
+
+	dm_digtable->rssilowthresh	= DM_DIG_THRESH_LOW;
+	dm_digtable->rssihighthresh	= DM_DIG_THRESH_HIGH;
+
+	dm_digtable->falowthresh	= DM_FALSEALARM_THRESH_LOW;
+	dm_digtable->fahighthresh	= DM_FALSEALARM_THRESH_HIGH;
+
+	dm_digtable->rx_gain_range_max = DM_DIG_MAX;
+	dm_digtable->rx_gain_range_min = DM_DIG_MIN;
+	dm_digtable->rx_gain_range_min_nolink = 0;
+
+	dm_digtable->backoffval = DM_DIG_BACKOFF_DEFAULT;
+	dm_digtable->backoffval_range_max = DM_DIG_BACKOFF_MAX;
+	dm_digtable->backoffval_range_min = DM_DIG_BACKOFF_MIN;
+
+	dm_digtable->precckpdstate = CCK_PD_STAGE_MAX;
+	dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
+	dm_digtable->forbiddenigi = DM_DIG_MIN;
+
+	dm_digtable->largefahit = 0;
+	dm_digtable->recover_cnt = 0;
+}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+static bool
+dm_DualMacGetParameterFromBuddyadapter(
+		struct rtw_adapter *	adapter
+)
+{
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct mlme_priv *pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
+
+	if (pHalData->MacPhyMode92D != DUALMAC_SINGLEPHY)
+		return false;
+
+	if (Buddyadapter == NULL)
+		return false;
+
+	if (pHalData->bSlaveOfDMSP)
+		return false;
+
+/* sherry sync with 92C_92D, 20110701 */
+	if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) && (!check_fwstate(pmlmepriv, _FW_LINKED))
+		&& (!check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)))
+		return true;
+	else
+		return false;
+}
+#endif
+
+static void
+odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(
+	struct rtw_adapter *	adapter
+)
+{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
+	struct dm_priv	*Buddydmpriv;
+	struct FALSE_ALARM_STATISTICS *FlaseAlmCntBuddyadapter;
+
+	if (Buddyadapter == NULL)
+		return;
+
+	if (adapter->DualMacConcurrent == false)
+		return;
+
+	Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+	FlaseAlmCntBuddyadapter = &(Buddydmpriv->falsealmcnt);
+
+	falsealmcnt->Cnt_Fast_Fsync =FlaseAlmCntBuddyadapter->Cnt_Fast_Fsync;
+	falsealmcnt->Cnt_SB_Search_fail =FlaseAlmCntBuddyadapter->Cnt_SB_Search_fail;
+	falsealmcnt->Cnt_Parity_Fail = FlaseAlmCntBuddyadapter->Cnt_Parity_Fail;
+	falsealmcnt->Cnt_Rate_Illegal = FlaseAlmCntBuddyadapter->Cnt_Rate_Illegal;
+	falsealmcnt->Cnt_Crc8_fail = FlaseAlmCntBuddyadapter->Cnt_Crc8_fail;
+	falsealmcnt->Cnt_Mcs_fail = FlaseAlmCntBuddyadapter->Cnt_Mcs_fail;
+
+	falsealmcnt->Cnt_Ofdm_fail =	falsealmcnt->Cnt_Parity_Fail + falsealmcnt->Cnt_Rate_Illegal +
+								falsealmcnt->Cnt_Crc8_fail + falsealmcnt->Cnt_Mcs_fail +
+								falsealmcnt->Cnt_Fast_Fsync + falsealmcnt->Cnt_SB_Search_fail;
+
+	/* hold cck counter */
+	falsealmcnt->Cnt_Cck_fail = FlaseAlmCntBuddyadapter->Cnt_Cck_fail;
+
+	falsealmcnt->Cnt_all = (	falsealmcnt->Cnt_Fast_Fsync +
+						falsealmcnt->Cnt_SB_Search_fail +
+						falsealmcnt->Cnt_Parity_Fail +
+						falsealmcnt->Cnt_Rate_Illegal +
+						falsealmcnt->Cnt_Crc8_fail +
+						falsealmcnt->Cnt_Mcs_fail +
+						falsealmcnt->Cnt_Cck_fail);
+
+#endif
+}
+
+static void
+odm_FalseAlarmCounterStatistics(
+	struct rtw_adapter *	adapter
+	)
+{
+	u32	ret_value;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
+	u8	BBReset;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
+	struct mlme_priv *pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
+#endif /* CONFIG_CONCURRENT_MODE */
+	/* hold ofdm counter */
+	PHY_SetBBReg(adapter, rOFDM0_LSTF, BIT31, 1); /* hold page C counter */
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT31, 1); /* hold page D counter */
+
+	ret_value = PHY_QueryBBReg(adapter, rOFDM0_FrameSync, bMaskDWord);
+	falsealmcnt->Cnt_Fast_Fsync = (ret_value&0xffff);
+	falsealmcnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter1, bMaskDWord);
+	falsealmcnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter2, bMaskDWord);
+	falsealmcnt->Cnt_Rate_Illegal = (ret_value&0xffff);
+	falsealmcnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);
+	ret_value = PHY_QueryBBReg(adapter, rOFDM_PHYCounter3, bMaskDWord);
+	falsealmcnt->Cnt_Mcs_fail = (ret_value&0xffff);
+
+	falsealmcnt->Cnt_Ofdm_fail =	falsealmcnt->Cnt_Parity_Fail + falsealmcnt->Cnt_Rate_Illegal +
+								falsealmcnt->Cnt_Crc8_fail + falsealmcnt->Cnt_Mcs_fail +
+								falsealmcnt->Cnt_Fast_Fsync + falsealmcnt->Cnt_SB_Search_fail;
+
+	if (pHalData->CurrentBandType92D != BAND_ON_5G)
+	{
+		/* hold cck counter */
+
+		ret_value = PHY_QueryBBReg(adapter, rCCK0_FACounterLower, bMaskByte0);
+		falsealmcnt->Cnt_Cck_fail = ret_value;
+
+		ret_value = PHY_QueryBBReg(adapter, rCCK0_FACounterUpper, bMaskByte3);
+		falsealmcnt->Cnt_Cck_fail +=  (ret_value& 0xff)<<8;
+	}
+	else
+	{
+		falsealmcnt->Cnt_Cck_fail = 0;
+	}
+
+	falsealmcnt->Cnt_all = (	falsealmcnt->Cnt_Fast_Fsync +
+						falsealmcnt->Cnt_SB_Search_fail +
+						falsealmcnt->Cnt_Parity_Fail +
+						falsealmcnt->Cnt_Rate_Illegal +
+						falsealmcnt->Cnt_Crc8_fail +
+						falsealmcnt->Cnt_Mcs_fail +
+						falsealmcnt->Cnt_Cck_fail);
+	adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
+#ifdef CONFIG_CONCURRENT_MODE
+	if (pbuddy_adapter)
+		pbuddy_adapter->recvpriv.falsealmcnt_all = falsealmcnt->Cnt_all;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	/* reset false alarm counter registers */
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, 0x08000000, 1);
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, 0x08000000, 0);
+	/* update ofdm counter */
+	PHY_SetBBReg(adapter, rOFDM0_LSTF, BIT31, 0); /* update page C counter */
+	PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT31, 0); /* update page D counter */
+	if (pHalData->CurrentBandType92D != BAND_ON_5G) {
+		/* reset cck counter */
+		PHY_SetBBReg(adapter, rCCK0_FalseAlarmReport, 0x0000c000, 0);
+		/* enable cck counter */
+		PHY_SetBBReg(adapter, rCCK0_FalseAlarmReport, 0x0000c000, 2);
+	}
+
+	/* BB Reset */
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+	{
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		{
+			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) && pHalData->bMasterOfDMSP && (check_fwstate(pmlmepriv, _FW_LINKED) == false))
+			{
+				/* before BB reset should do clock gated */
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+				BBReset = rtw_read8(adapter, 0x02);
+				rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+				rtw_write8(adapter, 0x02, BBReset|BIT0);
+				/* undo clock gated */
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+			}
+		}
+		else
+		{
+			if ((pHalData->CurrentBandType92D == BAND_ON_2_4G) &&(check_fwstate(pmlmepriv, _FW_LINKED) == false)
+#ifdef CONFIG_CONCURRENT_MODE
+				 && (check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == false)
+#endif /* CONFIG_CONCURRENT_MODE */
+			)
+			{
+				/* before BB reset should do clock gated */
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+				BBReset = rtw_read8(adapter, 0x02);
+				rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+				rtw_write8(adapter, 0x02, BBReset|BIT0);
+				/* undo clock gated */
+				rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+			}
+		}
+	}
+	else if (check_fwstate(pmlmepriv, _FW_LINKED) == false)
+	{
+		/* before BB reset should do clock gated */
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+		BBReset = rtw_read8(adapter, 0x02);
+		rtw_write8(adapter, 0x02, BBReset&(~BIT0));
+		rtw_write8(adapter, 0x02, BBReset|BIT0);
+		/* undo clock gated */
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+	}
+}
+
+static void
+odm_FindMinimumRSSI_Dmsp(
+	struct rtw_adapter *	adapter
+)
+{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	s32	rssi_val_min_back_for_mac0;
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
+	bool		rest_rssi = false;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct dm_priv	*Buddydmpriv;
+
+	if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+	{
+		if (Buddyadapter!= NULL)
+		{
+			Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+			if (pHalData->bSlaveOfDMSP)
+			{
+				Buddydmpriv->RssiValMinForAnotherMacOfDMSP = pdmpriv->MinUndecoratedPWDBForDM;
+			}
+			else
+			{
+				if (bGetValueFromBuddyadapter)
+				{
+					rest_rssi = true;
+					rssi_val_min_back_for_mac0 = pdmpriv->MinUndecoratedPWDBForDM;
+					pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->RssiValMinForAnotherMacOfDMSP;
+				}
+			}
+		}
+
+	}
+
+	if (rest_rssi)
+	{
+		rest_rssi = false;
+		pdmpriv->MinUndecoratedPWDBForDM = rssi_val_min_back_for_mac0;
+	}
+#endif
+}
+
+static void
+odm_FindMinimumRSSI_92D(
+struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	/* 1 1.Determine the minimum RSSI */
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&
+		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		pdmpriv->MinUndecoratedPWDBForDM = 0;
+	}
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	/*  Default port */
+	{
+		if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		{
+			pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+		}
+		else
+		{
+			pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->UndecoratedSmoothedPWDB;
+		}
+	}
+	else /*  associated entry pwdb */
+	{
+		pdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	}
+
+	odm_FindMinimumRSSI_Dmsp(adapter);
+
+}
+
+static u8
+odm_initial_gain_MinPWDB(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	s32	rssi_val_min = 0;
+	if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
+		rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
+					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	else
+		rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
+
+	return (u8)rssi_val_min;
+}
+
+static void
+DM_Write_DIG_DMSP(
+	struct rtw_adapter *	adapter
+	)
+{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	bool		bGetValueFromOtherMac = dm_DualMacGetParameterFromBuddyadapter(adapter);
+	struct dm_priv	*Buddydmpriv;
+
+	if (Buddyadapter == NULL)
+	{
+		if (pHalData->bMasterOfDMSP)
+		{
+			PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+			PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+			dm_digtable->preigvalue = dm_digtable->curigvalue;
+		}
+		else
+		{
+			dm_digtable->preigvalue = dm_digtable->curigvalue;
+		}
+		return;
+	}
+
+	if (bGetValueFromOtherMac)
+	{
+		if (pdmpriv->bWriteDigForAnotherMacOfDMSP)
+		{
+			pdmpriv->bWriteDigForAnotherMacOfDMSP = false;
+			PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
+			PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, pdmpriv->CurDigValueForAnotherMacOfDMSP);
+		}
+	}
+
+	Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+
+	if (dm_digtable->preigvalue != dm_digtable->curigvalue)
+	{
+		/*  Set initial gain. */
+		/*  20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity. */
+		/*  Just not to modified it for SD3 testing. */
+		 if (pHalData->bSlaveOfDMSP)
+		 {
+			Buddydmpriv->bWriteDigForAnotherMacOfDMSP = true;
+			Buddydmpriv->CurDigValueForAnotherMacOfDMSP =  dm_digtable->curigvalue;
+		 }
+		else
+		{
+			if (!bGetValueFromOtherMac)
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+				PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+			}
+		}
+		dm_digtable->preigvalue = dm_digtable->curigvalue;
+	}
+#endif
+}
+
+static void
+DM_Write_DIG(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+
+	if (dm_digtable->dig_enable_flag == false)
+		return;
+
+	if ((dm_digtable->preigvalue != dm_digtable->curigvalue) || (adapter->bForceWriteInitGain))
+	{
+		/*  Set initial gain. */
+		/*  20100211 Joseph: Set only BIT0~BIT6 for DIG. BIT7 is the function switch of Antenna diversity. */
+		/*  Just not to modified it for SD3 testing. */
+		PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dm_digtable->curigvalue);
+		PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dm_digtable->curigvalue);
+		if (dm_digtable->curigvalue != 0x17)
+			dm_digtable->preigvalue = dm_digtable->curigvalue;
+	}
+}
+
+static void odm_DIG(
+	struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv	*pmlmepriv = &(adapter->mlmepriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct registry_priv	 *pregistrypriv = &adapter->registrypriv;
+	struct FALSE_ALARM_STATISTICS *falsealmcnt = &(pdmpriv->falsealmcnt);
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+	static u8	DIG_Dynamic_MIN_0 = 0x25;
+	static u8	DIG_Dynamic_MIN_1 = 0x25;
+	u8	DIG_Dynamic_MIN;
+	static bool	bMediaConnect_0 = false;
+	static bool	bMediaConnect_1 = false;
+	bool		FirstConnect;
+	u8	TxRate = rtw_read8(adapter, REG_INIDATA_RATE_SEL);
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pbuddy_pHalData = GET_HAL_DATA(pbuddy_adapter);
+	struct mlme_priv	*pbuddy_pmlmepriv = &(pbuddy_adapter->mlmepriv);
+	struct dm_priv	*pbuddy_pdmpriv = &pbuddy_pHalData->dmpriv;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+	{
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		{
+			if (pHalData->bMasterOfDMSP)
+			{
+				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
+			}
+			else
+			{
+				DIG_Dynamic_MIN = DIG_Dynamic_MIN_1;
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
+			}
+		}
+		else
+		{
+			if (pHalData->CurrentBandType92D==BAND_ON_5G)
+			{
+				DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
+#ifdef CONFIG_CONCURRENT_MODE
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true ||check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+				) && (bMediaConnect_0 == false);
+#else
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
+#endif /* CONFIG_CONCURRENT_MODE */
+			}
+			else
+			{
+				DIG_Dynamic_MIN = DIG_Dynamic_MIN_1;
+#ifdef CONFIG_CONCURRENT_MODE
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+				) && (bMediaConnect_1 == false);
+#else
+				FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_1 == false);
+#endif /* CONFIG_CONCURRENT_MODE */
+			}
+		}
+	}
+	else
+	{
+		DIG_Dynamic_MIN = DIG_Dynamic_MIN_0;
+#ifdef CONFIG_CONCURRENT_MODE
+		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true
+		) && (bMediaConnect_0 == false);
+#else
+		FirstConnect = (check_fwstate(pmlmepriv, _FW_LINKED) == true) && (bMediaConnect_0 == false);
+#endif /* CONFIG_CONCURRENT_MODE */
+	}
+
+#ifndef CONFIG_CONCURRENT_MODE
+	if (pdmpriv->bDMInitialGainEnable == false)
+		return;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG) || !(pbuddy_pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+#else
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+#endif /* CONFIG_CONCURRENT_MODE */
+		return;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS || pbuddy_adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
+#else
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)
+#endif /* CONFIG_CONCURRENT_MODE */
+		return;
+
+	/* 1 Boundary Decision */
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+#else
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		/* 2 Get minimum RSSI value among associated devices */
+		dm_digtable->rssi_val_min = odm_initial_gain_MinPWDB(adapter);
+
+		/* 2 Modify DIG upper bound */
+		if ((dm_digtable->rssi_val_min + 20) > DM_DIG_MAX)
+			dm_digtable->rx_gain_range_max = DM_DIG_MAX;
+		else
+			dm_digtable->rx_gain_range_max = dm_digtable->rssi_val_min + 20;
+		/* 2 Modify DIG lower bound */
+		if ((falsealmcnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
+			DIG_Dynamic_MIN++;
+		if ((falsealmcnt->Cnt_all < 500)&&(DIG_Dynamic_MIN > DM_DIG_MIN))
+			DIG_Dynamic_MIN--;
+		if ((dm_digtable->rssi_val_min < 8) && (DIG_Dynamic_MIN > DM_DIG_MIN))
+			DIG_Dynamic_MIN--;
+	} else {
+		dm_digtable->rx_gain_range_max = DM_DIG_MAX;
+		DIG_Dynamic_MIN = DM_DIG_MIN;
+	}
+
+	/* 1 Modify DIG lower bound, deal with abnorally large false alarm */
+	if (falsealmcnt->Cnt_all > 10000)
+	{
+		dm_digtable->largefahit++;
+		if (dm_digtable->forbiddenigi < dm_digtable->curigvalue)
+		{
+			dm_digtable->forbiddenigi = dm_digtable->curigvalue;
+			dm_digtable->largefahit = 1;
+		}
+
+		if (dm_digtable->largefahit >= 3)
+		{
+			if ((dm_digtable->forbiddenigi+1) >dm_digtable->rx_gain_range_max)
+				dm_digtable->rx_gain_range_min = dm_digtable->rx_gain_range_max;
+			else
+				dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
+			dm_digtable->recover_cnt = 3600; /* 3600=2hr */
+		}
+
+	}
+	else
+	{
+		/* Recovery mechanism for IGI lower bound */
+		if (dm_digtable->recover_cnt != 0)
+			dm_digtable->recover_cnt --;
+		else
+		{
+			if (dm_digtable->largefahit == 0)
+			{
+				if ((dm_digtable->forbiddenigi -1) < DIG_Dynamic_MIN) /* DM_DIG_MIN) */
+				{
+					dm_digtable->forbiddenigi = DIG_Dynamic_MIN; /* DM_DIG_MIN; */
+					dm_digtable->rx_gain_range_min = DIG_Dynamic_MIN; /* DM_DIG_MIN; */
+				}
+				else
+				{
+					dm_digtable->forbiddenigi --;
+					dm_digtable->rx_gain_range_min = (dm_digtable->forbiddenigi + 1);
+				}
+			}
+			else if (dm_digtable->largefahit == 3)
+			{
+				dm_digtable->largefahit = 0;
+			}
+		}
+
+	}
+
+	/* 1 Adjust initial gain by false alarm */
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+#else
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		if (FirstConnect) {
+			dm_digtable->curigvalue = dm_digtable->rssi_val_min;
+		} else {
+			if (IS_HARDWARE_TYPE_8192D(adapter)) {
+				if (falsealmcnt->Cnt_all > DM_DIG_FA_TH2_92D)
+					dm_digtable->curigvalue = dm_digtable->preigvalue+2;
+				else if (falsealmcnt->Cnt_all > DM_DIG_FA_TH1_92D)
+					dm_digtable->curigvalue = dm_digtable->preigvalue+1;
+				else if (falsealmcnt->Cnt_all < DM_DIG_FA_TH0_92D)
+					dm_digtable->curigvalue =dm_digtable->preigvalue-1;
+			} else {
+				if (falsealmcnt->Cnt_all > DM_DIG_FA_TH2)
+					dm_digtable->curigvalue = dm_digtable->preigvalue+2;
+				else if (falsealmcnt->Cnt_all > DM_DIG_FA_TH1)
+					dm_digtable->curigvalue = dm_digtable->preigvalue+1;
+				else if (falsealmcnt->Cnt_all < DM_DIG_FA_TH0)
+					dm_digtable->curigvalue = dm_digtable->preigvalue-1;
+			}
+		}
+	} else {
+		/*	There is no network interface connects to AP. */
+		if (0 == dm_digtable->rx_gain_range_min_nolink) {
+			/*	First time to enter odm_DIG function and set the default value to rx_gain_range_min_nolink */
+			dm_digtable->rx_gain_range_min_nolink = 0x30;
+		} else {
+			if ((falsealmcnt->Cnt_all > 1000) && (falsealmcnt->Cnt_all < 2000)) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink + 1) > 0x3e) ?
+							0x3e : (dm_digtable->rx_gain_range_min_nolink + 1) ;
+			} else if (falsealmcnt->Cnt_all >= 2000) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink + 2) > 0x3e) ?
+							0x3e : (dm_digtable->rx_gain_range_min_nolink + 2) ;
+			} else if (falsealmcnt->Cnt_all < 500) {
+				dm_digtable->rx_gain_range_min_nolink = ((dm_digtable->rx_gain_range_min_nolink - 1) < 0x1e) ?
+							0x1e : (dm_digtable->rx_gain_range_min_nolink - 1) ;
+			}
+		}
+
+		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min_nolink;
+	}
+	/* 1 Check initial gain by upper/lower bound */
+	if (dm_digtable->curigvalue > dm_digtable->rx_gain_range_max)
+		dm_digtable->curigvalue = dm_digtable->rx_gain_range_max;
+
+	if (dm_digtable->curigvalue < dm_digtable->rx_gain_range_min)
+		dm_digtable->curigvalue = dm_digtable->rx_gain_range_min;
+
+	if (adapter->bRxRSSIDisplay)
+	{
+		DBG_8192D("Modify DIG algorithm for DMP DIG: RxGainMin = %X, RxGainMax = %X\n",
+			dm_digtable->rx_gain_range_min,
+			dm_digtable->rx_gain_range_max);
+	}
+
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+	{
+		/* sherry  delete DualMacSmartConncurrent 20110517 */
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		{
+			DM_Write_DIG_DMSP(adapter);
+			if (pHalData->bMasterOfDMSP)
+			{
+				bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
+				DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+				bMediaConnect_1 = check_fwstate(pmlmepriv, _FW_LINKED);
+				DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+		else
+		{
+			DM_Write_DIG(adapter);
+			if (pHalData->CurrentBandType92D==BAND_ON_5G)
+			{
+#ifdef CONFIG_CONCURRENT_MODE
+				bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
+#else
+				bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
+#endif /* CONFIG_CONCURRENT_MODE */
+				DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+			}
+			else
+			{
+#ifdef CONFIG_CONCURRENT_MODE
+				bMediaConnect_1 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
+#else
+				bMediaConnect_1 = check_fwstate(pmlmepriv, _FW_LINKED);
+#endif /* CONFIG_CONCURRENT_MODE */
+				DIG_Dynamic_MIN_1 = DIG_Dynamic_MIN;
+			}
+		}
+	}
+	else
+	{
+		DM_Write_DIG(adapter);
+#ifdef CONFIG_CONCURRENT_MODE
+		bMediaConnect_0 = (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED));
+#else
+		bMediaConnect_0 = check_fwstate(pmlmepriv, _FW_LINKED);
+#endif /* CONFIG_CONCURRENT_MODE */
+		DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;
+	}
+
+	if ((pregistrypriv->lowrate_two_xmit) && IS_HARDWARE_TYPE_8192D(adapter) &&
+		(pHalData->MacPhyMode92D != DUALMAC_DUALPHY) && (!pregistrypriv->special_rf_path))
+	{
+		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
+#ifdef CONFIG_CONCURRENT_MODE
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true || check_fwstate(pbuddy_pmlmepriv, _FW_LINKED) == true)
+#else
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+#endif /* CONFIG_CONCURRENT_MODE */
+		{
+			if (dm_digtable->rssi_val_min  <= 30)   /* low rate 2T2R settings */
+			{
+				/* Reg90C=0x83321333 (OFDM 2T) */
+				/* RegA07=0xc1            (CCK 2T2R) */
+				/* RegA11=0x9b            (no switch polarity of two antenna) */
+				/* RegA20=0x10            (extend CS ratio as X1.125) */
+				/* RegA2E=0xdf             (MRC on) */
+				/* RegA2F=0x10            (CDD 90ns for path-B) */
+				/* RegA75=0x01            (antenna selection enable) */
+
+				rtw_write32(adapter, 0x90C, 0x83321333);
+				rtw_write8(adapter, 0xA07, 0xc1);
+				rtw_write8(adapter, 0xA11, 0x9b);
+				rtw_write8(adapter, 0xA20, 0x10);
+				rtw_write8(adapter, 0xA2E, 0xdf);
+				rtw_write8(adapter, 0xA2F, 0x10);
+				rtw_write8(adapter, 0xA75, 0x01);
+
+			}
+			else if (dm_digtable->rssi_val_min  >= 35)  /* low rate 1T1R Settings */
+			{
+				/* Reg90C=0x81121313 */
+				/* RegA07=0x80 */
+				/* RegA11=0xbb */
+				/* RegA20=0x00 */
+				/* RegA2E=0xd3 */
+				/* RegA2F=0x00 */
+				/* RegA75=0x00 */
+
+				rtw_write32(adapter, 0x90C, 0x81121313);
+				rtw_write8(adapter, 0xA07, 0x80);
+				rtw_write8(adapter, 0xA11, 0xbb);
+				rtw_write8(adapter, 0xA20, 0x00);
+				rtw_write8(adapter, 0xA2E, 0xd3);
+				rtw_write8(adapter, 0xA2F, 0x00);
+				rtw_write8(adapter, 0xA75, 0x00);
+			}
+
+		}
+
+	}
+
+}
+
+static u8
+dm_initial_gain_MinPWDB(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	s32	rssi_val_min = 0;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+
+	if ((dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT) &&
+	   (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)) {
+		if (pdmpriv->EntryMinUndecoratedSmoothedPWDB != 0)
+			rssi_val_min  =  (pdmpriv->EntryMinUndecoratedSmoothedPWDB > pdmpriv->UndecoratedSmoothedPWDB)?
+					pdmpriv->UndecoratedSmoothedPWDB:pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+		else
+			rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
+	}
+	else if (	dm_digtable->curstaconnectstate == DIG_STA_CONNECT ||
+			dm_digtable->curstaconnectstate == DIG_STA_BEFORE_CONNECT)
+		rssi_val_min = pdmpriv->UndecoratedSmoothedPWDB;
+	else if (dm_digtable->curmultistaconnectstate == DIG_MultiSTA_CONNECT)
+		rssi_val_min = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+
+	return (u8)rssi_val_min;
+}
+
+static void dm_CCK_PacketDetectionThresh_DMSP(
+	struct rtw_adapter *	adapter)
+{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
+	struct dm_priv	*Buddydmpriv;
+
+	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT)
+	{
+		dm_digtable->rssi_val_min = dm_initial_gain_MinPWDB(adapter);
+		if (dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI)
+		{
+			if (dm_digtable->rssi_val_min <= 25)
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
+			else
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
+		}
+		else {
+			if (dm_digtable->rssi_val_min <= 20)
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
+			else
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
+		}
+	}
+	else
+		dm_digtable->curcckpdstate=CCK_PD_STAGE_MAX;
+
+	if (bGetValueFromBuddyadapter)
+	{
+		DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 1 connect,mac 0 disconnect case\n");
+		if (pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP)
+		{
+			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac1\n");
+			if (pdmpriv->curcckpdstateForAnotherMacOfDMSP == CCK_PD_STAGE_LOWRSSI)
+			{
+				PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
+			}
+			else
+			{
+				PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
+
+			}
+			pdmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = false;
+		}
+	}
+
+	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate)
+	{
+		if (Buddyadapter == NULL)
+		{
+			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): Buddyadapter == NULL case\n");
+			if (pHalData->bSlaveOfDMSP)
+			{
+				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
+			}
+			else
+			{
+				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+				{
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
+				}
+				else
+				{
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
+
+				}
+				dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
+			}
+			return;
+		}
+
+		if (pHalData->bSlaveOfDMSP)
+		{
+			Buddydmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+			DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): bslave case\n");
+			Buddydmpriv->bChangeCCKPDStateForAnotherMacOfDMSP = true;
+			Buddydmpriv->curcckpdstateForAnotherMacOfDMSP = dm_digtable->curcckpdstate;
+		}
+		else
+		{
+			if (!bGetValueFromBuddyadapter)
+			{
+				DBG_8192D("dm_CCK_PacketDetectionThresh_DMSP(): mac 0 set for mac0\n");
+				if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+				{
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
+				}
+				else
+				{
+					PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
+
+				}
+			}
+		}
+		dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
+	}
+#endif
+}
+
+static void dm_CCK_PacketDetectionThresh(struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct DIG_T *dm_digtable = &pdmpriv->DM_DigTable;
+
+	if (dm_digtable->curstaconnectstate == DIG_STA_CONNECT) {
+		if (dm_digtable->precckpdstate == CCK_PD_STAGE_LOWRSSI) {
+			if (pdmpriv->MinUndecoratedPWDBForDM <= 25)
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
+			else
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
+		} else {
+			if (pdmpriv->MinUndecoratedPWDBForDM <= 20)
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_LOWRSSI;
+			else
+				dm_digtable->curcckpdstate = CCK_PD_STAGE_HIGHRSSI;
+		}
+	} else {
+		dm_digtable->curcckpdstate=CCK_PD_STAGE_LOWRSSI;
+	}
+
+	if (dm_digtable->precckpdstate != dm_digtable->curcckpdstate) {
+		if (dm_digtable->curcckpdstate == CCK_PD_STAGE_LOWRSSI)
+			PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0x83);
+		else
+			PHY_SetBBReg(adapter, rCCK0_CCA, maskbyte2, 0xcd);
+		dm_digtable->precckpdstate = dm_digtable->curcckpdstate;
+	}
+}
+
+static void dm_1R_CCA(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct PS_T *dm_pstable = &pdmpriv->DM_PSTable;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+      if (pHalData->CurrentBandType92D == BAND_ON_5G)
+      {
+		if (pdmpriv->MinUndecoratedPWDBForDM != 0)
+		{
+			if (dm_pstable->preccastate == CCA_2R || dm_pstable->preccastate == CCA_MAX)
+			{
+				if (pdmpriv->MinUndecoratedPWDBForDM >= 35)
+					dm_pstable->curccastate = CCA_1R;
+				else
+					dm_pstable->curccastate = CCA_2R;
+
+			}
+			else {
+				if (pdmpriv->MinUndecoratedPWDBForDM <= 30)
+					dm_pstable->curccastate = CCA_2R;
+				else
+					dm_pstable->curccastate = CCA_1R;
+			}
+		}
+		else	/* disconnect */
+		{
+			dm_pstable->curccastate=CCA_MAX;
+		}
+
+		if (dm_pstable->preccastate != dm_pstable->curccastate)
+		{
+			if (dm_pstable->curccastate == CCA_1R)
+			{
+				if (pHalData->rf_type == RF_2T2R)
+				{
+					if (pregistrypriv->special_rf_path == 1) /*  path A only */
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+					else if (pregistrypriv->special_rf_path == 2) /* path B only */
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+					else
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x13);
+					/* PHY_SetBBReg(adapter, 0xe70, bMaskByte3, 0x20); */
+				}
+				else
+				{
+					if (pregistrypriv->special_rf_path == 1) /*  path A only */
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+					else if (pregistrypriv->special_rf_path == 2) /* path B only */
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+					else
+						PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x23);
+				}
+			} else if (dm_pstable->curccastate == CCA_2R || dm_pstable->curccastate == CCA_MAX) {
+				if (pregistrypriv->special_rf_path == 1) /*  path A only */
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x11);
+				else if (pregistrypriv->special_rf_path == 2) /* path B only */
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x22);
+				else
+					PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable  , bMaskByte0, 0x33);
+			}
+			dm_pstable->preccastate = dm_pstable->curccastate;
+		}
+	}
+}
+
+static void dm_InitDynamicTxPower(struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	pdmpriv->bDynamicTxPowerEnable = false;
+
+	pdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;
+	pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+}
+
+static void odm_DynamicTxPower_92D(struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	int	UndecoratedSmoothedPWDB;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct dm_priv	*pbuddy_dmpriv = NULL;
+	bool		bGetValueFromBuddyadapter = dm_DualMacGetParameterFromBuddyadapter(adapter);
+	u8		HighPowerLvlBackForMac0 = TxHighPwrLevel_Level1;
+#endif
+
+	/*  If dynamic high power is disabled. */
+	if ((pdmpriv->bDynamicTxPowerEnable != true) ||
+		(!(pdmpriv->DMFlag & DYNAMIC_FUNC_HP)))
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		return;
+	}
+
+	/*  STA not connected and AP not connected */
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) != true) &&
+		(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))
+	{
+		pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+
+		/* the LastDTPlvl should reset when disconnect, */
+		/* otherwise the tx power level wouldn't change when disconnect and connect again. */
+		/*  Maddest 20091220. */
+		pdmpriv->LastDTPLvl=TxHighPwrLevel_Normal;
+		return;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)	/*  Default port */
+	{
+		/* todo: AP Mode */
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		       (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+		}
+	}
+	else /*  associated entry pwdb */
+	{
+		UndecoratedSmoothedPWDB = pdmpriv->EntryMinUndecoratedSmoothedPWDB;
+	}
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G) {
+		if (UndecoratedSmoothedPWDB >= 0x33)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+		}
+		else if ((UndecoratedSmoothedPWDB <0x33) &&
+			(UndecoratedSmoothedPWDB >= 0x2b))
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+		}
+		else if (UndecoratedSmoothedPWDB < 0x2b)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		}
+	}
+	else
+	{
+		if (UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL2)
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level2;
+		}
+		else if ((UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL2-3)) &&
+			(UndecoratedSmoothedPWDB >= TX_POWER_NEAR_FIELD_THRESH_LVL1))
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Level1;
+		}
+		else if (UndecoratedSmoothedPWDB < (TX_POWER_NEAR_FIELD_THRESH_LVL1-5))
+		{
+			pdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;
+		}
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (bGetValueFromBuddyadapter)
+	{
+		DBG_8192D("dm_DynamicTxPower() mac 0 for mac 1\n");
+		if (pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP)
+		{
+			DBG_8192D("dm_DynamicTxPower() change value\n");
+			HighPowerLvlBackForMac0 = pdmpriv->DynamicTxHighPowerLvl;
+			pdmpriv->DynamicTxHighPowerLvl = pdmpriv->CurTxHighLvlForAnotherMacOfDMSP;
+			PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
+			pdmpriv->DynamicTxHighPowerLvl = HighPowerLvlBackForMac0;
+			pdmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = false;
+		}
+	}
+#endif
+
+	if ((pdmpriv->DynamicTxHighPowerLvl != pdmpriv->LastDTPLvl))
+	{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (adapter->DualMacConcurrent == true)
+		{
+			if (Buddyadapter == NULL)
+			{
+				DBG_8192D("dm_DynamicTxPower() Buddyadapter == NULL case\n");
+				if (!pHalData->bSlaveOfDMSP)
+				{
+					PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
+				}
+			}
+			else
+			{
+				if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+				{
+					DBG_8192D("dm_DynamicTxPower() Buddyadapter DMSP\n");
+					if (pHalData->bSlaveOfDMSP)
+					{
+						DBG_8192D("dm_DynamicTxPower() bslave case\n");
+						pbuddy_dmpriv = &GET_HAL_DATA(Buddyadapter)->dmpriv;
+						pbuddy_dmpriv->bChangeTxHighPowerLvlForAnotherMacOfDMSP = true;
+						pbuddy_dmpriv->CurTxHighLvlForAnotherMacOfDMSP = pdmpriv->DynamicTxHighPowerLvl;
+					}
+					else
+					{
+						DBG_8192D("dm_DynamicTxPower() master case\n");
+						if (!bGetValueFromBuddyadapter)
+						{
+							DBG_8192D("dm_DynamicTxPower() mac 0 for mac 0\n");
+							PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
+						}
+					}
+				}
+				else
+				{
+					DBG_8192D("dm_DynamicTxPower() Buddyadapter DMDP\n");
+					PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
+				}
+			}
+		}
+		else
+#endif
+		{
+			PHY_SetTxPowerLevel8192D(adapter, pHalData->CurrentChannel);
+		}
+	}
+	pdmpriv->LastDTPLvl = pdmpriv->DynamicTxHighPowerLvl;
+}
+
+static void PWDB_Monitor(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	int	i;
+	int	tmpEntryMaxPWDB=0, tmpEntryMinPWDB=0xff;
+	u8	sta_cnt=0;
+	u32	PWDB_rssi[NUM_STA]={0};/* 0~15]:MACID, [16~31]:PWDB_rssi */
+
+	if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+	{
+		struct list_head *plist, *phead;
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &adapter->stapriv;
+		u8 bcast_addr[ETH_ALEN]= {0xff,0xff,0xff,0xff,0xff,0xff};
+
+		spin_lock_bh(&pstapriv->sta_hash_lock);
+
+		for (i=0; i< NUM_STA; i++)
+		{
+			phead = &(pstapriv->sta_hash[i]);
+			plist = phead->next;
+
+			while ((rtw_end_of_queue_search(phead, plist)) == false)
+			{
+				psta = container_of(plist, struct sta_info, hash_list);
+
+				plist = plist->next;
+
+				if (_rtw_memcmp(psta	->hwaddr, bcast_addr, ETH_ALEN) ||
+					_rtw_memcmp(psta->hwaddr, myid(&adapter->eeprompriv), ETH_ALEN))
+					continue;
+
+				if (psta->state & WIFI_ASOC_STATE)
+				{
+
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16) | ((adapter->stapriv.asoc_sta_count+1) << 8));
+				}
+			}
+		}
+
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+		if (pHalData->fw_ractrl == true)
+		{
+			/*  Report every sta's RSSI to FW */
+			for (i=0; i< sta_cnt; i++)
+			{
+				FillH2CCmd92D(adapter, H2C_RSSI_REPORT, 3, (u8 *)(&PWDB_rssi[i]));
+			}
+		}
+	}
+
+	if (tmpEntryMaxPWDB != 0)	/*  If associated entry is found */
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;
+	}
+	else
+	{
+		pdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;
+	}
+
+	if (tmpEntryMinPWDB != 0xff) /*  If associated entry is found */
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;
+	}
+	else
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
+	}
+
+	if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE) == true
+		&& check_fwstate(&adapter->mlmepriv, _FW_LINKED) == true)
+	{
+		/*  Indicate Rx signal strength to FW. */
+		if (pHalData->fw_ractrl == true)
+		{
+			u32	temp = 0;
+
+			temp = pdmpriv->UndecoratedSmoothedPWDB;
+			temp = temp << 16;
+
+			/*  fw v12 cmdid 5:use max macid ,for nic ,default macid is 0 ,max macid is 1 */
+
+			/*  Commented by Kurt 20120705 */
+			/*  We could set max mac_id to FW without checking how many STAs we allocated */
+			/*  It's recommanded by SD3 */
+			/*  Original: temp = temp | ((adapter->stapriv.asoc_sta_count+1) << 8); */
+			temp = temp | ((32) << 8);
+
+			FillH2CCmd92D(adapter, H2C_RSSI_REPORT, 3, (u8 *)(&temp));
+		}
+		else
+		{
+			rtw_write8(adapter, 0x4fe, (u8)pdmpriv->UndecoratedSmoothedPWDB);
+		}
+	}
+}
+
+static void
+DM_InitEdcaTurbo(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	pHalData->bCurrentTurboEDCA = false;
+	adapter->recvpriv.bIsAnyNonBEPkts = false;
+}	/*  DM_InitEdcaTurbo */
+
+static void dm_CheckEdcaTurbo(struct rtw_adapter *adapter)
+{
+	u32	trafficIndex;
+	u32	edca_param;
+	u64	cur_tx_bytes = 0;
+	u64	cur_rx_bytes = 0;
+	u32	EDCA_BE[2] = {0x5ea42b, 0x5ea42b};
+	u8	bbtchange = false;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv *pdmpriv = &pHalData->dmpriv;
+	struct xmit_priv *pxmitpriv = &(adapter->xmitpriv);
+	struct recv_priv *precvpriv = &(adapter->recvpriv);
+	struct registry_priv *pregpriv = &adapter->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
+	{
+		EDCA_BE[UP_LINK] = 0x5ea42b;
+		EDCA_BE[DOWN_LINK] = 0x5ea42b;
+	}
+	else
+	{
+		EDCA_BE[UP_LINK] = 0x6ea42b;
+		EDCA_BE[DOWN_LINK] = 0x6ea42b;
+	}
+
+	if ((pregpriv->wifi_spec == 1) || (pmlmeext->cur_wireless_mode == WIRELESS_11B))
+	{
+		goto dm_CheckEdcaTurbo_EXIT;
+	}
+
+	if (pmlmeinfo->assoc_AP_vendor >= maxAP)
+	{
+		goto dm_CheckEdcaTurbo_EXIT;
+	}
+
+	/*  Check if the status needs to be changed. */
+	if ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts))
+	{
+		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
+		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
+
+		/* traffic, TX or RX */
+		if ((pmlmeinfo->assoc_AP_vendor == ralinkAP)||(pmlmeinfo->assoc_AP_vendor == atherosAP))
+		{
+			if (cur_tx_bytes > (cur_rx_bytes << 2))
+			{ /*  Uplink TP is present. */
+				trafficIndex = UP_LINK;
+			}
+			else
+			{ /*  Balance TP is present. */
+				trafficIndex = DOWN_LINK;
+			}
+		}
+		else
+		{
+			if (cur_rx_bytes > (cur_tx_bytes << 2))
+			{ /*  Downlink TP is present. */
+				trafficIndex = DOWN_LINK;
+			}
+			else
+			{ /*  Balance TP is present. */
+				trafficIndex = UP_LINK;
+			}
+		}
+
+		if ((pdmpriv->prv_traffic_idx != trafficIndex) || (!pHalData->bCurrentTurboEDCA))
+		{
+			{
+				if ((pmlmeinfo->assoc_AP_vendor == ciscoAP) && (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N)))
+				{
+					edca_param = EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex];
+				}
+				else if ((pmlmeinfo->assoc_AP_vendor == airgocapAP) &&
+					((pmlmeext->cur_wireless_mode == WIRELESS_11G) ||(pmlmeext->cur_wireless_mode == WIRELESS_11BG)))
+				{
+					if (trafficIndex == DOWN_LINK)
+						edca_param = 0xa630;
+					else
+						edca_param = EDCA_BE[trafficIndex];
+				}
+				else if ((pmlmeinfo->assoc_AP_vendor == atherosAP) &&
+					(pmlmeext->cur_wireless_mode&WIRELESS_11_5N))
+				{
+					if (trafficIndex == DOWN_LINK)
+						edca_param = 0xa42b;
+					else
+						edca_param = EDCA_BE[trafficIndex];
+				}
+				else
+				{
+					edca_param = EDCA_BE[trafficIndex];
+				}
+			}
+
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, edca_param);
+
+			pdmpriv->prv_traffic_idx = trafficIndex;
+		}
+
+		pHalData->bCurrentTurboEDCA = true;
+	}
+	else
+	{
+		/*  */
+		/*  Turn Off EDCA turbo here. */
+		/*  Restore original EDCA according to the declaration of AP. */
+		/*  */
+		 if (pHalData->bCurrentTurboEDCA)
+		{
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
+			pHalData->bCurrentTurboEDCA = false;
+		}
+	}
+
+dm_CheckEdcaTurbo_EXIT:
+	/*  Set variables for next time. */
+	precvpriv->bIsAnyNonBEPkts = false;
+	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
+	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
+}	/*  dm_CheckEdcaTurbo */
+
+static void dm_InitDynamicBBPowerSaving(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct PS_T *dm_pstable = &pdmpriv->DM_PSTable;
+
+	dm_pstable->preccastate = CCA_MAX;
+	dm_pstable->curccastate = CCA_MAX;
+	dm_pstable->prerfstate = RF_MAX;
+	dm_pstable->currfstate = RF_MAX;
+}
+
+static void
+dm_DynamicBBPowerSaving(
+struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/* 1 Power Saving for 92C */
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
+	{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (!pHalData->bSlaveOfDMSP)
+#endif
+			dm_1R_CCA(adapter);
+	}
+}
+
+static	void
+dm_RXGainTrackingCallback_ThermalMeter_92D(
+	struct rtw_adapter *	adapter)
+{
+	u8			index_mapping[Rx_index_mapping_NUM] = {
+						0x0f, 0x0f, 0x0f, 0x0f, 0x0b,
+						0x0a, 0x09, 0x08, 0x07, 0x06,
+						0x05, 0x04, 0x04, 0x03, 0x02
+					};
+
+	u8			eRFPath;
+	u32			u4tmp;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	u4tmp = (index_mapping[(pHalData->EEPROMThermalMeter - pdmpriv->ThermalValue_RxGain)]) << 12;
+
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++) {
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask, (pdmpriv->RegRF3C[eRFPath]&(~(0xF000)))|u4tmp);
+	}
+};
+
+/* 091212 chiyokolin */
+static	void
+dm_TXPowerTrackingCallback_ThermalMeter_92D(
+            struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u8		ThermalValue = 0, delta, delta_LCK, delta_IQK, delta_RxGain, index, offset;
+	u8		ThermalValue_AVG_count = 0;
+	u32		ThermalValue_AVG = 0;
+	s32		ele_A = 0, ele_D, TempCCk, X, value32;
+	s32		Y, ele_C;
+	s8		OFDM_index[2], CCK_index=0, OFDM_index_old[2], CCK_index_old=0;
+	s32		i = 0;
+	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
+	bool		bInteralPA = false;
+
+	u8		OFDM_min_index = 6, OFDM_min_index_internalPA = 12, rf; /* OFDM BB Swing should be less than +3.0dB, which is required by Arthur */
+	u8		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
+	u8 index_mapping[5][index_mapping_NUM] = {
+		{0, 1, 3, 6, 8, 9,			/* 5G, path A/MAC 0, decrease power */
+		11, 13, 14, 16, 17, 18, 18},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 2, 3, 6, 8, 9,			/* 5G, path B/MAC 1, decrease power */
+		11, 13, 14, 16, 17, 18, 18},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 4, 5,			/* 2.4G, for decreas power */
+		6, 7, 7, 8, 9, 10, 10},
+	};
+
+	u8 index_mapping_internalPA[8][index_mapping_NUM] = {
+		{0, 1, 2, 4, 6, 7,			/* 5G, path A/MAC 0, ch36-64, decrease power */
+		9, 11, 12, 14, 15, 16, 16},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, ch36-64, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 5, 6,			/* 5G, path A/MAC 0, ch100-165, decrease power */
+		8, 10, 11, 13, 14, 15, 15},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path A/MAC 0, ch100-165, increase power */
+		12, 14, 16, 18, 18, 18, 18},
+		{0, 1, 2, 4, 6, 7,			/* 5G, path B/MAC 1, ch36-64, decrease power */
+		9, 11, 12, 14, 15, 16, 16},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, ch36-64, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+		{0, 1, 2, 3, 5, 6,			/* 5G, path B/MAC 1, ch100-165, decrease power */
+		8, 9, 10, 12, 13, 14, 14},
+		{0, 2, 4, 5, 7, 10,			/* 5G, path B/MAC 1, ch100-165, increase power */
+		13, 16, 16, 18, 18, 18, 18},
+	};
+
+	pdmpriv->TXPowerTrackingCallbackCnt++;	/* cosa add for debug */
+	pdmpriv->bTXPowerTrackingInit = true;
+
+	if (pHalData->CurrentChannel == 14 && !pdmpriv->bCCKinCH14)
+		pdmpriv->bCCKinCH14 = true;
+	else if (pHalData->CurrentChannel != 14 && pdmpriv->bCCKinCH14)
+		pdmpriv->bCCKinCH14 = false;
+
+	ThermalValue = (u8)PHY_QueryRFReg(adapter, RF_PATH_A, RF_T_METER, 0xf800);	/* 0x42: RF Reg[15:11] 92D */
+
+	rtl8192d_PHY_APCalibrate(adapter, (ThermalValue - pHalData->EEPROMThermalMeter));/* notes:EEPROMThermalMeter is a fixed value from efuse/eeprom */
+
+	if (is2T)
+		rf = 2;
+	else
+		rf = 1;
+
+	if (ThermalValue)
+	{
+		{
+			/* Query OFDM path A default setting */
+			ele_D = PHY_QueryBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord)&bMaskOFDM_D;
+			for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
+			{
+				if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
+				{
+					OFDM_index_old[0] = (u8)i;
+					break;
+				}
+			}
+
+			/* Query OFDM path B default setting */
+			if (is2T)
+			{
+				ele_D = PHY_QueryBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord)&bMaskOFDM_D;
+				for (i=0; i<OFDM_TABLE_SIZE_92D; i++)	/* find the index */
+				{
+					if (ele_D == (OFDMSwingTable[i]&bMaskOFDM_D))
+					{
+						OFDM_index_old[1] = (u8)i;
+						break;
+					}
+				}
+			}
+
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			{
+				/* Query CCK default setting From 0xa24 */
+				TempCCk = pdmpriv->RegA24;
+
+				for (i=0 ; i<CCK_TABLE_SIZE ; i++)
+				{
+					if (pdmpriv->bCCKinCH14)
+					{
+						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch14[i][2], 4)==true)
+						{
+							CCK_index_old =(u8)i;
+							break;
+						}
+					}
+					else
+					{
+						if (_rtw_memcmp((void*)&TempCCk, (void*)&CCKSwingTable_Ch1_Ch13[i][2], 4)==true)
+						{
+							CCK_index_old =(u8)i;
+							break;
+						}
+					}
+				}
+			}
+			else
+			{
+				TempCCk = 0x090e1317;
+				CCK_index_old = 12;
+			}
+
+			if (!pdmpriv->ThermalValue)
+			{
+				pdmpriv->ThermalValue = pHalData->EEPROMThermalMeter;
+				pdmpriv->ThermalValue_LCK = ThermalValue;
+				pdmpriv->ThermalValue_IQK = ThermalValue;
+				pdmpriv->ThermalValue_RxGain = pHalData->EEPROMThermalMeter;
+
+				for (i = 0; i < rf; i++)
+					pdmpriv->OFDM_index[i] = OFDM_index_old[i];
+				pdmpriv->CCK_index = CCK_index_old;
+			}
+
+			if (pdmpriv->bReloadtxpowerindex)
+			{
+				DBG_8192D("reload ofdm index for band switch\n");
+			}
+
+			/* calculate average thermal meter */
+			{
+				pdmpriv->ThermalValue_AVG[pdmpriv->ThermalValue_AVG_index] = ThermalValue;
+				pdmpriv->ThermalValue_AVG_index++;
+				if (pdmpriv->ThermalValue_AVG_index == AVG_THERMAL_NUM)
+					pdmpriv->ThermalValue_AVG_index = 0;
+
+				for (i = 0; i < AVG_THERMAL_NUM; i++)
+				{
+					if (pdmpriv->ThermalValue_AVG[i])
+					{
+						ThermalValue_AVG += pdmpriv->ThermalValue_AVG[i];
+						ThermalValue_AVG_count++;
+					}
+				}
+
+				if (ThermalValue_AVG_count)
+					ThermalValue = (u8)(ThermalValue_AVG / ThermalValue_AVG_count);
+			}
+		}
+
+		if (pdmpriv->bReloadtxpowerindex)
+		{
+			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
+			pdmpriv->bReloadtxpowerindex = false;
+			pdmpriv->bDoneTxpower = false;
+		}
+		else if (pdmpriv->bDoneTxpower)
+		{
+			delta = (ThermalValue > pdmpriv->ThermalValue)?(ThermalValue - pdmpriv->ThermalValue):(pdmpriv->ThermalValue - ThermalValue);
+		}
+		else
+		{
+			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
+		}
+		delta_LCK = (ThermalValue > pdmpriv->ThermalValue_LCK)?(ThermalValue - pdmpriv->ThermalValue_LCK):(pdmpriv->ThermalValue_LCK - ThermalValue);
+		delta_IQK = (ThermalValue > pdmpriv->ThermalValue_IQK)?(ThermalValue - pdmpriv->ThermalValue_IQK):(pdmpriv->ThermalValue_IQK - ThermalValue);
+		delta_RxGain = (ThermalValue > pdmpriv->ThermalValue_RxGain)?(ThermalValue - pdmpriv->ThermalValue_RxGain):(pdmpriv->ThermalValue_RxGain - ThermalValue);
+
+		if ((delta_LCK > pdmpriv->Delta_LCK) && (pdmpriv->Delta_LCK != 0))
+		{
+			pdmpriv->ThermalValue_LCK = ThermalValue;
+			rtl8192d_PHY_LCCalibrate(adapter);
+		}
+
+		if (delta > 0 && pdmpriv->TxPowerTrackControl)
+		{
+			delta = ThermalValue > pHalData->EEPROMThermalMeter?(ThermalValue - pHalData->EEPROMThermalMeter):(pHalData->EEPROMThermalMeter - ThermalValue);
+
+			/* calculate new OFDM / CCK offset */
+			{
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				{
+					offset = 4;
+
+					if (delta > index_mapping_NUM-1)
+						index = index_mapping[offset][index_mapping_NUM-1];
+					else
+						index = index_mapping[offset][delta];
+
+					if (ThermalValue > pHalData->EEPROMThermalMeter)
+					{
+						for (i = 0; i < rf; i++)
+							OFDM_index[i] = pdmpriv->OFDM_index[i] -delta;
+						CCK_index = pdmpriv->CCK_index -delta;
+					}
+					else
+					{
+						for (i = 0; i < rf; i++)
+							OFDM_index[i] = pdmpriv->OFDM_index[i] + index;
+						CCK_index = pdmpriv->CCK_index + index;
+					}
+				}
+				else if (pHalData->CurrentBandType92D == BAND_ON_5G)
+				{
+					for (i = 0; i < rf; i++)
+					{
+						if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+							pHalData->interfaceIndex == 1)		/* MAC 1 5G */
+							bInteralPA = pHalData->InternalPA5G[1];
+						else
+							bInteralPA = pHalData->InternalPA5G[i];
+
+						if (bInteralPA)
+						{
+							if (pHalData->interfaceIndex == 1 || i == rf)
+								offset = 4;
+							else
+								offset = 0;
+
+							if (pHalData->CurrentChannel >= 100 && pHalData->CurrentChannel <= 165)
+								offset += 2;
+						}
+						else
+						{
+							if (pHalData->interfaceIndex == 1 || i == rf)
+								offset = 2;
+							else
+								offset = 0;
+						}
+
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	/* set larger Tx power */
+							offset++;
+
+						if (bInteralPA)
+						{
+							if (delta > index_mapping_NUM-1)
+								index = index_mapping_internalPA[offset][index_mapping_NUM-1];
+							else
+								index = index_mapping_internalPA[offset][delta];
+						}
+						else
+						{
+							if (delta > index_mapping_NUM-1)
+								index = index_mapping[offset][index_mapping_NUM-1];
+							else
+								index = index_mapping[offset][delta];
+						}
+
+						if (ThermalValue > pHalData->EEPROMThermalMeter)	/* set larger Tx power */
+						{
+							if (bInteralPA && ThermalValue > 0x12)
+							{
+								OFDM_index[i] = pdmpriv->OFDM_index[i] -((delta/2)*3+(delta%2));
+							}
+							else
+							{
+								OFDM_index[i] = pdmpriv->OFDM_index[i] -index;
+							}
+						}
+						else
+						{
+							OFDM_index[i] = pdmpriv->OFDM_index[i] + index;
+						}
+					}
+				}
+
+				/*if (is2T)
+				{
+					DBG_8192D("temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
+						pdmpriv->OFDM_index[0], pdmpriv->OFDM_index[1], pdmpriv->CCK_index);
+				}
+				else
+				{
+					DBG_8192D("temp OFDM_A_index=0x%x, CCK_index=0x%x\n",
+						pdmpriv->OFDM_index[0], pdmpriv->CCK_index);
+				}*/
+
+				for (i = 0; i < rf; i++)
+				{
+					if (OFDM_index[i] > OFDM_TABLE_SIZE_92D-1)
+					{
+						OFDM_index[i] = OFDM_TABLE_SIZE_92D-1;
+					}
+					else if (bInteralPA || pHalData->CurrentBandType92D == BAND_ON_2_4G)
+					{
+						if (OFDM_index[i] < OFDM_min_index_internalPA)
+							OFDM_index[i] = OFDM_min_index_internalPA;
+					}
+					else if (OFDM_index[i] < OFDM_min_index)
+					{
+						OFDM_index[i] = OFDM_min_index;
+					}
+				}
+
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				{
+					if (CCK_index > CCK_TABLE_SIZE-1)
+						CCK_index = CCK_TABLE_SIZE-1;
+					else if (CCK_index < 0)
+						CCK_index = 0;
+				}
+
+				/*if (is2T)
+				{
+					DBG_8192D("new OFDM_A_index=0x%x, OFDM_B_index=0x%x, CCK_index=0x%x\n",
+						OFDM_index[0], OFDM_index[1], CCK_index);
+				}
+				else
+				{
+					DBG_8192D("new OFDM_A_index=0x%x, CCK_index=0x%x\n",
+						OFDM_index[0], CCK_index);
+				}*/
+			}
+
+			/* Config by SwingTable */
+			if (pdmpriv->TxPowerTrackControl && !pHalData->bNOPG)
+			{
+				pdmpriv->bDoneTxpower = true;
+
+				/* Adujst OFDM Ant_A according to IQK result */
+				ele_D = (OFDMSwingTable[(u8)OFDM_index[0]] & 0xFFC00000)>>22;
+				X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0];
+				Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][1];
+
+				if (X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				{
+					if ((X & 0x00000200) != 0)
+						X = X | 0xFFFFFC00;
+					ele_A = ((X * ele_D)>>8)&0x000003FF;
+
+					/* new element C = element D x Y */
+					if ((Y & 0x00000200) != 0)
+						Y = Y | 0xFFFFFC00;
+					ele_C = ((Y * ele_D)>>8)&0x000003FF;
+
+					/* wirte new elements A, C, D to regC80 and regC94, element B is always 0 */
+					value32 = (ele_D<<22)|((ele_C&0x3F)<<16)|ele_A;
+					PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, value32);
+
+					value32 = (ele_C&0x000003C0)>>6;
+					PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, bMaskH4Bits, value32);
+
+					value32 = ((X * ele_D)>>7)&0x01;
+					PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, value32);
+
+				}
+				else
+				{
+					PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[0]]);
+					PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, bMaskH4Bits, 0x00);
+					PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, 0x00);
+				}
+
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				{
+					/* Adjust CCK according to IQK result */
+					if (!pdmpriv->bCCKinCH14) {
+						rtw_write8(adapter, 0xa22, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][0]);
+						rtw_write8(adapter, 0xa23, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][1]);
+						rtw_write8(adapter, 0xa24, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][2]);
+						rtw_write8(adapter, 0xa25, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][3]);
+						rtw_write8(adapter, 0xa26, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][4]);
+						rtw_write8(adapter, 0xa27, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][5]);
+						rtw_write8(adapter, 0xa28, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][6]);
+						rtw_write8(adapter, 0xa29, CCKSwingTable_Ch1_Ch13[(u8)CCK_index][7]);
+					}
+					else {
+						rtw_write8(adapter, 0xa22, CCKSwingTable_Ch14[(u8)CCK_index][0]);
+						rtw_write8(adapter, 0xa23, CCKSwingTable_Ch14[(u8)CCK_index][1]);
+						rtw_write8(adapter, 0xa24, CCKSwingTable_Ch14[(u8)CCK_index][2]);
+						rtw_write8(adapter, 0xa25, CCKSwingTable_Ch14[(u8)CCK_index][3]);
+						rtw_write8(adapter, 0xa26, CCKSwingTable_Ch14[(u8)CCK_index][4]);
+						rtw_write8(adapter, 0xa27, CCKSwingTable_Ch14[(u8)CCK_index][5]);
+						rtw_write8(adapter, 0xa28, CCKSwingTable_Ch14[(u8)CCK_index][6]);
+						rtw_write8(adapter, 0xa29, CCKSwingTable_Ch14[(u8)CCK_index][7]);
+					}
+				}
+
+				if (is2T)
+				{
+					ele_D = (OFDMSwingTable[(u8)OFDM_index[1]] & 0xFFC00000)>>22;
+
+					/* new element A = element D x X */
+					X = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4];
+					Y = pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][5];
+
+					if (X != 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G)
+					{
+						if ((X & 0x00000200) != 0)	/* consider minus */
+							X = X | 0xFFFFFC00;
+						ele_A = ((X * ele_D)>>8)&0x000003FF;
+
+						/* new element C = element D x Y */
+						if ((Y & 0x00000200) != 0)
+							Y = Y | 0xFFFFFC00;
+						ele_C = ((Y * ele_D)>>8)&0x00003FF;
+
+						/* wirte new elements A, C, D to regC88 and regC9C, element B is always 0 */
+						value32=(ele_D<<22)|((ele_C&0x3F)<<16) |ele_A;
+						PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, value32);
+
+						value32 = (ele_C&0x000003C0)>>6;
+						PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, bMaskH4Bits, value32);
+
+						value32 = ((X * ele_D)>>7)&0x01;
+						PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, value32);
+
+					}
+					else
+					{
+						PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, OFDMSwingTable[(u8)OFDM_index[1]]);
+						PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, bMaskH4Bits, 0x00);
+						PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, 0x00);
+					}
+
+				}
+
+			}
+		}
+
+		if ((delta_IQK > pdmpriv->Delta_IQK) && (pdmpriv->Delta_IQK != 0))
+		{
+			rtl8192d_PHY_ResetIQKResult(adapter);
+#ifdef CONFIG_CONCURRENT_MODE
+			if (rtw_buddy_adapter_up(adapter)) {
+				rtl8192d_PHY_ResetIQKResult(adapter->pbuddy_adapter);
+			}
+#endif
+			pdmpriv->ThermalValue_IQK = ThermalValue;
+			rtl8192d_PHY_IQCalibrate(adapter);
+		}
+
+		if (delta_RxGain > 0 && pHalData->CurrentBandType92D == BAND_ON_5G
+			&& ThermalValue <= pHalData->EEPROMThermalMeter && pHalData->bNOPG == false)
+		{
+			pdmpriv->ThermalValue_RxGain = ThermalValue;
+			dm_RXGainTrackingCallback_ThermalMeter_92D(adapter);
+		}
+
+		/* update thermal meter value */
+		if (pdmpriv->TxPowerTrackControl)
+		{
+			pdmpriv->ThermalValue = ThermalValue;
+		}
+
+	}
+
+	pdmpriv->TXPowercount = 0;
+}
+
+static	void
+dm_InitializeTXPowerTracking_ThermalMeter(
+	struct rtw_adapter *		adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	{
+		pdmpriv->bTXPowerTracking = true;
+		pdmpriv->TXPowercount = 0;
+		pdmpriv->bTXPowerTrackingInit = false;
+#if	(MP_DRIVER != 1)		/* for mp driver, turn off txpwrtracking as default */
+		pdmpriv->TxPowerTrackControl = true;
+#endif
+	}
+	MSG_8192D("pdmpriv->TxPowerTrackControl = %d\n", pdmpriv->TxPowerTrackControl);
+}
+
+static void
+DM_InitializeTXPowerTracking(
+	struct rtw_adapter *		adapter)
+{
+
+	{
+		dm_InitializeTXPowerTracking_ThermalMeter(adapter);
+	}
+}
+
+/*  */
+/*	Description: */
+/*		- Dispatch TxPower Tracking direct call ONLY for 92s. */
+/*		- We shall NOT schedule Workitem within PASSIVE LEVEL, which will cause system resource */
+/*		   leakage under some platform. */
+/*  */
+/*	Assumption: */
+/*		PASSIVE_LEVEL when this routine is called. */
+/*  */
+/*	Added by Roger, 2009.06.18. */
+/*  */
+static void
+DM_TXPowerTracking92CDirectCall(
+            struct rtw_adapter *		adapter)
+{
+	dm_TXPowerTrackingCallback_ThermalMeter_92D(adapter);
+}
+
+static void
+dm_CheckTXPowerTracking_ThermalMeter(
+	struct rtw_adapter *		adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_SS))
+	{
+		return;
+	}
+
+	if (!pdmpriv->bTXPowerTracking /*|| (!pHalData->TxPowerTrackControl && pHalData->bAPKdone)*/)
+	{
+		return;
+	}
+
+	if (!pdmpriv->TM_Trigger)		/* at least delay 1 sec */
+	{
+
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_T_METER, BIT17 | BIT16, 0x03);
+		pdmpriv->TM_Trigger = 1;
+		return;
+	}
+	else
+	{
+		DM_TXPowerTracking92CDirectCall(adapter); /* Using direct call is instead, added by Roger, 2009.06.18. */
+		pdmpriv->TM_Trigger = 0;
+	}
+}
+
+void
+rtl8192d_dm_CheckTXPowerTracking(
+	struct rtw_adapter *		adapter)
+{
+
+#if DISABLE_BB_RF
+	return;
+#endif
+	dm_CheckTXPowerTracking_ThermalMeter(adapter);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	dm_CheckPbcGPIO()
+ *
+ * Overview:	Check if PBC button is pressed.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	03/11/2008	hpfan	Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+static void	dm_CheckPbcGPIO(struct rtw_adapter * padapter)
+{
+	u8	tmp1byte;
+	u8	bPbcPressed = false;
+	int i=0;
+
+	if (!padapter->registrypriv.hw_wps_pbc)
+		return;
+
+	do
+	{
+		i++;
+	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
+	tmp1byte |= (HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as output mode */
+
+	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter,  GPIO_IN, tmp1byte);		/* reset the floating voltage level */
+
+	tmp1byte = rtw_read8(padapter, GPIO_IO_SEL);
+	tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+	rtw_write8(padapter, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as input mode */
+
+	tmp1byte =rtw_read8(padapter, GPIO_IN);
+
+	if (tmp1byte == 0xff)
+	{
+		bPbcPressed = false;
+		break ;
+	}
+
+	if (tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT)
+	{
+		bPbcPressed = true;
+
+		if (i<=3)
+			rtw_msleep_os(50);
+	}
+	}while (i<=3 && bPbcPressed == true);
+
+	if (true == bPbcPressed)
+	{
+		/*  Here we only set bPbcPressed to true */
+		/*  After trigger PBC, the variable will be set to false */
+		DBG_8192D("CheckPbcGPIO - PBC is pressed, try_cnt=%d\n", i-1);
+
+		if (padapter->pid[0] == 0)
+		{	/*	0 is the default value and it means the application monitors the HW PBC doesn't privde its pid to driver. */
+			return;
+		}
+
+		rtw_signal_process(padapter->pid[0], SIGUSR1);
+	}
+}
+
+static void dm_InitRateAdaptiveMask(struct rtw_adapter *	adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct rate_adaptive *ra = (struct rate_adaptive *)&pdmpriv->RateAdaptive;
+
+	ra->RATRState = DM_RATR_STA_INIT;
+	ra->PreRATRState = DM_RATR_STA_INIT;
+
+	if (pdmpriv->DM_Type == DM_Type_ByDriver)
+		pdmpriv->bUseRAMask = true;
+	else
+		pdmpriv->bUseRAMask = false;
+}
+
+/*  */
+/*  Initialize GPIO setting registers */
+/*  */
+static void
+dm_InitGPIOSetting(
+	struct rtw_adapter *	adapter
+	)
+{
+	u8	tmp1byte;
+
+	tmp1byte = rtw_read8(adapter, REG_GPIO_MUXCFG);
+	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
+	rtw_write8(adapter, REG_GPIO_MUXCFG, tmp1byte);
+}
+
+/*  */
+/*  functions */
+/*  */
+void rtl8192d_init_dm_priv(struct rtw_adapter * adapter)
+{
+}
+
+void rtl8192d_deinit_dm_priv(struct rtw_adapter * adapter)
+{
+}
+
+void
+rtl8192d_InitHalDm(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u8	i;
+
+	pdmpriv->DM_Type = DM_Type_ByDriver;
+	pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
+	pdmpriv->UndecoratedSmoothedPWDB = 0;
+
+	/* 1 DIG INIT */
+	pdmpriv->bDMInitialGainEnable = true;
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_DIG;
+	dm_DIGInit(adapter);
+
+	/* 2 DynamicTxPower INIT */
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_HP;
+	dm_InitDynamicTxPower(adapter);
+
+	/* 3 */
+	DM_InitEdcaTurbo(adapter);/* moved to  linked_status_chk() */
+
+	/* 4 RateAdaptive INIT */
+	dm_InitRateAdaptiveMask(adapter);
+
+	/* 5 Tx Power Tracking Init. */
+	pdmpriv->DMFlag |= DYNAMIC_FUNC_SS;
+	DM_InitializeTXPowerTracking(adapter);
+
+	dm_InitDynamicBBPowerSaving(adapter);
+
+	dm_InitGPIOSetting(adapter);
+
+	pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
+
+	/*  Save REG_INIDATA_RATE_SEL value for TXDESC. */
+	for (i = 0 ; i<32 ; i++)
+	{
+		pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, REG_INIDATA_RATE_SEL+i) & 0x3f;
+	}
+}
+
+#ifdef CONFIG_CONCURRENT_MODE
+static void FindMinimumRSSI(struct rtw_adapter * adapter)
+{
+	struct hal_data_8192du *pbuddy_HalData;
+	struct dm_priv *pbuddy_dmpriv;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
+
+	if (!rtw_buddy_adapter_up(adapter))
+		return;
+
+	pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
+	pbuddy_dmpriv = &pbuddy_HalData->dmpriv;
+
+	/* get min. [PWDB] when both interfaces are connected */
+	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
+		&& adapter->stapriv.asoc_sta_count > 2
+		&& check_buddy_fwstate(adapter, _FW_LINKED)) ||
+		(check_buddy_fwstate(adapter, WIFI_AP_STATE) == true
+		&& pbuddy_adapter->stapriv.asoc_sta_count > 2
+		&& check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+		&& check_buddy_fwstate(adapter,WIFI_STATION_STATE)
+		&& check_buddy_fwstate(adapter,_FW_LINKED)))
+	{
+		/* select smaller PWDB */
+		if (pdmpriv->UndecoratedSmoothedPWDB > pbuddy_dmpriv->UndecoratedSmoothedPWDB)
+			pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
+	}/* secondary interface is connected */
+	else if ((check_buddy_fwstate(adapter, WIFI_AP_STATE) == true
+		&& pbuddy_adapter->stapriv.asoc_sta_count > 2) ||
+		(check_buddy_fwstate(adapter,WIFI_STATION_STATE)
+		&& check_buddy_fwstate(adapter,_FW_LINKED)))
+	{
+		/* select buddy PWDB */
+		pdmpriv->UndecoratedSmoothedPWDB = pbuddy_dmpriv->UndecoratedSmoothedPWDB;
+	}
+	/* primary is connected */
+	else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
+		&& adapter->stapriv.asoc_sta_count > 2) ||
+		(check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		&& check_fwstate(pmlmepriv, _FW_LINKED)))
+	{
+		/* set buddy PWDB to 0 */
+		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
+	}
+	/* both interfaces are not connected */
+	else
+	{
+		pdmpriv->UndecoratedSmoothedPWDB = 0;
+		pbuddy_dmpriv->UndecoratedSmoothedPWDB = 0;
+	}
+
+	/* primary interface is ap mode */
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true && adapter->stapriv.asoc_sta_count > 2)
+	{
+		pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
+	}/* secondary interface is ap mode */
+	else if (check_buddy_fwstate(adapter, WIFI_AP_STATE) == true && pbuddy_adapter->stapriv.asoc_sta_count > 2)
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB;
+	}
+	else /* both interfaces are not ap mode */
+	{
+		pdmpriv->EntryMinUndecoratedSmoothedPWDB = pbuddy_dmpriv->EntryMinUndecoratedSmoothedPWDB = 0;
+	}
+}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+void
+rtl8192d_HalDmWatchDog(
+	struct rtw_adapter *	adapter
+	)
+{
+	bool		bFwCurrentInPSMode = false;
+	bool		bFwPSAwake = true;
+	u8 hw_init_completed = false;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+#ifdef CONFIG_CONCURRENT_MODE
+	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if ((pHalData->bInModeSwitchProcess))
+	{
+		DBG_8192D("HalDmWatchDog(): During dual mac mode switch or slave mac\n");
+		return;
+	}
+#endif
+
+	#if defined(CONFIG_CONCURRENT_MODE)
+	if (adapter->isprimary == false && pbuddy_adapter) {
+		hw_init_completed = pbuddy_adapter->hw_init_completed;
+	} else
+	#endif
+	{
+		hw_init_completed = adapter->hw_init_completed;
+	}
+
+	if (hw_init_completed == false)
+		goto skip_dm;
+
+#ifdef CONFIG_LPS
+	#if defined(CONFIG_CONCURRENT_MODE)
+	if (adapter->iface_type != IFACE_PORT0 && pbuddy_adapter) {
+		bFwCurrentInPSMode = pbuddy_adapter->pwrctrlpriv.bFwCurrentInPSMode;
+		rtw_hal_get_hwreg(pbuddy_adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
+	} else
+	#endif
+	{
+		bFwCurrentInPSMode = adapter->pwrctrlpriv.bFwCurrentInPSMode;
+		rtw_hal_get_hwreg(adapter, HW_VAR_FWLPS_RF_ON, (u8 *)(&bFwPSAwake));
+	}
+#endif
+
+	/*  Stop dynamic mechanism when: */
+	/*  1. RF is OFF. (No need to do DM.) */
+	/*  2. Fw is under power saving mode for FwLPS. (Prevent from SW/FW I/O racing.) */
+	/*  3. IPS workitem is scheduled. (Prevent from IPS sequence to be swapped with DM. */
+	/*      Sometimes DM execution time is longer than 100ms such that the assertion */
+	/*      in MgntActSet_RF_State() called by InactivePsWorkItem will be triggered by */
+	/*      wating to long for RFChangeInProgress.) */
+	/*  4. RFChangeInProgress is TRUE. (Prevent from broken by IPS/HW/SW Rf off.) */
+	/*  Noted by tynli. 2010.06.01. */
+	if ((hw_init_completed == true)
+		&& ((!bFwCurrentInPSMode) && bFwPSAwake))
+	{
+		/*  */
+		/*  For PWDB monitor and record some value for later use. */
+		/*  */
+		PWDB_Monitor(adapter);
+#ifdef CONFIG_CONCURRENT_MODE
+		if (adapter->adapter_type > PRIMARY_ADAPTER)
+			goto _record_initrate;
+		FindMinimumRSSI(adapter);
+#endif /* CONFIG_CONCURRENT_MODE */
+		/*  */
+		/*  Dynamic Initial Gain mechanism. */
+		/*  */
+/* sherry delete flag 20110517 */
+		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForGlobaladapterList);
+		if (pHalData->bSlaveOfDMSP)
+		{
+			odm_FalseAlarmCounterStatistics_ForSlaveOfDMSP(adapter);
+		}
+		else
+		{
+			odm_FalseAlarmCounterStatistics(adapter);
+		}
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForGlobaladapterList);
+#ifndef CONFIG_CONCURRENT_MODE
+		odm_FindMinimumRSSI_92D(adapter);
+#endif /* CONFIG_CONCURRENT_MODE */
+		odm_DIG(adapter);
+		if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		{
+			if (pHalData->CurrentBandType92D != BAND_ON_5G)
+				dm_CCK_PacketDetectionThresh_DMSP(adapter);
+		}
+		else
+		{
+			if (pHalData->CurrentBandType92D != BAND_ON_5G)
+				dm_CCK_PacketDetectionThresh(adapter);
+		}
+
+		/*  */
+		/*  Dynamic Tx Power mechanism. */
+		/*  */
+		odm_DynamicTxPower_92D(adapter);
+
+		/*  */
+		/*  Tx Power Tracking. */
+		/*  */
+		/* TX power tracking will make 92de DMDP MAC0's throughput bad. */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
+#endif
+			rtl8192d_dm_CheckTXPowerTracking(adapter);
+
+		/*  EDCA turbo */
+		/* update the EDCA paramter according to the Tx/RX mode */
+		dm_CheckEdcaTurbo(adapter);
+
+		/*  */
+		/* Dynamic BB Power Saving Mechanism */
+		/* vivi, 20101014, to pass DTM item: softap_excludeunencrypted_ext.htm */
+		/* temporarily disable it advised for performance test by yn,2010-11-03. */
+		dm_DynamicBBPowerSaving(adapter);
+
+_record_initrate:
+
+		/*  Read REG_INIDATA_RATE_SEL value for TXDESC. */
+		if (check_fwstate(&adapter->mlmepriv, WIFI_STATION_STATE)) {
+			pdmpriv->INIDATA_RATE[0] = rtw_read8(adapter, REG_INIDATA_RATE_SEL) & 0x3f;
+
+		} else {
+			u8	i;
+			for (i=1 ; i < (adapter->stapriv.asoc_sta_count + 1); i++)
+				pdmpriv->INIDATA_RATE[i] = rtw_read8(adapter, (REG_INIDATA_RATE_SEL+i)) & 0x3f;
+		}
+	}
+
+skip_dm:
+
+	/*  Check GPIO to determine current RF on/off and Pbc status. */
+	/*  Not enable for 92CU now!!! */
+	/*  Check Hardware Radio ON/OFF or not */
+
+	dm_CheckPbcGPIO(adapter);				/*  Add by hpfan 2008-03-11 */
+
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_hal_init.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_hal_init.c
new file mode 100644
index 0000000..ca6a6e3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_hal_init.c
@@ -0,0 +1,1927 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#define _RTL8192D_HAL_INIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_efuse.h>
+#include <hal_intf.h>
+#include <usb_hal.h>
+#include <rtl8192d_hal.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+
+atomic_t GlobalMutexForGlobaladapterList = ATOMIC_INIT(0);
+atomic_t GlobalMutexForMac0_2G_Mac1_5G = ATOMIC_INIT(0);
+atomic_t GlobalMutexForPowerAndEfuse = ATOMIC_INIT(0);
+atomic_t GlobalMutexForPowerOnAndPowerOff = ATOMIC_INIT(0);
+static atomic_t GlobalMutexForFwDownload = ATOMIC_INIT(0);
+#ifdef CONFIG_DUALMAC_CONCURRENT
+atomic_t GlobalCounterForMutex = ATOMIC_INIT(0);
+bool GlobalFirstConfigurationForNormalChip = true;
+#endif
+
+static bool _IsFWDownloaded(struct rtw_adapter *adapter)
+{
+	return ((rtw_read32(adapter, REG_MCUFWDL) & MCUFWDL_RDY) ? true : false);
+}
+
+static void _FWDownloadEnable(struct rtw_adapter *adapter, bool enable)
+{
+	u8	tmp;
+
+	if (enable) {
+		#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
+		{
+			u8 val;
+			if ((val = rtw_read8(adapter, REG_MCUFWDL)))
+				DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
+		}
+		#endif
+		/*  8051 enable */
+		tmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
+		rtw_write8(adapter, REG_SYS_FUNC_EN+1, tmp|0x04);
+
+		/*  MCU firmware download enable. */
+		tmp = rtw_read8(adapter, REG_MCUFWDL);
+		rtw_write8(adapter, REG_MCUFWDL, tmp|0x01);
+
+		/*  8051 reset */
+		tmp = rtw_read8(adapter, REG_MCUFWDL+2);
+		rtw_write8(adapter, REG_MCUFWDL+2, tmp&0xf7);
+	} else {
+		/*  MCU firmware download enable. */
+		tmp = rtw_read8(adapter, REG_MCUFWDL);
+		rtw_write8(adapter, REG_MCUFWDL, tmp&0xfe);
+	}
+}
+
+static int _BlockWrite_92d(struct rtw_adapter *adapter, void *buffer, u32 size)
+{
+	int ret = _SUCCESS;
+	u32			blockSize8 = sizeof(u64);
+	u32			blocksize4 = sizeof(u32);
+	u32			blockSize = 64;
+	u8*			bufferPtr = (u8*)buffer;
+	u32*		pu4BytePtr = (u32*)buffer;
+	u32			i, offset, blockCount, remainSize, remain8, remain4, blockCount8, blockCount4;
+
+	blockCount = size / blockSize;
+	remain8 = size % blockSize;
+	for (i = 0; i < blockCount; i++) {
+		offset = i * blockSize;
+		ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset), 64, (bufferPtr + offset));
+
+		if (ret == _FAIL)
+			goto exit;
+	}
+
+	if (remain8) {
+		offset = blockCount * blockSize;
+
+		blockCount8 = remain8/blockSize8;
+		remain4 = remain8%blockSize8;
+		for (i = 0; i < blockCount8; i++) {
+			ret = rtw_writeN(adapter, (FW_8192D_START_ADDRESS + offset+i*blockSize8), 8, (bufferPtr + offset+i*blockSize8));
+
+			if (ret == _FAIL)
+				goto exit;
+		}
+
+		if (remain4) {
+			offset = blockCount * blockSize+blockCount8*blockSize8;
+			blockCount4 = remain4/blocksize4;
+			remainSize = remain8%blocksize4;
+
+			for (i = 0; i < blockCount4; i++) {
+				ret = rtw_write32(adapter, (FW_8192D_START_ADDRESS + offset+i*blocksize4), le32_to_cpu(*(__le32 *)(pu4BytePtr+ offset/4+i)));
+
+				if (ret == _FAIL)
+					goto exit;
+			}
+
+			if (remainSize) {
+				offset = blockCount * blockSize+blockCount8*blockSize8+blockCount4*blocksize4;
+				for (i = 0; i < remainSize; i++) {
+					ret = rtw_write8(adapter, (FW_8192D_START_ADDRESS + offset + i), *(bufferPtr +offset+ i));
+
+					if (ret == _FAIL)
+						goto exit;
+				}
+			}
+
+		}
+
+	}
+
+exit:
+	return ret;
+}
+
+static int _PageWrite(struct rtw_adapter *adapter, u32 page,
+		      void *buffer, u32 size)
+{
+	u8 value8;
+	u8 u8page = (u8)(page & 0x07);
+
+	value8 = (rtw_read8(adapter, REG_MCUFWDL+2)& 0xF8) | u8page;
+	rtw_write8(adapter, REG_MCUFWDL+2, value8);
+	return _BlockWrite_92d(adapter, buffer, size);
+}
+
+static int _WriteFW(struct rtw_adapter *adapter, void *buffer, u32 size)
+{
+	int ret = _SUCCESS;
+	/*  Since we need to dynamically decide method of download fw,
+	 *  we call this function to get chip version.
+	 *  We can remove _ReadChipVersion from ReadadapterInfo8192C later.
+	 */
+	u32 pageNums, remainSize;
+	u32 page, offset;
+	u8 *bufferPtr = (u8*)buffer;
+
+	pageNums = size / MAX_PAGE_SIZE;
+	remainSize = size % MAX_PAGE_SIZE;
+
+	for (page = 0; page < pageNums;  page++) {
+		offset = page *MAX_PAGE_SIZE;
+		ret = _PageWrite(adapter, page, (bufferPtr+offset), MAX_PAGE_SIZE);
+
+		if (ret == _FAIL)
+			goto exit;
+	}
+	if (remainSize) {
+		offset = pageNums *MAX_PAGE_SIZE;
+		page = pageNums;
+		ret = _PageWrite(adapter, page, (bufferPtr+offset), remainSize);
+
+		if (ret == _FAIL)
+			goto exit;
+	}
+	DBG_8192D("_WriteFW Done- for Normal chip.\n");
+
+exit:
+	return ret;
+}
+
+static int _FWFreeToGo_92D(struct rtw_adapter *adapter)
+{
+	u32 counter = 0;
+	u32 value32;
+	/*  polling CheckSum report */
+	do {
+		value32 = rtw_read32(adapter, REG_MCUFWDL);
+	} while ((counter ++ < POLLING_READY_TIMEOUT_COUNT) &&
+		 (!(value32 & FWDL_ChkSum_rpt)));
+
+	if (counter >= POLLING_READY_TIMEOUT_COUNT) {
+		DBG_8192D("chksum report faill ! REG_MCUFWDL:0x%08x .\n", value32);
+		return _FAIL;
+	}
+	DBG_8192D("Checksum report OK ! REG_MCUFWDL:0x%08x .\n", value32);
+
+	value32 = rtw_read32(adapter, REG_MCUFWDL);
+	value32 |= MCUFWDL_RDY;
+	rtw_write32(adapter, REG_MCUFWDL, value32);
+	return _SUCCESS;
+}
+
+void rtl8192d_FirmwareSelfReset(struct rtw_adapter *adapter)
+{
+	u8	u1bTmp;
+	u8	Delay = 100;
+
+	rtw_write8(adapter, REG_FSIMR, 0x00);
+	/*  disable other HRCV INT to influence 8051 reset. */
+	rtw_write8(adapter, REG_FWIMR, 0x20);
+	/*  close mask to prevent incorrect FW write operation. */
+	rtw_write8(adapter, REG_FTIMR, 0x00);
+
+	/* 0x1cf = 0x20. Inform 8051 to reset. 2009.12.25. tynli_test */
+	rtw_write8(adapter, REG_HMETFR+3, 0x20);
+
+	u1bTmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
+	while (u1bTmp & BIT2) {
+		Delay--;
+		if (Delay == 0)
+			break;
+		rtw_udelay_os(50);
+		u1bTmp = rtw_read8(adapter, REG_SYS_FUNC_EN+1);
+	}
+
+	if ((u1bTmp&BIT2) && (Delay == 0)) {
+		rtw_write8(adapter, REG_FWIMR, 0x00);
+		/* debug reset fail */
+		pr_info("FirmwareDownload92C(): Fail! 0x1c = %x, 0x130 =>%08x, 0x134 =>%08x, 0x138 =>%08x, 0x1c4 =>%08x\n, 0x1cc =>%08x, , 0x80 =>%08x , 0x1c0 =>%08x\n",
+		        rtw_read32(adapter, 0x1c), rtw_read32(adapter, 0x130),
+			rtw_read32(adapter, 0x134), rtw_read32(adapter, 0x138),
+			rtw_read32(adapter, 0x1c4), rtw_read32(adapter, 0x1cc),
+			rtw_read32(adapter, 0x80), rtw_read32(adapter, 0x1c0));
+	}
+}
+
+/*  description :polling fw ready */
+static int _FWInit(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32 counter = 0;
+
+	DBG_8192D("FW already have download\n");
+
+	/*  polling for FW ready */
+	counter = 0;
+	do {
+		if (!pHalData->interfaceIndex) {
+			if (rtw_read8(adapter, FW_MAC0_ready) & mac0_ready) {
+				DBG_8192D("Polling FW ready success!! FW_MAC0_ready:0x%x\n",
+					  rtw_read8(adapter, FW_MAC0_ready));
+				return _SUCCESS;
+			}
+			rtw_udelay_os(5);
+		} else {
+			if (rtw_read8(adapter, FW_MAC1_ready) &mac1_ready) {
+				DBG_8192D("Polling FW ready success!! FW_MAC1_ready:0x%x\n",
+					  rtw_read8(adapter, FW_MAC1_ready));
+				return _SUCCESS;
+			}
+			rtw_udelay_os(5);
+		}
+
+	} while (counter++ < POLLING_READY_TIMEOUT_COUNT);
+
+	if (pHalData->interfaceIndex == 0) {
+		DBG_8192D("Polling FW ready fail!! MAC0 FW init not ready:0x%x\n",
+			  rtw_read8(adapter, FW_MAC0_ready));
+	} else {
+		DBG_8192D("Polling FW ready fail!! MAC1 FW init not ready:0x%x\n",
+			  rtw_read8(adapter, FW_MAC1_ready));
+	}
+
+	DBG_8192D("Polling FW ready fail!! REG_MCUFWDL:0x%x\n",
+		  rtw_read32(adapter, REG_MCUFWDL));
+	return _FAIL;
+}
+
+static bool get_fw_from_file(struct rtw_adapter *adapter)
+{
+	struct dvobj_priv *dvobj = adapter_to_dvobj(adapter);
+	struct device *device = dvobj_to_dev(dvobj);
+	const struct firmware *fw;
+	bool rtstatus = false;
+#ifdef CONFIG_WOWLAN
+	const char *fw_name = "rtlwifi/rtl8192dufw_wol.bin";
+#else
+	const char *fw_name = "rtlwifi/rtl8192dufw.bin";
+#endif /* CONFIG_WOWLAN */
+
+	if (request_firmware(&fw, fw_name, device) || !fw) {
+		pr_err("Firmware %s not available\n", fw_name);
+		return false;
+	}
+	if (fw->size > FW_8192D_SIZE) {
+		pr_err("Firmware size exceeds 0x%x. Check it.\n",
+		       FW_8192D_SIZE);
+		goto exit;
+	}
+
+	adapter->firmware = kmalloc(sizeof(struct rt_firmware_92d), GFP_KERNEL);
+	if (!adapter->firmware) {
+		goto exit;
+	}
+	adapter->firmware->buffer = vzalloc(fw->size);
+	if (!adapter->firmware->buffer) {
+		kfree(adapter->firmware);
+		adapter->firmware = NULL;
+		goto exit;
+	}
+	memcpy(adapter->firmware->buffer, fw->data, fw->size);
+	adapter->firmware->length = fw->size;
+	pr_info("r8192du: Loaded firmware file %s of %d bytes\n",
+		fw_name, adapter->firmware->length);
+	rtstatus = true;
+exit:
+	release_firmware(fw);
+	return rtstatus;
+}
+#ifdef CONFIG_WOWLAN
+MODULE_FIRMWARE("rtlwifi/rtl8192dufw_wol.bin");
+#else
+MODULE_FIRMWARE("rtlwifi/rtl8192dufw.bin");
+#endif /* CONFIG_WOWLAN */
+
+/*	Description: Download 8192D firmware code. */
+int FirmwareDownload92D(struct rtw_adapter *adapter, bool bUsedWoWLANFw)
+{
+	int rtStatus = _SUCCESS;
+	u8 writeFW_retry = 0;
+	u32 fwdl_start_time;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct rt_8192d_firmware_hdr *pFwHdr = NULL;
+	u8 *pFirmwareBuf;
+	u32 FirmwareLen;
+	u8 value;
+	u32 count;
+	bool bFwDownloaded = false, bFwDownloadInProcess = false;
+
+	if (adapter->bSurpriseRemoved)
+		return _FAIL;
+
+	/* Single MAC Single PHY units break if external firmware is loaded */
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+		return _SUCCESS;
+
+ 	if (!adapter->firmware || !adapter->firmware->buffer) {
+		if (!get_fw_from_file(adapter)) {
+			rtStatus = _FAIL;
+			adapter->firmware = NULL;
+			goto Exit;
+		}
+	}
+	pFirmwareBuf = adapter->firmware->buffer;
+	FirmwareLen = adapter->firmware->length;
+
+	/*  To Check Fw header. Added by tynli. 2009.12.04. */
+	pFwHdr = (struct rt_8192d_firmware_hdr *)adapter->firmware->buffer;
+
+	pHalData->FirmwareVersion =  le16_to_cpu(pFwHdr->Version);
+	pHalData->FirmwareSubVersion = pFwHdr->Subversion;
+
+	if (IS_FW_HEADER_EXIST(pFwHdr)) {
+		pFirmwareBuf = pFirmwareBuf + 32;
+		FirmwareLen = FirmwareLen -32;
+	}
+
+#ifdef CONFIG_WOWLAN
+	/* write 0x5 BIT(3), don't suspend to reset MAC */
+	if (bUsedWoWLANFw) {
+		u8 test;
+		test = rtw_read8(adapter, REG_APS_FSMCO+1);
+		test &= ~BIT(3);
+		rtw_write8(adapter, REG_APS_FSMCO+1, test);
+	}
+
+#endif /* CONFIG_WOWLAN */
+	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY ||
+	    pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY) {
+		bFwDownloaded = _IsFWDownloaded(adapter);
+		if ((rtw_read8(adapter, 0x1f)&BIT5) == BIT5)
+			bFwDownloadInProcess = true;
+		else
+			bFwDownloadInProcess = false;
+
+		if (bFwDownloaded) {
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+			goto Exit;
+		} else if (bFwDownloadInProcess) {
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+			for (count = 0; count < 5000; count++) {
+				rtw_udelay_os(500);
+				ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+				bFwDownloaded = _IsFWDownloaded(adapter);
+				if ((rtw_read8(adapter, 0x1f)&BIT5) == BIT5)
+					bFwDownloadInProcess = true;
+				else
+					bFwDownloadInProcess = false;
+				RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+				if (bFwDownloaded)
+					goto Exit;
+				else if (!bFwDownloadInProcess)
+					break;
+				else
+					DBG_8192D("Wait for another mac download fw\n");
+			}
+			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+			value = rtw_read8(adapter, 0x1f);
+			value|= BIT5;
+			rtw_write8(adapter, 0x1f, value);
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+		} else {
+			value = rtw_read8(adapter, 0x1f);
+			value|= BIT5;
+			rtw_write8(adapter, 0x1f, value);
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+		}
+
+		/*  Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself, */
+		/*  or it will cause download Fw fail. 2010.02.01. by tynli. */
+		if (rtw_read8(adapter, REG_MCUFWDL)&BIT7) /* 8051 RAM code */
+		{
+			DBG_8192D("Firmware self reset\n");
+			rtl8192d_FirmwareSelfReset(adapter);
+			rtw_write8(adapter, REG_MCUFWDL, 0x00);
+		}
+
+		_FWDownloadEnable(adapter, true);
+		fwdl_start_time = rtw_get_current_time();
+		while (1) {
+			/* reset the FWDL chksum */
+			rtw_write8(adapter, REG_MCUFWDL, rtw_read8(adapter, REG_MCUFWDL)|FWDL_ChkSum_rpt);
+
+			rtStatus = _WriteFW(adapter, pFirmwareBuf, FirmwareLen);
+
+			if (rtStatus == _SUCCESS ||
+			    (rtw_get_passing_time_ms(fwdl_start_time) > 500 &&
+			    writeFW_retry++ >= 3))
+				break;
+
+			DBG_8192D("%s writeFW_retry:%u, time after fwdl_start_time:%ums\n",
+				  __func__, writeFW_retry,
+				  rtw_get_passing_time_ms(fwdl_start_time));
+		}
+		_FWDownloadEnable(adapter, false);
+		if (_SUCCESS != rtStatus) {
+			DBG_8192D("DL Firmware failed!\n");
+			goto Exit;
+		}
+
+		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+		rtStatus = _FWFreeToGo_92D(adapter);
+		/*  download fw over, clear 0x1f[5] */
+		value = rtw_read8(adapter, 0x1f);
+		value&= (~BIT5);
+		rtw_write8(adapter, 0x1f, value);
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForFwDownload);
+
+		if (_SUCCESS != rtStatus) {
+			DBG_8192D("Firmware is not ready to run!\n");
+			goto Exit;
+		}
+	}
+
+Exit:
+	rtStatus = _FWInit(adapter);
+	return rtStatus;
+}
+
+#ifdef CONFIG_WOWLAN
+void InitializeFirmwareVars92D(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct pwrctrl_priv *pwrpriv;
+	pwrpriv = &adapter->pwrctrlpriv;
+
+	/*  Init Fw LPS related. */
+	adapter->pwrctrlpriv.bFwCurrentInPSMode = false;
+
+	pwrpriv->bkeepfwalive = true;
+	/* Init H2C counter. by tynli. 2009.12.09. */
+	pHalData->LastHMEBoxNum = 0;
+}
+
+/*  Description: Prepare some information to Fw for WoWLAN.
+ *			(1) Download wowlan Fw.
+ *			(2) Download RSVD page packets.
+ *			(3) Enable AP offload if needed.
+ */
+void SetFwRelatedForWoWLAN8192DU(struct rtw_adapter *padapter, u8 bHostIsGoingtoSleep)
+{
+	int	status = _FAIL;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	u8	 bRecover = false;
+
+	if (bHostIsGoingtoSleep) {
+		/*  1. Before WoWLAN we need to re-download WoWLAN Fw. */
+		status = FirmwareDownload92D(padapter, bHostIsGoingtoSleep);
+		if (status != _SUCCESS) {
+			DBG_8192D("ConfigFwRelatedForWoWLAN8192DU(): Re-Download Firmware failed!!\n");
+			return;
+		} else {
+			DBG_8192D("ConfigFwRelatedForWoWLAN8192DU(): Re-Download Firmware Success !!\n");
+		}
+
+		/*  */
+		/*  2. Re-Init the variables about Fw related setting. */
+		/*  */
+		InitializeFirmwareVars92D(padapter);
+	}
+}
+#endif /* CONFIG_WOWLAN */
+
+/* chnl" begins from 0. It's not a real channel. */
+/* channel_info[chnl]" is a real channel. */
+static u8 Hal_GetChnlGroupfromArray(u8 chnl)
+{
+	u8	group = 0;
+	u8	channel_info[59] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 149, 151, 153, 155, 157, 159, 161, 163, 165};
+
+	if (channel_info[chnl] <= 3)			/*  Chanel 1-3 */
+		group = 0;
+	else if (channel_info[chnl] <= 9)		/*  Channel 4-9 */
+		group = 1;
+	else	if (channel_info[chnl] <= 14)				/*  Channel 10-14 */
+		group = 2;
+	/*  For TX_POWER_FOR_5G_BAND */
+	else if (channel_info[chnl] <= 44)
+		group = 3;
+	else if (channel_info[chnl] <= 54)
+		group = 4;
+	else if (channel_info[chnl] <= 64)
+		group = 5;
+	else if (channel_info[chnl] <= 112)
+		group = 6;
+	else if (channel_info[chnl] <= 126)
+		group = 7;
+	else if (channel_info[chnl] <= 140)
+		group = 8;
+	else if (channel_info[chnl] <= 153)
+		group = 9;
+	else if (channel_info[chnl] <= 159)
+		group = 10;
+	else
+		group = 11;
+
+	return group;
+}
+
+void
+rtl8192d_ReadChipVersion(
+	struct rtw_adapter *			adapter
+	)
+{
+	u32	value32;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	enum VERSION_8192D	ChipVersion = VERSION_TEST_CHIP_88C;
+
+	value32 = rtw_read32(adapter, REG_SYS_CFG);
+	DBG_8192D("ReadChipVersion8192D 0xF0 = 0x%x\n", value32);
+
+	ChipVersion = (enum VERSION_8192D)(VERSION_NORMAL_CHIP_92D_SINGLEPHY | CHIP_92D);
+
+	/* Decide TestChip or NormalChip here. */
+	/* 92D's RF_type will be decided when the reg0x2c is filled. */
+	if (!(value32 & 0x000f0000))
+	{ /* Test or Normal Chip:  hardward id 0xf0[19:16] = 0 test chip */
+		ChipVersion = VERSION_TEST_CHIP_92D_SINGLEPHY;
+		DBG_8192D("TEST CHIP!!!\n");
+	}
+	else
+	{
+		ChipVersion = (enum VERSION_8192D)(ChipVersion | NORMAL_CHIP);
+		DBG_8192D("Normal CHIP!!!\n");
+	}
+
+	pHalData->VersionID = ChipVersion;
+}
+
+/*  */
+/*  */
+/*	Channel Plan */
+/*  */
+/*  */
+
+void
+rtl8192d_EfuseParseChnlPlan(
+	struct rtw_adapter *	adapter,
+	u8*			hwinfo,
+	bool		AutoLoadFail
+	)
+{
+	adapter->mlmepriv.ChannelPlan = hal_com_get_channel_plan(
+		adapter
+		, hwinfo?hwinfo[EEPROM_CHANNEL_PLAN]:0xFF
+		, adapter->registrypriv.channel_plan
+		, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G
+		, AutoLoadFail
+	);
+
+	DBG_8192D("mlmepriv.ChannelPlan = 0x%02x\n" , adapter->mlmepriv.ChannelPlan);
+}
+
+/*  */
+/*  */
+/*	EEPROM Power index mapping */
+/*  */
+/*  */
+
+static void
+hal_ReadPowerValueFromPROM92D(
+	struct rtw_adapter *adapter,
+	struct tx_power_info *pwrInfo,
+	u8*			PROMContent,
+	bool			AutoLoadFail
+	)
+{
+	u32	rfPath, eeAddr, group, offset1, offset2 = 0;
+	u8	i = 0;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	memset(pwrInfo, 0, sizeof(struct tx_power_info));
+
+	if (AutoLoadFail) {
+		for (group = 0; group < CHANNEL_GROUP_MAX; group++) {
+			for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+				if (group < CHANNEL_GROUP_MAX_2G) {
+					pwrInfo->CCKIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_2G;
+					pwrInfo->HT40_1SIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_2G;
+				} else {
+					pwrInfo->HT40_1SIndex[rfPath][group]		= EEPROM_Default_TxPowerLevel_5G;
+				}
+				pwrInfo->HT40_2SIndexDiff[rfPath][group]	= EEPROM_Default_HT40_2SDiff;
+				pwrInfo->HT20IndexDiff[rfPath][group]		= EEPROM_Default_HT20_Diff;
+				pwrInfo->OFDMIndexDiff[rfPath][group]	= EEPROM_Default_LegacyHTTxPowerDiff;
+				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;
+				pwrInfo->HT20MaxOffset[rfPath][group]	= EEPROM_Default_HT20_PwrMaxOffset;
+			}
+		}
+
+		for (i = 0; i < 3; i++)
+		{
+			pwrInfo->TSSI_A_5G[i] = EEPROM_Default_TSSI;
+			pwrInfo->TSSI_B_5G[i] = EEPROM_Default_TSSI;
+		}
+		pHalData->bNOPG = true;
+		return;
+	}
+
+	/* Maybe autoload OK, buf the tx power index vlaue is not filled. */
+	/* If we find it, we set it default value. */
+	for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+		for (group = 0; group < CHANNEL_GROUP_MAX_2G; group++) {
+			eeAddr = EEPROM_CCK_TX_PWR_INX_2G + (rfPath * 3) + group;
+			pwrInfo->CCKIndex[rfPath][group] =
+				(PROMContent[eeAddr] == 0xFF)?(eeAddr>0x7B?EEPROM_Default_TxPowerLevel_5G:EEPROM_Default_TxPowerLevel_2G):PROMContent[eeAddr];
+			if (PROMContent[eeAddr] == 0xFF)
+				pHalData->bNOPG = true;
+		}
+	}
+	for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+		for (group = 0; group < CHANNEL_GROUP_MAX; group++) {
+			offset1 = group / 3;
+			offset2 = group % 3;
+			eeAddr = EEPROM_HT40_1S_TX_PWR_INX_2G+ (rfPath * 3) + offset2 + offset1*21;
+			pwrInfo->HT40_1SIndex[rfPath][group] =
+				(PROMContent[eeAddr] == 0xFF)?(eeAddr>0x7B?EEPROM_Default_TxPowerLevel_5G:EEPROM_Default_TxPowerLevel_2G):PROMContent[eeAddr];
+		}
+	}
+
+	/* These just for 92D efuse offset. */
+	for (group = 0; group < CHANNEL_GROUP_MAX; group++) {
+		for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+			offset1 = group / 3;
+			offset2 = group % 3;
+
+			if (PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] != 0xFF)
+				pwrInfo->HT40_2SIndexDiff[rfPath][group] =
+					(PROMContent[EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
+			else
+				pwrInfo->HT40_2SIndexDiff[rfPath][group]	= EEPROM_Default_HT40_2SDiff;
+
+			if (PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
+			{
+				pwrInfo->HT20IndexDiff[rfPath][group] =
+					(PROMContent[EEPROM_HT20_TX_PWR_INX_DIFF_2G+ offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
+				if (pwrInfo->HT20IndexDiff[rfPath][group] & BIT3)	/* 4bit sign number to 8 bit sign number */
+					pwrInfo->HT20IndexDiff[rfPath][group] |= 0xF0;
+			}
+			else
+			{
+				pwrInfo->HT20IndexDiff[rfPath][group]		= EEPROM_Default_HT20_Diff;
+			}
+
+			if (PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] != 0xFF)
+				pwrInfo->OFDMIndexDiff[rfPath][group] =
+					(PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
+			else
+				pwrInfo->OFDMIndexDiff[rfPath][group]	= EEPROM_Default_LegacyHTTxPowerDiff;
+
+			if (PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
+				pwrInfo->HT40MaxOffset[rfPath][group] =
+					(PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
+			else
+				pwrInfo->HT40MaxOffset[rfPath][group]	= EEPROM_Default_HT40_PwrMaxOffset;
+
+			if (PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2 + offset1*21] != 0xFF)
+				pwrInfo->HT20MaxOffset[rfPath][group] =
+					(PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2 + offset1*21] >> (rfPath * 4)) & 0xF;
+			else
+				pwrInfo->HT20MaxOffset[rfPath][group]	= EEPROM_Default_HT20_PwrMaxOffset;
+
+		}
+	}
+
+	if (PROMContent[EEPROM_TSSI_A_5G] != 0xFF) {
+		/* 5GL */
+		pwrInfo->TSSI_A_5G[0] = PROMContent[EEPROM_TSSI_A_5G] & 0x3F;	/* 0:5] */
+		pwrInfo->TSSI_B_5G[0] = PROMContent[EEPROM_TSSI_B_5G] & 0x3F;
+
+		/* 5GM */
+		pwrInfo->TSSI_A_5G[1] = PROMContent[EEPROM_TSSI_AB_5G] & 0x3F;
+		pwrInfo->TSSI_B_5G[1] = (PROMContent[EEPROM_TSSI_AB_5G] & 0xC0) >> 6 |
+							(PROMContent[EEPROM_TSSI_AB_5G+1] & 0x0F) << 2;
+
+		/* 5GH */
+		pwrInfo->TSSI_A_5G[2] = (PROMContent[EEPROM_TSSI_AB_5G+1] & 0xF0) >> 4 |
+							(PROMContent[EEPROM_TSSI_AB_5G+2] & 0x03) << 4;
+		pwrInfo->TSSI_B_5G[2] = (PROMContent[EEPROM_TSSI_AB_5G+2] & 0xFC) >> 2;
+	}
+	else
+	{
+		for (i = 0; i < 3; i++)
+		{
+			pwrInfo->TSSI_A_5G[i] = EEPROM_Default_TSSI;
+			pwrInfo->TSSI_B_5G[i] = EEPROM_Default_TSSI;
+		}
+	}
+}
+
+void
+rtl8192d_ReadTxPowerInfo(
+	struct rtw_adapter *		adapter,
+	u8*			PROMContent,
+	bool			AutoLoadFail
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct tx_power_info pwrInfo;
+	u32			rfPath, ch, group;
+	u8			pwr, diff, tempval[2], i;
+
+	hal_ReadPowerValueFromPROM92D(adapter, &pwrInfo, PROMContent, AutoLoadFail);
+
+	if (!AutoLoadFail)
+	{
+		pHalData->EEPROMRegulatory = (PROMContent[EEPROM_RF_OPT1]&0x7);	/* bit0~2 */
+		pHalData->EEPROMThermalMeter = PROMContent[EEPROM_THERMAL_METER]&0x1f;
+		pHalData->CrystalCap = PROMContent[EEPROM_XTAL_K];
+		tempval[0] = PROMContent[EEPROM_IQK_DELTA]&0x03;
+		tempval[1] = (PROMContent[EEPROM_LCK_DELTA]&0x0C) >> 2;
+		pHalData->bTXPowerDataReadFromEEPORM = true;
+		if (IS_92D_D_CUT(pHalData->VersionID)||IS_92D_E_CUT(pHalData->VersionID))
+		{
+			pHalData->InternalPA5G[0] = !((PROMContent[EEPROM_TSSI_A_5G] & BIT6) >> 6);
+			pHalData->InternalPA5G[1] = !((PROMContent[EEPROM_TSSI_B_5G] & BIT6) >> 6);
+			DBG_8192D("Is D/E cut, Internal PA0 %d Internal PA1 %d\n", pHalData->InternalPA5G[0], pHalData->InternalPA5G[1]);
+		}
+		pHalData->EEPROMC9 = PROMContent[EEPROM_RF_OPT6];
+		pHalData->EEPROMCC = PROMContent[EEPROM_RF_OPT7];
+	}
+	else
+	{
+		pHalData->EEPROMRegulatory = 0;
+		pHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;
+		pHalData->CrystalCap = EEPROM_Default_CrystalCap;
+		tempval[0] = tempval[1] = 3;
+	}
+
+	pHalData->PAMode = PA_MODE_INTERNAL_SP3T;
+
+	if (pHalData->EEPROMC9 == 0xFF || AutoLoadFail)
+	{
+		switch (pHalData->PAMode)
+		{
+			/* external pa */
+			case 0:
+				pHalData->EEPROMC9 = EEPROM_Default_externalPA_C9;
+				pHalData->EEPROMCC = EEPROM_Default_externalPA_CC;
+				pHalData->InternalPA5G[0] = false;
+				pHalData->InternalPA5G[1] = false;
+				break;
+
+			/*  internal pa - SP3T */
+			case 1:
+				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SP3T_C9;
+				pHalData->EEPROMCC = EEPROM_Default_internalPA_SP3T_CC;
+				pHalData->InternalPA5G[0] = true;
+				pHalData->InternalPA5G[1] = true;
+				break;
+
+			/* intermal pa = SPDT */
+			case 2:
+				pHalData->EEPROMC9 = EEPROM_Default_internalPA_SPDT_C9;
+				pHalData->EEPROMCC = EEPROM_Default_internalPA_SPDT_CC;
+				pHalData->InternalPA5G[0] = true;
+				pHalData->InternalPA5G[1] = true;
+				break;
+
+			default:
+				break;
+		}
+	}
+	DBG_8192D("PHY_SetPAMode mode %d, c9 = 0x%x cc = 0x%x interface index %d\n", pHalData->PAMode, pHalData->EEPROMC9, pHalData->EEPROMCC, pHalData->interfaceIndex);
+
+	/* Use default value to fill parameters if efuse is not filled on some place. */
+
+	/*  ThermalMeter from EEPROM */
+	if (pHalData->EEPROMThermalMeter < 0x06 || pHalData->EEPROMThermalMeter > 0x1c)
+		pHalData->EEPROMThermalMeter = 0x12;
+
+	pdmpriv->ThermalMeter[0] = pHalData->EEPROMThermalMeter;
+
+	/* check XTAL_K */
+	if (pHalData->CrystalCap == 0xFF)
+		pHalData->CrystalCap = 0;
+
+	if (pHalData->EEPROMRegulatory >3)
+		pHalData->EEPROMRegulatory = 0;
+
+	for (i = 0; i < 2; i++)
+	{
+		switch (tempval[i])
+		{
+			case 0:
+				tempval[i] = 2;
+				break;
+
+			case 1:
+				tempval[i] = 4;
+				break;
+
+			case 2:
+				tempval[i] = 6;
+				break;
+
+			case 3:
+			default:
+				tempval[i] = 0;
+				break;
+		}
+	}
+
+	/* this is suggested by Mimic, every 4 steps to redo IQK, every 7 steps to redo LCK */
+	pdmpriv->Delta_IQK = 4;
+	pdmpriv->Delta_LCK = 7;
+	if (pHalData->EEPROMC9 == 0xFF)
+		pHalData->EEPROMC9 = 0x00;
+
+	for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+		for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+			group = Hal_GetChnlGroupfromArray((u8)ch);
+
+			if (ch < CHANNEL_MAX_NUMBER_2G)
+				pHalData->TxPwrLevelCck[rfPath][ch]		= pwrInfo.CCKIndex[rfPath][group];
+			pHalData->TxPwrLevelHT40_1S[rfPath][ch]	= pwrInfo.HT40_1SIndex[rfPath][group];
+
+			pHalData->TxPwrHt20Diff[rfPath][ch]		= pwrInfo.HT20IndexDiff[rfPath][group];
+			pHalData->TxPwrLegacyHtDiff[rfPath][ch]	= pwrInfo.OFDMIndexDiff[rfPath][group];
+			pHalData->PwrGroupHT20[rfPath][ch]		= pwrInfo.HT20MaxOffset[rfPath][group];
+			pHalData->PwrGroupHT40[rfPath][ch]		= pwrInfo.HT40MaxOffset[rfPath][group];
+
+			pwr		= pwrInfo.HT40_1SIndex[rfPath][group];
+			diff	= pwrInfo.HT40_2SIndexDiff[rfPath][group];
+
+			pHalData->TxPwrLevelHT40_2S[rfPath][ch]  = (pwr > diff) ? (pwr - diff) : 0;
+		}
+	}
+
+#if DBG
+
+	for (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {
+		for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+			if (ch < CHANNEL_MAX_NUMBER_2G)
+			{
+				DBG_8192D("RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",
+					rfPath, ch,
+					pHalData->TxPwrLevelCck[rfPath][ch],
+					pHalData->TxPwrLevelHT40_1S[rfPath][ch],
+					pHalData->TxPwrLevelHT40_2S[rfPath][ch]);
+			}
+			else
+			{
+				DBG_8192D("RF(%d)-Ch(%d) [HT40_1S / HT40_2S] = [0x%x / 0x%x]\n",
+					rfPath, ch,
+					pHalData->TxPwrLevelHT40_1S[rfPath][ch],
+					pHalData->TxPwrLevelHT40_2S[rfPath][ch]);
+			}
+		}
+	}
+
+	for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+		DBG_8192D("RF-A Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF_PATH_A][ch]);
+	}
+
+	for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+		DBG_8192D("RF-A Legacy to Ht40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_A][ch]);
+	}
+
+	for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+		DBG_8192D("RF-B Ht20 to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrHt20Diff[RF_PATH_B][ch]);
+	}
+
+	for (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {
+		DBG_8192D("RF-B Legacy to HT40 Diff[%d] = 0x%x\n", ch, pHalData->TxPwrLegacyHtDiff[RF_PATH_B][ch]);
+	}
+
+#endif
+}
+
+/*  */
+/*	Description: */
+/*		Reset Dual Mac Mode Switch related settings */
+/*  */
+/*	Assumption: */
+/*  */
+void rtl8192d_ResetDualMacSwitchVariables(
+		struct rtw_adapter *			adapter
+)
+{
+}
+
+u8 GetEEPROMSize8192D(struct rtw_adapter * adapter)
+{
+	u8	size = 0;
+	u32	curRCR;
+
+	curRCR = rtw_read16(adapter, REG_9346CR);
+	size = (curRCR & BOOT_FROM_EEPROM) ? 6 : 4; /*  6: EEPROM used is 93C46, 4: boot from E-Fuse. */
+
+	pr_info("r8192du: EEPROM type is %s", size == 4 ? "E-FUSE" : "93C46");
+
+	return size;
+}
+
+/************************************************************
+Function: Synchrosize for power off with dual mac
+*************************************************************/
+bool
+PHY_CheckPowerOffFor8192D(
+	struct rtw_adapter *   adapter
+)
+{
+	u8 u1bTmp;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY) {
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
+		return true;
+	}
+
+	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+	if (pHalData->interfaceIndex == 0) {
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, u1bTmp&(~MAC0_ON));
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
+		u1bTmp &= MAC1_ON;
+
+	} else {
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
+		rtw_write8(adapter, REG_MAC1, u1bTmp&(~MAC1_ON));
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		u1bTmp &= MAC0_ON;
+	}
+
+	if (u1bTmp)
+	{
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+		return false;
+	}
+
+	u1bTmp = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
+	u1bTmp|= BIT7;
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, u1bTmp);
+
+	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+	return true;
+}
+
+/************************************************************
+Function: Synchrosize for power off/on with dual mac
+*************************************************************/
+void
+PHY_SetPowerOnFor8192D(
+	struct rtw_adapter *adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	value8;
+	u16	i;
+
+	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex == 0?REG_MAC0:REG_MAC1));
+		value8 |= BIT1;
+		rtw_write8(adapter, (pHalData->interfaceIndex == 0?REG_MAC0:REG_MAC1), value8);
+	}
+	else
+	{
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex == 0?REG_MAC0:REG_MAC1));
+		value8 &= (~BIT1);
+		rtw_write8(adapter, (pHalData->interfaceIndex == 0?REG_MAC0:REG_MAC1), value8);
+	}
+
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+	{
+		value8 = rtw_read8(adapter, REG_MAC0);
+		rtw_write8(adapter, REG_MAC0, value8|MAC0_ON);
+	}
+	else
+	{
+		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+		if (pHalData->interfaceIndex == 0)
+		{
+			value8 = rtw_read8(adapter, REG_MAC0);
+			rtw_write8(adapter, REG_MAC0, value8|MAC0_ON);
+		}
+		else
+		{
+			value8 = rtw_read8(adapter, REG_MAC1);
+			rtw_write8(adapter, REG_MAC1, value8|MAC1_ON);
+		}
+		value8 = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+
+		for (i = 0;i<200;i++)
+		{
+			if ((value8&BIT7) == 0)
+			{
+				break;
+			}
+			else
+			{
+				rtw_udelay_os(500);
+				ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+				value8 = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
+				RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+			}
+		}
+
+		if (i == 200)
+			DBG_8192D("Another mac power off over time\n");
+	}
+}
+
+void rtl8192d_free_hal_data(struct rtw_adapter * padapter)
+{
+
+	DBG_8192D("===== rtl8192du_free_hal_data =====\n");
+
+	kfree(padapter->HalData);
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	GlobalFirstConfigurationForNormalChip = true;
+#endif
+
+}
+
+/*  */
+/*				Efuse related code */
+/*  */
+enum{
+		VOLTAGE_V25						= 0x03,
+		LDOE25_SHIFT						= 28 ,
+	};
+
+static void rtl8192d_EfusePowerSwitch(struct rtw_adapter *adapter, u8 bWrite,
+				      u8 PwrState)
+{
+	u8	tempval;
+	u16	tmpV16;
+
+	if (PwrState) {
+		/*  1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid */
+		tmpV16 = rtw_read16(adapter, REG_SYS_ISO_CTRL);
+		if (!(tmpV16 & PWC_EV12V)) {
+			tmpV16 |= PWC_EV12V;
+			 rtw_write16(adapter, REG_SYS_ISO_CTRL, tmpV16);
+		}
+		/*  Reset: 0x0000h[28], default valid */
+		tmpV16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
+		if (!(tmpV16 & FEN_ELDR)) {
+			tmpV16 |= FEN_ELDR;
+			rtw_write16(adapter, REG_SYS_FUNC_EN, tmpV16);
+		}
+
+		/*  Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid */
+		tmpV16 = rtw_read16(adapter, REG_SYS_CLKR);
+		if ((!(tmpV16 & LOADER_CLK_EN)) || (!(tmpV16 & ANA8M))) {
+			tmpV16 |= (LOADER_CLK_EN | ANA8M);
+			rtw_write16(adapter, REG_SYS_CLKR, tmpV16);
+		}
+
+		if (bWrite == true) {
+			/*  Enable LDO 2.5V before read/write action */
+			tempval = rtw_read8(adapter, EFUSE_TEST+3);
+			tempval &= 0x0F;
+			tempval |= (VOLTAGE_V25 << 4);
+			rtw_write8(adapter, EFUSE_TEST+3, (tempval | 0x80));
+		}
+	} else {
+		if (bWrite == true) {
+			/*  Disable LDO 2.5V after read/write action */
+			tempval = rtw_read8(adapter, EFUSE_TEST+3);
+			rtw_write8(adapter, EFUSE_TEST+3, (tempval & 0x7F));
+		}
+	}
+}
+
+static void ReadEFuse_RTL8192D(struct rtw_adapter *adapter, u8 efuseType,
+			       u16 _offset, u16 _size_byte, u8 *pbuf,
+			       bool bPseudoTest)
+{
+	u8	efuseTbl[EFUSE_MAP_LEN];
+	u8	rtemp8[1];
+	u16	eFuse_Addr = 0;
+	u8	offset, wren;
+	u16  i, j;
+	u16	eFuseWord[EFUSE_MAX_SECTION][EFUSE_MAX_WORD_UNIT];
+	u16	efuse_utilized = 0;
+	u8	u1temp = 0;
+
+	/*  Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10. */
+	if ((_offset + _size_byte)>EFUSE_MAP_LEN) {
+		/*  total E-Fuse table is 128bytes */
+		DBG_8192D("ReadEFuse(): Invalid offset(%#x) with read bytes(%#x)!!\n", _offset, _size_byte);
+		return;
+	}
+
+	/*  0. Refresh efuse init map as all oxFF. */
+	for (i = 0; i < EFUSE_MAX_SECTION; i++)
+		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
+			eFuseWord[i][j] = 0xFFFF;
+	/*  1. Read the first byte to check if efuse is empty!!! */
+	ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+	if (*rtemp8 != 0xFF) {
+		efuse_utilized++;
+		eFuse_Addr++;
+	} else {
+		return;
+	}
+
+	/*  2. Read real efuse content. Filter PG header and every section data. */
+	while ((*rtemp8 != 0xFF) && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN)) {
+		/*  Check PG header for section num. */
+		if ((*rtemp8 & 0x1F) == 0x0F) {		/* extended header */
+			u1temp = ((*rtemp8 & 0xE0) >> 5);
+
+			ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+
+			if ((*rtemp8 & 0x0F) == 0x0F) {
+				eFuse_Addr++;
+				ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+
+				if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN))
+					eFuse_Addr++;
+				continue;
+			} else {
+				offset = ((*rtemp8 & 0xF0) >> 1) | u1temp;
+				wren = (*rtemp8 & 0x0F);
+				eFuse_Addr++;
+			}
+		} else {
+			offset = ((*rtemp8 >> 4) & 0x0f);
+			wren = (*rtemp8 & 0x0f);
+		}
+
+		if (offset < EFUSE_MAX_SECTION) {
+			/*  Get word enable value from PG header */
+
+			for (i = 0; i<EFUSE_MAX_WORD_UNIT; i++) {
+				/*  Check word enable condition in the section */
+				if (!(wren & 0x01)) {
+					ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+					eFuse_Addr++;
+					efuse_utilized++;
+					eFuseWord[offset][i] = (*rtemp8 & 0xff);
+					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+						break;
+					ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+					eFuse_Addr++;
+					efuse_utilized++;
+					eFuseWord[offset][i] |= (((u16)*rtemp8 << 8) & 0xff00);
+
+					if (eFuse_Addr >= EFUSE_REAL_CONTENT_LEN)
+						break;
+				}
+				wren >>= 1;
+			}
+		}
+
+		/*  Read next PG header */
+		ReadEFuseByte(adapter, eFuse_Addr, rtemp8, bPseudoTest);
+
+		if (*rtemp8 != 0xFF && (eFuse_Addr < EFUSE_REAL_CONTENT_LEN)) {
+			efuse_utilized++;
+			eFuse_Addr++;
+		}
+	}
+
+	/*  3. Collect 16 sections and 4 word unit into Efuse map. */
+	for (i = 0; i<EFUSE_MAX_SECTION; i++) {
+		for (j = 0; j<EFUSE_MAX_WORD_UNIT; j++) {
+			efuseTbl[(i*8)+(j*2)]= (eFuseWord[i][j] & 0xff);
+			efuseTbl[(i*8)+((j*2)+1)]= ((eFuseWord[i][j] >> 8) & 0xff);
+		}
+	}
+	/*  4. Copy from Efuse map to output pointer memory!!! */
+	for (i = 0; i<_size_byte; i++)
+		pbuf[i] = efuseTbl[_offset+i];
+	/*  5. Calculate Efuse utilization. */
+	rtw_hal_set_hwreg(adapter, HW_VAR_EFUSE_BYTES, (u8*)&efuse_utilized);
+}
+
+static void hal_EfuseUpdateNormalChipVersion_92D(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	enum VERSION_8192D	ChipVer = pHalData->VersionID;
+	u8	CutValue[2];
+	u16	ChipValue = 0;
+
+	ReadEFuseByte(adapter, EEPROME_CHIP_VERSION_H, &CutValue[1], false);
+	ReadEFuseByte(adapter, EEPROME_CHIP_VERSION_L, &CutValue[0], false);
+
+	ChipValue = (CutValue[1] << 8) | CutValue[0];
+	switch (ChipValue) {
+	case 0xAA55:
+		ChipVer = (enum VERSION_8192D)(ChipVer | C_CUT_VERSION);
+		pr_cont(", C-CUT chip\n");
+		break;
+	case 0x9966:
+		ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
+		pr_cont(", D-CUT chip\n");
+		break;
+	case 0xCC33:
+		ChipVer = (enum VERSION_8192D)(ChipVer | E_CUT_VERSION);
+		pr_cont(", E-CUT chip\n");
+		break;
+	default:
+		ChipVer = (enum VERSION_8192D)(ChipVer | D_CUT_VERSION);
+		pr_cont(", Unknown CUT chip\n");
+		break;
+	}
+	pHalData->VersionID = ChipVer;
+}
+
+static bool hal_EfuseMacMode_ISVS_92D(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	PartNo;
+	bool bResult = false;
+
+	/*  92D VS not support dual mac mode */
+	if (IS_NORMAL_CHIP92D(pHalData->VersionID)) {
+		ReadEFuseByte(adapter, EEPROM_DEF_PART_NO, &PartNo, false);
+
+		if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
+			(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
+		{
+			bResult = true;
+		} else if (PartNo == 0x00) {
+			ReadEFuseByte(adapter, EEPROM_DEF_PART_NO+1, &PartNo, false);
+			if ((((PartNo & 0xc0) ==  PARTNO_92D_NIC)&&((PartNo & 0x0c) == PARTNO_SINGLE_BAND_VS))||
+				(((PartNo & 0xF0) == PARTNO_92D_NIC_REMARK) &&((PartNo & 0x0F) == PARTNO_SINGLE_BAND_VS_REMARK)))
+			{
+				bResult = true;
+			}
+		}
+	}
+	return bResult;
+}
+
+static void rtl8192d_ReadEFuse(struct rtw_adapter *adapter, u8 efuseType,
+			       u16 _offset, u16 _size_byte, u8 *pbuf,
+			       bool bPseudoTest)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	ReadEFuse_RTL8192D(adapter, efuseType, _offset, _size_byte, pbuf, bPseudoTest);
+
+	hal_EfuseUpdateNormalChipVersion_92D(adapter);
+	pHalData->bIsVS = hal_EfuseMacMode_ISVS_92D(adapter);
+}
+
+static void rtl8192d_EFUSE_GetEfuseDefinition(struct rtw_adapter *adapter,
+					      u8 efuseType, u8 type,
+					      void **pOut, bool bPseudoTest)
+{
+	switch (type) {
+	case TYPE_EFUSE_MAX_SECTION:
+		{
+			u8	*pMax_section;
+			pMax_section = (u8 *)pOut;
+			*pMax_section = EFUSE_MAX_SECTION;
+		}
+		break;
+	case TYPE_EFUSE_REAL_CONTENT_LEN:
+		{
+			u16 *pu2Tmp;
+			pu2Tmp = (u16 *)pOut;
+			*pu2Tmp = EFUSE_REAL_CONTENT_LEN;
+		}
+		break;
+	case TYPE_AVAILABLE_EFUSE_BYTES_BANK:
+		{
+			u16	*pu2Tmp;
+			pu2Tmp = (u16 *)pOut;
+			*pu2Tmp = (u16)(EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES);
+		}
+		break;
+	case TYPE_AVAILABLE_EFUSE_BYTES_TOTAL:
+		{
+			u16 *pu2Tmp;
+			pu2Tmp = (u16 *)pOut;
+			*pu2Tmp = (u16)(EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES);
+		}
+		break;
+	case TYPE_EFUSE_MAP_LEN:
+		{
+			u16 *pu2Tmp;
+			pu2Tmp = (u16 *)pOut;
+			*pu2Tmp = (u16)EFUSE_MAP_LEN;
+		}
+		break;
+	case TYPE_EFUSE_PROTECT_BYTES_BANK:
+		{
+			u8 *pu1Tmp;
+			pu1Tmp = (u8 *)pOut;
+			*pu1Tmp = (u8)(EFUSE_OOB_PROTECT_BYTES);
+		}
+		break;
+	default: {
+		u8 *pu1Tmp;
+		pu1Tmp = (u8 *)pOut;
+		*pu1Tmp = 0;
+		break; }
+	}
+}
+
+static u16 rtl8192d_EfuseGetCurrentSize(struct rtw_adapter *adapter,
+					u8 efuseType, bool bPseudoTest)
+{
+	int	bContinual = true;
+	u16	efuse_addr = 0;
+	u8	hoffset = 0, hworden = 0;
+	u8	efuse_data, word_cnts = 0;
+
+	while (bContinual &&
+	       efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest) &&
+	       (efuse_addr  < EFUSE_REAL_CONTENT_LEN)) {
+		if (efuse_data!= 0xFF) {
+			if ((efuse_data&0x1F) == 0x0F) {		/* extended header */
+				hoffset = efuse_data;
+				efuse_addr++;
+				efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest);
+				if ((efuse_data & 0x0F) == 0x0F) {
+					efuse_addr++;
+					continue;
+				} else {
+					hoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
+					hworden = efuse_data & 0x0F;
+				}
+			} else {
+				hoffset = (efuse_data>>4) & 0x0F;
+				hworden =  efuse_data & 0x0F;
+			}
+			word_cnts = Efuse_CalculateWordCnts(hworden);
+			/* read next header */
+			efuse_addr = efuse_addr + (word_cnts*2)+1;
+		} else {
+			bContinual = false;
+		}
+	}
+	return efuse_addr;
+}
+
+static int
+rtl8192d_Efuse_PgPacketRead(	struct rtw_adapter *	adapter,
+					u8			offset,
+					u8			*data,
+					bool		bPseudoTest)
+{
+	u8	ReadState = PG_STATE_HEADER;
+	int	bContinual = true;
+	int	bDataEmpty = true;
+	u8	efuse_data, word_cnts = 0;
+	u16	efuse_addr = 0;
+	u8	hoffset = 0, hworden = 0;
+	u8	tmpidx = 0;
+	u8	tmpdata[8];
+	u8	tmp_header = 0;
+
+	if (data == NULL)
+		return false;
+	if (offset >= EFUSE_MAX_SECTION)
+		return false;
+
+	memset((void *)data, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
+	memset((void *)tmpdata, 0xff, sizeof(u8)*PGPKT_DATA_SIZE);
+
+	/*  <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  Skip dummy parts to prevent unexpected data read from Efuse. */
+	/*  By pass right now. 2009.02.19. */
+	while (bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN)) {
+		/*   Header Read ------------- */
+		if (ReadState & PG_STATE_HEADER) {
+			if (efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest) &&
+			    (efuse_data!= 0xFF)) {
+				if ((efuse_data & 0x1F) == 0x0F) {
+					tmp_header = efuse_data;
+					efuse_addr++;
+					efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest);
+					if ((efuse_data & 0x0F) != 0x0F) {
+						hoffset = ((tmp_header & 0xE0) >> 5) |
+							  ((efuse_data & 0xF0) >> 1);
+						hworden = efuse_data & 0x0F;
+					} else {
+						efuse_addr++;
+						continue;
+					}
+				} else {
+					hoffset = (efuse_data>>4) & 0x0F;
+					hworden =  efuse_data & 0x0F;
+				}
+				word_cnts = Efuse_CalculateWordCnts(hworden);
+				bDataEmpty = true;
+
+				if (hoffset == offset) {
+					for (tmpidx = 0; tmpidx < word_cnts*2; tmpidx++) {
+						if (efuse_OneByteRead(adapter, efuse_addr+1+tmpidx, &efuse_data, bPseudoTest)) {
+							tmpdata[tmpidx] = efuse_data;
+							if (efuse_data!= 0xff)
+								bDataEmpty = false;
+						}
+					}
+					if (bDataEmpty == false) {
+						ReadState = PG_STATE_DATA;
+					} else {/* read next header */
+						efuse_addr = efuse_addr + (word_cnts*2)+1;
+						ReadState = PG_STATE_HEADER;
+					}
+				} else {/* read next header */
+					efuse_addr = efuse_addr + (word_cnts*2)+1;
+					ReadState = PG_STATE_HEADER;
+				}
+
+			} else {
+				bContinual = false;
+			}
+		}
+		/*   Data section Read ------------- */
+		else if (ReadState & PG_STATE_DATA) {
+			efuse_WordEnableDataRead(hworden, tmpdata, data);
+			efuse_addr = efuse_addr + (word_cnts*2)+1;
+			ReadState = PG_STATE_HEADER;
+		}
+	}
+
+	if ((data[0]== 0xff) &&(data[1]== 0xff) && (data[2]== 0xff)  && (data[3]== 0xff) &&
+	    (data[4]== 0xff) &&(data[5]== 0xff) && (data[6]== 0xff)  && (data[7]== 0xff))
+		return false;
+	else
+		return true;
+}
+
+static int
+rtl8192d_Efuse_PgPacketWrite(struct rtw_adapter *	adapter,
+					u8			offset,
+					u8			word_en,
+					u8			*data,
+					bool		bPseudoTest)
+{
+	u8	WriteState = PG_STATE_HEADER;
+	int	bContinual = true, bDataEmpty = true, bResult = true;
+	u16	efuse_addr = 0;
+	u8	efuse_data;
+	u8	pg_header = 0, pg_header_temp = 0;
+	u8	tmp_word_cnts = 0, target_word_cnts = 0;
+	u8	tmp_header, match_word_en, tmp_word_en;
+	struct pg_pkt_struct_a target_pkt;
+	struct pg_pkt_struct_a tmp_pkt = {
+		.offset = 0,
+		.word_en = 0,
+		.data ={0, 0, 0, 0, 0, 0, 0, 0},
+		.word_cnts = 0
+	};
+	u8	originaldata[sizeof(u8)*8];
+	u8	tmpindex = 0, badworden = 0x0F;
+	static int	repeat_times;
+	bool		bExtendedHeader = false;
+	u8	efuseType = EFUSE_WIFI;
+
+	/*  */
+	/*  <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  So we have to prevent unexpected data string connection, which will cause */
+	/*  incorrect data auto-load from HW. The total size is equal or smaller than 498bytes */
+	/*  (i.e., offset 0~497, and dummy 1bytes) expected after CP test. */
+	/*  2009.02.19. */
+	/*  */
+	if (Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest) >= (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))
+		return false;
+
+	/*  Init the 8 bytes content as 0xff */
+	target_pkt.offset = offset;
+	target_pkt.word_en = word_en;
+
+	memset((void *)target_pkt.data, 0xFF, sizeof(u8)*8);
+
+	efuse_WordEnableDataRead(word_en, data, target_pkt.data);
+	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
+
+	/*  <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP. */
+	/*  So we have to prevent unexpected data string connection, which will cause */
+	/*  incorrect data auto-load from HW. Dummy 1bytes is additional. */
+	while (bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN-EFUSE_OOB_PROTECT_BYTES))) {
+
+		if (WriteState == PG_STATE_HEADER) {
+			bDataEmpty = true;
+			badworden = 0x0F;
+			/*   so ******************* */
+			if (efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest) &&
+			    (efuse_data!= 0xFF)) {
+				if ((efuse_data&0x1F) == 0x0F) {		/* extended header */
+					tmp_header = efuse_data;
+					efuse_addr++;
+					efuse_OneByteRead(adapter, efuse_addr, &efuse_data, bPseudoTest);
+					if ((efuse_data & 0x0F) == 0x0F) {	/* wren fail */
+						efuse_addr++;
+						continue;
+					} else {
+						tmp_pkt.offset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
+						tmp_pkt.word_en = efuse_data & 0x0F;
+					}
+				} else {
+					tmp_header  =  efuse_data;
+					tmp_pkt.offset	= (tmp_header>>4) & 0x0F;
+					tmp_pkt.word_en = tmp_header & 0x0F;
+				}
+				tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+
+				/*   so-1 ******************* */
+				if (tmp_pkt.offset  != target_pkt.offset) {
+					efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
+#if (EFUSE_ERROE_HANDLE == 1)
+					WriteState = PG_STATE_HEADER;
+#endif
+				} else {		/* write the same offset */
+					/*   so-2 ******************* */
+					for (tmpindex = 0; tmpindex < (tmp_word_cnts*2); tmpindex++) {
+						if (efuse_OneByteRead(adapter, (efuse_addr+1+tmpindex), &efuse_data, bPseudoTest) &&
+						    (efuse_data != 0xFF))
+							bDataEmpty = false;
+					}
+					/*   so-2-1 ******************* */
+					if (!bDataEmpty) {
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
+#if (EFUSE_ERROE_HANDLE == 1)
+						WriteState = PG_STATE_HEADER;
+#endif
+					} else {/*   so-2-2 ******************* */
+
+						match_word_en = 0x0F;			/* same bit as original wren */
+						if (!((target_pkt.word_en&BIT0)|(tmp_pkt.word_en&BIT0)))
+							 match_word_en &= (~BIT0);
+						if (!((target_pkt.word_en&BIT1)|(tmp_pkt.word_en&BIT1)))
+							 match_word_en &= (~BIT1);
+						if (!((target_pkt.word_en&BIT2)|(tmp_pkt.word_en&BIT2)))
+							 match_word_en &= (~BIT2);
+						if (!((target_pkt.word_en&BIT3)|(tmp_pkt.word_en&BIT3)))
+							 match_word_en &= (~BIT3);
+
+						/*   so-2-2-A ******************* */
+						if ((match_word_en&0x0F)!= 0x0F) {
+							badworden = Efuse_WordEnableDataWrite(adapter, efuse_addr+1, tmp_pkt.word_en , target_pkt.data, bPseudoTest);
+
+							/*   so-2-2-A-1 ******************* */
+							if (0x0F != (badworden&0x0F)) {
+								u8	reorg_offset = offset;
+								u8	reorg_worden = badworden;
+								Efuse_PgPacketWrite(adapter, reorg_offset, reorg_worden, target_pkt.data, bPseudoTest);
+							}
+
+							tmp_word_en = 0x0F;		/* not the same bit as original wren */
+							if ((target_pkt.word_en&BIT0)^(match_word_en&BIT0))
+								tmp_word_en &= (~BIT0);
+							if ((target_pkt.word_en&BIT1)^(match_word_en&BIT1))
+								tmp_word_en &=  (~BIT1);
+							if ((target_pkt.word_en&BIT2)^(match_word_en&BIT2))
+								tmp_word_en &= (~BIT2);
+							if ((target_pkt.word_en&BIT3)^(match_word_en&BIT3))
+								tmp_word_en &= (~BIT3);
+
+							/*   so-2-2-A-2 ******************* */
+							if ((tmp_word_en&0x0F)!= 0x0F) {
+								/* reorganize other pg packet */
+								efuse_addr = Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest);
+								target_pkt.offset = offset;
+								target_pkt.word_en = tmp_word_en;
+							} else {
+								bContinual = false;
+							}
+#if (EFUSE_ERROE_HANDLE == 1)
+							WriteState = PG_STATE_HEADER;
+							repeat_times++;
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								bResult = false;
+							}
+#endif
+						} else {/*   so-2-2-B ******************* */
+							/* reorganize other pg packet */
+							efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;/* next pg packet addr */
+							target_pkt.offset = offset;
+							target_pkt.word_en = target_pkt.word_en;
+#if (EFUSE_ERROE_HANDLE == 1)
+							WriteState = PG_STATE_HEADER;
+#endif
+						}
+					}
+				}
+			} else		/*   s1: header == oxff  ******************* */
+			{
+				bExtendedHeader = false;
+
+				if (target_pkt.offset >= EFUSE_MAX_SECTION_BASE) {
+					pg_header = ((target_pkt.offset &0x07) << 5) | 0x0F;
+
+					efuse_OneByteWrite(adapter, efuse_addr, pg_header, bPseudoTest);
+					efuse_OneByteRead(adapter, efuse_addr, &tmp_header, bPseudoTest);
+
+					while (tmp_header == 0xFF) {
+						repeat_times++;
+
+						if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+							bContinual = false;
+							bResult = false;
+							efuse_addr++;
+							break;
+						}
+						efuse_OneByteWrite(adapter, efuse_addr, pg_header, bPseudoTest);
+						efuse_OneByteRead(adapter, efuse_addr, &tmp_header, bPseudoTest);
+					}
+
+					if (!bContinual)
+						break;
+
+					if (tmp_header == pg_header) {
+						efuse_addr++;
+						pg_header_temp = pg_header;
+						pg_header = ((target_pkt.offset & 0x78) << 1) | target_pkt.word_en;
+
+						efuse_OneByteWrite(adapter, efuse_addr, pg_header, bPseudoTest);
+						efuse_OneByteRead(adapter, efuse_addr, &tmp_header, bPseudoTest);
+
+						while (tmp_header == 0xFF) {
+							repeat_times++;
+
+							if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								bResult = false;
+								break;
+							}
+							efuse_OneByteWrite(adapter, efuse_addr, pg_header, bPseudoTest);
+							efuse_OneByteRead(adapter, efuse_addr, &tmp_header, bPseudoTest);
+						}
+
+						if (!bContinual)
+							break;
+
+						if ((tmp_header & 0x0F) == 0x0F)	/* wren PG fail */
+						{
+							repeat_times++;
+
+							if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								bResult = false;
+								break;
+							} else {
+								efuse_addr++;
+								continue;
+							}
+						} else if (pg_header != tmp_header)	/* offset PG fail */
+						{
+							bExtendedHeader = true;
+							tmp_pkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
+							tmp_pkt.word_en =  tmp_header & 0x0F;
+							tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+						}
+					} else if ((tmp_header & 0x1F) == 0x0F)		/* wrong extended header */
+					{
+						efuse_addr+= 2;
+						continue;
+					}
+				} else {
+					pg_header = ((target_pkt.offset << 4)&0xf0) |target_pkt.word_en;
+					efuse_OneByteWrite(adapter, efuse_addr, pg_header, bPseudoTest);
+					efuse_OneByteRead(adapter, efuse_addr, &tmp_header, bPseudoTest);
+				}
+
+				if (tmp_header == pg_header) {
+					/*   s1-1******************* */
+					WriteState = PG_STATE_DATA;
+				}
+#if (EFUSE_ERROE_HANDLE == 1)
+				else if (tmp_header == 0xFF) {/*   s1-3: if Write or read func doesn't work ******************* */
+					/* efuse_addr doesn't change */
+					WriteState = PG_STATE_HEADER;
+					repeat_times++;
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+						bContinual = false;
+						bResult = false;
+					}
+				}
+#endif
+				else {/*   s1-2 : fixed the header procedure ******************* */
+					if (!bExtendedHeader) {
+						tmp_pkt.offset = (tmp_header>>4) & 0x0F;
+						tmp_pkt.word_en =  tmp_header & 0x0F;
+						tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+					}
+
+					/*   s1-2-A :cover the exist data ******************* */
+					memset((void *)originaldata, 0xff, sizeof(u8)*8);
+
+					if (Efuse_PgPacketRead(adapter, tmp_pkt.offset, originaldata, bPseudoTest))
+					{	/* check if data exist */
+						badworden = Efuse_WordEnableDataWrite(adapter, efuse_addr+1, tmp_pkt.word_en, originaldata, bPseudoTest);
+						/*  */
+						if (0x0F != (badworden&0x0F)) {
+							u8	reorg_offset = tmp_pkt.offset;
+							u8	reorg_worden = badworden;
+							Efuse_PgPacketWrite(adapter, reorg_offset, reorg_worden, originaldata, bPseudoTest);
+							efuse_addr = Efuse_GetCurrentSize(adapter, efuseType, bPseudoTest);
+						} else {
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
+						}
+					}
+					 /*   s1-2-B: wrong address******************* */
+					else {
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) +1; /* Next pg_packet */
+					}
+
+#if (EFUSE_ERROE_HANDLE == 1)
+					WriteState = PG_STATE_HEADER;
+					repeat_times++;
+					if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+						bContinual = false;
+						bResult = false;
+					}
+#endif
+				}
+			}
+		}
+		/* write data state */
+		else if (WriteState == PG_STATE_DATA) {
+			/*   s1-1  ******************* */
+			badworden = 0x0f;
+			badworden = Efuse_WordEnableDataWrite(adapter, efuse_addr+1, target_pkt.word_en, target_pkt.data , bPseudoTest);
+			if ((badworden&0x0F) == 0x0F) {
+				/*   s1-1-A ******************* */
+				bContinual = false;
+			} else {
+				/* reorganize other pg packet **  s1-1-B **/
+				efuse_addr = efuse_addr + (2*target_word_cnts) +1;/* next pg packet addr */
+
+				target_pkt.offset = offset;
+				target_pkt.word_en = badworden;
+				target_word_cnts =  Efuse_CalculateWordCnts(target_pkt.word_en);
+#if (EFUSE_ERROE_HANDLE == 1)
+				WriteState = PG_STATE_HEADER;
+				repeat_times++;
+				if (repeat_times>EFUSE_REPEAT_THRESHOLD_) {
+					bContinual = false;
+					bResult = false;
+				}
+#endif
+			}
+		}
+	}
+	return bResult;
+}
+
+static u8 rtl8192d_Efuse_WordEnableDataWrite(struct rtw_adapter *adapter,
+					     u16 efuse_addr, u8 word_en,
+					     u8 *data, bool bPseudoTest)
+{
+	u16	tmpaddr = 0;
+	u16	start_addr = efuse_addr;
+	u8	badworden = 0x0F;
+	u8	tmpdata[8];
+
+	memset((void *)tmpdata, 0xff, PGPKT_DATA_SIZE);
+	if (!(word_en&BIT0)) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(adapter, start_addr++, data[0], bPseudoTest);
+		efuse_OneByteWrite(adapter, start_addr++, data[1], bPseudoTest);
+
+		efuse_OneByteRead(adapter, tmpaddr, &tmpdata[0], bPseudoTest);
+		efuse_OneByteRead(adapter, tmpaddr+1, &tmpdata[1], bPseudoTest);
+		if ((data[0]!= tmpdata[0])||(data[1]!= tmpdata[1])) {
+			badworden &= (~BIT0);
+		}
+	}
+	if (!(word_en&BIT1)) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(adapter, start_addr++, data[2], bPseudoTest);
+		efuse_OneByteWrite(adapter, start_addr++, data[3], bPseudoTest);
+
+		efuse_OneByteRead(adapter, tmpaddr    , &tmpdata[2], bPseudoTest);
+		efuse_OneByteRead(adapter, tmpaddr+1, &tmpdata[3], bPseudoTest);
+		if ((data[2]!= tmpdata[2])||(data[3]!= tmpdata[3]))
+			badworden &= (~BIT1);
+	}
+	if (!(word_en&BIT2)) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(adapter, start_addr++, data[4], bPseudoTest);
+		efuse_OneByteWrite(adapter, start_addr++, data[5], bPseudoTest);
+
+		efuse_OneByteRead(adapter, tmpaddr, &tmpdata[4], bPseudoTest);
+		efuse_OneByteRead(adapter, tmpaddr+1, &tmpdata[5], bPseudoTest);
+		if ((data[4]!= tmpdata[4])||(data[5]!= tmpdata[5]))
+			badworden &= (~BIT2);
+	}
+	if (!(word_en&BIT3)) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(adapter, start_addr++, data[6], bPseudoTest);
+		efuse_OneByteWrite(adapter, start_addr++, data[7], bPseudoTest);
+
+		efuse_OneByteRead(adapter, tmpaddr, &tmpdata[6], bPseudoTest);
+		efuse_OneByteRead(adapter, tmpaddr+1, &tmpdata[7], bPseudoTest);
+		if ((data[6]!= tmpdata[6])||(data[7]!= tmpdata[7]))
+			badworden &= (~BIT3);
+	}
+	return badworden;
+}
+
+static void hal_notch_filter_8192d(struct rtw_adapter *adapter, bool enable)
+{
+	if (enable) {
+		DBG_8192D("Enable notch filter\n");
+		rtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) | BIT1);
+	} else {
+		DBG_8192D("Disable notch filter\n");
+		rtw_write8(adapter, rOFDM0_RxDSP+1, rtw_read8(adapter, rOFDM0_RxDSP+1) & ~BIT1);
+	}
+}
+
+static s32 c2h_id_filter_ccx_8192d(u8 id)
+{
+	s32 ret = false;
+	if (id == C2H_CCX_TX_RPT)
+		ret = true;
+
+	return ret;
+}
+
+static s32 c2h_handler_8192d(struct rtw_adapter *padapter, struct c2h_evt_hdr *c2h_evt)
+{
+	s32 ret = _SUCCESS;
+	u8 i = 0;
+
+	if (c2h_evt == NULL) {
+		DBG_8192D("%s c2h_evt is NULL\n", __func__);
+		ret = _FAIL;
+		goto exit;
+	}
+
+	switch (c2h_evt->id) {
+	case C2H_CCX_TX_RPT:
+		handle_txrpt_ccx_8192d(padapter, c2h_evt->payload);
+		break;
+	default:
+		ret = _FAIL;
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc)
+{
+	pHalFunc->free_hal_data = &rtl8192d_free_hal_data;
+
+	pHalFunc->dm_init = &rtl8192d_init_dm_priv;
+	pHalFunc->dm_deinit = &rtl8192d_deinit_dm_priv;
+	pHalFunc->read_chip_version = &rtl8192d_ReadChipVersion;
+
+	pHalFunc->set_bwmode_handler = &PHY_SetBWMode8192D;
+	pHalFunc->set_channel_handler = &PHY_SwChnl8192D;
+
+	pHalFunc->hal_dm_watchdog = &rtl8192d_HalDmWatchDog;
+
+	pHalFunc->Add_RateATid = &rtl8192d_Add_RateATid;
+
+	pHalFunc->read_bbreg = &rtl8192d_PHY_QueryBBReg;
+	pHalFunc->write_bbreg = &rtl8192d_PHY_SetBBReg;
+	pHalFunc->read_rfreg = &rtl8192d_PHY_QueryRFReg;
+	pHalFunc->write_rfreg = &rtl8192d_PHY_SetRFReg;
+
+	/* Efuse related function */
+	pHalFunc->EfusePowerSwitch = &rtl8192d_EfusePowerSwitch;
+	pHalFunc->ReadEFuse = &rtl8192d_ReadEFuse;
+	pHalFunc->EFUSEGetEfuseDefinition = &rtl8192d_EFUSE_GetEfuseDefinition;
+	pHalFunc->EfuseGetCurrentSize = &rtl8192d_EfuseGetCurrentSize;
+	pHalFunc->Efuse_PgPacketRead = &rtl8192d_Efuse_PgPacketRead;
+	pHalFunc->Efuse_PgPacketWrite = &rtl8192d_Efuse_PgPacketWrite;
+	pHalFunc->Efuse_WordEnableDataWrite = &rtl8192d_Efuse_WordEnableDataWrite;
+
+	pHalFunc->hal_notch_filter = &hal_notch_filter_8192d;
+
+	pHalFunc->c2h_handler = c2h_handler_8192d;
+	pHalFunc->c2h_id_filter_ccx = c2h_id_filter_ccx_8192d;
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_phycfg.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_phycfg.c
new file mode 100644
index 0000000..373df15
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_phycfg.c
@@ -0,0 +1,6405 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/******************************************************************************
+
+ Module:	rtl8192d_phycfg.c
+
+ Note:		Merge 92DE/SDU PHY config as below
+			1. BB register R/W API
+			2. RF register R/W API
+			3. Initial BB/RF/MAC config by reading BB/MAC/RF txt.
+			3. Power setting API
+			4. Channel switch API
+			5. Initial gain switch API.
+			6. Other BB/MAC/RF API.
+
+ Function:	PHY: Extern function, phy: local function
+
+ Export:	PHY_FunctionName
+
+ Abbrev:	NONE
+
+ History:
+	Data		Who		Remark
+	08/08/2008  MHC		1. Port from 9x series phycfg.c
+						2. Reorganize code arch and ad description.
+						3. Collect similar function.
+						4. Seperate extern/local API.
+	08/12/2008	MHC		We must merge or move USB PHY relative function later.
+	10/07/2008	MHC		Add IQ calibration for PHY.(Only 1T2R mode now!!!)
+	11/06/2008	MHC		Add TX Power index PG file to config in 0xExx register
+						area to map with EEPROM/EFUSE tx pwr index.
+
+******************************************************************************/
+#define _HAL_8192D_PHYCFG_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_efuse.h>
+
+#include <hal_intf.h>
+#include <rtl8192d_hal.h>
+#include <hal8192dphycfg.h>
+
+/*---------------------------Define Local Constant---------------------------*/
+
+/*------------------------Define global variable-----------------------------*/
+#ifdef CONFIG_DUALMAC_CONCURRENT
+extern atomic_t GlobalCounterForMutex;
+#endif
+/*------------------------Define local variable------------------------------*/
+
+/*--------------------Define export function prototype-----------------------*/
+/*  Please refer to header file */
+/*--------------------Define export function prototype-----------------------*/
+
+/*---------------------Define local function prototype-----------------------*/
+static void
+phy_PathAFillIQKMatrix(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	);
+
+static void
+phy_PathAFillIQKMatrix_5G_Normal(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	);
+
+static void
+phy_PathBFillIQKMatrix(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	);
+
+static void
+phy_PathBFillIQKMatrix_5G_Normal(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	);
+/*----------------------------Function Body----------------------------------*/
+
+static u8 GetRightChnlPlace(u8 chnl)
+{
+	u8	channel_5G[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+	u8	place = chnl;
+
+	if (chnl > 14)
+	{
+		for (place = 14; place<sizeof(channel_5G); place++)
+		{
+			if (channel_5G[place] == chnl)
+			{
+				place++;
+				break;
+			}
+		}
+	}
+
+	return place;
+}
+
+static u8 GetChnlFromPlace(u8 place)
+{
+	u8	channel_5G[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+
+	return channel_5G[place];
+}
+
+u8 rtl8192d_GetRightChnlPlaceforIQK(u8 chnl)
+{
+	u8	channel_all[TARGET_CHNL_NUM_2G_5G] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+	u8	place = chnl;
+
+	if (chnl > 14)
+	{
+		for (place = 14; place<sizeof(channel_all); place++)
+		{
+			if (channel_all[place] == chnl)
+			{
+				return place-13;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*  */
+/*  1. BB register R/W API */
+/*  */
+/**
+* Function:	phy_CalculateBitShift
+*
+* OverView:	Get shifted position of the BitMask
+*
+* Input:
+*			u4Byte		BitMask,
+*
+* Output:	none
+* Return:		u4Byte		Return the shift bit bit position of the mask
+*/
+static	u32
+phy_CalculateBitShift(
+	u32 BitMask
+	)
+{
+	u32 i;
+
+	for (i=0; i<=31; i++)
+	{
+		if (((BitMask>>i) &  0x1) == 1)
+			break;
+	}
+
+	return (i);
+}
+
+/*  */
+/* To avoid miswrite Reg0x800 for 92D */
+/*  */
+void
+rtl8192d_PHY_SetBBReg1Byte(
+	struct rtw_adapter *	adapter,
+	u32		RegAddr,
+	u32		BitMask,
+	u32		Data
+	)
+{
+	u32			OriginalValue, BitShift,offset = 0;
+       u8			value=0;
+
+#if (DISABLE_BB_RF == 1)
+	return;
+#endif
+	/*  BitMask only support bit0~bit7 or bit8~bit15,bit16~bit23,bit24~bit31,should in 1 byte scale; */
+	BitShift = phy_CalculateBitShift(BitMask);
+	offset = BitShift /8;
+
+	OriginalValue = rtw_read32(adapter, RegAddr);
+	Data = ((OriginalValue & (~BitMask)) | ((Data << BitShift) & BitMask));
+
+	value =(u8)(Data>>(8*offset));
+
+	rtw_write8(adapter, RegAddr+offset, value);
+}
+
+/**
+* Function:	PHY_QueryBBReg
+*
+* OverView:	Read "sepcific bits" from BB register
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			u4Byte			RegAddr,	The target address to be readback
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be readback
+* Output:	None
+* Return:		u4Byte			Data		The readback register value
+* Note:		This function is equal to "GetRegSetting" in PHY programming guide
+*/
+u32
+rtl8192d_PHY_QueryBBReg(
+	struct rtw_adapter *	adapter,
+	u32		RegAddr,
+	u32		BitMask
+	)
+{
+	u32	ReturnValue = 0, OriginalValue, BitShift;
+
+#if (DISABLE_BB_RF == 1)
+	return 0;
+#endif
+
+	OriginalValue = rtw_read32(adapter, RegAddr);
+	BitShift = phy_CalculateBitShift(BitMask);
+	ReturnValue = (OriginalValue & BitMask) >> BitShift;
+	return (ReturnValue);
+}
+
+/**
+* Function:	PHY_SetBBReg
+*
+* OverView:	Write "Specific bits" to BB register (page 8~)
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			u4Byte			RegAddr,	The target address to be modified
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be modified
+*			u4Byte			Data		The new register value in the target bit position
+*								of the target address
+*
+* Output:	None
+* Return:		None
+* Note:		This function is equal to "PutRegSetting" in PHY programming guide
+*/
+
+void
+rtl8192d_PHY_SetBBReg(
+	struct rtw_adapter *	adapter,
+	u32		RegAddr,
+	u32		BitMask,
+	u32		Data
+	)
+{
+	u32	OriginalValue, BitShift;
+
+#if (DISABLE_BB_RF == 1)
+	return;
+#endif
+
+	if (BitMask!= bMaskDWord)
+	{/* if not "double word" write */
+		OriginalValue = rtw_read32(adapter, RegAddr);
+		BitShift = phy_CalculateBitShift(BitMask);
+		Data = ((OriginalValue & (~BitMask)) | ((Data << BitShift) & BitMask));
+	}
+
+	rtw_write32(adapter, RegAddr, Data);
+}
+
+/*  */
+/*  2. RF register R/W API */
+/*  */
+/*-----------------------------------------------------------------------------
+ * Function:	phy_FwRFSerialRead()
+ *
+ * Overview:	We support firmware to execute RF-R/W.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	01/21/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+static	u32
+phy_FwRFSerialRead(
+	struct rtw_adapter *			adapter,
+	enum RF_RADIO_PATH_E	eRFPath,
+	u32				Offset	)
+{
+	u32		retValue = 0;
+	return	(retValue);
+}	/* phy_FwRFSerialRead */
+
+/**
+* Function:	phy_RFSerialRead
+*
+* OverView:	Read regster from RF chips
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			Offset,		The target address to be read
+*
+* Output:	None
+* Return:		u4Byte			reback value
+* Note:		Threre are three types of serial operations:
+*			1. Software serial write
+*			2. Hardware LSSI-Low Speed Serial Interface
+*			3. Hardware HSSI-High speed
+*			serial write. Driver need to implement (1) and (2).
+*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
+*/
+static	u32
+phy_RFSerialRead(
+	struct rtw_adapter *			adapter,
+	enum RF_RADIO_PATH_E	eRFPath,
+	u32				Offset
+	)
+{
+	u32	retValue = 0;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
+	u32	NewOffset;
+	u32	tmplong,tmplong2;
+	u8	RfPiEnable=0;
+	u8	i;
+	u32	MaskforPhySet=0;
+
+	/*  */
+	/*  Make sure RF register offset is correct */
+	/*  */
+	if (Offset & MAC1_ACCESS_PHY0)
+		MaskforPhySet = MAC1_ACCESS_PHY0;
+	else if (Offset & MAC0_ACCESS_PHY1)
+		MaskforPhySet = MAC0_ACCESS_PHY1;
+
+	Offset &=0x7F;
+
+	/*  */
+	/*  Switch page for 8256 RF IC */
+	/*  */
+	NewOffset = Offset;
+
+	/*  For 92S LSSI Read RFLSSIRead */
+	/*  For RF A/B write 0x824/82c(does not work in the future) */
+	/*  We must use 0x824 for RF A and B to execute read trigger */
+	tmplong = PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord);
+	if (eRFPath == RF_PATH_A)
+		tmplong2 = tmplong;
+	else
+		tmplong2 = PHY_QueryBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord);
+
+	tmplong2 = (tmplong2 & (~bLSSIReadAddress)) | (NewOffset<<23) | bLSSIReadEdge;	/* T65 RF */
+
+	PHY_SetBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong&(~bLSSIReadEdge));
+	rtw_udelay_os(10);
+
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, bMaskDWord, tmplong2);
+	for (i = 0; i < 2; i++)
+		rtw_udelay_os(MAX_STALL_TIME);
+	PHY_SetBBReg(adapter, rFPGA0_XA_HSSIParameter2|MaskforPhySet, bMaskDWord, tmplong|bLSSIReadEdge);
+	rtw_udelay_os(10);
+
+	if (eRFPath == RF_PATH_A)
+		RfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1|MaskforPhySet, BIT8);
+	else if (eRFPath == RF_PATH_B)
+		RfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XB_HSSIParameter1|MaskforPhySet, BIT8);
+
+	if (RfPiEnable) {
+		/*  Read from BBreg8b8, 12 bits for 8190, 20bits for T65 RF */
+		retValue = PHY_QueryBBReg(adapter, pPhyReg->rfLSSIReadBackPi|MaskforPhySet, bLSSIReadBackData);
+	} else {
+		/* Read from BBreg8a0, 12 bits for 8190, 20 bits for T65 RF */
+		retValue = PHY_QueryBBReg(adapter, pPhyReg->rfLSSIReadBack|MaskforPhySet, bLSSIReadBackData);
+	}
+
+	return retValue;
+}
+
+/**
+* Function:	phy_RFSerialWrite
+*
+* OverView:	Write data to RF register (page 8~)
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			Offset,		The target address to be read
+*			u4Byte			Data		The new register Data in the target bit position
+*								of the target to be read
+*
+* Output:	None
+* Return:		None
+* Note:		Threre are three types of serial operations:
+*			1. Software serial write
+*			2. Hardware LSSI-Low Speed Serial Interface
+*			3. Hardware HSSI-High speed
+*			serial write. Driver need to implement (1) and (2).
+*			This function is equal to the combination of RF_ReadReg() and  RFLSSIRead()
+ *
+ * Note:		  For RF8256 only
+ *			 The total count of RTL8256(Zebra4) register is around 36 bit it only employs
+ *			 4-bit RF address. RTL8256 uses "register mode control bit" (Reg00[12], Reg00[10])
+ *			 to access register address bigger than 0xf. See "Appendix-4 in PHY Configuration
+ *			 programming guide" for more details.
+ *			 Thus, we define a sub-finction for RTL8526 register address conversion
+ *		       ===========================================================
+ *			 Register Mode		RegCTL[1]		RegCTL[0]		Note
+ *								(Reg00[12])		(Reg00[10])
+ *		       ===========================================================
+ *			 Reg_Mode0				0				x			Reg 0 ~15(0x0 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *			 Reg_Mode1				1				0			Reg 16 ~30(0x1 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *			 Reg_Mode2				1				1			Reg 31 ~ 45(0x1 ~ 0xf)
+ *		       ------------------------------------------------------------------
+ *
+ *	2008/09/02	MH	Add 92S RF definition
+ *
+ *
+ *
+*/
+static	void
+phy_RFSerialWrite(
+	struct rtw_adapter *			adapter,
+	enum RF_RADIO_PATH_E	eRFPath,
+	u32				Offset,
+	u32				Data
+	)
+{
+	u32	DataAndAddr = 0;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
+	u32	NewOffset,MaskforPhySet=0;
+
+	/*  2009/06/17 MH We can not execute IO for power save or other accident mode. */
+
+	if (Offset & MAC1_ACCESS_PHY0)
+		MaskforPhySet = MAC1_ACCESS_PHY0;
+	else if (Offset & MAC0_ACCESS_PHY1)
+		MaskforPhySet = MAC0_ACCESS_PHY1;
+
+	Offset &=0x7F;
+
+	/*  */
+	/* 92D RF offset >0x3f */
+
+	/*  */
+	/*  Shadow Update */
+	/*  */
+
+	/*  */
+	/*  Switch page for 8256 RF IC */
+	/*  */
+	NewOffset = Offset;
+
+	/*  */
+	/*  Put write addr in [5:0]  and write data in [31:16] */
+	/*  */
+	DataAndAddr = ((NewOffset<<20) | (Data&0x000fffff)) & 0x0fffffff;	/*  T65 RF */
+
+	/*  */
+	/*  Write Operation */
+	/*  */
+	PHY_SetBBReg(adapter, pPhyReg->rf3wireOffset|MaskforPhySet, bMaskDWord, DataAndAddr);
+}
+
+/**
+* Function:	PHY_QueryRFReg
+*
+* OverView:	Query "Specific bits" to RF register (page 8~)
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			RegAddr,	The target address to be read
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be read
+*
+* Output:	None
+* Return:		u4Byte			Readback value
+* Note:		This function is equal to "GetRFRegSetting" in PHY programming guide
+*/
+u32
+rtl8192d_PHY_QueryRFReg(
+	struct rtw_adapter *			adapter,
+	enum RF_RADIO_PATH_E	eRFPath,
+	u32				RegAddr,
+	u32				BitMask
+	)
+{
+	u32 Original_Value, Readback_Value, BitShift;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+#if (DISABLE_BB_RF == 1)
+	return 0;
+#endif
+
+	if (!pHalData->bPhyValueInitReady)
+		return 0;
+
+	if (pHalData->bReadRFbyFW)
+		Original_Value = rtw_read32(adapter,(0x66<<24|eRFPath<<16)|RegAddr); /* 0x66 Just a identifier.by wl */
+	else
+		Original_Value = phy_RFSerialRead(adapter, eRFPath, RegAddr);
+
+	BitShift =  phy_CalculateBitShift(BitMask);
+	Readback_Value = (Original_Value & BitMask) >> BitShift;
+
+	return (Readback_Value);
+}
+
+/**
+* Function:	PHY_SetRFReg
+*
+* OverView:	Write "Specific bits" to RF register (page 8~)
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*			enum RF_RADIO_PATH_E	eRFPath,	Radio path of A/B/C/D
+*			u4Byte			RegAddr,	The target address to be modified
+*			u4Byte			BitMask		The target bit position in the target address
+*								to be modified
+*			u4Byte			Data		The new register Data in the target bit position
+*								of the target address
+*
+* Output:	None
+* Return:		None
+* Note:		This function is equal to "PutRFRegSetting" in PHY programming guide
+*/
+void
+rtl8192d_PHY_SetRFReg(
+	struct rtw_adapter *			adapter,
+	enum RF_RADIO_PATH_E	eRFPath,
+	u32				RegAddr,
+	u32				BitMask,
+	u32				Data
+	)
+{
+
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32			Original_Value, BitShift;
+
+#if (DISABLE_BB_RF == 1)
+	return;
+#endif
+
+	if (!pHalData->bPhyValueInitReady)
+		return;
+
+	if (BitMask == 0)
+		return;
+
+	/*  RF data is 12 bits only */
+	if (BitMask != bRFRegOffsetMask)
+	{
+		Original_Value = phy_RFSerialRead(adapter, eRFPath, RegAddr);
+		BitShift =  phy_CalculateBitShift(BitMask);
+		Data = (((Original_Value) & (~BitMask)) | (Data<< BitShift));
+	}
+
+	phy_RFSerialWrite(adapter, eRFPath, RegAddr, Data);
+}
+
+/*  */
+/*  3. Initial MAC/BB/RF config by reading MAC/BB/RF txt. */
+/*  */
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigMACWithParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write
+ *
+ * Input:	struct rtw_adapter *		adapter
+ *			ps1Byte				pFileName
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *
+ * Note:		The format of MACPHY_REG.txt is different from PHY and RF.
+ *			[Register][Mask][Value]
+ *---------------------------------------------------------------------------*/
+#ifndef CONFIG_EMBEDDED_FWIMG
+static	int
+phy_ConfigMACWithParaFile(
+	struct rtw_adapter *		adapter,
+	u8*			pFileName
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	int		rtStatus = _SUCCESS;
+
+	return rtStatus;
+}
+#endif /* CONFIG_EMBEDDED_FWIMG */
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigMACWithHeaderFile()
+ *
+ * Overview:    This function read BB parameters from Header file we gen, and do register
+ *			  Read/Write
+ *
+ * Input:	struct rtw_adapter *		adapter
+ *			ps1Byte				pFileName
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *
+ * Note:		The format of MACPHY_REG.txt is different from PHY and RF.
+ *			[Register][Mask][Value]
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigMACWithHeaderFile(
+	struct rtw_adapter *		adapter
+)
+{
+	u32					i = 0;
+	u32					ArrayLength = 0;
+	u32*				ptrArray;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/* 2008.11.06 Modified by tynli. */
+
+	ArrayLength = Rtl8192D_MAC_ArrayLength;
+	ptrArray = (u32 *)Rtl8192D_MAC_Array;
+
+	for (i = 0 ;i < ArrayLength;i=i+2) { /*  Add by tynli for 2 column */
+		rtw_write8(adapter, ptrArray[i], (u8)ptrArray[i+1]);
+	}
+
+	return _SUCCESS;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_MACConfig8192C
+ *
+ * Overview:	Condig MAC by header file or parameter file.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ *  When		Who		Remark
+ *  08/12/2008	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+int PHY_MACConfig8192D(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+#ifndef CONFIG_EMBEDDED_FWIMG
+	char		*pszMACRegFile;
+#endif
+	char		sz92DMACRegFile[] = RTL8192D_PHY_MACREG;
+	int		rtStatus = _SUCCESS;
+
+	if (adapter->bSurpriseRemoved) {
+		rtStatus = _FAIL;
+		return rtStatus;
+	}
+
+#ifndef CONFIG_EMBEDDED_FWIMG
+	pszMACRegFile = sz92DMACRegFile;
+#endif
+
+	/*  */
+	/*  Config MAC */
+	/*  */
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigMACWithHeaderFile(adapter);
+#else
+
+	/*  Not make sure EEPROM, add later */
+	rtStatus = phy_ConfigMACWithParaFile(adapter, pszMACRegFile);
+#endif
+
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+	{
+		/* improve 2-stream TX EVM by Jenyu */
+		/*  2010.07.13 AMPDU aggregation number 9 */
+		rtw_write8(adapter, REG_MAX_AGGR_NUM, 0x0B); /* By tynli. 2010.11.18. */
+	}
+	else
+		rtw_write8(adapter, REG_MAX_AGGR_NUM, 0x07); /* 92D need to test to decide the num. */
+
+	return rtStatus;
+}
+
+/**
+* Function:	phy_InitBBRFRegisterDefinition
+*
+* OverView:	Initialize Register definition offset for Radio Path A/B/C/D
+*
+* Input:
+*			struct rtw_adapter *		adapter,
+*
+* Output:	None
+* Return:		None
+* Note:		The initialization value is constant and it should never be changes
+*/
+static	void
+phy_InitBBRFRegisterDefinition(
+	struct rtw_adapter *		adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/*  RF Interface Sowrtware Control */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW; /*  16 LSBs if read 32-bit from 0x870 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW; /*  16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) */
+	pHalData->PHYRegDef[RF_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;/*  16 LSBs if read 32-bit from 0x874 */
+	pHalData->PHYRegDef[RF_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;/*  16 MSBs if read 32-bit from 0x874 (16-bit for 0x876) */
+
+	/*  RF Interface Readback Value */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB; /*  16 LSBs if read 32-bit from 0x8E0 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;/*  16 MSBs if read 32-bit from 0x8E0 (16-bit for 0x8E2) */
+	pHalData->PHYRegDef[RF_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;/*  16 LSBs if read 32-bit from 0x8E4 */
+	pHalData->PHYRegDef[RF_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;/*  16 MSBs if read 32-bit from 0x8E4 (16-bit for 0x8E6) */
+
+	/*  RF Interface Output (and Enable) */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE; /*  16 LSBs if read 32-bit from 0x860 */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE; /*  16 LSBs if read 32-bit from 0x864 */
+
+	/*  RF Interface (Output and)  Enable */
+	pHalData->PHYRegDef[RF_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE; /*  16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) */
+	pHalData->PHYRegDef[RF_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; /*  16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) */
+
+	/* Addr of LSSI. Wirte RF register by driver */
+	pHalData->PHYRegDef[RF_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter; /* LSSI Parameter */
+	pHalData->PHYRegDef[RF_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;
+
+	/*  RF parameter */
+	pHalData->PHYRegDef[RF_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;  /* BB Band Select */
+	pHalData->PHYRegDef[RF_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;
+	pHalData->PHYRegDef[RF_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+	pHalData->PHYRegDef[RF_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;
+
+	/*  Tx AGC Gain Stage (same for all path. Should we remove this?) */
+	pHalData->PHYRegDef[RF_PATH_A].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_B].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_C].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+	pHalData->PHYRegDef[RF_PATH_D].rfTxGainStage = rFPGA0_TxGainStage; /* Tx gain stage */
+
+	/*  Tranceiver A~D HSSI Parameter-1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;  /* wire control parameter1 */
+	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;  /* wire control parameter1 */
+
+	/*  Tranceiver A~D HSSI Parameter-2 */
+	pHalData->PHYRegDef[RF_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;  /* wire control parameter2 */
+	pHalData->PHYRegDef[RF_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;  /* wire control parameter2 */
+
+	/*  RF switch Control */
+	pHalData->PHYRegDef[RF_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl; /* TR/Ant switch control */
+	pHalData->PHYRegDef[RF_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;
+	pHalData->PHYRegDef[RF_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+	pHalData->PHYRegDef[RF_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;
+
+	/*  AGC control 1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;
+	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;
+	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;
+	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;
+
+	/*  AGC control 2 */
+	pHalData->PHYRegDef[RF_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;
+	pHalData->PHYRegDef[RF_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;
+	pHalData->PHYRegDef[RF_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;
+	pHalData->PHYRegDef[RF_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;
+
+	/*  RX AFE control 1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;
+
+	/*  RX AFE control 1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfRxAFE = rOFDM0_XARxAFE;
+	pHalData->PHYRegDef[RF_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;
+	pHalData->PHYRegDef[RF_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;
+	pHalData->PHYRegDef[RF_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;
+
+	/*  Tx AFE control 1 */
+	pHalData->PHYRegDef[RF_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;
+	pHalData->PHYRegDef[RF_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;
+
+	/*  Tx AFE control 2 */
+	pHalData->PHYRegDef[RF_PATH_A].rfTxAFE = rOFDM0_XATxAFE;
+	pHalData->PHYRegDef[RF_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;
+	pHalData->PHYRegDef[RF_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;
+	pHalData->PHYRegDef[RF_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;
+
+	/*  Tranceiver LSSI Readback SI mode */
+	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;
+	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;
+	pHalData->PHYRegDef[RF_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;
+	pHalData->PHYRegDef[RF_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;
+
+	/*  Tranceiver LSSI Readback PI mode */
+	pHalData->PHYRegDef[RF_PATH_A].rfLSSIReadBackPi = TransceiverA_HSPI_Readback;
+	pHalData->PHYRegDef[RF_PATH_B].rfLSSIReadBackPi = TransceiverB_HSPI_Readback;
+	pHalData->bPhyValueInitReady = true;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigBBWithHeaderFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write
+ *
+ * Input:	struct rtw_adapter *		adapter
+ *			u1Byte			ConfigType     0 => PHY_CONFIG
+ *										 1 =>AGC_TAB
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithHeaderFile(
+	struct rtw_adapter *		adapter,
+	u8			ConfigType
+)
+{
+	int i;
+	u32*	Rtl819XPHY_REGArray_Table;
+	u32*	Rtl819XAGCTAB_Array_Table=NULL;
+	u32*	Rtl819XAGCTAB_5GArray_Table=NULL;
+	u16	PHY_REGArrayLen=0, AGCTAB_ArrayLen=0, AGCTAB_5GArrayLen=0;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
+	if (pHalData->interfaceIndex == 0) {
+		AGCTAB_ArrayLen = Rtl8192D_AGCTAB_ArrayLength;
+		Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_Array;
+	} else {
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
+			AGCTAB_ArrayLen = Rtl8192D_AGCTAB_2GArrayLength;
+			Rtl819XAGCTAB_Array_Table = (u32 *)Rtl8192D_AGCTAB_2GArray;
+		} else {
+			AGCTAB_5GArrayLen = Rtl8192D_AGCTAB_5GArrayLength;
+			Rtl819XAGCTAB_5GArray_Table = (u32 *)Rtl8192D_AGCTAB_5GArray;
+		}
+	}
+
+	PHY_REGArrayLen = Rtl8192D_PHY_REG_2TArrayLength;
+	Rtl819XPHY_REGArray_Table = (u32 *)Rtl8192D_PHY_REG_2TArray;
+
+	if (ConfigType == BaseBand_Config_PHY_REG) {
+		for (i = 0; i < PHY_REGArrayLen; i = i+2) {
+			if (Rtl819XPHY_REGArray_Table[i] == 0xfe || Rtl819XPHY_REGArray_Table[i] == 0xffe) {
+				#ifdef CONFIG_LONG_DELAY_ISSUE
+				rtw_msleep_os(50);
+				#else
+				rtw_mdelay_os(50);
+				#endif
+			}
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfd)
+				rtw_mdelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfc)
+				rtw_mdelay_os(1);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfb)
+				rtw_udelay_os(50);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xfa)
+				rtw_udelay_os(5);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xf9)
+				rtw_udelay_os(1);
+			else if (Rtl819XPHY_REGArray_Table[i] == 0xa24)
+				pdmpriv->RegA24 = Rtl819XPHY_REGArray_Table[i+1];
+			PHY_SetBBReg(adapter, Rtl819XPHY_REGArray_Table[i], bMaskDWord, Rtl819XPHY_REGArray_Table[i+1]);
+
+			/*  Add 1us delay between BB/RF register setting. */
+			rtw_udelay_os(1);
+		}
+	} else if (ConfigType == BaseBand_Config_AGC_TAB) {
+		/* especial for 5G, vivi, 20100528 */
+		if (pHalData->interfaceIndex == 0) {
+			for (i = 0; i < AGCTAB_ArrayLen; i = i+2) {
+				PHY_SetBBReg(adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
+
+				/*  Add 1us delay between BB/RF register setting. */
+				rtw_udelay_os(1);
+
+			}
+		} else {
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			{
+				for (i=0;i<AGCTAB_ArrayLen;i=i+2)
+				{
+					PHY_SetBBReg(adapter, Rtl819XAGCTAB_Array_Table[i], bMaskDWord, Rtl819XAGCTAB_Array_Table[i+1]);
+
+					/*  Add 1us delay between BB/RF register setting. */
+					rtw_udelay_os(1);
+				}
+			} else {
+				for (i=0;i<AGCTAB_5GArrayLen;i=i+2)
+				{
+					PHY_SetBBReg(adapter, Rtl819XAGCTAB_5GArray_Table[i], bMaskDWord, Rtl819XAGCTAB_5GArray_Table[i+1]);
+
+					/*  Add 1us delay between BB/RF register setting. */
+					rtw_udelay_os(1);
+				}
+			}
+		}
+	}
+
+	return _SUCCESS;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigBBWithParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write
+ *
+ * Input:	struct rtw_adapter *		adapter
+ *			ps1Byte				pFileName
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *	2008/11/06	MH	For 92S we do not support silent reset now. Disable
+ *					parameter file compare!!!!!!??
+ *
+ *---------------------------------------------------------------------------*/
+#ifndef CONFIG_EMBEDDED_FWIMG
+static	int
+phy_ConfigBBWithParaFile(
+	struct rtw_adapter *		adapter,
+	u8*			pFileName
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	int		rtStatus = _SUCCESS;
+
+	return rtStatus;
+}
+#endif /* CONFIG_EMBEDDED_FWIMG */
+#if MP_DRIVER != 1
+static void
+storePwrIndexDiffRateOffset(
+	struct rtw_adapter *	adapter,
+	u32		RegAddr,
+	u32		BitMask,
+	u32		Data
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (RegAddr == rTxAGC_A_Rate18_06)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][0] = Data;
+	if (RegAddr == rTxAGC_A_Rate54_24)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][1] = Data;
+	if (RegAddr == rTxAGC_A_CCK1_Mcs32)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][6] = Data;
+	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0xffffff00)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][7] = Data;
+	if (RegAddr == rTxAGC_A_Mcs03_Mcs00)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][2] = Data;
+	if (RegAddr == rTxAGC_A_Mcs07_Mcs04)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][3] = Data;
+	if (RegAddr == rTxAGC_A_Mcs11_Mcs08)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][4] = Data;
+	if (RegAddr == rTxAGC_A_Mcs15_Mcs12)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][5] = Data;
+	if (RegAddr == rTxAGC_B_Rate18_06)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][8] = Data;
+	if (RegAddr == rTxAGC_B_Rate54_24)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][9] = Data;
+	if (RegAddr == rTxAGC_B_CCK1_55_Mcs32)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][14] = Data;
+	if (RegAddr == rTxAGC_B_CCK11_A_CCK2_11 && BitMask == 0x000000ff)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][15] = Data;
+	if (RegAddr == rTxAGC_B_Mcs03_Mcs00)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][10] = Data;
+	if (RegAddr == rTxAGC_B_Mcs07_Mcs04)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][11] = Data;
+	if (RegAddr == rTxAGC_B_Mcs11_Mcs08)
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][12] = Data;
+	if (RegAddr == rTxAGC_B_Mcs15_Mcs12) {
+		pHalData->MCSTxPowerLevelOriginalOffset[pHalData->pwrGroupCnt][13] = Data;
+		pHalData->pwrGroupCnt++;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ConfigBBWithPgHeaderFile
+ *
+ * Overview:	Config PHY_REG_PG array
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/06/2008	MHC		Add later!!!!!!.. Please modify for new files!!!!
+ * 11/10/2008	tynli		Modify to mew files.
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithPgHeaderFile(
+	struct rtw_adapter *		adapter,
+	u8			ConfigType)
+{
+	int i;
+	u32*	Rtl819XPHY_REGArray_Table_PG;
+	u16	PHY_REGArrayPGLen;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	PHY_REGArrayPGLen = Rtl8192D_PHY_REG_Array_PGLength;
+	Rtl819XPHY_REGArray_Table_PG = (u32 *)Rtl8192D_PHY_REG_Array_PG;
+
+	if (ConfigType == BaseBand_Config_PHY_REG) {
+		for (i = 0; i < PHY_REGArrayPGLen; i = i+3) {
+			storePwrIndexDiffRateOffset(adapter, Rtl819XPHY_REGArray_Table_PG[i],
+				Rtl819XPHY_REGArray_Table_PG[i+1],
+				Rtl819XPHY_REGArray_Table_PG[i+2]);
+		}
+	}
+
+	return _SUCCESS;
+}	/* phy_ConfigBBWithPgHeaderFile */
+#endif
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ConfigBBWithPgParaFile
+ *
+ * Overview:
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/06/2008	MHC		Create Version 0.
+ * 2009/07/29	tynli		(porting from 92SE branch)2009/03/11 Add copy parameter file to buffer for silent reset
+ *---------------------------------------------------------------------------*/
+#ifndef CONFIG_EMBEDDED_FWIMG
+static	int
+phy_ConfigBBWithPgParaFile(
+	struct rtw_adapter *		adapter,
+	u8*			pFileName)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	int		rtStatus = _SUCCESS;
+
+	return rtStatus;
+}	/* phy_ConfigBBWithPgParaFile */
+#endif /* CONFIG_EMBEDDED_FWIMG */
+#if MP_DRIVER == 1
+#ifndef CONFIG_EMBEDDED_FWIMG
+/*-----------------------------------------------------------------------------
+ * Function:    phy_ConfigBBWithMpParaFile()
+ *
+ * Overview:    This function read BB parameters from general file format, and do register
+ *			  Read/Write
+ *
+ * Input:	struct rtw_adapter *		adapter
+ *			ps1Byte				pFileName
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *	2008/11/06	MH	For 92S we do not support silent reset now. Disable
+ *					parameter file compare!!!!!!??
+ *
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithMpParaFile(
+	struct rtw_adapter *	adapter,
+	s8			*pFileName
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	int	rtStatus = _SUCCESS;
+
+	return rtStatus;
+}
+#else
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ConfigBBWithMpHeaderFile
+ *
+ * Overview:	Config PHY_REG_MP array
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 02/04/2010	chiyokolin		Modify to new files.
+ *---------------------------------------------------------------------------*/
+static	int
+phy_ConfigBBWithMpHeaderFile(
+	struct rtw_adapter *		adapter,
+	u1Byte			ConfigType)
+{
+	int	i;
+	u32	*Rtl8192CPHY_REGArray_Table_MP;
+	u16	PHY_REGArrayMPLen;
+
+	PHY_REGArrayMPLen = Rtl8192D_PHY_REG_Array_MPLength;
+	Rtl8192CPHY_REGArray_Table_MP = (u32 *)Rtl8192D_PHY_REG_Array_MP;
+
+	if (ConfigType == BaseBand_Config_PHY_REG)
+	{
+		for (i=0;i<PHY_REGArrayMPLen;i=i+2)
+		{
+			if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xfe) {
+				#ifdef CONFIG_LONG_DELAY_ISSUE
+				rtw_msleep_os(50);
+				#else
+				rtw_mdelay_os(50);
+				#endif
+			}
+			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xfd)
+				rtw_mdelay_os(5);
+			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xfc)
+				rtw_mdelay_os(1);
+			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xfb)
+				rtw_udelay_os(50);
+			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xfa)
+				rtw_udelay_os(5);
+			else if (Rtl8192CPHY_REGArray_Table_MP[i] == 0xf9)
+				rtw_udelay_os(1);
+			PHY_SetBBReg(adapter, Rtl8192CPHY_REGArray_Table_MP[i], bMaskDWord, Rtl8192CPHY_REGArray_Table_MP[i+1]);
+
+			/*  Add 1us delay between BB/RF register setting. */
+
+			rtw_udelay_os(1);
+		}
+	}
+	return _SUCCESS;
+}	/* phy_ConfigBBWithPgHeaderFile */
+
+#endif
+#endif
+
+static	int
+phy_BB8192D_Config_ParaFile(
+	struct rtw_adapter *	adapter
+	)
+{
+#if MP_DRIVER != 1
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+#endif
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	int		rtStatus = _SUCCESS;
+	s8		sz92DBBRegFile[] = RTL8192D_PHY_REG;
+	s8		sz92DBBRegPgFile[] = RTL8192D_PHY_REG_PG;
+	s8		sz92DBBRegMpFile[] = RTL8192D_PHY_REG_MP;
+	s8		sz92DAGCTableFile[] = RTL8192D_AGC_TAB;
+	s8		sz92D2GAGCTableFile[] = RTL8192D_AGC_TAB_2G;
+	s8		sz92D5GAGCTableFile[] = RTL8192D_AGC_TAB_5G;
+#ifndef CONFIG_EMBEDDED_FWIMG
+	char		*pszBBRegFile;
+	char *pszAGCTableFile;
+	char *pszBBRegPgFile;
+	char *pszBBRegMpFile;
+#endif
+
+#ifndef CONFIG_EMBEDDED_FWIMG
+	pszBBRegFile = sz92DBBRegFile;
+	pszBBRegPgFile = sz92DBBRegPgFile;
+
+	/* Normal chip,Mac0 use AGC_TAB.txt for 2G and 5G band. */
+	if (pHalData->interfaceIndex == 0) {
+		pszAGCTableFile = sz92DAGCTableFile;
+	} else {
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			pszAGCTableFile = sz92D2GAGCTableFile;
+		else
+			pszAGCTableFile = sz92D5GAGCTableFile;
+	}
+	pszBBRegMpFile = sz92DBBRegMpFile;
+#endif
+
+	/*  1. Read PHY_REG.TXT BB INIT!! */
+	/*  We will seperate as 88C / 92C according to chip version */
+	/*  */
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_PHY_REG);
+#else
+	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
+	/*  type of parameter files to phy_reg.txt at first. */
+	rtStatus = phy_ConfigBBWithParaFile(adapter,pszBBRegFile);
+#endif
+
+	if (rtStatus != _SUCCESS)
+		goto phy_BB8190_Config_ParaFile_Fail;
+
+#if MP_DRIVER == 1
+	/*  */
+	/*  1.1 Read PHY_REG_MP.TXT BB INIT!! */
+	/*  We will seperate as 88C / 92C according to chip version */
+	/*  */
+#ifdef CONFIG_EMBEDDED_FWIMG
+	rtStatus = phy_ConfigBBWithMpHeaderFile(adapter, BaseBand_Config_PHY_REG);
+#else
+	/*  No matter what kind of CHIP we always read PHY_REG.txt. We must copy different */
+	/*  type of parameter files to phy_reg.txt at first. */
+	rtStatus = phy_ConfigBBWithMpParaFile(adapter,pszBBRegMpFile);
+#endif
+
+	if (rtStatus != _SUCCESS)
+		goto phy_BB8190_Config_ParaFile_Fail;
+#endif
+
+#if MP_DRIVER != 1
+	/*  */
+	/*  2. If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt */
+	/*  */
+	if (pEEPROM->bautoload_fail_flag == false)
+	{
+		pHalData->pwrGroupCnt = 0;
+
+#ifdef CONFIG_EMBEDDED_FWIMG
+		rtStatus = phy_ConfigBBWithPgHeaderFile(adapter, BaseBand_Config_PHY_REG);
+#else
+		rtStatus = phy_ConfigBBWithPgParaFile(adapter, pszBBRegPgFile);
+#endif
+	}
+
+	if (rtStatus != _SUCCESS)
+		goto phy_BB8190_Config_ParaFile_Fail;
+#endif
+
+	/*  */
+	/*  3. BB AGC table Initialization */
+	/*  */
+#ifdef CONFIG_EMBEDDED_FWIMG
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bSlaveOfDMSP)
+	{
+		DBG_8192D("BB config slave skip  2222\n");
+	}
+	else
+#endif
+	{
+		rtStatus = phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
+	}
+#else
+	rtStatus = phy_ConfigBBWithParaFile(adapter, pszAGCTableFile);
+#endif
+
+	if (rtStatus != _SUCCESS)
+		goto phy_BB8190_Config_ParaFile_Fail;
+
+	/*  Check if the CCK HighPower is turned ON. */
+	/*  This is used to calculate PWDB. */
+	pHalData->bCckHighPower = (bool)(PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter2, 0x200));
+
+phy_BB8190_Config_ParaFile_Fail:
+
+	return rtStatus;
+}
+
+int
+PHY_BBConfig8192D(
+	struct rtw_adapter *	adapter
+	)
+{
+	int	rtStatus = _SUCCESS;
+	/* u8		PathMap = 0, index = 0, rf_num = 0; */
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32	RegVal;
+	u8	value;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+	if (adapter->bSurpriseRemoved) {
+		rtStatus = _FAIL;
+		return rtStatus;
+	}
+
+	phy_InitBBRFRegisterDefinition(adapter);
+
+	/*  Enable BB and RF */
+	RegVal = rtw_read16(adapter, REG_SYS_FUNC_EN);
+	rtw_write16(adapter, REG_SYS_FUNC_EN, RegVal|BIT13|BIT0|BIT1);
+
+	/*  20090923 Joseph: Advised by Steven and Jenyu. Power sequence before init RF. */
+	rtw_write8(adapter, REG_AFE_PLL_CTRL, 0x83);
+	rtw_write8(adapter, REG_AFE_PLL_CTRL+1, 0xdb);
+	value=rtw_read8(adapter, REG_RF_CTRL);     /*   0x1f bit7 bit6 represent for mac0/mac1 driver ready */
+	rtw_write8(adapter, REG_RF_CTRL, value|RF_EN|RF_RSTB|RF_SDMRSTB);
+
+	rtw_write8(adapter, REG_SYS_FUNC_EN, FEN_USBA | FEN_USBD | FEN_BB_GLB_RSTn | FEN_BBRSTB);
+	/* undo clock gated */
+	rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)&(~BIT31));
+	/* To Fix MAC loopback mode fail. Suggested by SD4 Johnny. 2010.03.23. */
+	rtw_write8(adapter, REG_LDOHCI12_CTRL, 0x0f);
+	rtw_write8(adapter, 0x15, 0xe9);
+
+	rtw_write8(adapter, REG_AFE_XTAL_CTRL+1, 0x80);
+
+	/*  */
+	/*  Config BB and AGC */
+	/*  */
+	rtStatus = phy_BB8192D_Config_ParaFile(adapter);
+
+	/* Crystal Calibration */
+	PHY_SetBBReg(adapter, 0x24, 0xF0, pHalData->CrystalCap & 0x0F);
+	PHY_SetBBReg(adapter, 0x28, 0xF0000000, ((pHalData->CrystalCap & 0xF0) >> 4));
+
+	/* to save power for special 1T1R */
+	if (pregistrypriv->special_rf_path == 1)
+	{
+		PHY_SetBBReg(adapter, rFPGA0_XCD_SwitchControl, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rBlue_Tooth, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_CCA, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_RFON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_BBON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_RFON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_BBON, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_To_Rx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rTx_To_Tx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_CCK, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_OFDM, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_RIFS, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rRx_TO_Rx, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rStandby, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rSleep, BIT24|BIT25|BIT27|BIT30, 0);
+		PHY_SetBBReg(adapter, rPMPD_ANAEN, BIT24|BIT25|BIT27|BIT30, 0);
+	}
+	else if (pregistrypriv->special_rf_path == 2)
+	{
+		PHY_SetBBReg(adapter, rFPGA0_XCD_SwitchControl, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rBlue_Tooth, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_CCA, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_RFON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_CCK_BBON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_RFON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_OFDM_BBON, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_To_Rx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rTx_To_Tx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_CCK, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_OFDM, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_Wait_RIFS, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rRx_TO_Rx, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rStandby, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rSleep, BIT22|BIT23|BIT26|BIT29, 0);
+		PHY_SetBBReg(adapter, rPMPD_ANAEN, BIT22|BIT23|BIT26|BIT29, 0);
+	}
+
+	return rtStatus;
+}
+
+int
+PHY_RFConfig8192D(
+	struct rtw_adapter *	adapter
+	)
+{
+	int		rtStatus = _SUCCESS;
+
+	if (adapter->bSurpriseRemoved) {
+		rtStatus = _FAIL;
+		return rtStatus;
+	}
+
+	/*  */
+	/*  RF config */
+	/*  */
+	rtStatus = PHY_RF6052_Config8192D(adapter);
+	return rtStatus;
+}
+
+/*  */
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_ConfigRFWithHeaderFile()
+ *
+ * Overview:    This function read RF parameters from general file format, and do RF 3-wire
+ *
+ * Input:	struct rtw_adapter *			adapter
+ *			ps1Byte					pFileName
+ *			enum RF_RADIO_PATH_E	eRFPath
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: configuration file exist
+ *
+ * Note:		Delay may be required for RF configuration
+ *---------------------------------------------------------------------------*/
+int
+rtl8192d_PHY_ConfigRFWithHeaderFile(
+	struct rtw_adapter *			adapter,
+	enum RF_CONTENT			Content,
+	enum RF_RADIO_PATH_E		eRFPath
+)
+{
+	int	i, j;
+	int	rtStatus = _SUCCESS;
+	u32*	Rtl819XRadioA_Array_Table;
+	u32*	Rtl819XRadioB_Array_Table;
+	u16		RadioA_ArrayLen,RadioB_ArrayLen;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32	MaskforPhySet= (u32)(Content&0xE000);
+
+	Content &= 0x1FFF;
+
+	DBG_8192D(" ===> PHY_ConfigRFWithHeaderFile() intferace = %d, Radio_txt = 0x%x, eRFPath = %d,MaskforPhyAccess:0x%x.\n", pHalData->interfaceIndex, Content,eRFPath,MaskforPhySet);
+
+	RadioA_ArrayLen = Rtl8192D_RadioA_2TArrayLength;
+	Rtl819XRadioA_Array_Table = (u32 *)Rtl8192D_RadioA_2TArray;
+	RadioB_ArrayLen = Rtl8192D_RadioB_2TArrayLength;
+	Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2TArray;
+
+	if (pHalData->InternalPA5G[0])
+	{
+		RadioA_ArrayLen = Rtl8192D_RadioA_2T_intPAArrayLength;
+		Rtl819XRadioA_Array_Table = (u32 *)Rtl8192D_RadioA_2T_intPAArray;
+	}
+
+	if (pHalData->InternalPA5G[1])
+	{
+		RadioB_ArrayLen = Rtl8192D_RadioB_2T_intPAArrayLength;
+		Rtl819XRadioB_Array_Table = (u32 *)Rtl8192D_RadioB_2T_intPAArray;
+	}
+
+	rtStatus = _SUCCESS;
+
+	/* vivi added this for read parameter from header, 20100908 */
+	/* 1this only happens when DMDP, mac0 start on 2.4G, mac1 start on 5G, */
+	/* 1mac 0 has to set phy0&phy1 pathA or mac1 has to set phy0&phy1 pathA */
+	if ((Content == radiob_txt)&&(eRFPath == RF_PATH_A)) {
+		RadioA_ArrayLen = RadioB_ArrayLen;
+		Rtl819XRadioA_Array_Table = Rtl819XRadioB_Array_Table;
+	}
+
+	switch (eRFPath) {
+		case RF_PATH_A:
+			for (i = 0;i<RadioA_ArrayLen; i=i+2)
+			{
+				if (Rtl819XRadioA_Array_Table[i] == 0xfe)
+				{
+					#ifdef CONFIG_LONG_DELAY_ISSUE
+					rtw_msleep_os(50);
+					#else
+					rtw_mdelay_os(50);
+					#endif
+				}
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfd)
+				{
+					for (j=0;j<100;j++)
+						rtw_udelay_os(MAX_STALL_TIME);
+				}
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfc)
+				{
+					for (j=0;j<20;j++)
+						rtw_udelay_os(MAX_STALL_TIME);
+				}
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfb)
+				{
+					rtw_udelay_os(50);
+				}
+				else if (Rtl819XRadioA_Array_Table[i] == 0xfa)
+				{
+					rtw_udelay_os(5);
+				}
+				else if (Rtl819XRadioA_Array_Table[i] == 0xf9)
+				{
+					rtw_udelay_os(1);
+				}
+				else
+				{
+					PHY_SetRFReg(adapter, eRFPath, Rtl819XRadioA_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioA_Array_Table[i+1]);
+					/*  Add 1us delay between BB/RF register setting. */
+					rtw_udelay_os(1);
+				}
+			}
+			break;
+		case RF_PATH_B:
+			for (i = 0;i<RadioB_ArrayLen; i=i+2)
+			{
+				if (Rtl819XRadioB_Array_Table[i] == 0xfe)
+				{ /*  Deay specific ms. Only RF configuration require delay. */
+					#ifdef CONFIG_LONG_DELAY_ISSUE
+					rtw_msleep_os(50);
+					#else
+					rtw_mdelay_os(50);
+					#endif
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfd)
+				{
+					/* rtw_mdelay_os(5); */
+					for (j=0;j<100;j++)
+						rtw_udelay_os(MAX_STALL_TIME);
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfc)
+				{
+					/* rtw_mdelay_os(1); */
+					for (j=0;j<20;j++)
+						rtw_udelay_os(MAX_STALL_TIME);
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfb)
+				{
+					rtw_udelay_os(50);
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xfa)
+				{
+					rtw_udelay_os(5);
+				}
+				else if (Rtl819XRadioB_Array_Table[i] == 0xf9)
+				{
+					rtw_udelay_os(1);
+				}
+				else
+				{
+					PHY_SetRFReg(adapter, eRFPath, Rtl819XRadioB_Array_Table[i]|MaskforPhySet, bRFRegOffsetMask, Rtl819XRadioB_Array_Table[i+1]);
+					/*  Add 1us delay between BB/RF register setting. */
+					rtw_udelay_os(1);
+				}
+			}
+			break;
+		case RF_PATH_C:
+			break;
+		case RF_PATH_D:
+			break;
+	}
+
+	return rtStatus;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_CheckBBAndRFOK()
+ *
+ * Overview:    This function is write register and then readback to make sure whether
+ *			  BB[PHY0, PHY1], RF[Patha, path b, path c, path d] is Ok
+ *
+ * Input:	struct rtw_adapter *			adapter
+ *			enum HW90_BLOCK		CheckBlock
+ *			enum RF_RADIO_PATH_E	eRFPath		it is used only when CheckBlock is HW90_BLOCK_RF
+ *
+ * Output:      NONE
+ *
+ * Return:      RT_STATUS_SUCCESS: PHY is OK
+ *
+ * Note:		This function may be removed in the ASIC
+ *---------------------------------------------------------------------------*/
+int
+rtl8192d_PHY_CheckBBAndRFOK(
+	struct rtw_adapter *			adapter,
+	enum HW90_BLOCK		CheckBlock,
+	enum RF_RADIO_PATH_E	eRFPath
+	)
+{
+	int			rtStatus = _SUCCESS;
+
+	u32				i, CheckTimes = 4,ulRegRead=0;
+
+	u32				WriteAddr[4];
+	u32				WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};
+
+	/*  Initialize register address offset to be checked */
+	WriteAddr[HW90_BLOCK_MAC] = 0x100;
+	WriteAddr[HW90_BLOCK_PHY0] = 0x900;
+	WriteAddr[HW90_BLOCK_PHY1] = 0x800;
+	WriteAddr[HW90_BLOCK_RF] = 0x3;
+
+	for (i=0 ; i < CheckTimes ; i++)
+	{
+
+		/*  */
+		/*  Write Data to register and readback */
+		/*  */
+		switch (CheckBlock)
+		{
+		case HW90_BLOCK_MAC:
+			break;
+
+		case HW90_BLOCK_PHY0:
+		case HW90_BLOCK_PHY1:
+			rtw_write32(adapter, WriteAddr[CheckBlock], WriteData[i]);
+			ulRegRead = rtw_read32(adapter, WriteAddr[CheckBlock]);
+			break;
+
+		case HW90_BLOCK_RF:
+			/*  When initialization, we want the delay function(delay_ms(), delay_us() */
+			/*  ==> actually we call PlatformStallExecution()) to do NdisStallExecution() */
+			/*  [busy wait] instead of NdisMSleep(). So we acquire RT_INITIAL_SPINLOCK */
+			/*  to run at Dispatch level to achive it. */
+			/* cosa PlatformAcquireSpinLock(adapter, RT_INITIAL_SPINLOCK); */
+			WriteData[i] &= 0xfff;
+			PHY_SetRFReg(adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask, WriteData[i]);
+			/*  TODO: we should not delay for such a long time. Ask SD3 */
+			rtw_mdelay_os(10);
+			ulRegRead = PHY_QueryRFReg(adapter, eRFPath, WriteAddr[HW90_BLOCK_RF], bRFRegOffsetMask);
+			rtw_mdelay_os(10);
+			/* cosa PlatformReleaseSpinLock(adapter, RT_INITIAL_SPINLOCK); */
+			break;
+
+		default:
+			rtStatus = _FAIL;
+			break;
+		}
+
+		/*  */
+		/*  Check whether readback data is correct */
+		/*  */
+		if (ulRegRead != WriteData[i])
+		{
+			rtStatus = _FAIL;
+			break;
+		}
+	}
+
+	return rtStatus;
+}
+
+void
+rtl8192d_PHY_GetHWRegOriginalValue(
+	struct rtw_adapter *		adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/*  read rx initial gain */
+	pHalData->DefaultInitialGain[0] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XAAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[1] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XBAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[2] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XCAGCCore1, bMaskByte0);
+	pHalData->DefaultInitialGain[3] = (u8)PHY_QueryBBReg(adapter, rOFDM0_XDAGCCore1, bMaskByte0);
+
+	/*  read framesync */
+	pHalData->framesync = (u8)PHY_QueryBBReg(adapter, rOFDM0_RxDetector3, bMaskByte0);
+	pHalData->framesyncC34 = PHY_QueryBBReg(adapter, rOFDM0_RxDetector2, bMaskDWord);
+}
+
+/*  */
+/*	Description: */
+/*		Map dBm into Tx power index according to */
+/*		current HW model, for example, RF and PA, and */
+/*		current wireless mode. */
+/*	By Bruce, 2008-01-29. */
+/*  */
+static	u8
+phy_DbmToTxPwrIdx(
+	struct rtw_adapter *		adapter,
+	enum WIRELESS_MODE	WirelessMode,
+	int			PowerInDbm
+	)
+{
+	u8				TxPwrIdx = 0;
+	int				Offset = 0;
+
+	/*  */
+	/*  Tested by MP, we found that CCK Index 0 equals to 8dbm, OFDM legacy equals to */
+	/*  3dbm, and OFDM HT equals to 0dbm repectively. */
+	/*  Note: */
+	/*	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*  By Bruce, 2008-01-29. */
+	/*  */
+	switch (WirelessMode)
+	{
+	case WIRELESS_MODE_B:
+		Offset = -7;
+		break;
+
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+		Offset = -8;
+		break;
+
+	default:
+		break;
+	}
+
+	if ((PowerInDbm - Offset) > 0)
+	{
+		TxPwrIdx = (u8)((PowerInDbm - Offset) * 2);
+	}
+	else
+	{
+		TxPwrIdx = 0;
+	}
+
+	/*  Tx Power Index is too large. */
+	if (TxPwrIdx > MAX_TXPWR_IDX_NMODE_92S)
+		TxPwrIdx = MAX_TXPWR_IDX_NMODE_92S;
+
+	return TxPwrIdx;
+}
+
+/*  */
+/*	Description: */
+/*		Map Tx power index into dBm according to */
+/*		current HW model, for example, RF and PA, and */
+/*		current wireless mode. */
+/*	By Bruce, 2008-01-29. */
+/*  */
+static int
+phy_TxPwrIdxToDbm(
+	struct rtw_adapter *		adapter,
+	enum WIRELESS_MODE	WirelessMode,
+	u8			TxPwrIdx
+	)
+{
+	int				Offset = 0;
+	int				PwrOutDbm = 0;
+
+	/*  */
+	/*  Tested by MP, we found that CCK Index 0 equals to -7dbm, OFDM legacy equals to -8dbm. */
+	/*  Note: */
+	/*	The mapping may be different by different NICs. Do not use this formula for what needs accurate result. */
+	/*  By Bruce, 2008-01-29. */
+	/*  */
+	switch (WirelessMode)
+	{
+	case WIRELESS_MODE_B:
+		Offset = -7;
+		break;
+
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_N_24G:
+		Offset = -8;
+		break;
+
+	default:
+		break;
+	}
+
+	PwrOutDbm = TxPwrIdx / 2 + Offset; /*  Discard the decimal part. */
+
+	return PwrOutDbm;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    GetTxPowerLevel8190()
+ *
+ * Overview:    This function is export to "common" moudule
+ *
+ * Input:       struct rtw_adapter *		adapter
+ *			psByte			Power Level
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ *---------------------------------------------------------------------------*/
+void
+PHY_GetTxPowerLevel8192D(
+	struct rtw_adapter *		adapter,
+	u32*		powerlevel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8			TxPwrLevel = 0;
+	int			TxPwrDbm;
+
+	/*  */
+	/*  Because the Tx power indexes are different, we report the maximum of them to */
+	/*  meet the CCX TPC request. By Bruce, 2008-01-31. */
+	/*  */
+
+	/*  CCK */
+	TxPwrLevel = pHalData->CurrentCckTxPwrIdx;
+	TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_B, TxPwrLevel);
+
+	/*  Legacy OFDM */
+	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx + pHalData->LegacyHTTxPowerDiff;
+
+	/*  Compare with Legacy OFDM Tx power. */
+	if (phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_G, TxPwrLevel);
+
+	/*  HT OFDM */
+	TxPwrLevel = pHalData->CurrentOfdm24GTxPwrIdx;
+
+	/*  Compare with HT OFDM Tx power. */
+	if (phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_N_24G, TxPwrLevel) > TxPwrDbm)
+		TxPwrDbm = phy_TxPwrIdxToDbm(adapter, WIRELESS_MODE_N_24G, TxPwrLevel);
+
+	*powerlevel = TxPwrDbm;
+}
+
+static void getTxPowerIndex(
+	struct rtw_adapter *		adapter,
+	u8			channel,
+	u8*		cckPowerLevel,
+	u8*		ofdmPowerLevel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	index = (channel -1);
+
+	/*  1. CCK */
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{
+		cckPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelCck[RF_PATH_A][index];	/* RF-A */
+		cckPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelCck[RF_PATH_B][index];	/* RF-B */
+	}
+	else
+		cckPowerLevel[RF_PATH_A] = cckPowerLevel[RF_PATH_B] = 0;
+
+	/*  2. OFDM for 1S or 2S */
+	if (GET_RF_TYPE(adapter) == RF_1T2R || GET_RF_TYPE(adapter) == RF_1T1R)
+	{
+		/*  Read HT 40 OFDM TX power */
+		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_1S[RF_PATH_A][index];
+		ofdmPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelHT40_1S[RF_PATH_B][index];
+	}
+	else if (GET_RF_TYPE(adapter) == RF_2T2R)
+	{
+		/*  Read HT 40 OFDM TX power */
+		ofdmPowerLevel[RF_PATH_A] = pHalData->TxPwrLevelHT40_2S[RF_PATH_A][index];
+		ofdmPowerLevel[RF_PATH_B] = pHalData->TxPwrLevelHT40_2S[RF_PATH_B][index];
+	}
+}
+
+static void ccxPowerIndexCheck(
+	struct rtw_adapter *		adapter,
+	u8			channel,
+	u8*		cckPowerLevel,
+	u8*		ofdmPowerLevel
+	)
+{
+}
+/*-----------------------------------------------------------------------------
+ * Function:    SetTxPowerLevel8190()
+ *
+ * Overview:    This function is export to "HalCommon" moudule
+ *			We must consider RF path later!!!!!!!
+ *
+ * Input:       struct rtw_adapter *		adapter
+ *			u1Byte		channel
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *	2008/11/04	MHC		We remove EEPROM_93C56.
+ *						We need to move CCX relative code to independet file.
+ *	2009/01/21	MHC		Support new EEPROM format from SD3 requirement.
+ *
+ *---------------------------------------------------------------------------*/
+void
+PHY_SetTxPowerLevel8192D(
+	struct rtw_adapter *		adapter,
+	u8			channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	cckPowerLevel[2], ofdmPowerLevel[2];	/*  [0]:RF-A, [1]:RF-B */
+
+#if (MP_DRIVER == 1)
+	return;
+#endif
+
+	if ((adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(adapter_to_dvobj(adapter)->ishighspeed == false))
+		return;
+
+	if (pHalData->bTXPowerDataReadFromEEPORM == false)
+		return;
+
+	channel = GetRightChnlPlace(channel);
+
+	getTxPowerIndex(adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		ccxPowerIndexCheck(adapter, channel, &cckPowerLevel[0], &ofdmPowerLevel[0]);
+
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		rtl8192d_PHY_RF6052SetCckTxPower(adapter, &cckPowerLevel[0]);
+	rtl8192d_PHY_RF6052SetOFDMTxPower(adapter, &ofdmPowerLevel[0], channel);
+}
+
+/*  */
+/*	Description: */
+/*		Update transmit power level of all channel supported. */
+/*  */
+/*	TODO: */
+/*		A mode. */
+/*	By Bruce, 2008-02-04. */
+/*  */
+bool
+PHY_UpdateTxPowerDbm8192D(
+	struct rtw_adapter *	adapter,
+	int		powerInDbm
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	idx;
+	u8	rf_path;
+
+	/*  TODO: A mode Tx power. */
+	u8	CckTxPwrIdx = phy_DbmToTxPwrIdx(adapter, WIRELESS_MODE_B, powerInDbm);
+	u8	OfdmTxPwrIdx = phy_DbmToTxPwrIdx(adapter, WIRELESS_MODE_N_24G, powerInDbm);
+
+	if (OfdmTxPwrIdx - pHalData->LegacyHTTxPowerDiff > 0)
+		OfdmTxPwrIdx -= pHalData->LegacyHTTxPowerDiff;
+	else
+		OfdmTxPwrIdx = 0;
+
+	for (idx = 0; idx < CHANNEL_MAX_NUMBER; idx++)
+	{
+		for (rf_path = 0; rf_path < 2; rf_path++)
+		{
+			if (idx < CHANNEL_MAX_NUMBER_2G)
+				pHalData->TxPwrLevelCck[rf_path][idx] = CckTxPwrIdx;
+			pHalData->TxPwrLevelHT40_1S[rf_path][idx] =
+			pHalData->TxPwrLevelHT40_2S[rf_path][idx] = OfdmTxPwrIdx;
+		}
+	}
+
+	return true;
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_SetBWModeCallback8192C()
+ *
+ * Overview:    Timer callback function for SetSetBWMode
+ *
+ * Input:		PRT_TIMER		pTimer
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		(1) We do not take j mode into consideration now
+ *			(2) Will two workitem of "switch channel" and "switch channel bandwidth" run
+ *			     concurrently?
+ *---------------------------------------------------------------------------*/
+static void
+_PHY_SetBWMode92D(
+	struct rtw_adapter *	adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	regBwOpMode;
+	u8	regRRSR_RSC;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	/*  FOr 92D dual mac config. */
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
+#endif
+
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
+		return;
+
+	/*  There is no 40MHz mode in RF_8225. */
+	if (pHalData->rf_chip==RF_8225)
+		return;
+
+	if (adapter->bDriverStopped)
+		return;
+
+	/* 3 */
+	/* 3<1>Set MAC register */
+	/* 3 */
+	/* adapter->HalFunc.SetBWModeHandler(); */
+
+	regBwOpMode = rtw_read8(adapter, REG_BWOPMODE);
+	regRRSR_RSC = rtw_read8(adapter, REG_RRSR+2);
+
+	switch (pHalData->CurrentChannelBW)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			regBwOpMode |= BW_OPMODE_20MHZ;
+			   /*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
+			rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
+			break;
+
+		case HT_CHANNEL_WIDTH_40:
+			regBwOpMode &= ~BW_OPMODE_20MHZ;
+				/*  2007/02/07 Mark by Emily becasue we have not verify whether this register works */
+			rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
+
+			regRRSR_RSC = (regRRSR_RSC&0x90) |(pHalData->nCur40MhzPrimeSC<<5);
+			rtw_write8(adapter, REG_RRSR+2, regRRSR_RSC);
+			break;
+
+		default:
+			/*RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetBWModeCallback8192C():
+						unknown Bandwidth: %#X\n",pHalData->CurrentChannelBW));*/
+			break;
+	}
+
+	/* 3 */
+	/* 3<2>Set PHY related register */
+	/* 3 */
+	switch (pHalData->CurrentChannelBW)
+	{
+		/* 20 MHz channel*/
+		case HT_CHANNEL_WIDTH_20:
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bRFMOD, 0x0);
+
+			PHY_SetBBReg(adapter, rFPGA1_RFMOD, bRFMOD, 0x0);
+
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 3);/*  SET BIT10 BIT11  for receive cck */
+
+			break;
+
+		/* 40 MHz channel*/
+		case HT_CHANNEL_WIDTH_40:
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bRFMOD, 0x1);
+
+			PHY_SetBBReg(adapter, rFPGA1_RFMOD, bRFMOD, 0x1);
+
+			/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			{
+				PHY_SetBBReg(adapter, rCCK0_System, bCCKSideBand, (pHalData->nCur40MhzPrimeSC>>1));
+			}
+			PHY_SetBBReg(adapter, rOFDM1_LSTF, 0xC00, pHalData->nCur40MhzPrimeSC);
+
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter2, BIT10|BIT11, 0);/*  SET BIT10 BIT11  for receive cck */
+
+			PHY_SetBBReg(adapter, 0x818, (BIT26|BIT27), (pHalData->nCur40MhzPrimeSC==HAL_PRIME_CHNL_OFFSET_LOWER)?2:1);
+
+			break;
+
+		default:
+			/*RT_TRACE(COMP_DBG, DBG_LOUD, ("PHY_SetBWModeCallback8192C(): unknown Bandwidth: %#X\n"\
+						,pHalData->CurrentChannelBW));*/
+			break;
+
+	}
+
+	/* 3<3>Set RF related register */
+	switch (pHalData->rf_chip)
+	{
+		case RF_8225:
+			break;
+
+		case RF_8256:
+			/*  Please implement this function in Hal8190PciPhy8256.c */
+			break;
+
+		case RF_8258:
+			/*  Please implement this function in Hal8190PciPhy8258.c */
+			break;
+
+		case RF_PSEUDO_11N:
+			/*  Do Nothing */
+			break;
+
+		case RF_6052:
+			rtl8192d_PHY_RF6052SetBandwidth(adapter, pHalData->CurrentChannelBW);
+			break;
+
+		default:
+			break;
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (adapter->DualMacConcurrent == true && Buddyadapter != NULL)
+	{
+		if (pHalData->bMasterOfDMSP)
+		{
+			pHalDataBuddyadapter = GET_HAL_DATA(Buddyadapter);
+			pHalDataBuddyadapter->CurrentChannelBW=pHalData->CurrentChannelBW;
+			pHalDataBuddyadapter->nCur40MhzPrimeSC = pHalData->nCur40MhzPrimeSC;
+		}
+	}
+#endif
+
+}
+
+ /*-----------------------------------------------------------------------------
+ * Function:   SetBWMode8190Pci()
+ *
+ * Overview:  This function is export to "HalCommon" moudule
+ *
+ * Input:		struct rtw_adapter *			adapter
+ *			HT_CHANNEL_WIDTH	Bandwidth	20M or 40M
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		We do not take j mode into consideration now
+ *---------------------------------------------------------------------------*/
+void
+PHY_SetBWMode8192D(
+	struct rtw_adapter *					adapter,
+	enum HT_CHANNEL_WIDTH	Bandwidth,	/*  20M or 40M */
+	unsigned char	Offset		/*  Upper, Lower, or Don't care */
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	enum HT_CHANNEL_WIDTH	tmpBW= pHalData->CurrentChannelBW;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bInModeSwitchProcess)
+	{
+		DBG_8192D("PHY_SwChnl8192D(): During mode switch\n");
+		return;
+	}
+#endif
+
+	pHalData->CurrentChannelBW = Bandwidth;
+
+	pHalData->nCur40MhzPrimeSC = Offset;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	{
+		{
+			DBG_8192D("PHY_SetBWMode92D():slave return when slave\n");
+			return;
+		}
+	}
+#endif
+
+	if ((!adapter->bDriverStopped) && (!adapter->bSurpriseRemoved))
+	{
+#ifndef USE_WORKITEM
+	_PHY_SetBWMode92D(adapter);
+#endif
+	}
+	else
+	{
+		pHalData->CurrentChannelBW = tmpBW;
+	}
+}
+
+/*******************************************************************
+Descriptor:
+			stop TRX Before change bandType dynamically
+
+********************************************************************/
+void
+PHY_StopTRXBeforeChangeBand8192D(
+	  struct rtw_adapter *		adapter
+)
+{
+#if MP_DRIVER == 1
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	pdmpriv->RegC04_MP = (u8)PHY_QueryBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0);
+	pdmpriv->RegD04_MP = PHY_QueryBBReg(adapter, rOFDM1_TRxPathEnable, bDWord);
+#endif
+
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x00);
+
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x00);
+	PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x0);
+}
+
+static void PHY_SwitchWirelessBand(struct rtw_adapter *adapter, u8 Band)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u8	i, value8;/*  RegValue */
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bInModeSwitchProcess || pHalData->bSlaveOfDMSP)
+	{
+		DBG_8192D("PHY_SwitchWirelessBand(): skip for mode switch or slave\n");
+		return;
+	}
+#endif
+
+	pHalData->BandSet92D = pHalData->CurrentBandType92D = (enum BAND_TYPE)Band;
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
+		pHalData->BandSet92D = BAND_ON_BOTH;
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+	{
+		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_5G;
+	}
+	else
+	{
+		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_24G;
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bMasterOfDMSP)
+	{
+		struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+		if (Buddyadapter!=NULL)
+		{
+			if (Buddyadapter->hw_init_completed)
+			{
+				GET_HAL_DATA(Buddyadapter)->BandSet92D = pHalData->BandSet92D;
+				GET_HAL_DATA(Buddyadapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
+				GET_HAL_DATA(Buddyadapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
+			}
+		}
+	}
+#endif
+
+	/* stop RX/Tx */
+	PHY_StopTRXBeforeChangeBand8192D(adapter);
+
+	/* reconfig BB/RF according to wireless mode */
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{
+		/* BB & RF Config */
+		if (pHalData->interfaceIndex == 1)
+		{
+#ifdef CONFIG_EMBEDDED_FWIMG
+			phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
+#else
+			PHY_SetAGCTab8192D(adapter);
+#endif
+		}
+	}
+	else	/* 5G band */
+	{
+		if (pHalData->interfaceIndex == 1)
+		{
+#ifdef CONFIG_EMBEDDED_FWIMG
+			phy_ConfigBBWithHeaderFile(adapter, BaseBand_Config_AGC_TAB);
+#else
+			PHY_SetAGCTab8192D(adapter);
+#endif
+		}
+	}
+
+	PHY_UpdateBBRFConfiguration8192D(adapter, true);
+
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{
+		update_tx_basic_rate(adapter, WIRELESS_11BG_24N);
+
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
+	}
+	else
+	{
+		/* avoid using cck rate in 5G band */
+		/*  Set RRSR rate table. */
+		update_tx_basic_rate(adapter, WIRELESS_11A_5N);
+
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bMasterOfDMSP)
+	{
+		struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+		if (Buddyadapter!=NULL)
+		{
+			if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+				rtw_write16(Buddyadapter, REG_RRSR, 0x15d);
+			else
+				rtw_write16(Buddyadapter, REG_RRSR, 0x150);
+		}
+	}
+#endif
+
+	pdmpriv->bReloadtxpowerindex = true;
+
+	/*  notice fw know band status  0x81[1]/0x53[1] = 0: 5G, 1: 2G */
+	if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	{
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 |= BIT1;
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+	}
+	else
+	{
+		value8 = rtw_read8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1));
+		value8 &= (~BIT1);
+		rtw_write8(adapter, (pHalData->interfaceIndex==0?REG_MAC0:REG_MAC1),value8);
+	}
+
+	for (i=0;i<20;i++)
+			rtw_udelay_os(MAX_STALL_TIME);
+
+}
+
+static void
+PHY_EnableRFENV(
+	struct rtw_adapter *		adapter,
+	u8				eRFPath	,
+	u32				MaskforPhySet,
+	u32*			pu4RegValue
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
+
+	/*----Store original RFENV control type----*/
+	switch (eRFPath)
+	{
+		case RF_PATH_A:
+		case RF_PATH_C:
+			*pu4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
+			break;
+		case RF_PATH_B:
+		case RF_PATH_D:
+			*pu4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
+			break;
+	}
+
+	/*----Set RF_ENV enable----*/
+	PHY_SetBBReg(adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
+	rtw_udelay_os(1);
+
+	/*----Set RF_ENV output high----*/
+	PHY_SetBBReg(adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
+	rtw_udelay_os(1);
+
+	/* Set bit number of Address and Data for RF register */
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
+	rtw_udelay_os(1);
+
+	PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0); /*  Set 0 to 12	bits for 8255 */
+	rtw_udelay_os(1);
+}
+
+static void
+PHY_RestoreRFENV(
+	struct rtw_adapter *		adapter,
+	u8				eRFPath,
+	u32				MaskforPhySet,
+	u32*			pu4RegValue
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct bb_register_def *pPhyReg = &pHalData->PHYRegDef[eRFPath];
+
+	/* If another MAC is ON,need do this? */
+	/*----Restore RFENV control type----*/;
+	switch (eRFPath)
+	{
+		case RF_PATH_A:
+		case RF_PATH_C:
+			PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, *pu4RegValue);
+			break;
+		case RF_PATH_B :
+		case RF_PATH_D:
+			PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, *pu4RegValue);
+			break;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_SwitchRfSetting
+ *
+ * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
+ *
+ * Input:       struct rtw_adapter *				adapter
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 01/08/2009	MHC		Suggestion from SD3 Willis for 92S series.
+ * 01/09/2009	MHC		Add CCK modification for 40MHZ. Suggestion from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+ static	void
+ phy_SwitchRfSetting(
+	struct rtw_adapter *			adapter,
+	u8					channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8			path = pHalData->CurrentBandType92D==BAND_ON_5G?RF_PATH_A:RF_PATH_B;
+	u8			index = 0,	i = 0, eRFPath = RF_PATH_A;
+	bool		bNeedPowerDownRadio = false, bInteralPA = false;
+	u32			u4RegValue, mask = 0x1C000, value = 0, u4tmp, u4tmp2,MaskforPhySet=0;
+	/* Query regB30 bit27 */
+	u32			Regb30 = PHY_QueryBBReg(adapter, 0xb30, BIT27);
+
+	/* only for 92D C-cut SMSP */
+
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
+		return;
+
+	/* config path A for 5G */
+	if (pHalData->CurrentBandType92D==BAND_ON_5G)
+	{
+		u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
+
+		for (i = 0; i < RF_CHNL_NUM_5G; i++)
+		{
+			if (channel == RF_CHNL_5G[i] && channel <= 140)
+				index = 0;
+		}
+
+		for (i = 0; i < RF_CHNL_NUM_5G_40M; i++)
+		{
+			if (channel == RF_CHNL_5G_40M[i] && channel <= 140)
+				index = 1;
+		}
+
+		if (channel ==149 || channel == 155 || channel ==161)
+			index = 2;
+		else if (channel == 151 || channel == 153 || channel == 163 || channel == 165)
+			index = 3;
+		else if (channel == 157 || channel == 159)
+			index = 4;
+
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+		{
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+			MaskforPhySet = MAC1_ACCESS_PHY0;
+			/* asume no this case */
+			if (bNeedPowerDownRadio)
+				PHY_EnableRFENV(adapter, path, MaskforPhySet, &u4RegValue);
+		}
+
+		/* DMDP, if band = 5G,Mac0 need to set PHY1 when regB30[27]=1 */
+		if (Regb30 && pHalData->interfaceIndex == 0)
+		{
+			DBG_8192D("===============phy_SwitchRfSetting8192D interface %d,B30&BIT27=1!!!!\n", pHalData->interfaceIndex);
+
+			bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
+			MaskforPhySet= MAC0_ACCESS_PHY1;
+			/* asume no this case */
+			if (bNeedPowerDownRadio)
+				PHY_EnableRFENV(adapter, path, MaskforPhySet, &u4RegValue);
+		}
+
+		for (i = 0; i < RF_REG_NUM_for_C_CUT_5G; i++)
+		{
+			if (i == 0 && (pHalData->MacPhyMode92D == DUALMAC_DUALPHY))
+			{
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, 0xE439D);
+			}
+			else if (RF_REG_for_C_CUT_5G[i] == RF_SYN_G4)
+			{
+#if SWLCK == 1
+				u4tmp2= (RF_REG_Param_for_C_CUT_5G[index][i]&0x7FF)|(u4tmp << 11);
+
+				if (channel == 36)
+					u4tmp2 &= ~(BIT7|BIT6);
+
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, u4tmp2);
+#else
+				u4tmp2= RF_REG_Param_for_C_CUT_5G[index][i];
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, 0xFF8FF, u4tmp2);
+#endif
+			} else {
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_5G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G[index][i]);
+			}
+		}
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1) {
+			if (bNeedPowerDownRadio)
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+		}
+
+		if (Regb30 && pHalData->interfaceIndex == 0) {
+			if (bNeedPowerDownRadio)
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
+		}
+
+		if (channel < 149)
+			value = 0x07;
+		else if (channel >= 149)
+			value = 0x02;
+
+		if (channel >= 36 && channel <= 64)
+			index = 0;
+		else if (channel >=100 && channel <= 140)
+			index = 1;
+		else
+			index = 2;
+
+		for (eRFPath = RF_PATH_A; eRFPath < pHalData->NumTotalRFPath; eRFPath++)
+		{
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY &&
+				pHalData->interfaceIndex == 1)		/* MAC 1 5G */
+				bInteralPA = pHalData->InternalPA5G[1];
+			else
+				bInteralPA = pHalData->InternalPA5G[eRFPath];
+
+			if (bInteralPA)
+			{
+				for (i = 0; i < RF_REG_NUM_for_C_CUT_5G_internalPA; i++)
+				{
+					if (RF_REG_for_C_CUT_5G_internalPA[i] == 0x03 &&
+						channel >=36 && channel <=64)
+						PHY_SetRFReg(adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, 0x7bdef);
+					else
+						PHY_SetRFReg(adapter, eRFPath, RF_REG_for_C_CUT_5G_internalPA[i], bRFRegOffsetMask, RF_REG_Param_for_C_CUT_5G_internalPA[index][i]);
+				}
+			}
+			else
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, mask, value);
+		}
+	}
+	else if (pHalData->CurrentBandType92D==BAND_ON_2_4G)
+	{
+		u4tmp = CurveIndex[channel-1];
+
+		if (channel == 1 || channel == 2 || channel ==4 || channel == 9 || channel == 10 ||
+			channel == 11 || channel ==12)
+			index = 0;
+		else if (channel ==3 || channel == 13 || channel == 14)
+			index = 1;
+		else if (channel >= 5 && channel <= 8)
+			index = 2;
+
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		{
+			path = RF_PATH_A;
+			if (pHalData->interfaceIndex == 0)
+			{
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
+				MaskforPhySet = MAC0_ACCESS_PHY1;
+				if (bNeedPowerDownRadio)
+					PHY_EnableRFENV(adapter, path,MaskforPhySet,&u4RegValue);
+			}
+
+			/* DMDP, if band = 2G,MAC1 need to set PHY0 when regB30[27]=1 */
+			if (Regb30 && pHalData->interfaceIndex == 1)
+			{
+
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+				MaskforPhySet= MAC1_ACCESS_PHY0;
+				/* asume no this case */
+				if (bNeedPowerDownRadio)
+					PHY_EnableRFENV(adapter, path,MaskforPhySet,&u4RegValue);
+			}
+		}
+
+		for (i = 0; i < RF_REG_NUM_for_C_CUT_2G; i++)
+		{
+#if SWLCK == 1
+			if (RF_REG_for_C_CUT_2G[i] == RF_SYN_G7)
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, (RF_REG_Param_for_C_CUT_2G[index][i] | BIT17));
+			else
+#endif
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_REG_for_C_CUT_2G[i]|MaskforPhySet, bRFRegOffsetMask, RF_REG_Param_for_C_CUT_2G[index][i]);
+		}
+
+#if SWLCK == 1
+		/* for SWLCK */
+
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_SYN_G4|MaskforPhySet, bRFRegOffsetMask, RF_REG_SYN_G4_for_C_CUT_2G | (u4tmp << 11));
+#endif
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
+		{
+			if (bNeedPowerDownRadio) {
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			}
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
+		}
+
+		if (Regb30 && pHalData->interfaceIndex == 1) {
+			if (bNeedPowerDownRadio)
+				PHY_RestoreRFENV(adapter, path,MaskforPhySet, &u4RegValue);
+			rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+		}
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ReloadLCKSetting
+ *
+ * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
+ *
+ * Input:       struct rtw_adapter *				adapter
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 01/08/2009	MHC		Suggestion from SD3 Willis for 92S series.
+ * 01/09/2009	MHC		Add CCK modification for 40MHZ. Suggestion from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+static  void
+ phy_ReloadLCKSetting(
+	struct rtw_adapter *				adapter,
+	u8					channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8		eRFPath = pHalData->CurrentBandType92D == BAND_ON_5G?RF_PATH_A:IS_92D_SINGLEPHY(pHalData->VersionID)?RF_PATH_B:RF_PATH_A;
+	u32		u4tmp = 0, u4RegValue = 0;
+	bool		bNeedPowerDownRadio = false;
+	u32		MaskforPhySet = 0;
+
+	/* only for 92D C-cut SMSP */
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+	{
+		/* Path-A for 5G */
+		{
+			u4tmp = CurveIndex[GetRightChnlPlace(channel)-1];
+
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 1)
+			{
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+				MaskforPhySet = MAC1_ACCESS_PHY0;
+				/* asume no this case */
+				if (bNeedPowerDownRadio)
+					PHY_EnableRFENV(adapter, eRFPath, MaskforPhySet,&u4RegValue);
+			}
+
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
+
+			if (bNeedPowerDownRadio) {
+				PHY_RestoreRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+			}
+		}
+	}
+	else if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{
+		{
+			u32 u4tmp=0;
+			u4tmp = CurveIndex[channel-1];
+
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY && pHalData->interfaceIndex == 0)
+			{
+				bNeedPowerDownRadio = rtl8192d_PHY_EnableAnotherPHY(adapter, true);
+				MaskforPhySet = MAC0_ACCESS_PHY1;
+				if (bNeedPowerDownRadio)
+					PHY_EnableRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
+			}
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_SYN_G4|MaskforPhySet, 0x3f800, u4tmp);
+
+			if (bNeedPowerDownRadio) {
+				PHY_RestoreRFENV(adapter, eRFPath,MaskforPhySet, &u4RegValue);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
+			}
+		}
+	}
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ReloadIMRSetting
+ *
+ * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
+ *
+ * Input:       struct rtw_adapter *				adapter
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 01/08/2009	MHC		Suggestion from SD3 Willis for 92S series.
+ * 01/09/2009	MHC		Add CCK modification for 40MHZ. Suggestion from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+ static void
+ phy_ReloadIMRSetting(
+	struct rtw_adapter *				adapter,
+	u8					channel,
+	u8					eRFPath
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32		IMR_NUM = MAX_RF_IMR_INDEX;
+	u32		RFMask=bRFRegOffsetMask;
+	u8		group=0, i;
+
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
+		return;
+
+	/* only for 92D C-cut SMSP */
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+	{
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
+
+		/*  fc area 0xd2c */
+		if (channel>=149)
+			PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT13|BIT14,2);
+		else
+			PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT13|BIT14,1);
+
+		group = channel<=64?1:2; /* leave 0 for channel1-14. */
+		IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
+
+		for (i=0; i<IMR_NUM; i++) {
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], RFMask,RF_IMR_Param_Normal[0][group][i]);
+		}
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 2);
+	}
+	else { /* G band. */
+
+		if (!pHalData->bLoadIMRandIQKSettingFor2G) {
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT25|BIT24, 0);
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,	0xf);
+
+			IMR_NUM = MAX_RF_IMR_INDEX_NORMAL;
+			for (i=0; i<IMR_NUM; i++) {
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_REG_FOR_5G_SWCHNL_NORMAL[i], bRFRegOffsetMask,RF_IMR_Param_Normal[0][0][i]);
+			}
+			PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,0);
+			PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
+		}
+	}
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	phy_ReloadIQKSetting
+ *
+ * Overview:	Change RF Setting when we siwthc channel for 92D C-cut.
+ *
+ * Input:       struct rtw_adapter *				adapter
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 01/08/2009	MHC		Suggestion from SD3 Willis for 92S series.
+ * 01/09/2009	MHC		Add CCK modification for 40MHZ. Suggestion from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+ static void
+ phy_ReloadIQKSetting(
+	struct rtw_adapter *				adapter,
+	u8					channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8		Indexforchannel;/* index, */
+
+	/* only for 92D C-cut SMSP */
+
+	if (adapter_to_dvobj(adapter)->ishighspeed == false)
+		return;
+
+	/* Do IQK for normal chip and test chip 5G band---------------- */
+	Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(channel);
+
+#if MP_DRIVER == 1
+	pHalData->bNeedIQK = true;
+	pHalData->bLoadIMRandIQKSettingFor2G = false;
+#endif
+
+	if (pHalData->bNeedIQK && !pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone)
+	{ /* Re Do IQK. */
+		DBG_8192D("Do IQK Matrix reg for channel:%d....\n", channel);
+		rtl8192d_PHY_IQCalibrate(adapter);
+	}
+	else /* Just load the value. */
+	{
+		/*  2G band just load once. */
+		if (((!pHalData->bLoadIMRandIQKSettingFor2G) && Indexforchannel==0) ||Indexforchannel>0)
+		{
+
+			if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][0] != 0)/*&&(RegEA4 != 0)*/)
+			{
+				if (pHalData->CurrentBandType92D == BAND_ON_5G)
+					phy_PathAFillIQKMatrix_5G_Normal(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+				else
+					phy_PathAFillIQKMatrix(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][2] == 0));
+			}
+
+			if (IS_92D_SINGLEPHY(pHalData->VersionID))
+			{
+				if ((pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][4] != 0)/*&&(RegEC4 != 0)*/)
+				{
+					if (pHalData->CurrentBandType92D == BAND_ON_5G)
+						phy_PathBFillIQKMatrix_5G_Normal(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+					else
+						phy_PathBFillIQKMatrix(adapter, true, pHalData->IQKMatrixRegSetting[Indexforchannel].Value, 0, (pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][6] == 0));
+				}
+			}
+
+			if ((adapter->mlmeextpriv.sitesurvey_res.state == SCAN_PROCESS)&&(Indexforchannel==0))
+				pHalData->bLoadIMRandIQKSettingFor2G=true;
+		}
+	}
+	pHalData->bNeedIQK = false;
+}
+
+static void _PHY_SwChnl8192D(struct rtw_adapter * adapter, u8 channel)
+{
+	u8	eRFPath;
+	u32	param1, param2;
+	u32	ret_value;
+	enum BAND_TYPE	bandtype, target_bandtype;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+#if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
+	/*  FOr 92D dual mac config. and sw concurrent mode */
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+#endif
+
+	if (adapter->bNotifyChannelChange)
+	{
+		DBG_8192D("[%s] ch = %d\n", __func__, channel);
+	}
+
+	if (pHalData->BandSet92D == BAND_ON_BOTH) {
+		/*  Need change band? */
+		/*  BB {Reg878[0],[16]} bit0= 1 is 5G, bit0=0 is 2G. */
+		ret_value = PHY_QueryBBReg(adapter, rFPGA0_XAB_RFParameter, bMaskDWord);
+
+		if (ret_value & BIT0)
+			bandtype = BAND_ON_5G;
+		else
+			bandtype = BAND_ON_2_4G;
+
+		/*  Use current channel to judge Band Type and switch Band if need. */
+		if (channel > 14)
+		{
+			target_bandtype = BAND_ON_5G;
+		}
+		else
+		{
+			target_bandtype = BAND_ON_2_4G;
+		}
+
+		if (target_bandtype != bandtype)
+			PHY_SwitchWirelessBand(adapter,target_bandtype);
+	}
+
+	do{
+		/* s1. pre common command - CmdID_SetTxPowerLevel */
+		PHY_SetTxPowerLevel8192D(adapter, channel);
+
+		/* s2. RF dependent command - CmdID_RF_WriteReg, param1=RF_CHNLBW, param2=channel */
+		param1 = RF_CHNLBW;
+		param2 = channel;
+		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+		{
+			pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xffffff00) | param2);
+			if (pHalData->CurrentBandType92D == BAND_ON_5G)
+			{
+				if (param2>99)
+				{
+					pHalData->RfRegChnlVal[eRFPath]=pHalData->RfRegChnlVal[eRFPath]|(BIT18);
+				}
+				else
+				{
+					pHalData->RfRegChnlVal[eRFPath]=pHalData->RfRegChnlVal[eRFPath]&(~BIT18);
+				}
+				pHalData->RfRegChnlVal[eRFPath] |= (BIT16|BIT8);
+			}
+			else
+			{
+				pHalData->RfRegChnlVal[eRFPath] &= ~(BIT8|BIT16|BIT18);
+			}
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, param1, bRFRegOffsetMask, pHalData->RfRegChnlVal[eRFPath]);
+			phy_ReloadIMRSetting(adapter, channel, eRFPath);
+		}
+
+		phy_SwitchRfSetting(adapter, channel);
+
+		/* do IQK when all parameters are ready */
+		phy_ReloadIQKSetting(adapter, channel);
+		break;
+	}while (true);
+
+	/* s3. post common command - CmdID_End, None */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (Buddyadapter) {
+		GET_HAL_DATA(Buddyadapter)->CurrentChannel = channel;
+		GET_HAL_DATA(Buddyadapter)->BandSet92D = pHalData->BandSet92D;
+		GET_HAL_DATA(Buddyadapter)->CurrentBandType92D = pHalData->CurrentBandType92D;
+		GET_HAL_DATA(Buddyadapter)->CurrentWirelessMode = pHalData->CurrentWirelessMode;
+	}
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (adapter->DualMacConcurrent == true && Buddyadapter != NULL)
+	{
+		if (pHalData->bMasterOfDMSP)
+		{
+			GET_HAL_DATA(Buddyadapter)->CurrentChannel=channel;
+		}
+	}
+#endif
+}
+
+void
+PHY_SwChnl8192D(	/*  Call after initialization */
+	struct rtw_adapter *adapter,
+	u8		channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	tmpchannel = pHalData->CurrentChannel;
+	bool  bResult = true;
+	u32	timeout = 1000, timecount = 0;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
+#endif
+
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
+	{
+		return;									/* return immediately if it is peudo-phy */
+	}
+
+	if (adapter->mlmeextpriv.sitesurvey_res.state == SCAN_COMPLETE)
+		pHalData->bLoadIMRandIQKSettingFor2G = false;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bInModeSwitchProcess)
+	{
+		DBG_8192D("PHY_SwChnl8192D(): During mode switch\n");
+		return;
+	}
+
+	if (Buddyadapter != NULL &&
+		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
+		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
+	{
+		pHalDataBuddyadapter=GET_HAL_DATA(Buddyadapter);
+		while (pHalDataBuddyadapter->bLCKInProgress && timecount < timeout)
+		{
+			#ifdef CONFIG_LONG_DELAY_ISSUE
+			rtw_msleep_os(50);
+			#else
+			rtw_mdelay_os(50);
+			#endif
+			timecount += 50;
+		}
+	}
+#endif
+
+	while (pHalData->bLCKInProgress && timecount < timeout)
+	{
+		#ifdef CONFIG_LONG_DELAY_ISSUE
+		rtw_msleep_os(50);
+		#else
+		rtw_mdelay_os(50);
+		#endif
+		timecount += 50;
+	}
+
+	/*  */
+	switch (pHalData->CurrentWirelessMode)
+	{
+		case WIRELESS_MODE_A:
+		case WIRELESS_MODE_N_5G:
+			/* Get first channel error when change between 5G and 2.4G band. */
+			/* FIX ME!!! */
+			break;
+		case WIRELESS_MODE_B:
+			break;
+		case WIRELESS_MODE_G:
+		case WIRELESS_MODE_N_24G:
+			/* Get first channel error when change between 5G and 2.4G band. */
+			break;
+
+		default:
+			break;
+	}
+	/*  */
+
+	if (channel == 0) {/* FIXME!!!A band? */
+		channel = 1;
+	}
+
+	pHalData->CurrentChannel=channel;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if ((Buddyadapter !=NULL) && (pHalData->bSlaveOfDMSP))
+	{
+		DBG_8192D("PHY_SwChnl8192D():slave return when slave\n");
+		return;
+	}
+#endif
+
+	if ((!adapter->bDriverStopped) && (!adapter->bSurpriseRemoved))
+	{
+#ifndef USE_WORKITEM
+		_PHY_SwChnl8192D(adapter, channel);
+#endif
+		if (!bResult)
+				pHalData->CurrentChannel = tmpchannel;
+
+	} else {
+			pHalData->CurrentChannel = tmpchannel;
+	}
+}
+
+static	bool
+phy_SetSwChnlCmdArray(
+	struct sw_chnl_cmd *cmdtable,
+	u32			cmdtableidx,
+	u32			cmdtablesz,
+	enum swchnl_cmdid	cmdid,
+	u32			para1,
+	u32			para2,
+	u32			msdelay
+	)
+{
+	struct sw_chnl_cmd *cmd;
+
+	if (cmdtable == NULL)
+		return false;
+	if (cmdtableidx >= cmdtablesz)
+		return false;
+
+	cmd = cmdtable + cmdtableidx;
+	cmd->cmdid = cmdid;
+	cmd->Para1 = para1;
+	cmd->Para2 = para2;
+	cmd->msDelay = msdelay;
+
+	return true;
+}
+
+/*  */
+/*  Description: */
+/*	Switch channel synchronously. Called by SwChnlByDelayHandler. */
+/*  */
+/*  Implemented by Bruce, 2008-02-14. */
+/*  The following procedure is operted according to SwChanlCallback8190Pci(). */
+/*  However, this procedure is performed synchronously  which should be running under */
+/*  passive level. */
+/*  */
+void
+PHY_SwChnlPhy8192D(	/*  Only called during initialize */
+	struct rtw_adapter *	adapter,
+	u8		channel
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/*  Cannot IO. */
+
+	/*  Channel Switching is in progress. */
+
+	/* return immediately if it is peudo-phy */
+	if (pHalData->rf_chip == RF_PSEUDO_11N)
+	{
+		return;
+	}
+
+	if (channel == 0)
+		channel = 1;
+
+	pHalData->CurrentChannel=channel;
+}
+
+/*  */
+/*  */
+/*	IQK */
+/*  */
+/*  */
+#define MAX_TOLERANCE		5
+#define MAX_TOLERANCE_92D	3
+#define IQK_DELAY_TIME		1	/* ms */
+
+static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
+phy_PathA_IQK(
+	struct rtw_adapter *	adapter,
+	bool		configPathB
+	)
+{
+	u32	regEAC, regE94, regE9C, regEA4;
+	u8	result = 0x00;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/* path-A IQK setting */
+	if (pHalData->interfaceIndex == 0)
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);
+	}
+	else
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x10008c22);
+	}
+
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140102);
+
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, configPathB ? 0x28160202 :
+		IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID)?0x28160202:0x28160502);
+
+	/* path-B IQK setting */
+	if (configPathB)
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x10008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140102);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x28160206);
+		else
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x28160202);
+	}
+
+	/* LO calibration setting */
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+	else
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x001028d1);
+
+	/* One shot, path A LOK & IQK */
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+	/*  delay x ms */
+	rtw_udelay_os(IQK_DELAY_TIME*1000);
+
+	/*  Check failed */
+	regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regE94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+	regE9C= PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord);
+	regEA4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+
+	if (!(regEAC & BIT28) &&
+		(((regE94 & 0x03FF0000)>>16) != 0x142) &&
+		(((regE9C & 0x03FF0000)>>16) != 0x42))
+		result |= 0x01;
+	else							/* if Tx not OK, ignore Rx */
+		return result;
+
+	if (!(regEAC & BIT27) &&		/* if Tx is OK, check whether Rx is OK */
+		(((regEA4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regEAC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		DBG_8192D("Path A Rx IQK fail!!\n");
+
+	return result;
+
+}
+
+static u8			/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
+phy_PathA_IQK_5G_Normal(
+	struct rtw_adapter *	adapter,
+	bool		configPathB
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32	regEAC, regE94, regEA4;
+	u8	result = 0x00;
+	u8	i = 0;
+#if MP_DRIVER == 1
+	u8	retryCount = 9;
+#else
+	u8	retryCount = 2;
+#endif
+	u8	timeout = 20, timecount = 0;
+
+	u32	TxOKBit = BIT28, RxOKBit = BIT27;
+
+	if (pHalData->interfaceIndex == 1)	/* PHY1 */
+	{
+		TxOKBit = BIT31;
+		RxOKBit = BIT30;
+	}
+
+	/* path-A IQK setting */
+
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82140307);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68160960);
+
+	/* path-B IQK setting */
+	if (configPathB)
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+	}
+
+	/* LO calibration setting */
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+
+	/* path-A PA on */
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x07000f60);
+	PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, 0x66e60e30);
+
+	for (i = 0 ; i < retryCount ; i++)
+	{
+
+		/* One shot, path A LOK & IQK */
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+		/*  delay x ms */
+		rtw_mdelay_os(IQK_DELAY_TIME*10);
+
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, BIT26) == 0x00)
+		{
+			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
+			timecount++;
+		}
+
+		timecount = 0;
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, 0x3FF0000) == 0x00)
+		{
+			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
+			timecount++;
+		}
+
+		/*  Check failed */
+		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		regE94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+		regEA4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+
+		if (!(regEAC & TxOKBit) &&
+			(((regE94 & 0x03FF0000)>>16) != 0x142) )
+		{
+			result |= 0x01;
+		}
+		else			/* if Tx not OK, ignore Rx */
+		{
+			continue;
+		}
+
+		if (!(regEAC & RxOKBit) &&			/* if Tx is OK, check whether Rx is OK */
+			(((regEA4 & 0x03FF0000)>>16) != 0x132))
+		{
+			result |= 0x02;
+			break;
+		}
+		else
+		{
+		}
+	}
+
+	/* path A PA off */
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
+	PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[1]);
+
+	if (!(result & 0x01))	/* Tx IQK fail */
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
+	}
+
+	if (!(result & 0x02))	/* Rx IQK fail */
+	{
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
+
+		DBG_8192D("Path A Rx IQK fail!!0xe34 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord));
+	}
+
+	return result;
+}
+
+static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
+phy_PathB_IQK(
+	struct rtw_adapter *	adapter
+	)
+{
+	u32 regEAC, regEB4, regEBC, regEC4, regECC;
+	u8	result = 0x00;
+
+	/* One shot, path B LOK & IQK */
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+
+	/*  delay x ms */
+	rtw_udelay_os(IQK_DELAY_TIME*1000);/* PlatformStallExecution(IQK_DELAY_TIME*1000); */
+
+	/*  Check failed */
+	regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	regEB4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
+	regEBC= PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord);
+	regEC4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+	regECC= PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord);
+
+	if (!(regEAC & BIT31) &&
+		(((regEB4 & 0x03FF0000)>>16) != 0x142) &&
+		(((regEBC & 0x03FF0000)>>16) != 0x42))
+		result |= 0x01;
+	else
+		return result;
+
+	if (!(regEAC & BIT30) &&
+		(((regEC4 & 0x03FF0000)>>16) != 0x132) &&
+		(((regECC & 0x03FF0000)>>16) != 0x36))
+		result |= 0x02;
+	else
+		DBG_8192D("Path B Rx IQK fail!!\n");
+
+	return result;
+}
+
+static u8				/* bit0 = 1 => Tx OK, bit1 = 1 => Rx OK */
+phy_PathB_IQK_5G_Normal(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32	regEAC, regEB4, regEC4;
+	u8	result = 0x00;
+	u8	i = 0;
+#if MP_DRIVER == 1
+	u8	retryCount = 9;
+#else
+	u8	retryCount = 2;
+#endif
+	u8	timeout = 20, timecount = 0;
+
+	/* path-A IQK setting */
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x18008c1f);
+
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+
+	/* path-B IQK setting */
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x18008c2f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140307);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68160960);
+
+	/* LO calibration setting */
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+
+	/* path-B PA on */
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, 0x0f600700);
+	PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, 0x061f0d30);
+
+	for (i = 0 ; i < retryCount ; i++)
+	{
+		/* One shot, path B LOK & IQK */
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xfa000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+		/*  delay x ms */
+		rtw_mdelay_os(IQK_DELAY_TIME*10);
+
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, BIT29) == 0x00) {
+			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
+			timecount++;
+		}
+
+		timecount = 0;
+		while (timecount < timeout && PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, 0x3FF0000) == 0x00) {
+			rtw_udelay_os(IQK_DELAY_TIME*1000*2);
+			timecount++;
+		}
+
+		/*  Check failed */
+		regEAC = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		regEB4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
+		regEC4= PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+
+		if (!(regEAC & BIT31) &&
+			(((regEB4 & 0x03FF0000)>>16) != 0x142))
+			result |= 0x01;
+		else
+			continue;
+
+		if (!(regEAC & BIT30) &&
+			(((regEC4 & 0x03FF0000)>>16) != 0x132))
+		{
+			result |= 0x02;
+			break;
+		}
+		else
+		{
+		}
+	}
+
+	/* path B PA off */
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, bMaskDWord, pdmpriv->IQK_BB_backup[0]);
+	PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, bMaskDWord, pdmpriv->IQK_BB_backup[2]);
+
+	if (!(result & 0x01))	/* Tx IQK fail */
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
+	}
+
+	if (!(result & 0x02))	/* Rx IQK fail */
+	{
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
+		DBG_8192D("Path B Rx IQK fail!!0xe54 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord));
+	}
+
+	return result;
+}
+
+static void
+phy_PathAFillIQKMatrix(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	)
+{
+	u32	Oldval_0, X, TX0_A, reg;
+	int	Y, TX0_C;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (final_candidate == 0xFF)
+		return;
+
+	else if (bIQKOK)
+	{
+		Oldval_0 = (PHY_QueryBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord) >> 22) & 0x3FF;/* OFDM0_D */
+
+		X = result[final_candidate][0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX0_A = (X * Oldval_0) >> 8;
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, 0x3FF, TX0_A);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, ((X* Oldval_0>>7) & 0x1));
+		else
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(31), ((X* Oldval_0>>7) & 0x1));
+
+		Y = result[final_candidate][1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+
+		/* path B IQK result + 3 */
+		if (pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)
+			Y += 3;
+
+		TX0_C = (Y * Oldval_0) >> 8;
+		PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, 0xF0000000, ((TX0_C&0x3C0)>>6));
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, 0x003F0000, (TX0_C&0x3F));
+		if (IS_HARDWARE_TYPE_8192D(adapter)/*&&is2T*/)
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT26, ((Y* Oldval_0>>7) & 0x1));
+		else
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(29), ((Y* Oldval_0>>7) & 0x1));
+
+	        if (bTxOnly)
+		{
+			return;
+		}
+
+		reg = result[final_candidate][2];
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+
+		reg = result[final_candidate][3] & 0x3F;
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][3] >> 6) & 0xF;
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+	}
+}
+
+static void
+phy_PathAFillIQKMatrix_5G_Normal(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly
+	)
+{
+	u32	X, reg;
+	int	Y;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (bIQKOK && final_candidate != 0xFF)
+	{
+		X = result[final_candidate][0];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, 0x3FF0000, X);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT24, 0);
+
+		Y = result[final_candidate][1];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+
+		/* path A/B IQK result + 3, suggest by Jenyu */
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
+			Y += 3;
+
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, 0x003FF, Y);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT26, 0);
+
+		if (bTxOnly)
+		{
+			return;
+		}
+
+		reg = result[final_candidate][2];
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0x3FF, reg);
+
+		reg = result[final_candidate][3] & 0x3F;
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][3] >> 6) & 0xF;
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, reg);
+	}
+	else
+	{
+		DBG_8192D("phy_PathAFillIQKMatrix Tx/Rx FAIL restore default value\n");
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A , bMaskDWord, 0x19008c00);
+	}
+}
+
+static void
+phy_PathBFillIQKMatrix(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly			/* do Tx only */
+	)
+{
+	u32	Oldval_1, X, TX1_A, reg;
+	int	Y, TX1_C;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+        if (final_candidate == 0xFF)
+		return;
+
+	else if (bIQKOK)
+	{
+		Oldval_1 = (PHY_QueryBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord) >> 22) & 0x3FF;
+
+		X = result[final_candidate][4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+		TX1_A = (X * Oldval_1) >> 8;
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, 0x3FF, TX1_A);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, ((X* Oldval_1>>7) & 0x1));
+		else
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(27), ((X* Oldval_1>>7) & 0x1));
+
+		Y = result[final_candidate][5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
+			Y += 3;		/* temp modify for preformance */
+		TX1_C = (Y * Oldval_1) >> 8;
+		PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, 0xF0000000, ((TX1_C&0x3C0)>>6));
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, 0x003F0000, (TX1_C&0x3F));
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT30, ((Y* Oldval_1>>7) & 0x1));
+		else
+			PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT(25), ((Y* Oldval_1>>7) & 0x1));
+
+		if (bTxOnly)
+			return;
+
+		reg = result[final_candidate][6];
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+
+		reg = result[final_candidate][7] & 0x3F;
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][7] >> 6) & 0xF;
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+	}
+}
+
+static void
+phy_PathBFillIQKMatrix_5G_Normal(
+	struct rtw_adapter *	adapter,
+	bool	bIQKOK,
+	int		result[][8],
+	u8		final_candidate,
+	bool	bTxOnly			/* do Tx only */
+	)
+{
+	u32	X, reg;
+	int	Y;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (bIQKOK && final_candidate != 0xFF)
+	{
+		X = result[final_candidate][4];
+		if ((X & 0x00000200) != 0)
+			X = X | 0xFFFFFC00;
+
+		PHY_SetBBReg(adapter, 0xe50, 0x3FF0000, X);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT28, 0);
+
+		Y = result[final_candidate][5];
+		if ((Y & 0x00000200) != 0)
+			Y = Y | 0xFFFFFC00;
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
+			Y += 3;		/* temp modify for preformance, suggest by Jenyu */
+
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, 0x003FF, Y);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold, BIT30, 0);
+
+		if (bTxOnly)
+			return;
+
+		reg = result[final_candidate][6];
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0x3FF, reg);
+
+		reg = result[final_candidate][7] & 0x3F;
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, 0xFC00, reg);
+
+		reg = (result[final_candidate][7] >> 6) & 0xF;
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, reg);
+	}
+	else
+	{
+		DBG_8192D("phy_PathBFillIQKMatrix Tx/Rx FAIL\n");
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x19008c00);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance , bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B , bMaskDWord, 0x19008c00);
+	}
+}
+
+static void
+phy_SaveADDARegisters(
+	struct rtw_adapter *	adapter,
+	u32*		ADDAReg,
+	u32*		ADDABackup,
+	u32			RegisterNum
+	)
+{
+	u32	i;
+
+	for (i = 0 ; i < RegisterNum ; i++) {
+		ADDABackup[i] = PHY_QueryBBReg(adapter, ADDAReg[i], bMaskDWord);
+	}
+}
+
+static void
+phy_SaveMACRegisters(
+	struct rtw_adapter *	adapter,
+	u32*		MACReg,
+	u32*		MACBackup
+	)
+{
+	u32	i;
+
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
+		MACBackup[i] = rtw_read8(adapter, MACReg[i]);
+	}
+	MACBackup[i] = rtw_read32(adapter, MACReg[i]);
+}
+
+static void
+phy_ReloadADDARegisters(
+	struct rtw_adapter *	adapter,
+	u32*		ADDAReg,
+	u32*		ADDABackup,
+	u32			RegiesterNum
+	)
+{
+	u32	i;
+
+	for (i = 0 ; i < RegiesterNum ; i++) {
+		/* path-A/B BB to initial gain */
+		if (ADDAReg[i] == rOFDM0_XAAGCCore1 || ADDAReg[i] == rOFDM0_XBAGCCore1)
+			PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, 0x50);
+		PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, ADDABackup[i]);
+	}
+}
+
+static void
+phy_ReloadMACRegisters(
+	struct rtw_adapter *	adapter,
+	u32*		MACReg,
+	u32*		MACBackup
+	)
+{
+	u32	i;
+
+	for (i = 0 ; i < (IQK_MAC_REG_NUM - 1); i++) {
+		rtw_write8(adapter, MACReg[i], (u8)MACBackup[i]);
+	}
+	rtw_write32(adapter, MACReg[i], MACBackup[i]);
+}
+
+static void
+phy_PathADDAOn(
+	struct rtw_adapter *	adapter,
+	u32*		ADDAReg,
+	bool		isPathAOn,
+	bool		is2T
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32	pathOn;
+	u32	i;
+
+	pathOn = isPathAOn ? 0x04db25a4 : 0x0b1b25a4;
+	/*  Modified by Neil Chen */
+	/*  for Path diversity and original IQK */
+	if (isPathAOn)     /*  Neil Chen */
+		pathOn = pHalData->interfaceIndex == 0? 0x04db25a4 : 0x0b1b25a4;
+
+	for (i = 0 ; i < IQK_ADDA_REG_NUM ; i++) {
+		PHY_SetBBReg(adapter, ADDAReg[i], bMaskDWord, pathOn);
+	}
+}
+
+static void
+phy_MACSettingCalibration(
+	struct rtw_adapter *	adapter,
+	u32*		MACReg,
+	u32*		MACBackup
+	)
+{
+	u32	i = 0;
+
+	rtw_write8(adapter, MACReg[i], 0x3F);
+
+	for (i = 1 ; i < (IQK_MAC_REG_NUM - 1); i++) {
+		rtw_write8(adapter, MACReg[i], (u8)(MACBackup[i]&(~BIT3)));
+	}
+	rtw_write8(adapter, MACReg[i], (u8)(MACBackup[i]&(~BIT5)));
+}
+
+static void
+phy_PathAStandBy(
+	struct rtw_adapter *	adapter
+	)
+{
+
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x0);
+	PHY_SetBBReg(adapter, 0x840, bMaskDWord, 0x00010000);
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+}
+
+static void
+phy_PIModeSwitch(
+	struct rtw_adapter *	adapter,
+	bool		PIMode
+	)
+{
+	u32	mode;
+
+	mode = PIMode ? 0x01000100 : 0x01000000;
+	PHY_SetBBReg(adapter, 0x820, bMaskDWord, mode);
+	PHY_SetBBReg(adapter, 0x828, bMaskDWord, mode);
+}
+
+static bool
+phy_SimularityCompare_92D(
+	struct rtw_adapter *	adapter,
+	int		result[][8],
+	u8		 c1,
+	u8		 c2
+	)
+{
+	u32	i, j, diff, SimularityBitMap, bound = 0, u4temp = 0;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	final_candidate[2] = {0xFF, 0xFF};	/* for path A and path B */
+	bool		bResult = true;
+	bool		is2T = IS_92D_SINGLEPHY(pHalData->VersionID);
+
+	if (is2T)
+		bound = 8;
+	else
+		bound = 4;
+
+	SimularityBitMap = 0;
+
+	/* check Tx */
+	for (i = 0; i < bound; i++)
+	{
+		diff = (result[c1][i] > result[c2][i]) ? (result[c1][i] - result[c2][i]) : (result[c2][i] - result[c1][i]);
+		if (diff > MAX_TOLERANCE_92D)
+		{
+			if ((i == 2 || i == 6) && !SimularityBitMap)
+			{
+				if (result[c1][i]+result[c1][i+1] == 0)
+					final_candidate[(i/4)] = c2;
+				else if (result[c2][i]+result[c2][i+1] == 0)
+					final_candidate[(i/4)] = c1;
+				else
+					SimularityBitMap = SimularityBitMap|(1<<i);
+			}
+			else
+				SimularityBitMap = SimularityBitMap|(1<<i);
+		}
+	}
+
+	if (SimularityBitMap == 0)
+	{
+		for (i = 0; i < (bound/4); i++)
+		{
+			if (final_candidate[i] != 0xFF)
+			{
+				for (j = i*4; j < (i+1)*4-2; j++)
+					result[3][j] = result[final_candidate[i]][j];
+				bResult = false;
+			}
+		}
+
+		for (i = 0; i < bound; i++)
+		{
+			u4temp += (result[c1][i]+	result[c2][i]);
+		}
+		if (u4temp == 0)	/* IQK fail for c1 & c2 */
+			bResult = false;
+
+		return bResult;
+	}
+
+	if (!(SimularityBitMap & 0x0F))			/* path A OK */
+	{
+		for (i = 0; i < 4; i++)
+			result[3][i] = result[c1][i];
+	}
+	else if (!(SimularityBitMap & 0x03))		/* path A, Tx OK */
+	{
+		for (i = 0; i < 2; i++)
+			result[3][i] = result[c1][i];
+	}
+
+	if (!(SimularityBitMap & 0xF0) && is2T)		/* path B OK */
+	{
+		for (i = 4; i < 8; i++)
+			result[3][i] = result[c1][i];
+	}
+	else if (!(SimularityBitMap & 0x30))		/* path B, Tx OK */
+	{
+		for (i = 4; i < 6; i++)
+			result[3][i] = result[c1][i];
+	}
+
+	return false;
+}
+
+/*
+return false => do IQK again
+*/
+static bool
+phy_SimularityCompare(
+	struct rtw_adapter *	adapter,
+	int		result[][8],
+	u8		 c1,
+	u8		 c2
+	)
+{
+	return phy_SimularityCompare_92D(adapter, result, c1, c2);
+}
+
+static void
+phy_IQCalibrate(
+	struct rtw_adapter *	adapter,
+	int		result[][8],
+	u8		t,
+	bool		is2T
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32			i;
+	u8			PathAOK, PathBOK;
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
+						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
+						rRx_Wait_CCA,		rTx_CCK_RFON,
+						rTx_CCK_BBON,	rTx_OFDM_RFON,
+						rTx_OFDM_BBON,	rTx_To_Rx,
+						rTx_To_Tx,		rRx_CCK,
+						rRx_OFDM,		rRx_Wait_RIFS,
+						rRx_TO_Rx,		rStandby,
+						rSleep,				rPMPD_ANAEN };
+	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE,		REG_BCN_CTRL,
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	/* since 92C & 92D have the different define in IQK_BB_REG */
+	u32	IQK_BB_REG_92C[IQK_BB_REG_NUM_92C] = {
+							rOFDM0_TRxPathEnable,		rOFDM0_TRMuxPar,
+							rFPGA0_XCD_RFInterfaceSW,	rConfig_AntA,	rConfig_AntB,
+							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
+							rFPGA0_XB_RFInterfaceOE,	rFPGA0_RFMOD
+							};
+
+	u32	IQK_BB_REG_92D[IQK_BB_REG_NUM_92D] = {	/* for normal */
+							rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
+							rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
+							rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
+							rFPGA0_RFMOD,			rFPGA0_AnalogParameter4,
+							rOFDM0_XAAGCCore1,		rOFDM0_XBAGCCore1
+						};
+
+#if MP_DRIVER
+	const u32	retryCount = 9;
+#else
+	const u32	retryCount = 2;
+#endif
+
+	/*  Note: IQ calibration must be performed after loading */
+	/*		PHY_REG.txt , and radio_a, radio_b.txt */
+	if (t == 0) {
+		/*  Save ADDA parameters, turn Path A ADDA on */
+		phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+			phy_SaveADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+		else
+			phy_SaveADDARegisters(adapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
+	}
+
+	phy_PathADDAOn(adapter, ADDA_REG, true, is2T);
+
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
+
+	if (t==0)
+		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+
+	if (!pdmpriv->bRfPiEnable) {
+		/*  Switch BB to PI mode to do IQ Calibration. */
+		phy_PIModeSwitch(adapter, true);
+	}
+
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT24, 0x00);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
+	else
+	{
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
+		PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
+	}
+
+	if (is2T)
+	{
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00010000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00010000);
+	}
+
+	/* MAC settings */
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+	if (IS_HARDWARE_TYPE_8192D(adapter))
+	{
+		PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+
+		if (is2T)
+		{
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+		}
+	}
+	else
+	{
+		/* Page B init */
+		PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x00080000);
+
+		if (is2T)
+		{
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x00080000);
+		}
+	}
+
+	/*  IQ calibration setting */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x01007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
+
+	for (i = 0 ; i < retryCount ; i++) {
+		PathAOK = phy_PathA_IQK(adapter, is2T);
+		if (PathAOK == 0x03) {
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][2] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][3] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			break;
+		}
+		else if (i == (retryCount-1) && PathAOK == 0x01)	/* Tx IQK OK */
+		{
+
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		}
+	}
+
+	if (0x00 == PathAOK) {
+		DBG_8192D("Path A IQK failed!!\n");
+	}
+
+	if (is2T) {
+		phy_PathAStandBy(adapter);
+
+		/*  Turn Path B ADDA on */
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
+
+		for (i = 0 ; i < retryCount ; i++) {
+			PathBOK = phy_PathB_IQK(adapter);
+			if (PathBOK == 0x03) {
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				break;
+			}
+			else if (i == (retryCount - 1) && PathBOK == 0x01)	/* Tx IQK OK */
+			{
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+			}
+		}
+
+		if (0x00 == PathBOK) {
+			DBG_8192D("Path B IQK failed!!\n");
+		}
+	}
+
+	/* Back to BB mode, load original value */
+	/* RTPRINT(FINIT, INIT_IQK, ("IQK:Back to BB mode, load original value!\n")); */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
+
+	if (t!=0)
+	{
+		if (!pdmpriv->bRfPiEnable) {
+			/*  Switch back BB to SI mode after finish IQ Calibration. */
+			phy_PIModeSwitch(adapter, false);
+		}
+
+		/*  Reload ADDA power saving parameters */
+		phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+
+		/*  Reload MAC parameters */
+		phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+		/*  Reload BB parameters */
+		if (IS_HARDWARE_TYPE_8192D(adapter))
+		{
+			if (is2T)
+				phy_ReloadADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+			else
+				phy_ReloadADDARegisters(adapter, IQK_BB_REG_92D, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D -1);
+		}
+		else
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG_92C, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92C);
+
+		if (!IS_HARDWARE_TYPE_8192D(adapter))
+		{
+			/*  Restore RX initial gain */
+			PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032ed3);
+			if (is2T) {
+				PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032ed3);
+			}
+		}
+
+		/* load 0xe30 IQC default value */
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+
+	}
+}
+
+static void
+phy_IQCalibrate_5G(
+	struct rtw_adapter *	adapter,
+	int		result[][8]
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32			extPAon, REG0xe5c, RX0REG0xe40, REG0xe40, REG0xe94;
+	u32			REG0xeac, RX1REG0xe40, REG0xeb4, REG0xea4,REG0xec4;
+	u8			TX0IQKOK = false, TX1IQKOK = false ;
+	u32			TX_X0, TX_Y0, TX_X1, TX_Y1, RX_X0, RX_Y0, RX_X1, RX_Y1;
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
+						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
+						rRx_Wait_CCA,		rTx_CCK_RFON,
+						rTx_CCK_BBON,	rTx_OFDM_RFON,
+						rTx_OFDM_BBON,	rTx_To_Rx,
+						rTx_To_Tx,		rRx_CCK,
+						rRx_OFDM,		rRx_Wait_RIFS,
+						rRx_TO_Rx,		rStandby,
+						rSleep,				rPMPD_ANAEN };
+
+	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE,		REG_BCN_CTRL,
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	u32			IQK_BB_REG[IQK_BB_REG_NUM_test] = {	/* for normal */
+						rFPGA0_XAB_RFInterfaceSW,	rOFDM0_TRMuxPar,
+						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
+						rFPGA0_RFMOD,			rFPGA0_AnalogParameter4
+					};
+
+	bool			is2T =  IS_92D_SINGLEPHY(pHalData->VersionID);
+
+	DBG_8192D("IQK for 5G:Start!!!interface %d\n", pHalData->interfaceIndex);
+
+	DBG_8192D("IQ Calibration for %s\n", (is2T ? "2T2R" : "1T1R"));
+
+	/* Save MAC default value */
+	phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+	/* Save BB Parameter */
+	phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
+
+	/* Save AFE Parameters */
+	phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+
+	/* 1 Path-A TX IQK */
+	/* Path-A AFE all on */
+	phy_PathADDAOn(adapter, ADDA_REG, true, true);
+
+	/* MAC register setting */
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+	/* IQK must be done in PI mode */
+	pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+	if (!pdmpriv->bRfPiEnable)
+		phy_PIModeSwitch(adapter, true);
+
+	/* TXIQK RF setting */
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
+
+	/* BB setting */
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT6|BIT5,  0x03);
+	PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT22|BIT21,  0x03);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000,  0x0f);
+
+	/* AP or IQK */
+	PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+	PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+
+	/* IQK global setting */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
+
+	/* path-A IQK setting */
+	if (pHalData->interfaceIndex == 0)
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
+	}
+	else
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c22);
+	}
+
+	if (is2T)
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e2);
+	else
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x821402e6);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+
+	/* path-B IQK setting */
+	if (is2T)
+	{
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+	}
+
+	/* LO calibration setting */
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+
+	/* One shot, path A LOK & IQK */
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+	PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+	/* Delay 1 ms */
+	rtw_udelay_os(IQK_DELAY_TIME*1000);
+
+	/* Exit IQK mode */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+
+	/* Check_TX_IQK_A_result() */
+	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
+	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	REG0xe94 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord);
+
+	if (((REG0xeac&BIT(28)) == 0) && (((REG0xe94&0x3FF0000)>>16)!=0x142))
+	{
+		TX_X0 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		TX_Y0 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		RX0REG0xe40 =  0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X0<<16) | TX_Y0;
+		result[0][0] = TX_X0;
+		result[0][1] = TX_Y0;
+		TX0IQKOK = true;
+		DBG_8192D("IQK for 5G: Path A TxOK interface %u\n", pHalData->interfaceIndex);
+	}
+	else
+	{
+		DBG_8192D("IQK for 5G: Path A Tx Fail interface %u\n", pHalData->interfaceIndex);
+	}
+
+	/* 1 path A RX IQK */
+	if (TX0IQKOK == true)
+	{
+
+		DBG_8192D("IQK for 5G: Path A Rx  START interface %u\n", pHalData->interfaceIndex);
+
+		/* TXIQK RF setting */
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+
+		/* turn on external PA */
+		if (pHalData->interfaceIndex == 1)
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0x01);
+
+		/* IQK global setting */
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+
+		/* path-A IQK setting */
+		if (pHalData->interfaceIndex == 0)
+		{
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+		}
+		else
+		{
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x14008c22);
+		}
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+		if (pHalData->interfaceIndex == 0)
+			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, (pHalData->CurrentChannel<=140)?0x68160c62:0x68160c66);
+		else
+			PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68160962);
+
+		/* path-B IQK setting */
+		if (is2T)
+		{
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+			PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+			PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+		}
+
+		/* load TX0 IMR setting */
+		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX0REG0xe40);
+		/* Sleep(5) -> delay 1ms */
+		rtw_udelay_os(IQK_DELAY_TIME*1000);
+
+		/* LO calibration setting */
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+
+		/* One shot, path A LOK & IQK */
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf9000000);
+		PHY_SetBBReg(adapter, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);
+
+		/* Delay 3 ms */
+		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
+
+		/* Exit IQK mode */
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+
+		/* Check_RX_IQK_A_result() */
+		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		REG0xea4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord);
+		if (pHalData->interfaceIndex == 0)
+		{
+			if (((REG0xeac&BIT(27)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
+			{
+				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[0][2] = RX_X0;
+				result[0][3] = RX_Y0;
+			}
+		}
+		else
+		{
+			if (((REG0xeac&BIT(30)) == 0) && (((REG0xea4&0x3FF0000)>>16)!=0x132))
+			{
+				RX_X0 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				RX_Y0 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+				result[0][2] = RX_X0;
+				result[0][3] = RX_Y0;
+			}
+		}
+	}
+
+	if (!is2T)
+		goto Exit_IQK;
+
+	/* 1 path B TX IQK */
+	/* Path-B AFE all on */
+
+	DBG_8192D("IQK for 5G: Path B Tx  START interface %u\n", pHalData->interfaceIndex);
+
+	phy_PathADDAOn(adapter, ADDA_REG, false, true);
+
+	/* TXIQK RF setting */
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01940000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01940000);
+
+	/* IQK global setting */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
+
+	/* path-A IQK setting */
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x30008c1f);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+
+	/* path-B IQK setting */
+	PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+	PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x30008c22);
+	PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82140386);
+	PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, 0x68110000);
+
+	/* LO calibration setting */
+	PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x00462911);
+
+	/* One shot, path A LOK & IQK */
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+	PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+
+	/* Delay 1 ms */
+	rtw_udelay_os(IQK_DELAY_TIME*1000);
+
+	/* Exit IQK mode */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+
+	/*  Check_TX_IQK_B_result() */
+	REG0xe40 = PHY_QueryBBReg(adapter, rTx_IQK, bMaskDWord);
+	REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+	REG0xeb4 = PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord);
+	if (((REG0xeac&BIT(31)) == 0) && ((REG0xeb4&0x3FF0000)!=0x142))
+	{
+		TX_X1 = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+		TX_Y1 = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+		RX1REG0xe40 = 0x80000000 | (REG0xe40 & 0xfc00fc00) | (TX_X1<<16) | TX_Y1;
+		result[0][4] = TX_X1;
+		result[0][5] = TX_Y1;
+		TX1IQKOK = true;
+	}
+
+	/* 1 path B RX IQK */
+	if (TX1IQKOK == true)
+	{
+
+		DBG_8192D("IQK for 5G: Path B Rx  START interface %u\n", pHalData->interfaceIndex);
+
+		if (pHalData->CurrentChannel<=140)
+		{
+			REG0xe5c = 0x68160960;
+			extPAon = 0x1;
+		}
+		else
+		{
+			REG0xe5c = 0x68150c66;
+			extPAon = 0x0;
+		}
+
+		/* TXIQK RF setting */
+		PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+		PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+
+		/* turn on external PA */
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), extPAon);
+
+		/* BB setting */
+		PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, bMaskDWord, 0xcc300080);
+
+		/* IQK global setting */
+		PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+
+		/* path-A IQK setting */
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x14008c1f);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x34008c1f);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_A, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_A, bMaskDWord, 0x68110000);
+
+		/* path-B IQK setting */
+		PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x14008c22);
+		PHY_SetBBReg(adapter, rTx_IQK_PI_B, bMaskDWord, 0x82110000);
+		PHY_SetBBReg(adapter, rRx_IQK_PI_B, bMaskDWord, REG0xe5c);
+
+		/* load TX0 IMR setting */
+		PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, RX1REG0xe40);
+
+		/* Sleep(5) -> delay 1ms */
+		rtw_udelay_os(IQK_DELAY_TIME*1000);
+
+		/* LO calibration setting */
+		PHY_SetBBReg(adapter, rIQK_AGC_Rsp, bMaskDWord, 0x0046a911);
+
+		/* One shot, path A LOK & IQK */
+		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000002);
+		PHY_SetBBReg(adapter, rIQK_AGC_Cont, bMaskDWord, 0x00000000);
+
+		/* Delay 1 ms */
+		rtw_udelay_os(3*IQK_DELAY_TIME*1000);
+
+		/* Check_RX_IQK_B_result() */
+		REG0xeac = PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord);
+		REG0xec4 = PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord);
+		if (((REG0xeac&BIT(30)) == 0) && (((REG0xec4&0x3FF0000)>>16)!=0x132))
+		{
+			RX_X1 =  (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+			RX_Y1 =  (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+			result[0][6] = RX_X1;
+			result[0][7] = RX_Y1;
+		}
+	}
+
+Exit_IQK:
+	/* turn off external PA */
+	if (pHalData->interfaceIndex == 1 || is2T)
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT(30), 0);
+
+	/* Exit IQK mode */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+	phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_test);
+
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x01900000);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x01900000);
+	PHY_SetBBReg(adapter, rFPGA0_XA_LSSIParameter, bMaskDWord, 0x00032fff);
+	PHY_SetBBReg(adapter, rFPGA0_XB_LSSIParameter, bMaskDWord, 0x00032fff);
+
+	/* reload MAC default value */
+	phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+	if (!pdmpriv->bRfPiEnable)
+		phy_PIModeSwitch(adapter, false);
+	/* Reload ADDA power saving parameters */
+	phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+}
+
+static void
+phy_IQCalibrate_5G_Normal(
+	struct rtw_adapter *	adapter,
+	int		result[][8],
+	u8		t
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32			PathAOK, PathBOK;
+	u32			ADDA_REG[IQK_ADDA_REG_NUM] = {
+						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
+						rRx_Wait_CCA,		rTx_CCK_RFON,
+						rTx_CCK_BBON,	rTx_OFDM_RFON,
+						rTx_OFDM_BBON,	rTx_To_Rx,
+						rTx_To_Tx,		rRx_CCK,
+						rRx_OFDM,		rRx_Wait_RIFS,
+						rRx_TO_Rx,		rStandby,
+						rSleep,				rPMPD_ANAEN };
+	u32			IQK_MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE,		REG_BCN_CTRL,
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	u32			IQK_BB_REG[IQK_BB_REG_NUM] = {	/* for normal */
+						rFPGA0_XAB_RFInterfaceSW,	rFPGA0_XA_RFInterfaceOE,
+						rFPGA0_XB_RFInterfaceOE,	rOFDM0_TRMuxPar,
+						rFPGA0_XCD_RFInterfaceSW,	rOFDM0_TRxPathEnable,
+						rFPGA0_RFMOD,			rFPGA0_AnalogParameter4,
+						rOFDM0_XAAGCCore1,		rOFDM0_XBAGCCore1
+					};
+
+	/*  Note: IQ calibration must be performed after loading */
+	/*		PHY_REG.txt , and radio_a, radio_b.txt */
+	/* 3 PathDiv */
+       /* Neil Chen--2011--05--19-- */
+	u8                 rfPathDiv;   /* for Path Diversity */
+	/*  */
+
+	bool		is2T =  IS_92D_SINGLEPHY(pHalData->VersionID);
+
+	rtw_mdelay_os(IQK_DELAY_TIME*20);
+
+	if (t==0) {
+		/*  Save ADDA parameters, turn Path A ADDA on */
+		phy_SaveADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+		phy_SaveMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+		if (is2T)
+			phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+		else
+			phy_SaveADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
+	}
+
+	/*  */
+	/* 3 Path Diversity */
+	/* Path-A AFE all on */
+	/* Neil Chen--2011--05--19 */
+	rfPathDiv =(u8) (PHY_QueryBBReg(adapter, 0xB30, bMaskDWord)>>27);
+
+	if ((rfPathDiv&0x01)==1)   /*  Div on */
+	{
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
+	}
+	else
+		phy_PathADDAOn(adapter, ADDA_REG, true, is2T);
+	/* 3 end */
+       /*  */
+
+	/* Path-A AFE all on */
+
+	/* MAC settings */
+	phy_MACSettingCalibration(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+	if (t==0)
+	{
+		pdmpriv->bRfPiEnable = (u8)PHY_QueryBBReg(adapter, rFPGA0_XA_HSSIParameter1, BIT(8));
+	}
+
+	if (!pdmpriv->bRfPiEnable) {
+		/*  Switch BB to PI mode to do IQ Calibration. */
+		phy_PIModeSwitch(adapter, true);
+	}
+
+	PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, BIT24, 0x00);
+	PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
+	PHY_SetBBReg(adapter, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
+	PHY_SetBBReg(adapter, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xf00000, 0x0f);
+
+	/* Page A AP setting for IQK */
+	PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x00000000);
+	PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x20000000);
+
+	/* Page B AP setting for IQK */
+	if (is2T) {
+		PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x00000000);
+		PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x20000000);
+	}
+	/*  IQ calibration setting */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+	PHY_SetBBReg(adapter, rTx_IQK, bMaskDWord, 0x10007c00);
+	PHY_SetBBReg(adapter, rRx_IQK, bMaskDWord, 0x01004800);
+
+	{
+		PathAOK = phy_PathA_IQK_5G_Normal(adapter, is2T);
+		if (PathAOK == 0x03) {
+			DBG_8192D("Path A IQK Success!!\n");
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][2] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+			result[t][3] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_A_2, bMaskDWord)&0x3FF0000)>>16;
+		}
+		else if (PathAOK == 0x01)	/* Tx IQK OK */
+		{
+			DBG_8192D("Path A IQK Only  Tx Success!!\n");
+
+			result[t][0] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+			result[t][1] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_A, bMaskDWord)&0x3FF0000)>>16;
+		}
+		else
+		{
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
+			DBG_8192D("0xe70 = 0x%x\n", PHY_QueryBBReg(adapter, rRx_Wait_CCA, bMaskDWord));
+			DBG_8192D("RF path A 0x0 = 0x%x\n", PHY_QueryRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask));
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80800000);
+			DBG_8192D("Path A IQK Fail!!\n");
+		}
+	}
+
+	if (is2T) {
+
+		/*  Turn Path B ADDA on */
+		phy_PathADDAOn(adapter, ADDA_REG, false, is2T);
+
+		{
+			PathBOK = phy_PathB_IQK_5G_Normal(adapter);
+			if (PathBOK == 0x03) {
+				DBG_8192D("Path B IQK Success!!\n");
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][6] = (PHY_QueryBBReg(adapter, rRx_Power_Before_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+				result[t][7] = (PHY_QueryBBReg(adapter, rRx_Power_After_IQK_B_2, bMaskDWord)&0x3FF0000)>>16;
+			}
+			else if (PathBOK == 0x01)	/* Tx IQK OK */
+			{
+				DBG_8192D("Path B Only Tx IQK Success!!\n");
+				result[t][4] = (PHY_QueryBBReg(adapter, rTx_Power_Before_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+				result[t][5] = (PHY_QueryBBReg(adapter, rTx_Power_After_IQK_B, bMaskDWord)&0x3FF0000)>>16;
+			}
+			else {
+				DBG_8192D("Path B IQK failed!!\n");
+			}
+		}
+	}
+
+	/* Back to BB mode, load original value */
+	PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0);
+
+	if (t!=0)
+	{
+		if (is2T)
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D);
+		else
+			phy_ReloadADDARegisters(adapter, IQK_BB_REG, pdmpriv->IQK_BB_backup, IQK_BB_REG_NUM_92D-1);
+
+		/* path A IQ path to DP block */
+		PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x010170b8);
+
+		/* path B IQ path to DP block */
+		if (is2T)
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x010170b8);
+
+		/*  Reload MAC parameters */
+		phy_ReloadMACRegisters(adapter, IQK_MAC_REG, pdmpriv->IQK_MAC_backup);
+
+		if (!pdmpriv->bRfPiEnable) {
+			/*  Switch back BB to SI mode after finish IQ Calibration. */
+			phy_PIModeSwitch(adapter, false);
+		}
+
+		/*  Reload ADDA power saving parameters */
+		phy_ReloadADDARegisters(adapter, ADDA_REG, pdmpriv->ADDA_backup, IQK_ADDA_REG_NUM);
+	}
+}
+
+#if SWLCK != 1
+static void
+phy_LCCalibrate92D(
+	struct rtw_adapter *	adapter,
+	bool		is2T
+	)
+{
+	u8	tmpReg, index = 0;
+	u32	RF_mode[2], tmpu4Byte[2];
+	u8	path = is2T?2:1;
+#if SWLCK == 1
+	u16	timeout = 800, timecount = 0;
+#endif
+
+	/* Check continuous TX and Packet TX */
+	tmpReg = rtw_read8(adapter, 0xd03);
+
+	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
+		rtw_write8(adapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+	else							/*  Deal with Packet TX case */
+		rtw_write8(adapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
+
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+
+	for (index = 0; index <path; index ++)
+	{
+		/* 1. Read original RF mode */
+		RF_mode[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask);
+
+		/* 2. Set RF mode = standby mode */
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, 0x70000, 0x01);
+
+		tmpu4Byte[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
+
+		/* 4. Set LC calibration begin */
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
+
+	}
+
+#if SWLCK == 1
+	for (index = 0; index <path; index ++)
+	{
+		while (!(PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, BIT11)) &&
+			timecount <= timeout)
+		{
+
+			#ifdef CONFIG_LONG_DELAY_ISSUE
+			rtw_msleep_os(50);
+			#else
+			rtw_mdelay_os(50);
+			#endif
+			timecount += 50;
+		}
+	}
+#else
+	#ifdef CONFIG_LONG_DELAY_ISSUE
+	rtw_msleep_os(100);
+	#else
+	rtw_mdelay_os(100);
+	#endif
+#endif
+
+	/* Restore original situation */
+	for (index = 0; index <path; index ++)
+	{
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, RF_mode[index]);
+	}
+
+	if ((tmpReg&0x70) != 0)
+	{
+		/* Path-A */
+		rtw_write8(adapter, 0xd03, tmpReg);
+	}
+	else /*  Deal with Packet TX case */
+	{
+		rtw_write8(adapter, REG_TXPAUSE, 0x00);
+	}
+
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
+}
+#endif  /* SWLCK != 1, amy, temp remove */
+
+static u32
+get_abs(
+	u32	val1,
+	u32	val2
+	)
+{
+	u32 ret=0;
+
+	if (val1 >= val2)
+	{
+		ret = val1 - val2;
+	}
+	else
+	{
+		ret = val2 - val1;
+	}
+	return ret;
+}
+
+#define	TESTFLAG			0
+#define	BASE_CHNL_NUM		6
+#define	BASE_CHNL_NUM_2G	2
+
+static void
+phy_CalcCurvIndex(
+	struct rtw_adapter *	adapter,
+	u32*		TargetChnl,
+	u32*		CurveCountVal,
+	bool		is5G,
+	u32*		CurveIndex
+	)
+{
+	u32	smallestABSVal = 0xffffffff, u4tmp;
+	u8	i, channel=1, pre_channel=1, start = is5G?TARGET_CHNL_NUM_2G:0,
+		start_base = is5G?BASE_CHNL_NUM_2G:0,
+		end_base = is5G?BASE_CHNL_NUM:BASE_CHNL_NUM_2G;
+	u8	chnl_num = is5G?TARGET_CHNL_NUM_2G_5G:TARGET_CHNL_NUM_2G;
+	u8	Base_chnl[BASE_CHNL_NUM] = {1, 14, 36, 100, 149};
+	u32	j, base_index = 0, search_bound = 128;
+
+	for (i = start; i < chnl_num; i++) {
+		if (is5G) {
+			if (i != start)
+				pre_channel = channel;
+			channel = GetChnlFromPlace(i);	/* actual channel number */
+
+			if (i == start)
+				pre_channel = channel;
+		} else {
+			if (i != start)
+				pre_channel = channel;
+			channel = i+1;
+
+			if (i == start)
+				pre_channel = channel;
+		}
+
+		for (j = start_base; j < end_base; j++) {
+			if (channel == Base_chnl[j]) {
+				base_index = 0;
+				search_bound = (CV_CURVE_CNT*2);	/* search every 128 */
+				break;
+			}
+			else if (channel < Base_chnl[j] || j == end_base-1)
+			{
+				base_index = CurveIndex[GetRightChnlPlace(pre_channel)-1];
+
+				if (base_index > 5)
+					base_index -= 5;	/* search -5~5, not every 128 */
+				else
+					base_index = 0;
+				search_bound = base_index+10;
+				break;
+			}
+		}
+
+		CurveIndex[i] = 0;
+		for (j=base_index; j<base_index+search_bound; j++)
+		{
+			u4tmp = get_abs(TargetChnl[channel-1], CurveCountVal[j]);
+
+			if (u4tmp < smallestABSVal)
+			{
+				CurveIndex[i] = j;
+				smallestABSVal = u4tmp;
+			}
+		}
+
+		smallestABSVal = 0xffffffff;
+	}
+}
+
+static void
+phy_LCCalibrate92DSW(
+	struct rtw_adapter *	adapter,
+	bool		is2T
+	)
+{
+	u8	RF_mode[2], tmpReg, index = 0;
+#if (TESTFLAG == 0)
+	u32	tmpu4Byte[2];
+#endif /* TESTFLAG == 0) */
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	u1bTmp=0,path = is2T?2:1;
+	u32	i, u4tmp, offset;
+	u32	curveCountVal[CV_CURVE_CNT*2]={0};
+	u16	timeout = 800, timecount = 0;
+
+	/* Check continuous TX and Packet TX */
+	tmpReg = rtw_read8(adapter, 0xd03);
+
+	if ((tmpReg&0x70) != 0)			/* Deal with contisuous TX case */
+		rtw_write8(adapter, 0xd03, tmpReg&0x8F);	/* disable all continuous TX */
+	else							/*  Deal with Packet TX case */
+		rtw_write8(adapter, REG_TXPAUSE, 0xFF);			/*  block all queues */
+
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x0F);
+
+	for (index = 0; index <path; index ++)
+	{
+
+		/* 1. Read original RF mode */
+		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
+		RF_mode[index] = rtw_read8(adapter, offset);
+
+		/* 2. Set RF mode = standby mode */
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_AC, bRFRegOffsetMask, 0x010000);
+#if (TESTFLAG == 0)
+		tmpu4Byte[index] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, 0x700, 0x07);
+#endif
+
+		if (adapter->hw_init_completed)
+		{
+			/*  switch CV-curve control by LC-calibration */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x0);
+
+			/* 4. Set LC calibration begin */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x01);
+
+		}
+	}
+
+	for (index = 0; index <path; index ++)
+	{
+		u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
+
+		while ((!(u4tmp & BIT11)) &&
+			timecount <= timeout)
+		{
+				#ifdef CONFIG_LONG_DELAY_ISSUE
+				rtw_msleep_os(50);
+				#else
+				rtw_mdelay_os(50);
+				#endif
+			timecount += 50;
+			u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G6, bRFRegOffsetMask);
+		}
+	}
+	/* Disable TX only need during phy lck, To reduce LCK affect on chariot, */
+	/*  move enable tx here after PHY LCK finish, it will not affect sw lck result. */
+	/*  zhiyuan 2011/06/03 */
+	if ((tmpReg&0x70) != 0)
+	{
+		/* Path-A */
+		rtw_write8(adapter, 0xd03, tmpReg);
+	}
+	else /*  Deal with Packet TX case */
+	{
+		rtw_write8(adapter, REG_TXPAUSE, 0x00);
+	}
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0xF00000, 0x00);
+
+	for (index = 0; index <path; index ++)
+	{
+		u4tmp = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask);
+
+		{
+
+			memset(&curveCountVal[0], 0, CV_CURVE_CNT*2);
+
+			/* Set LC calibration off */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_CHNLBW, 0x08000, 0x0);
+
+			/* save Curve-counting number */
+			for (i=0; i<CV_CURVE_CNT; i++)
+			{
+				u32	readVal=0, readVal2=0;
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_TRSW, 0x7f, i);
+
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x4D, bRFRegOffsetMask, 0x0);
+				readVal = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x4F, bRFRegOffsetMask);
+
+				curveCountVal[2*i+1] = (readVal & 0xfffe0) >> 5;
+				/*  reg 0x4f [4:0] */
+				/*  reg 0x50 [19:10] */
+				readVal2 = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)index, 0x50, 0xffc00);
+				curveCountVal[2*i] = (((readVal & 0x1F) << 10) | readVal2);
+
+			}
+
+			if (index == 0 && pHalData->interfaceIndex == 0)
+				phy_CalcCurvIndex(adapter, TargetChnl_5G, curveCountVal, true, CurveIndex);
+			else
+				phy_CalcCurvIndex(adapter, TargetChnl_2G, curveCountVal, false, CurveIndex);
+
+			/*  switch CV-curve control mode */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G7, BIT17, 0x1);
+		}
+
+	}
+
+	/* Restore original situation */
+	for (index = 0; index <path; index ++)
+	{
+#if (TESTFLAG == 0)
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)index, RF_SYN_G4, bRFRegOffsetMask, tmpu4Byte[index]);
+#endif
+		offset = index == 0?rOFDM0_XAAGCCore1:rOFDM0_XBAGCCore1;
+		rtw_write8(adapter, offset, 0x50);
+		rtw_write8(adapter, offset, RF_mode[index]);
+	}
+
+	phy_ReloadLCKSetting(adapter, pHalData->CurrentChannel);
+}
+
+static void
+phy_LCCalibrate(
+	struct rtw_adapter *	adapter,
+	bool		is2T
+	)
+{
+#if SWLCK == 1
+	phy_LCCalibrate92DSW(adapter, is2T);
+#else
+	phy_LCCalibrate92D(adapter, is2T);
+#endif
+}
+
+/* Analog Pre-distortion calibration */
+#define		APK_BB_REG_NUM	8
+#define		APK_CURVE_REG_NUM 4
+#define		PATH_NUM		2
+
+static void
+phy_APCalibrate(
+	struct rtw_adapter *	adapter,
+	char		delta,
+	bool		is2T
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u32			regD[PATH_NUM];
+	u32			tmpReg, index, offset, path, i, pathbound = PATH_NUM, apkbound;
+
+	u32			BB_backup[APK_BB_REG_NUM];
+	u32			BB_REG[APK_BB_REG_NUM] = {
+						rFPGA1_TxBlock,		rOFDM0_TRxPathEnable,
+						rFPGA0_RFMOD,	rOFDM0_TRMuxPar,
+						rFPGA0_XCD_RFInterfaceSW,	rFPGA0_XAB_RFInterfaceSW,
+						rFPGA0_XA_RFInterfaceOE,	rFPGA0_XB_RFInterfaceOE	};
+	u32			BB_AP_MODE[APK_BB_REG_NUM] = {
+						0x00000020, 0x00a05430, 0x02040000,
+						0x000800e4, 0x00204000 };
+	u32			BB_normal_AP_MODE[APK_BB_REG_NUM] = {
+						0x00000020, 0x00a05430, 0x02040000,
+						0x000800e4, 0x22204000 };
+
+	u32			AFE_backup[IQK_ADDA_REG_NUM];
+	u32			AFE_REG[IQK_ADDA_REG_NUM] = {
+						rFPGA0_XCD_SwitchControl,	rBlue_Tooth,
+						rRx_Wait_CCA,		rTx_CCK_RFON,
+						rTx_CCK_BBON,	rTx_OFDM_RFON,
+						rTx_OFDM_BBON,	rTx_To_Rx,
+						rTx_To_Tx,		rRx_CCK,
+						rRx_OFDM,		rRx_Wait_RIFS,
+						rRx_TO_Rx,		rStandby,
+						rSleep,				rPMPD_ANAEN };
+
+	u32			MAC_backup[IQK_MAC_REG_NUM];
+	u32			MAC_REG[IQK_MAC_REG_NUM] = {
+						REG_TXPAUSE,		REG_BCN_CTRL,
+						REG_BCN_CTRL_1,	REG_GPIO_MUXCFG};
+
+	u32			APK_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x1852c, 0x5852c, 0x1852c, 0x5852c},
+					{0x2852e, 0x0852e, 0x3852e, 0x0852e, 0x0852e}
+					};
+
+	u32			APK_normal_RF_init_value[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x0852c, 0x0a52c, 0x3a52c, 0x5a52c, 0x5a52c},	/* path settings equal to path b settings */
+					{0x0852c, 0x0a52c, 0x5a52c, 0x5a52c, 0x5a52c}
+					};
+
+	u32			APK_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52014, 0x52013, 0x5200f, 0x5208d},
+					{0x5201a, 0x52019, 0x52016, 0x52033, 0x52050}
+					};
+
+	u32			APK_normal_RF_value_0[PATH_NUM][APK_BB_REG_NUM] = {
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a},	/* path settings equal to path b settings */
+					{0x52019, 0x52017, 0x52010, 0x5200d, 0x5206a}
+					};
+	u32			AFE_on_off[PATH_NUM] = {
+					0x04db25a4, 0x0b1b25a4};	/* path A on path B off / path A off path B on */
+
+	u32			APK_offset[PATH_NUM] = {
+					rConfig_AntA, rConfig_AntB};
+
+	u32			APK_normal_offset[PATH_NUM] = {
+					rConfig_Pmpd_AntA, rConfig_Pmpd_AntB};
+
+	u32			APK_value[PATH_NUM] = {
+					0x92fc0000, 0x12fc0000};
+
+	u32			APK_normal_value[PATH_NUM] = {
+					0x92680000, 0x12680000};
+
+	char			APK_delta_mapping[APK_BB_REG_NUM][13] = {
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-4, -3, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-6, -4, -2, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6},
+					{-11, -9, -7, -5, -3, -1, 0, 0, 0, 0, 0, 0, 0}
+					};
+
+	u32			APK_normal_setting_value_1[13] = {
+					0x01017018, 0xf7ed8f84, 0x1b1a1816, 0x2522201e, 0x322e2b28,
+					0x433f3a36, 0x5b544e49, 0x7b726a62, 0xa69a8f84, 0xdfcfc0b3,
+					0x12680000, 0x00880000, 0x00880000
+					};
+
+	u32			APK_normal_setting_value_2[16] = {
+					0x01c7021d, 0x01670183, 0x01000123, 0x00bf00e2, 0x008d00a3,
+					0x0068007b, 0x004d0059, 0x003a0042, 0x002b0031, 0x001f0025,
+					0x0017001b, 0x00110014, 0x000c000f, 0x0009000b, 0x00070008,
+					0x00050006
+					};
+
+	u32			APK_result[PATH_NUM][APK_BB_REG_NUM];	/* val_1_1a, val_1_2a, val_2a, val_3a, val_4a */
+
+	int			BB_offset, delta_V, delta_offset;
+
+#if (MP_DRIVER == 1)
+	PMPT_CONTEXT	pMptCtx = &adapter->mppriv.MptCtx;
+
+	pMptCtx->APK_bound[0] = 45;
+	pMptCtx->APK_bound[1] = 52;
+#endif
+
+	if (!is2T)
+		pathbound = 1;
+
+	/* 2 FOR NORMAL CHIP SETTINGS */
+
+/*  Temporarily do not allow normal driver to do the following settings because these offset */
+/*  and value will cause RF internal PA to be unpredictably disabled by HW, such that RF Tx signal */
+/*  will disappear after disable/enable card many times on 88CU. RF SD and DD have not find the */
+/*  root cause, so we remove these actions temporarily. Added by tynli and SD3 Allen. 2010.05.31. */
+#if MP_DRIVER == 1
+
+	/* settings adjust for normal chip */
+	for (index = 0; index < PATH_NUM; index ++)
+	{
+		APK_offset[index] = APK_normal_offset[index];
+		APK_value[index] = APK_normal_value[index];
+		AFE_on_off[index] = 0x6fdb25a4;
+	}
+
+	for (index = 0; index < APK_BB_REG_NUM; index ++)
+	{
+		for (path = 0; path < pathbound; path++)
+		{
+			APK_RF_init_value[path][index] = APK_normal_RF_init_value[path][index];
+			APK_RF_value_0[path][index] = APK_normal_RF_value_0[path][index];
+		}
+		BB_AP_MODE[index] = BB_normal_AP_MODE[index];
+	}
+
+	apkbound = 6;
+
+	/* save BB default value */
+	for (index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+		if (index == 0)		/* skip */
+			continue;
+		BB_backup[index] = PHY_QueryBBReg(adapter, BB_REG[index], bMaskDWord);
+	}
+
+	/* save MAC default value */
+	phy_SaveMACRegisters(adapter, MAC_REG, MAC_backup);
+
+	/* save AFE default value */
+	phy_SaveADDARegisters(adapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+
+	for (path = 0; path < pathbound; path++)
+	{
+
+		if (path == RF_PATH_A)
+		{
+			/* path A APK */
+			/* load APK setting */
+			/* path-A */
+			offset = rPdp_AntA;
+			for (index = 0; index < 11; index ++)
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+
+				offset += 0x04;
+			}
+
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+
+			offset = rConfig_AntA;
+			for (; index < 13; index ++)
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+
+				offset += 0x04;
+			}
+
+			/* page-B1 */
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+
+			/* path A */
+			offset = rPdp_AntA;
+			for (index = 0; index < 16; index++)
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
+
+				offset += 0x04;
+			}
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+		}
+		else if (path == RF_PATH_B)
+		{
+			/* path B APK */
+			/* load APK setting */
+			/* path-B */
+			offset = rPdp_AntB;
+			for (index = 0; index < 10; index ++)
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+
+				offset += 0x04;
+			}
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntA, bMaskDWord, 0x12680000);
+
+			PHY_SetBBReg(adapter, rConfig_Pmpd_AntB, bMaskDWord, 0x12680000);
+
+			offset = rConfig_AntA;
+			index = 11;
+			for (; index < 13; index ++) /* offset 0xb68, 0xb6c */
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_1[index]);
+
+				offset += 0x04;
+			}
+
+			/* page-B1 */
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x40000000);
+
+			/* path B */
+			offset = 0xb60;
+			for (index = 0; index < 16; index++)
+			{
+				PHY_SetBBReg(adapter, offset, bMaskDWord, APK_normal_setting_value_2[index]);
+
+				offset += 0x04;
+			}
+			PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+		}
+
+		/* save RF default value */
+		regD[path] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask);
+
+		/* Path A AFE all on, path B AFE All off or vise versa */
+		for (index = 0; index < IQK_ADDA_REG_NUM ; index++)
+			PHY_SetBBReg(adapter, AFE_REG[index], bMaskDWord, AFE_on_off[path]);
+
+		/* BB to AP mode */
+		if (path == 0)
+		{
+			for (index = 0; index < APK_BB_REG_NUM ; index++)
+			{
+
+				if (index == 0)		/* skip */
+					continue;
+				else if (index < 5)
+				PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_AP_MODE[index]);
+				else if (BB_REG[index] == 0x870)
+					PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_backup[index]|BIT10|BIT26);
+				else
+					PHY_SetBBReg(adapter, BB_REG[index], BIT10, 0x0);
+			}
+
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_A, bMaskDWord, 0x01008c00);
+		}
+		else		/* path B */
+		{
+			PHY_SetBBReg(adapter, rTx_IQK_Tone_B, bMaskDWord, 0x01008c00);
+			PHY_SetBBReg(adapter, rRx_IQK_Tone_B, bMaskDWord, 0x01008c00);
+
+		}
+
+		/* MAC settings */
+		phy_MACSettingCalibration(adapter, MAC_REG, MAC_backup);
+
+		if (path == RF_PATH_A)	/* Path B to standby mode */
+		{
+			PHY_SetRFReg(adapter, RF_PATH_B, RF_AC, bRFRegOffsetMask, 0x10000);
+		}
+		else			/* Path A to standby mode */
+		{
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x10000);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20103);
+		}
+
+		delta_offset = ((delta+14)/2);
+		if (delta_offset < 0)
+			delta_offset = 0;
+		else if (delta_offset > 12)
+			delta_offset = 12;
+
+		/* AP calibration */
+		for (index = 0; index < APK_BB_REG_NUM; index++) {
+			if (index != 1)	/* only DO PA11+PAD01001, AP RF setting */
+				continue;
+
+			tmpReg = APK_RF_init_value[path][index];
+			if (!pdmpriv->bAPKThermalMeterIgnore) {
+				BB_offset = (tmpReg & 0xF0000) >> 16;
+
+				if (!(tmpReg & BIT15)) /* sign bit 0 */
+					BB_offset = -BB_offset;
+
+				delta_V = APK_delta_mapping[index][delta_offset];
+
+				BB_offset += delta_V;
+
+				if (BB_offset < 0) {
+					tmpReg = tmpReg & (~BIT15);
+					BB_offset = -BB_offset;
+				} else {
+					tmpReg = tmpReg | BIT15;
+				}
+				tmpReg = (tmpReg & 0xFFF0FFFF) | (BB_offset << 16);
+			}
+
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_IPA_A, bRFRegOffsetMask, 0x8992e);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_AC, bRFRegOffsetMask, APK_RF_value_0[path][index]);
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, tmpReg);
+
+			/*  PA11+PAD01111, one shot */
+			i = 0;
+			do {
+				PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x80000000);
+				PHY_SetBBReg(adapter, APK_offset[path], bMaskDWord, APK_value[0]);
+				rtw_mdelay_os(3);
+				PHY_SetBBReg(adapter, APK_offset[path], bMaskDWord, APK_value[1]);
+
+				rtw_mdelay_os(20);
+				PHY_SetBBReg(adapter, rFPGA0_IQK, bMaskDWord, 0x00000000);
+
+				if (path == RF_PATH_A)
+				tmpReg = PHY_QueryBBReg(adapter, rAPK, 0x03E00000);
+				else
+					tmpReg = PHY_QueryBBReg(adapter, rAPK, 0xF8000000);
+
+				i++;
+			}
+			while (tmpReg > apkbound && i < 4);
+
+			APK_result[path][index] = tmpReg;
+		}
+	}
+
+	/* reload MAC default value */
+	phy_ReloadMACRegisters(adapter, MAC_REG, MAC_backup);
+
+	/* reload BB default value */
+	for (index = 0; index < APK_BB_REG_NUM ; index++)
+	{
+
+		if (index == 0)		/* skip */
+			continue;
+		PHY_SetBBReg(adapter, BB_REG[index], bMaskDWord, BB_backup[index]);
+	}
+
+	/* reload AFE default value */
+	phy_ReloadADDARegisters(adapter, AFE_REG, AFE_backup, IQK_ADDA_REG_NUM);
+
+	/* reload RF path default value */
+	for (path = 0; path < pathbound; path++)
+	{
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_TXBIAS_A, bRFRegOffsetMask, regD[path]);
+		if (path == RF_PATH_B)
+		{
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE1, bRFRegOffsetMask, 0x1000f);
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_MODE2, bRFRegOffsetMask, 0x20101);
+		}
+
+		/* note no index == 0 */
+		if (APK_result[path][1] > 6)
+			APK_result[path][1] = 6;
+	}
+
+	for (path = 0; path < pathbound; path++)
+	{
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G1_G4, bRFRegOffsetMask,
+		((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (APK_result[path][1] << 5) | APK_result[path][1]));
+		if (path == RF_PATH_A)
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x00 << 5) | 0x05));
+		else
+		PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)path, RF_BS_PA_APSET_G5_G8, bRFRegOffsetMask,
+			((APK_result[path][1] << 15) | (APK_result[path][1] << 10) | (0x02 << 5) | 0x05));
+
+	}
+
+	pdmpriv->bAPKdone = true;
+#endif
+}
+
+static void phy_SetRFPathSwitch(
+	struct rtw_adapter *	adapter,
+	bool		main,
+	bool		is2T
+	)
+{
+
+	if (!adapter->hw_init_completed)
+	{
+		PHY_SetBBReg(adapter, 0x4C, BIT23, 0x01);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+	}
+
+	if (main)
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x2);
+	else
+		PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, 0x300, 0x1);
+
+}
+
+void
+rtl8192d_PHY_IQCalibrate(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	int			result[4][8];	/* last is final result */
+	u8			i, final_candidate, Indexforchannel;
+	bool		bPathAOK, bPathBOK;
+	int			RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC, RegTmp = 0;
+	bool		is12simular, is13simular, is23simular;
+	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
+
+#if (MP_DRIVER == 1)
+	bStartContTx = adapter->mppriv.MptCtx.bStartContTx;
+	bSingleTone = adapter->mppriv.MptCtx.bSingleTone;
+	bCarrierSuppression = adapter->mppriv.MptCtx.bCarrierSuppression;
+#endif
+
+	/* ignore IQK when continuous Tx */
+	if (bStartContTx || bSingleTone || bCarrierSuppression)
+		return;
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bSlaveOfDMSP)
+		return;
+#endif
+
+	for (i = 0; i < 8; i++)
+	{
+		result[0][i] = 0;
+		result[1][i] = 0;
+		result[2][i] = 0;
+		result[3][i] = 0;
+	}
+	final_candidate = 0xff;
+	bPathAOK = false;
+	bPathBOK = false;
+	is12simular = false;
+	is23simular = false;
+	is13simular = false;
+
+	for (i=0; i<3; i++)
+	{
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
+		{
+			phy_IQCalibrate_5G_Normal(adapter, result, i);
+		}
+		else if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		{
+			if (IS_92D_SINGLEPHY(pHalData->VersionID))
+				phy_IQCalibrate(adapter, result, i, true);
+			else
+				phy_IQCalibrate(adapter, result, i, false);
+		}
+
+		if (i == 1)
+		{
+			is12simular = phy_SimularityCompare(adapter, result, 0, 1);
+			if (is12simular)
+			{
+				final_candidate = 0;
+				break;
+			}
+		}
+
+		if (i == 2)
+		{
+			is13simular = phy_SimularityCompare(adapter, result, 0, 2);
+			if (is13simular)
+			{
+				final_candidate = 0;
+				break;
+			}
+
+			is23simular = phy_SimularityCompare(adapter, result, 1, 2);
+			if (is23simular)
+				final_candidate = 1;
+			else
+			{
+				for (i = 0; i < 8; i++)
+					RegTmp += result[3][i];
+
+				if (RegTmp != 0)
+					final_candidate = 3;
+				else
+					final_candidate = 0xFF;
+			}
+		}
+	}
+
+        for (i=0; i<4; i++)
+	{
+		RegE94 = result[i][0];
+		RegE9C = result[i][1];
+		RegEA4 = result[i][2];
+		RegEAC = result[i][3];
+		RegEB4 = result[i][4];
+		RegEBC = result[i][5];
+		RegEC4 = result[i][6];
+		RegECC = result[i][7];
+	}
+
+	if (final_candidate != 0xff)
+	{
+		pdmpriv->RegE94 = RegE94 = result[final_candidate][0];
+		pdmpriv->RegE9C = RegE9C = result[final_candidate][1];
+		RegEA4 = result[final_candidate][2];
+		RegEAC = result[final_candidate][3];
+		pdmpriv->RegEB4 = RegEB4 = result[final_candidate][4];
+		pdmpriv->RegEBC = RegEBC = result[final_candidate][5];
+		RegEC4 = result[final_candidate][6];
+		RegECC = result[final_candidate][7];
+		DBG_8192D("IQK: final_candidate is %x\n", final_candidate);
+		DBG_8192D("IQK: RegE94=%x RegE9C=%x RegEA4=%x RegEAC=%x RegEB4=%x RegEBC=%x RegEC4=%x RegECC=%x\n", RegE94, RegE9C, RegEA4, RegEAC, RegEB4, RegEBC, RegEC4, RegECC);
+		bPathAOK = bPathBOK = true;
+	}
+	else
+	{
+		pdmpriv->RegE94 = pdmpriv->RegEB4 = 0x100;	/* X default value */
+		pdmpriv->RegE9C = pdmpriv->RegEBC = 0x0;		/* Y default value */
+	}
+
+	if ((RegE94 != 0)/*&&(RegEA4 != 0)*/)
+	{
+		if (pHalData->CurrentBandType92D == BAND_ON_5G)
+			phy_PathAFillIQKMatrix_5G_Normal(adapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+		else
+			phy_PathAFillIQKMatrix(adapter, bPathAOK, result, final_candidate, (RegEA4 == 0));
+	}
+
+	if (IS_92C_SERIAL(pHalData->VersionID) || IS_92D_SINGLEPHY(pHalData->VersionID))
+	{
+		if ((RegEB4 != 0)/*&&(RegEC4 != 0)*/)
+		{
+			if (pHalData->CurrentBandType92D == BAND_ON_5G)
+				phy_PathBFillIQKMatrix_5G_Normal(adapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+			else
+				phy_PathBFillIQKMatrix(adapter, bPathBOK, result, final_candidate, (RegEC4 == 0));
+		}
+	}
+
+	if (IS_HARDWARE_TYPE_8192D(adapter) && final_candidate != 0xFF)
+	{
+		Indexforchannel = rtl8192d_GetRightChnlPlaceforIQK(pHalData->CurrentChannel);
+
+		for (i = 0; i < IQK_Matrix_REG_NUM; i++)
+		{
+			pHalData->IQKMatrixRegSetting[Indexforchannel].Value[0][i] =
+				result[final_candidate][i];
+		}
+
+		pHalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(adapter)) {
+			struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
+			struct hal_data_8192du *pbuddy_HalData = GET_HAL_DATA(pbuddy_adapter);
+
+			for (i = 0; i < IQK_Matrix_REG_NUM; i++)
+			{
+				pbuddy_HalData->IQKMatrixRegSetting[Indexforchannel].Value[0][i] =
+					result[final_candidate][i];
+			}
+
+			pbuddy_HalData->IQKMatrixRegSetting[Indexforchannel].bIQKDone = true;
+		}
+#endif
+	}
+}
+
+void
+rtl8192d_PHY_LCCalibrate(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	bool		bStartContTx = false, bSingleTone = false, bCarrierSuppression = false;
+	u32			timeout = 2000, timecount = 0;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+	struct mlme_priv	*pmlmeprivBuddyadapter;
+#endif
+
+#if MP_DRIVER == 1
+	bStartContTx = adapter->mppriv.MptCtx.bStartContTx;
+	bSingleTone = adapter->mppriv.MptCtx.bSingleTone;
+	bCarrierSuppression = adapter->mppriv.MptCtx.bCarrierSuppression;
+#endif
+
+#if DISABLE_BB_RF
+	return;
+#endif
+
+	/* ignore IQK when continuous Tx */
+	if (bStartContTx || bSingleTone || bCarrierSuppression)
+		return;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (Buddyadapter != NULL &&
+		((pHalData->interfaceIndex == 0 && pHalData->CurrentBandType92D == BAND_ON_2_4G) ||
+		(pHalData->interfaceIndex == 1 && pHalData->CurrentBandType92D == BAND_ON_5G)))
+	{
+		pmlmeprivBuddyadapter = &Buddyadapter->mlmepriv;
+		while ((check_fwstate(pmlmeprivBuddyadapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==true) && timecount < timeout)
+		{
+			rtw_msleep_os(50);
+			timecount += 50;
+		}
+	}
+#endif
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+		return;
+
+	pHalData->bLCKInProgress = true;
+
+	if (IS_92D_SINGLEPHY(pHalData->VersionID))
+	{
+		phy_LCCalibrate(adapter, true);
+	}
+	else {
+		/*  For 88C 1T1R */
+		phy_LCCalibrate(adapter, false);
+	}
+
+	pHalData->bLCKInProgress = false;
+
+}
+
+void
+rtl8192d_PHY_APCalibrate(
+	struct rtw_adapter *	adapter,
+	char		delta
+	)
+{
+}
+
+void
+PHY_UpdateBBRFConfiguration8192D(
+	struct rtw_adapter * adapter,
+	bool bisBandSwitch
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u8	eRFPath = 0;
+	bool			bInternalPA;
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+	/* Update BB */
+	/* r_select_5G for path_A/B.0 for 2.4G,1 for 5G */
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+	{/*  2.4G band */
+		/* r_select_5G for path_A/B,0x878 */
+
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT0, 0x0);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0x0);
+		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
+		{
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT16, 0x0);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31, 0x0);
+		}
+
+		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G,0xc78 */
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x0);
+
+		/* fc_area 0xd2c */
+		PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x0);
+		/*  5G LAN ON */
+		PHY_SetBBReg(adapter, 0xB30, 0x00F00000, 0xa);
+
+		/* TX BB gain shift*1,Just for testchip,0xc80,0xc88 */
+		PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
+
+		if (pregistrypriv->special_rf_path == 1)
+			PHY_SetBBReg(adapter, rCCK0_AFESetting, bMaskByte3, 0x80);
+		else if (pregistrypriv->special_rf_path == 2)
+			PHY_SetBBReg(adapter, rCCK0_AFESetting, bMaskByte3, 0x45);
+
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		{
+			PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+			pdmpriv->OFDM_index[RF_PATH_A] = 0x0c;
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
+				((pHalData->EEPROMC9&BIT3) >> 3)|(pHalData->EEPROMC9&BIT1)|((pHalData->EEPROMCC&BIT1) << 4));
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
+				((pHalData->EEPROMC9&BIT2) >> 2)|((pHalData->EEPROMC9&BIT0) << 1)|((pHalData->EEPROMCC&BIT0) << 5));
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
+			PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+		}
+		else
+		{
+			PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x40000100);
+			PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x40000100);
+			pdmpriv->OFDM_index[RF_PATH_A] = 0x0c;
+			pdmpriv->OFDM_index[RF_PATH_B] = 0x0c;
+
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
+				((pHalData->EEPROMC9&BIT3) >> 3)|(pHalData->EEPROMC9&BIT1)|((pHalData->EEPROMCC&BIT1) << 4)|((pHalData->EEPROMC9&BIT7) << 9)|((pHalData->EEPROMC9&BIT5) << 12)|((pHalData->EEPROMCC&BIT3) << 18));
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10|BIT6|BIT5,
+				((pHalData->EEPROMC9&BIT2) >> 2)|((pHalData->EEPROMC9&BIT0) << 1)|((pHalData->EEPROMCC&BIT0) << 5));
+			PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10|BIT6|BIT5,
+				((pHalData->EEPROMC9&BIT6) >> 6)|((pHalData->EEPROMC9&BIT4) >> 3)|((pHalData->EEPROMCC&BIT2) << 3));
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15, 0);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017038);
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x01017038);
+
+			PHY_SetBBReg(adapter, rConfig_AntA, bMaskDWord, 0x0f600000);
+			PHY_SetBBReg(adapter, rConfig_AntB, bMaskDWord, 0x0f600000);
+		}
+		pdmpriv->CCK_index = 0x0c;
+
+	}
+	else	/* 5G band */
+	{
+
+		/* r_select_5G for path_A/B */
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT0, 0x1);
+		PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15, 0x1);
+		if (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)
+		{
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT16, 0x1);
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31, 0x1);
+		}
+
+		/* rssi_table_select:index 0 for 2.4G.1~3 for 5G */
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, BIT6|BIT7, 0x1);
+
+		/* fc_area */
+		PHY_SetBBReg(adapter, rOFDM1_CFOTracking, BIT14|BIT13, 0x1);
+		/*  5G LAN ON */
+		PHY_SetBBReg(adapter, 0xB30, 0x00F00000, 0x0);
+
+		/* TX BB gain shift,Just for testchip,0xc80,0xc88 */
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		{
+			if (pHalData->interfaceIndex == 0)
+				bInternalPA = pHalData->InternalPA5G[0];
+			else
+				bInternalPA = pHalData->InternalPA5G[1];
+
+			if (bInternalPA)
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
+				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
+			}
+			else
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
+				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
+			}
+		}
+		else
+		{
+			if (pHalData->InternalPA5G[0])
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x2d4000b5);
+				pdmpriv->OFDM_index[RF_PATH_A] = 0x12;
+			}
+			else
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XATxIQImbalance, bMaskDWord, 0x20000080);
+				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
+			}
+
+			if (pHalData->InternalPA5G[1])
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x2d4000b5);
+				pdmpriv->OFDM_index[RF_PATH_B] = 0x12;
+			}
+			else
+			{
+				PHY_SetBBReg(adapter, rOFDM0_XBTxIQImbalance, bMaskDWord, 0x20000080);
+				pdmpriv->OFDM_index[RF_PATH_A] = 0x18;
+			}
+		}
+
+		PHY_SetBBReg(adapter, 0xB30, BIT27, 0x0);
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		{
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT10|BIT6|BIT5,
+				(pHalData->EEPROMCC&BIT5));
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
+				((pHalData->EEPROMCC&BIT4) >> 4));
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT15,
+				(pHalData->EEPROMCC&BIT4) >> 4);
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017098);
+			if (pdmpriv->bDPKdone[RF_PATH_A])
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x08080000);
+			else
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x20000000);
+		}
+		else
+		{
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFInterfaceSW, BIT26|BIT22|BIT21|BIT10|BIT6|BIT5,
+				(pHalData->EEPROMCC&BIT5)|((pHalData->EEPROMCC&BIT7) << 14));
+			PHY_SetBBReg(adapter, rFPGA0_XA_RFInterfaceOE, BIT10,
+				((pHalData->EEPROMCC&BIT4) >> 4));
+			PHY_SetBBReg(adapter, rFPGA0_XB_RFInterfaceOE, BIT10,
+				((pHalData->EEPROMCC&BIT6) >> 6));
+			PHY_SetBBReg(adapter, rFPGA0_XAB_RFParameter, BIT31|BIT15,
+				((pHalData->EEPROMCC&BIT4) >> 4)|((pHalData->EEPROMCC&BIT6) << 10));
+			PHY_SetBBReg(adapter, rPdp_AntA, bMaskDWord, 0x01017098);
+			PHY_SetBBReg(adapter, rPdp_AntB, bMaskDWord, 0x01017098);
+			if (pdmpriv->bDPKdone[RF_PATH_A])
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x08080000);
+			else
+				PHY_SetBBReg(adapter, 0xb68, bMaskDWord, 0x20000000);
+			if (pdmpriv->bDPKdone[RF_PATH_B])
+				PHY_SetBBReg(adapter, 0xb6c, bMaskDWord, 0x08080000);
+			else
+				PHY_SetBBReg(adapter, 0xb6c, bMaskDWord, 0x20000000);
+		}
+
+	}
+
+	/* update IQK related settings */
+	{
+		PHY_SetBBReg(adapter, rOFDM0_XARxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XBRxIQImbalance, bMaskDWord, 0x40000100);
+		PHY_SetBBReg(adapter, rOFDM0_XCTxAFE, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_ECCAThreshold,  BIT30|BIT28|BIT26|BIT24,  0x00);
+		PHY_SetBBReg(adapter, rOFDM0_XDTxAFE, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_RxIQExtAnta, 0xF0000000, 0x00);
+		PHY_SetBBReg(adapter, rOFDM0_AGCRSSITable, 0x0000F000, 0x00);
+	}
+
+	/* Update RF */
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G) {
+			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT8|BIT16|BIT18|0xFF, 1);
+
+			/* RF0x0b[16:14] =3b'111 */
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_TXPA_AG, 0x1c000, 0x07);
+		}
+		else { /* 5G band */
+			/* MOD_AG for RF paht_A 0x18 BIT8,BIT16 */
+			PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x97524); /* set channel 36 */
+
+		}
+
+		if ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G) ||
+		    (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)) {
+			/* Set right channel on RF reg0x18 for another mac. */
+			if (pHalData->interfaceIndex == 0) /* set MAC1 default channel if MAC1 not up. */
+			{
+				if (!(rtw_read8(adapter, REG_MAC1)&MAC1_ON)) {
+					rtl8192d_PHY_EnableAnotherPHY(adapter, true);
+					PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW|MAC0_ACCESS_PHY1, bRFRegOffsetMask, 0x97524); /* set channel 36 */
+					rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
+				}
+			} else if (pHalData->interfaceIndex == 1) { /* set MAC0 default channel */
+				if (!(rtw_read8(adapter, REG_MAC0)&MAC0_ON)) {
+					rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+					PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW|MAC1_ACCESS_PHY0, bRFRegOffsetMask, 0x87401); /*  set channel 1 */
+					rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+				}
+			}
+		}
+	}
+
+	/* Update for all band. */
+	if (pHalData->rf_type == RF_1T1R)
+	{ /* DMDP */
+		/* Use antenna 0,0xc04,0xd04 */
+#if MP_DRIVER == 1
+		if (!bisBandSwitch)
+#endif
+		{
+		PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
+		PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
+		}
+
+		/* enable ad/da clock1 for dual-phy reg0x888 */
+		if (pHalData->interfaceIndex == 0)
+			PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0x3);
+		else
+		{
+			bool bMAC0NotUp =false;
+
+			/* 3 Path Div */
+			/*  Neil Chen---2011--05--31---Begin */
+
+			bMAC0NotUp = rtl8192d_PHY_EnableAnotherPHY(adapter, false);
+			if (bMAC0NotUp)
+			{
+				PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn|MAC1_ACCESS_PHY0, BIT12|BIT13, 0x3);
+				rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+			}
+		}
+
+		/* supported mcs */
+		PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT19|BIT20, 0x0);
+	}
+	else /*  2T2R Single PHY */
+	{
+		if (pregistrypriv->special_rf_path == 2)
+		{
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x22);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x2);
+			PHY_SetBBReg(adapter, rFPGA1_TxInfo, bMaskDWord, 0x82221322);	/* OFDM Tx */
+		}
+		else if (pregistrypriv->special_rf_path == 1)
+		{
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x11);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x1);
+			PHY_SetBBReg(adapter, rFPGA1_TxInfo, bMaskDWord, 0x81121311);	/* OFDM Tx */
+		}
+		else
+		{
+			/* Use antenna 0 & 1,0xc04,0xd04 */
+			PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, 0x33);
+			PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, 0x3);
+		}
+
+		/* disable ad/da clock1,0x888 */
+		PHY_SetBBReg(adapter, rFPGA0_AdDaClockEn, BIT12|BIT13, 0);
+
+		/* supported mcs */
+		PHY_SetBBReg(adapter, rOFDM1_LSTF, BIT19|BIT20, 0x1);
+	}
+
+#if MP_DRIVER == 1
+	if (bisBandSwitch)
+	{
+		PHY_SetBBReg(adapter, rOFDM0_TRxPathEnable, bMaskByte0, pdmpriv->RegC04_MP);
+		PHY_SetBBReg(adapter, rOFDM1_TRxPathEnable, bDWord, pdmpriv->RegD04_MP);
+	}
+#endif
+
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+		pHalData->RfRegChnlVal[eRFPath] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, bRFRegOffsetMask);
+		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
+	}
+
+}
+
+/*  */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
+/*  */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*  */
+void PHY_ReadMacPhyMode92D(
+		struct rtw_adapter *			adapter,
+		bool		AutoloadFail
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	MacPhyCrValue = 0;
+
+	if (AutoloadFail)
+	{
+		pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
+		return;
+	}
+
+	MacPhyCrValue = rtw_read8(adapter, REG_MAC_PHY_CTRL_NORMAL);
+
+	DBG_8192D("PHY_ReadMacPhyMode92D():   MAC_PHY_CTRL Value %x\n",MacPhyCrValue);
+
+	if ((MacPhyCrValue&0x03) == 0x03)
+	{
+		pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
+	}
+	else if ((MacPhyCrValue&0x03) == 0x01)
+	{
+		pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
+	}
+	else
+	{
+		pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
+	}
+}
+
+/*  */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
+/*  */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*  */
+void PHY_ConfigMacPhyMode92D(
+		struct rtw_adapter *			adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	offset = REG_MAC_PHY_CTRL_NORMAL, temp;
+
+	temp = rtw_read8(adapter, offset);
+	temp &= ~(BIT(0)|BIT(1)|BIT(2));
+	switch (pHalData->MacPhyMode92D) {
+	case DUALMAC_DUALPHY:
+		pr_info("r8192du: MacPhyMode: DUALMAC_DUALPHY\n");
+		rtw_write8(adapter, offset, temp | BIT(0)|BIT(1));
+		break;
+	case SINGLEMAC_SINGLEPHY:
+		pr_info("r8192du: MacPhyMode: SINGLEMAC_SINGLEPHY\n");
+		rtw_write8(adapter, offset, temp | BIT(2));
+		break;
+	case DUALMAC_SINGLEPHY:
+		pr_info("r8192du: MacPhyMode: DUALMAC_SINGLEPHY\n");
+		rtw_write8(adapter, offset, temp | BIT(0));
+		break;
+	}
+}
+
+/*  */
+/*	Description: */
+/*		Read HW adapter information through EEPROM 93C46. */
+/*		Or For EFUSE 92S .And Get and Set 92D MACPHY mode and Band Type. */
+/*		MacPhyMode:DMDP,SMSP. */
+/*		BandType:2.4G,5G. */
+/*  */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*  */
+void PHY_ConfigMacPhyModeInfo92D(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct hal_data_8192du *pHalDataBuddyadapter;
+#endif
+
+	switch (pHalData->MacPhyMode92D) {
+		case DUALMAC_SINGLEPHY:
+			pHalData->rf_type = RF_2T2R;
+			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID | RF_TYPE_2T2R);
+			pHalData->BandSet92D = BAND_ON_BOTH;
+			pHalData->CurrentBandType92D = BAND_ON_2_4G;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+/* get bMasetOfDMSP and bSlaveOfDMSP sync with buddy adapter */
+			ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
+			if (Buddyadapter != NULL)
+			{
+				pHalDataBuddyadapter = GET_HAL_DATA(Buddyadapter);
+				pHalData->bMasterOfDMSP = !pHalDataBuddyadapter->bMasterOfDMSP;
+				pHalData->bSlaveOfDMSP = !pHalDataBuddyadapter->bSlaveOfDMSP;
+				pHalData->CurrentBandType92D = pHalDataBuddyadapter->CurrentBandType92D;
+			}
+			else
+			{
+				if (pHalData->interfaceIndex == 0)
+				{
+					pHalData->bMasterOfDMSP = true;
+					pHalData->bSlaveOfDMSP = false;
+				}
+				else if (pHalData->interfaceIndex == 1)
+				{
+					pHalData->bMasterOfDMSP = false;
+					pHalData->bSlaveOfDMSP = true;
+				}
+			}
+			RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
+#endif
+			break;
+
+		case SINGLEMAC_SINGLEPHY:
+			pHalData->rf_type = RF_2T2R;
+			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID | RF_TYPE_2T2R);
+			pHalData->BandSet92D = BAND_ON_BOTH;
+			pHalData->CurrentBandType92D = BAND_ON_2_4G;
+			pHalData->bMasterOfDMSP = false;
+			pHalData->bSlaveOfDMSP = false;
+			break;
+
+		case DUALMAC_DUALPHY:
+			pHalData->rf_type = RF_1T1R;
+			pHalData->VersionID = (enum VERSION_8192D)(pHalData->VersionID & RF_TYPE_1T1R);
+			if (pHalData->interfaceIndex == 1) {
+				pHalData->BandSet92D = BAND_ON_5G;
+				pHalData->CurrentBandType92D = BAND_ON_5G;/* Now we let MAC1 run on 5G band. */
+			}
+			else {
+				pHalData->BandSet92D = BAND_ON_2_4G;
+				pHalData->CurrentBandType92D = BAND_ON_2_4G;/*  */
+			}
+			pHalData->bMasterOfDMSP = false;
+			pHalData->bSlaveOfDMSP = false;
+			break;
+
+		default:
+			break;
+	}
+
+	/*if (adapter->bInHctTest&&(pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY))
+	{
+		pHalData->CurrentBandType92D=BAND_ON_2_4G;
+		pHalData->BandSet92D = BAND_ON_2_4G;
+	}*/
+
+	if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+		pHalData->CurrentChannel = 1;
+	else
+		pHalData->CurrentChannel = 36;
+
+	adapter->registrypriv.channel = pHalData->CurrentChannel;
+
+#if DBG
+	switch (pHalData->VersionID)
+	{
+		case VERSION_NORMAL_CHIP_92D_D_CUT_SINGLEPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_D_CUT_SINGLEPHY.\n");
+			break;
+		case VERSION_NORMAL_CHIP_92D_D_CUT_DUALPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_D_CUT_DUALPHY.\n");
+			break;
+		case VERSION_NORMAL_CHIP_92D_E_CUT_SINGLEPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_E_CUT_SINGLEPHY.\n");
+			break;
+		case VERSION_NORMAL_CHIP_92D_E_CUT_DUALPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_E_CUT_DUALPHY.\n");
+			break;
+		case VERSION_NORMAL_CHIP_92D_C_CUT_SINGLEPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_C_CUT_SINGLEPHY.\n");
+			break;
+		case VERSION_NORMAL_CHIP_92D_C_CUT_DUALPHY:
+			MSG_8192D("Chip Version ID: VERSION_NORMAL_CHIP_92D_C_CUT_DUALPHY.\n");
+			break;
+		case VERSION_TEST_CHIP_92D_SINGLEPHY:
+			MSG_8192D("Chip Version ID: VERSION_TEST_CHIP_92D_SINGLEPHY.\n");
+			break;
+		case VERSION_TEST_CHIP_92D_DUALPHY:
+			MSG_8192D("Chip Version ID: VERSION_TEST_CHIP_92D_DUALPHY.\n");
+			break;
+		default:
+			MSG_8192D("Chip Version ID: ???????????????.0x%04X\n",pHalData->VersionID);
+			break;
+	}
+#endif
+
+	switch (pHalData->BandSet92D)
+	{
+		case BAND_ON_2_4G:
+			adapter->registrypriv.wireless_mode = WIRELESS_11BG_24N;
+			break;
+
+		case BAND_ON_5G:
+			adapter->registrypriv.wireless_mode = WIRELESS_11A_5N;
+			break;
+
+		case BAND_ON_BOTH:
+			adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
+			break;
+
+		default:
+			adapter->registrypriv.wireless_mode = WIRELESS_11ABGN;
+			break;
+	}
+	DBG_8192D("%s(): wireless_mode = %x\n",__func__,adapter->registrypriv.wireless_mode);
+}
+
+/*  */
+/*	Description: */
+/*	set RX packet buffer and other setting acording to dual mac mode */
+/*  */
+/*	Assumption: */
+/*		1. Boot from EEPROM and CR9346 regiser has verified. */
+/*		2. PASSIVE_LEVEL (USB interface) */
+/*  */
+void PHY_ConfigMacCoexist_RFPage92D(
+		struct rtw_adapter *			adapter
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	switch (pHalData->MacPhyMode92D)
+	{
+		case DUALMAC_DUALPHY:
+			rtw_write8(adapter,REG_DMC, 0x0);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x08);
+			rtw_write16(adapter,(REG_TRXFF_BNDY+2), 0x13ff);
+			break;
+		case DUALMAC_SINGLEPHY:
+			rtw_write8(adapter,REG_DMC, 0xf8);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x08);
+			rtw_write16(adapter,(REG_TRXFF_BNDY+2), 0x13ff);
+			break;
+		case SINGLEMAC_SINGLEPHY:
+			rtw_write8(adapter,REG_DMC, 0x0);
+			rtw_write8(adapter,REG_RX_PKT_LIMIT,0x10);
+			rtw_write16(adapter, (REG_TRXFF_BNDY + 2), 0x27FF);
+			break;
+		default:
+			break;
+	}
+}
+
+void
+rtl8192d_PHY_InitRxSetting(
+	struct rtw_adapter * adapter
+	)
+{
+#if MP_DRIVER == 1
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (pHalData->interfaceIndex == 0)
+	{
+		rtw_write32(adapter, REG_MACID, 0x87654321);
+		rtw_write32(adapter, 0x0700, 0x87654321);
+	}
+	else
+	{
+		rtw_write32(adapter, REG_MACID, 0x12345678);
+		rtw_write32(adapter, 0x0700, 0x12345678);
+	}
+#endif
+}
+
+void rtl8192d_PHY_ResetIQKResult(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8			i;
+
+	for (i = 0; i < IQK_Matrix_Settings_NUM; i++) {
+		pHalData->IQKMatrixRegSetting[i].Value[0][0] = 0x100;
+		pHalData->IQKMatrixRegSetting[i].Value[0][2] = 0x100;
+		pHalData->IQKMatrixRegSetting[i].Value[0][4] = 0x100;
+		pHalData->IQKMatrixRegSetting[i].Value[0][6] = 0x100;
+
+		pHalData->IQKMatrixRegSetting[i].Value[0][1] = 0;
+		pHalData->IQKMatrixRegSetting[i].Value[0][3] = 0;
+		pHalData->IQKMatrixRegSetting[i].Value[0][5] = 0;
+		pHalData->IQKMatrixRegSetting[i].Value[0][7] = 0;
+
+		pHalData->IQKMatrixRegSetting[i].bIQKDone = false;
+	}
+}
+
+void rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *adapter, bool main)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+#if DISABLE_BB_RF
+	return ;
+#else
+
+	if (IS_92D_SINGLEPHY(pHalData->VersionID)) {
+		phy_SetRFPathSwitch(adapter, main, true);
+	} else {
+		/*  For 88C 1T1R */
+		phy_SetRFPathSwitch(adapter, main, false);
+	}
+#endif
+}
+
+void
+HalChangeCCKStatus8192D(
+	struct rtw_adapter *	adapter,
+	bool		bCCKDisable
+)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	i;
+
+	if (pHalData->BandSet92D != BAND_ON_BOTH)
+	{
+		return;
+	}
+
+	if (bCCKDisable)
+	{
+		rtw_write16(adapter, REG_RL,0x0101);
+		for (i=0;i<30;i++)
+		{
+			if (rtw_read32(adapter, 0x200) != rtw_read32(adapter, 0x204))
+			{
+				DBG_8192D("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", rtw_read32(adapter, 0x204));
+				DBG_8192D("packet in tx packet buffer aaaaaaa 0x200 %x\n", rtw_read32(adapter, 0x200));
+				rtw_udelay_os(1000);
+			}
+			else
+			{
+				break;
+			}
+		}
+
+		/*if ((Buddyadapter != NULL) && Buddyadapter->bHWInitReady && (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY))
+		{
+			if (ACTING_AS_AP(Buddyadapter) ||ACTING_AS_AP(ADJUST_TO_ADAPTIVE_ADAPTER(Buddyadapter, FALSE)) || Buddyadapter->MgntInfo.mIbss)
+				StopTxBeacon(Buddyadapter);
+			PlatformEFIOWrite2Byte(Buddyadapter, REG_RL,0x0101);
+			for (i=0;i<30;i++)
+			{
+				if (PlatformEFIORead4Byte(Buddyadapter, 0x200) != PlatformEFIORead4Byte(Buddyadapter, 0x204))
+				{
+					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaaaa 0x204 %x\n", PlatformEFIORead4Byte(Buddyadapter, 0x204)));
+					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("packet in tx packet buffer aaaaaaa 0x200 %x\n", PlatformEFIORead4Byte(Buddyadapter, 0x200)));
+					PlatformStallExecution(1000);
+				}
+				else
+				{
+					RT_TRACE(COMP_EASY_CONCURRENT,DBG_LOUD,("no packet in tx packet buffer\n"));
+					break;
+				}
+			}
+
+		}*/
+
+		PHY_SetBBReg1Byte(adapter, rFPGA0_RFMOD, bOFDMEn|bCCKEn, 3);
+	}
+	else
+	{
+		u8	RetryLimit = 0x30;
+
+		rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+	}
+}
+
+void
+PHY_InitPABias92D(struct rtw_adapter * adapter)
+{
+	u8	tmpU1b;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	bool		is92 = IS_92D_SINGLEPHY(pHalData->VersionID);
+	enum RF_RADIO_PATH_E eRFPath = RF_PATH_A;
+
+	tmpU1b = EFUSE_Read1Byte(adapter, 0x3FA);
+
+	DBG_8192D("PHY_InitPABias92D 0x3FA 0x%x\n",tmpU1b);
+
+	if (!(tmpU1b & BIT0) && (is92 || pHalData->interfaceIndex == 0))
+	{
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F425);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F425);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F425);
+
+		/* Back to RX Mode */
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
+		DBG_8192D("2G PA BIAS path A\n");
+	}
+
+	if (!(tmpU1b & BIT1) && (is92 || pHalData->interfaceIndex == 1))
+	{
+		eRFPath = pHalData->interfaceIndex == 1?RF_PATH_A:RF_PATH_B;
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x07401);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F425);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F425);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F425);
+
+		/* Back to RX Mode */
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		DBG_8192D("2G PA BIAS path B\n");
+	}
+
+	if (!(tmpU1b & BIT2) && (is92 || pHalData->interfaceIndex == 0))
+	{
+		/* 5GL_channel */
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* 5GM_channel */
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* 5GH_channel */
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* Back to RX Mode */
+		PHY_SetRFReg(adapter, RF_PATH_A, RF_AC, bRFRegOffsetMask, 0x30000);
+
+		DBG_8192D("5G PA BIAS path A\n");
+	}
+
+	if (!(tmpU1b & BIT3) && (is92 || pHalData->interfaceIndex == 1))
+	{
+		eRFPath = (pHalData->interfaceIndex == 1)?RF_PATH_A:RF_PATH_B;
+		/* 5GL_channel */
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x17524);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* 5GM_channel */
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x37564);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* 5GH_channel */
+		PHY_SetRFReg(adapter, eRFPath, RF_CHNLBW, bRFRegOffsetMask, 0x57595);
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x70000);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x0F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x4F496);
+		PHY_SetRFReg(adapter, eRFPath, RF_IPA, bRFRegOffsetMask, 0x8F496);
+
+		/* Back to RX Mode */
+		PHY_SetRFReg(adapter, eRFPath, RF_AC, bRFRegOffsetMask, 0x30000);
+		DBG_8192D("5G PA BIAS path B\n");
+	}
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_rf6052.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_rf6052.c
new file mode 100644
index 0000000..f1821c5
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_rf6052.c
@@ -0,0 +1,798 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/******************************************************************************
+ *
+ *
+ * Module:	HalRf6052.c	(Source C File)
+ *
+ * Note:	Provide RF 6052 series relative API.
+ *
+ * Function:
+ *
+ * Export:
+ *
+ * Abbrev:
+ *
+ * History:
+ * Data			Who		Remark
+ *
+ * 09/25/2008	MHC		Create initial version.
+ * 11/05/2008	MHC		Add API for tw power setting.
+ *
+ *
+******************************************************************************/
+
+#define _RTL8192D_RF6052_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <hal_intf.h>
+#include <rtl8192d_hal.h>
+
+/*---------------------------Define Local Constant---------------------------*/
+/*  Define local structure for debug!!!!! */
+struct rf_shadow_compare_map {
+	/*  Shadow register value */
+	u32		Value;
+	/*  Compare or not flag */
+	u8		Compare;
+	/*  Record If it had ever modified unpredicted */
+	u8		ErrorOrNot;
+	/*  Recorver Flag */
+	u8		Recorver;
+	/*  */
+	u8		Driver_Write;
+};
+/*---------------------------Define Local Constant---------------------------*/
+
+/*------------------------Define global variable-----------------------------*/
+/*------------------------Define global variable-----------------------------*/
+
+/*------------------------Define local variable------------------------------*/
+/*  2008/11/20 MH For Debug only, RF */
+static	struct rf_shadow_compare_map RF_Shadow[RF6052_MAX_PATH][RF6052_MAX_REG];
+/*------------------------Define local variable------------------------------*/
+
+/*-----------------------------------------------------------------------------
+ * Function:    PHY_RF6052SetBandwidth()
+ *
+ * Overview:    This function is called by SetBWModeCallback8190Pci() only
+ *
+ * Input:       struct rtw_adapter *				adapter
+ *			WIRELESS_BANDWIDTH_E	Bandwidth	20M or 40M
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Note:		For RF type 0222D
+ *---------------------------------------------------------------------------*/
+void
+rtl8192d_PHY_RF6052SetBandwidth(
+	struct rtw_adapter *				adapter,
+	enum HT_CHANNEL_WIDTH		Bandwidth)	/* 20M or 40M */
+{
+	u8			eRFPath;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	switch (Bandwidth)
+	{
+		case HT_CHANNEL_WIDTH_20:
+			for (eRFPath=0;eRFPath<pHalData->NumTotalRFPath;eRFPath++)
+			{
+				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffff3ff) | 0x0400);
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x01);
+
+			}
+			break;
+
+		case HT_CHANNEL_WIDTH_40:
+			for (eRFPath=0;eRFPath<pHalData->NumTotalRFPath;eRFPath++)
+			{
+				pHalData->RfRegChnlVal[eRFPath] = ((pHalData->RfRegChnlVal[eRFPath] & 0xfffff3ff));
+				PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, RF_CHNLBW, BIT10|BIT11, 0x00);
+			}
+			break;
+
+		default:
+			break;
+	}
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_RF6052SetCckTxPower
+ *
+ * Overview:
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/05/2008	MHC		Simulate 8192series..
+ *
+ *---------------------------------------------------------------------------*/
+
+void
+rtl8192d_PHY_RF6052SetCckTxPower(
+	struct rtw_adapter *		adapter,
+	u8*			pPowerlevel)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	u32			TxAGC[2]={0, 0}, tmpval=0;
+	bool		TurboScanOff = false;
+	u8			idx1, idx2;
+	u8*			ptr;
+
+	if (pHalData->EEPROMRegulatory != 0)
+		TurboScanOff = true;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+	{
+		TxAGC[RF_PATH_A] = 0x3f3f3f3f;
+		TxAGC[RF_PATH_B] = 0x3f3f3f3f;
+
+		TurboScanOff =  true;/* disable Turbo scan */
+
+		if (TurboScanOff)
+		{
+			for (idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
+			{
+				TxAGC[idx1] =
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+			}
+		}
+	}
+	else
+	{
+/* vivi merge from 92c, pass win7 DTM item: performance_ext */
+/*  20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism. */
+/*  Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism. */
+/*  In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder. */
+		{
+			for (idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
+			{
+				TxAGC[idx1] =
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+			}
+
+			if (pHalData->EEPROMRegulatory==0)
+			{
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][6]) +
+						(pHalData->MCSTxPowerLevelOriginalOffset[0][7]<<8);
+				TxAGC[RF_PATH_A] += tmpval;
+
+				tmpval = (pHalData->MCSTxPowerLevelOriginalOffset[0][14]) +
+						(pHalData->MCSTxPowerLevelOriginalOffset[0][15]<<24);
+				TxAGC[RF_PATH_B] += tmpval;
+			}
+		}
+	}
+
+	for (idx1=RF_PATH_A; idx1<=RF_PATH_B; idx1++)
+	{
+		ptr = (u8 *)(&(TxAGC[idx1]));
+		for (idx2=0; idx2<4; idx2++)
+		{
+			if (*ptr > RF6052_MAX_TX_PWR)
+				*ptr = RF6052_MAX_TX_PWR;
+			ptr++;
+		}
+	}
+
+	/*  rf-A cck tx power */
+	tmpval = TxAGC[RF_PATH_A]&0xff;
+	PHY_SetBBReg(adapter, rTxAGC_A_CCK1_Mcs32, bMaskByte1, tmpval);
+	tmpval = TxAGC[RF_PATH_A]>>8;
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK11_A_CCK2_11, 0xffffff00, tmpval);
+
+	/*  rf-B cck tx power */
+	tmpval = TxAGC[RF_PATH_B]>>24;
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK11_A_CCK2_11, bMaskByte0, tmpval);
+	tmpval = TxAGC[RF_PATH_B]&0x00ffffff;
+	PHY_SetBBReg(adapter, rTxAGC_B_CCK1_55_Mcs32, 0xffffff00, tmpval);
+}	/* PHY_RF6052SetCckTxPower */
+
+/*  */
+/*  powerbase0 for OFDM rates */
+/*  powerbase1 for HT MCS rates */
+/*  */
+static void getPowerBase(
+	struct rtw_adapter *	adapter,
+	u8		*pPowerLevel,
+	u8		Channel,
+	u32	*OfdmBase,
+	u32	*MCSBase
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u32	powerBase0, powerBase1;
+	u8	Legacy_pwrdiff=0;
+	s8	HT20_pwrdiff=0;
+	u8	i, powerlevel[2];
+
+	for (i=0; i<2; i++)
+	{
+		powerlevel[i] = pPowerLevel[i];
+		Legacy_pwrdiff = pHalData->TxPwrLegacyHtDiff[i][Channel-1];
+		powerBase0 = powerlevel[i] + Legacy_pwrdiff;
+
+		powerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;
+		*(OfdmBase+i) = powerBase0;
+	}
+
+	for (i=0; i<2; i++)
+	{
+		/* Check HT20 to HT40 diff */
+		if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+		{
+			HT20_pwrdiff = pHalData->TxPwrHt20Diff[i][Channel-1];
+			powerlevel[i] += HT20_pwrdiff;
+		}
+		powerBase1 = powerlevel[i];
+		powerBase1 = (powerBase1<<24) | (powerBase1<<16) |(powerBase1<<8) |powerBase1;
+		*(MCSBase+i) = powerBase1;
+	}
+}
+
+/*
+Decide the group value according to the PHY_REG_PG.txt with 2G band and 5G band.
+*/
+static u8 getChnlGroupByPG(u8 chnlindex)
+{
+	u8	group=0;
+	u8	channel_info[59] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,161,163,165};
+
+	if (channel_info[chnlindex] <= 3)			/*  Cjanel 1-3 */
+		group = 0;
+	else if (channel_info[chnlindex] <= 9)		/*  Channel 4-9 */
+		group = 1;
+	else if (channel_info[chnlindex] <=14)				/*  Channel 10-14 */
+		group = 2;
+	else if (channel_info[chnlindex] <= 64)
+		group = 6;
+	else if (channel_info[chnlindex] <= 140)
+		group = 7;
+	else
+		group = 8;
+
+	return group;
+}
+
+static void getTxPowerWriteValByRegulatory(
+		struct rtw_adapter *	adapter,
+		u8*			pPowerLevel,
+		u8			Channel,
+		u8			index,
+		u32*		powerBase0,
+		u32*		powerBase1,
+		u32*		pOutWriteVal
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	u8	i, chnlGroup=0, pwr_diff_limit[4], customer_pwr_limit;
+	s8	pwr_diff=0;
+	u32	writeVal, customer_limit, rf;
+
+	/*  */
+	/*  Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate */
+	/*  */
+	for (rf=0; rf<2; rf++)
+	{
+		switch (pHalData->EEPROMRegulatory)
+		{
+			case 0:	/*  Realtek better performance */
+					/*  increase power diff defined by Realtek for large power */
+				chnlGroup = 0;
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+					((index<2)?powerBase0[rf]:powerBase1[rf]);
+				break;
+			case 1:	/*  Realtek regulatory */
+					/*  increase power diff defined by Realtek for regulatory */
+					if (pHalData->pwrGroupCnt == 1)
+						chnlGroup = 0;
+					if (pHalData->pwrGroupCnt >= MAX_PG_GROUP)
+					{
+						chnlGroup = getChnlGroupByPG(Channel-1);
+
+						if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+							chnlGroup++;
+						else	   /*  40M BW */
+							chnlGroup += 4;
+					}
+					writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+							((index<2)?powerBase0[rf]:powerBase1[rf]);
+
+				break;
+			case 2:	/*  Better regulatory */
+					/*  don't increase any power diff */
+				writeVal = ((index<2)?powerBase0[rf]:powerBase1[rf]);
+				break;
+			case 3:	/*  Customer defined power diff. */
+					/*  increase power diff defined by customer. */
+				chnlGroup = 0;
+
+				if (index < 2)
+					pwr_diff = pHalData->TxPwrLegacyHtDiff[rf][Channel-1];
+				else if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_20)
+					pwr_diff = pHalData->TxPwrHt20Diff[rf][Channel-1];
+
+				if (pHalData->CurrentChannelBW == HT_CHANNEL_WIDTH_40)
+					customer_pwr_limit = pHalData->PwrGroupHT40[rf][Channel-1];
+				else
+					customer_pwr_limit = pHalData->PwrGroupHT20[rf][Channel-1];
+
+				if (pwr_diff >= customer_pwr_limit)
+					pwr_diff = 0;
+				else
+					pwr_diff = customer_pwr_limit - pwr_diff;
+
+				for (i=0; i<4; i++)
+				{
+					pwr_diff_limit[i] = (u8)((pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]&(0x7f<<(i*8)))>>(i*8));
+
+					if (pwr_diff_limit[i] > pwr_diff)
+						pwr_diff_limit[i] = pwr_diff;
+				}
+
+				customer_limit = (pwr_diff_limit[3]<<24) | (pwr_diff_limit[2]<<16) |
+								(pwr_diff_limit[1]<<8) | (pwr_diff_limit[0]);
+
+				writeVal = customer_limit + ((index<2)?powerBase0[rf]:powerBase1[rf]);
+				break;
+			default:
+				chnlGroup = 0;
+				writeVal = pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)] +
+						((index<2)?powerBase0[rf]:powerBase1[rf]);
+				break;
+		}
+
+		/*  20100628 Joseph: High power mode for BT-Coexist mechanism. */
+		/*  This mechanism is only applied when Driver-Highpower-Mechanism is OFF. */
+		if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT1)
+		{
+			writeVal = writeVal - 0x06060606;
+		}
+		else if (pdmpriv->DynamicTxHighPowerLvl == TxHighPwrLevel_BT2)
+		{
+			writeVal = writeVal ;
+		}
+
+			/*  add for  OID_RT_11N_TX_POWER_BY_RATE ,disable tx powre change by rate */
+		/*  */
+		*(pOutWriteVal+rf) = writeVal;
+	}
+}
+
+static void writeOFDMPowerReg(
+		struct rtw_adapter *	adapter,
+		u8			index,
+		u32			*pValue
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u16	RegOffset_A[6] = {rTxAGC_A_Rate18_06, rTxAGC_A_Rate54_24,
+				  rTxAGC_A_Mcs03_Mcs00, rTxAGC_A_Mcs07_Mcs04,
+				  rTxAGC_A_Mcs11_Mcs08, rTxAGC_A_Mcs15_Mcs12};
+	u16	RegOffset_B[6] = {rTxAGC_B_Rate18_06, rTxAGC_B_Rate54_24,
+				  rTxAGC_B_Mcs03_Mcs00, rTxAGC_B_Mcs07_Mcs04,
+				  rTxAGC_B_Mcs11_Mcs08, rTxAGC_B_Mcs15_Mcs12};
+	u8	i, rf, pwr_val[4];
+	u32	writeVal;
+	u16	RegOffset;
+
+	for (rf=0; rf<2; rf++)
+	{
+		writeVal = pValue[rf];
+		for (i=0; i<4; i++)
+		{
+			pwr_val[i] = (u8)((writeVal & (0x7f<<(i*8)))>>(i*8));
+			if (pwr_val[i]  > RF6052_MAX_TX_PWR)
+				pwr_val[i]  = RF6052_MAX_TX_PWR;
+		}
+		writeVal = (pwr_val[3]<<24) | (pwr_val[2]<<16) |(pwr_val[1]<<8) |pwr_val[0];
+
+		if (rf == 0)
+			RegOffset = RegOffset_A[index];
+		else
+			RegOffset = RegOffset_B[index];
+		PHY_SetBBReg(adapter, RegOffset, bMaskDWord, writeVal);
+
+		/*  201005115 Joseph: Set Tx Power diff for Tx power training mechanism. */
+		if (((pHalData->rf_type == RF_2T2R) &&
+				(RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs15_Mcs12))||
+		     ((pHalData->rf_type != RF_2T2R) &&
+				(RegOffset == rTxAGC_A_Mcs07_Mcs04 || RegOffset == rTxAGC_B_Mcs07_Mcs04))	)
+		{
+			writeVal = pwr_val[3];
+			if (RegOffset == rTxAGC_A_Mcs15_Mcs12 || RegOffset == rTxAGC_A_Mcs07_Mcs04)
+				RegOffset = 0xc90;
+			if (RegOffset == rTxAGC_B_Mcs15_Mcs12 || RegOffset == rTxAGC_B_Mcs07_Mcs04)
+				RegOffset = 0xc98;
+			for (i=0; i<3; i++)
+			{
+				if (i!=2)
+					writeVal = (writeVal>8)?(writeVal-8):0;
+				else
+					writeVal = (writeVal>6)?(writeVal-6):0;
+				rtw_write8(adapter, (u32)(RegOffset+i), (u8)writeVal);
+			}
+		}
+	}
+}
+/*-----------------------------------------------------------------------------
+ * Function:	PHY_RF6052SetOFDMTxPower
+ *
+ * Overview:	For legacy and HY OFDM, we must read EEPROM TX power index for
+ *			different channel and read original value in TX power register area from
+ *			0xe00. We increase offset and original value to be correct tx pwr.
+ *
+ * Input:       NONE
+ *
+ * Output:      NONE
+ *
+ * Return:      NONE
+ *
+ * Revised History:
+ * When			Who		Remark
+ * 11/05/2008	MHC		Simulate 8192 series method.
+ * 01/06/2009	MHC		1. Prevent Path B tx power overflow or underflow dure to
+ *						A/B pwr difference or legacy/HT pwr diff.
+ *						2. We concern with path B legacy/HT OFDM difference.
+ * 01/22/2009	MHC		Support new EPRO format from SD3.
+ *
+ *---------------------------------------------------------------------------*/
+void
+rtl8192d_PHY_RF6052SetOFDMTxPower(
+	struct rtw_adapter *	adapter,
+	u8*		pPowerLevel,
+	u8		Channel)
+{
+	u32	writeVal[2], powerBase0[2], powerBase1[2];
+	u8	index = 0;
+
+	getPowerBase(adapter, pPowerLevel, Channel, &powerBase0[0], &powerBase1[0]);
+
+	for (index=0; index<6; index++)
+	{
+		getTxPowerWriteValByRegulatory(adapter, pPowerLevel, Channel, index,
+			&powerBase0[0], &powerBase1[0], &writeVal[0]);
+
+		writeOFDMPowerReg(adapter, index, &writeVal[0]);
+	}
+}
+
+bool
+rtl8192d_PHY_EnableAnotherPHY(
+	struct rtw_adapter *		adapter,
+	bool			bMac0
+	)
+{
+	u8			u1bTmp;
+	u8			MAC_REG = bMac0==true?REG_MAC1:REG_MAC0;
+	u8			MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
+	bool		bResult = true;	/* true: need to enable BB/RF power */
+	u32			MaskForPHYSet = 0;
+
+	/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
+	u1bTmp = rtw_read8(adapter, MAC_REG);
+
+	if (!(u1bTmp&MAC_ON_BIT))
+	{
+		/*  Enable BB and RF power */
+		if (bMac0)
+			MaskForPHYSet = MAC0_ACCESS_PHY1;
+		else
+			MaskForPHYSet = MAC1_ACCESS_PHY0;
+		rtw_write16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet)&0xFFFC);
+		rtw_write16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet, rtw_read16(adapter, REG_SYS_FUNC_EN|MaskForPHYSet)|BIT13|BIT0|BIT1);
+	} else {
+		/*  We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load. */
+		bResult = false;
+	}
+	return bResult;
+}
+
+void
+rtl8192d_PHY_PowerDownAnotherPHY(
+	struct rtw_adapter *		adapter,
+	bool			bMac0
+	)
+{
+	u8	u1bTmp;
+	u8	MAC_REG = bMac0==true?REG_MAC1:REG_MAC0;
+	u8	MAC_ON_BIT = bMac0==true?MAC1_ON:MAC0_ON;
+	u32	MaskforPhySet = 0;
+
+	/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
+	u1bTmp = rtw_read8(adapter, MAC_REG);
+
+	if (!(u1bTmp&MAC_ON_BIT)) {
+		/*  power down RF radio A according to YuNan's advice. */
+		if (bMac0)
+			MaskforPhySet = MAC0_ACCESS_PHY1;
+		else
+			MaskforPhySet = MAC1_ACCESS_PHY0;
+		  rtw_write32(adapter, rFPGA0_XA_LSSIParameter|MaskforPhySet, 0x00000000);
+	}
+
+}
+
+static int
+phy_RF6052_Config_ParaFile(
+	struct rtw_adapter *		adapter
+	)
+{
+	u32	u4RegValue=0;
+	u8	eRFPath;
+	struct bb_register_def *pPhyReg;
+	int	rtStatus = _SUCCESS;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+#ifndef CONFIG_EMBEDDED_FWIMG
+	u8	*pszRadioAFile = NULL;
+	u8	*pszRadioBFile = NULL;
+#endif
+	static s8		sz92DRadioAFile[] = RTL8192D_PHY_RADIO_A;
+	static s8		sz92DRadioBFile[] = RTL8192D_PHY_RADIO_B;
+	static s8		sz92DRadioAintPAFile[] = RTL8192D_PHY_RADIO_A_intPA;
+	static s8		sz92DRadioBintPAFile[] = RTL8192D_PHY_RADIO_B_intPA;
+	bool		bMac1NeedInitRadioAFirst = false,bMac0NeedInitRadioBFirst = false;
+	bool		bNeedPowerDownRadioA = false,bNeedPowerDownRadioB = false;
+	bool		bTrueBPath = false;/* vivi added this for read parameter from header, 20100908 */
+	u32	MaskforPhySet = 0; /* For 92d PHY cross access, 88c must set value 0. */
+
+#ifndef CONFIG_EMBEDDED_FWIMG
+	pszRadioAFile = sz92DRadioAFile;
+	pszRadioBFile = sz92DRadioBFile;
+#endif
+
+#ifndef CONFIG_EMBEDDED_FWIMG
+	if (pHalData->InternalPA5G[0])
+		pszRadioAFile = sz92DRadioAintPAFile;
+	if (pHalData->InternalPA5G[1])
+		pszRadioBFile = sz92DRadioBintPAFile;
+#endif
+
+	/* DMDP,MAC0 on G band,MAC1 on A band. */
+	if (pHalData->MacPhyMode92D==DUALMAC_DUALPHY)
+	{
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G && pHalData->interfaceIndex == 0)
+		{
+			/* MAC0 Need PHY1 load radio_b.txt . Driver use DBI to write. */
+			if (rtl8192d_PHY_EnableAnotherPHY(adapter, true))
+			{
+				pHalData->NumTotalRFPath = 2;
+				bMac0NeedInitRadioBFirst = true;
+			}
+			else
+			{
+				/*  We think if MAC1 is ON,then radio_a.txt and radio_b.txt has been load. */
+				return rtStatus;
+			}
+		}
+		else if (pHalData->CurrentBandType92D == BAND_ON_5G && pHalData->interfaceIndex == 1)
+		{
+			/* MAC1 Need PHY0 load radio_a.txt . Driver use DBI to write. */
+			if (rtl8192d_PHY_EnableAnotherPHY(adapter, false))
+			{
+				pHalData->NumTotalRFPath = 2;
+				bMac1NeedInitRadioAFirst = true;
+			}
+			else
+			{
+				/*  We think if MAC0 is ON,then radio_a.txt and radio_b.txt has been load. */
+				return rtStatus;
+			}
+		}
+		else if (pHalData->interfaceIndex == 1)
+		{
+			/*  MAC0 enabled, only init radia B. */
+#ifndef CONFIG_EMBEDDED_FWIMG
+			pszRadioAFile = pszRadioBFile;
+#endif
+			bTrueBPath = true;  /* vivi added this for read parameter from header, 20100909 */
+		}
+	}
+
+	/* 3----------------------------------------------------------------- */
+	/* 3 <2> Initialize RF */
+	/* 3----------------------------------------------------------------- */
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+		if (bMac1NeedInitRadioAFirst) /* Mac1 use PHY0 write */
+		{
+			if (eRFPath == RF_PATH_A)
+			{
+				bNeedPowerDownRadioA = true;
+				MaskforPhySet = MAC1_ACCESS_PHY0;
+			}
+			else if (eRFPath == RF_PATH_B)
+			{
+				MaskforPhySet = 0;
+				bMac1NeedInitRadioAFirst = false;
+				eRFPath = RF_PATH_A;
+				bTrueBPath = true;
+#ifndef CONFIG_EMBEDDED_FWIMG
+				pszRadioAFile = pszRadioBFile;
+#endif
+				pHalData->NumTotalRFPath = 1;
+			}
+		}
+		else  if (bMac0NeedInitRadioBFirst) /* Mac0 use PHY1 write */
+		{
+			if (eRFPath == RF_PATH_A)
+			{
+				MaskforPhySet = 0;
+			}
+
+			if (eRFPath == RF_PATH_B)
+			{
+				MaskforPhySet = MAC0_ACCESS_PHY1;
+				bMac0NeedInitRadioBFirst = false;
+				bNeedPowerDownRadioB = true;
+				eRFPath = RF_PATH_A;
+				bTrueBPath = true;
+#ifndef CONFIG_EMBEDDED_FWIMG
+				pszRadioAFile = pszRadioBFile;
+#endif
+				pHalData->NumTotalRFPath = 1;
+			}
+		}
+
+		pPhyReg = &pHalData->PHYRegDef[eRFPath];
+
+		/*----Store original RFENV control type----*/
+		switch (eRFPath)
+		{
+			case RF_PATH_A:
+			case RF_PATH_C:
+				u4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV);
+				break;
+			case RF_PATH_B :
+			case RF_PATH_D:
+				u4RegValue = PHY_QueryBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16);
+				break;
+		}
+
+		/*----Set RF_ENV enable----*/
+		PHY_SetBBReg(adapter, pPhyReg->rfintfe|MaskforPhySet, bRFSI_RFENV<<16, 0x1);
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
+
+		/*----Set RF_ENV output high----*/
+		PHY_SetBBReg(adapter, pPhyReg->rfintfo|MaskforPhySet, bRFSI_RFENV, 0x1);
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
+
+		/* Set bit number of Address and Data for RF register */
+		PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireAddressLength, 0x0);	/*  Set 1 to 4 bits for 8255 */
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
+
+		PHY_SetBBReg(adapter, pPhyReg->rfHSSIPara2|MaskforPhySet, b3WireDataLength, 0x0);	/*  Set 0 to 12  bits for 8255 */
+		rtw_udelay_os(1);/* PlatformStallExecution(1); */
+
+		/*----Initialize RF fom connfiguration file----*/
+		switch (eRFPath)
+		{
+			case RF_PATH_A:
+#ifdef CONFIG_EMBEDDED_FWIMG
+				/* vivi added this for read parameter from header, 20100908 */
+				if (bTrueBPath == true)
+					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radiob_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
+				else
+					rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radioa_txt|MaskforPhySet, (enum RF_RADIO_PATH_E)eRFPath);
+#else
+				rtStatus = _SUCCESS;
+#endif
+				break;
+			case RF_PATH_B:
+#ifdef CONFIG_EMBEDDED_FWIMG
+			rtStatus = rtl8192d_PHY_ConfigRFWithHeaderFile(adapter,radiob_txt, (enum RF_RADIO_PATH_E)eRFPath);
+#else
+			rtStatus = _SUCCESS;
+#endif
+				break;
+			case RF_PATH_C:
+				break;
+			case RF_PATH_D:
+				break;
+		}
+
+		/*----Restore RFENV control type----*/;
+		switch (eRFPath)
+		{
+			case RF_PATH_A:
+			case RF_PATH_C:
+				PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV, u4RegValue);
+				break;
+			case RF_PATH_B :
+			case RF_PATH_D:
+				PHY_SetBBReg(adapter, pPhyReg->rfintfs|MaskforPhySet, bRFSI_RFENV<<16, u4RegValue);
+				break;
+		}
+
+		if (rtStatus != _SUCCESS) {
+			goto phy_RF6052_Config_ParaFile_Fail;
+		}
+
+	}
+
+	if (bNeedPowerDownRadioA)
+	{
+		/*  check MAC0 enable or not again now, if enabled, not power down radio A. */
+		rtl8192d_PHY_PowerDownAnotherPHY(adapter, false);
+	}
+	else  if (bNeedPowerDownRadioB)
+	{
+		/*  check MAC1 enable or not again now, if enabled, not power down radio B. */
+		rtl8192d_PHY_PowerDownAnotherPHY(adapter, true);
+	}
+
+	for (eRFPath = RF_PATH_A; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+	{
+#if MP_DRIVER == 1
+		PHY_SetRFReg(adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask, 0xff456);
+#endif
+		pdmpriv->RegRF3C[eRFPath] = PHY_QueryRFReg(adapter, eRFPath, RF_RXRF_A3, bRFRegOffsetMask);
+	}
+
+	return rtStatus;
+
+phy_RF6052_Config_ParaFile_Fail:
+	return rtStatus;
+}
+
+int
+PHY_RF6052_Config8192D(
+	struct rtw_adapter *		adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	int rtStatus = _SUCCESS;
+
+	/*  */
+	/*  Initialize general global value */
+	/*  */
+	/*  TODO: Extend RF_PATH_C and RF_PATH_D in the future */
+	if (pHalData->rf_type == RF_1T1R)
+		pHalData->NumTotalRFPath = 1;
+	else
+		pHalData->NumTotalRFPath = 2;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bSlaveOfDMSP)
+	{
+		DBG_871X(("PHY_RF6052_Config() skip configuration RF\n"));
+		return rtStatus;
+	}
+#endif
+
+	/*  */
+	/*  Config BB and RF */
+	/*  */
+	rtStatus = phy_RF6052_Config_ParaFile(adapter);
+
+	return rtStatus;
+}
+
+/* End of HalRf6052.c */
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_rxdesc.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_rxdesc.c
new file mode 100644
index 0000000..b3e364c
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_rxdesc.c
@@ -0,0 +1,581 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192C_REDESC_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl8192d_hal.h>
+
+static u8 evm_db2percentage(s8 value)
+{
+	/*  */
+	/*  -33dB~0dB to 0%~99% */
+	/*  */
+	s8 ret_val;
+
+	ret_val = value;
+	/* ret_val /= 2; */
+
+	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("EVMdbToPercentage92S Value=%d / %x\n", ret_val, ret_val));
+
+	if (ret_val >= 0)
+		ret_val = 0;
+	if (ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val*=3;
+
+	if (ret_val == 99)
+		ret_val = 100;
+
+	return(ret_val);
+}
+
+static s32 signal_scale_mapping(struct rtw_adapter *padapter, s32 cur_sig)
+{
+	s32 ret_sig;
+
+	if (cur_sig >= 51 && cur_sig <= 100)
+		ret_sig = 100;
+	else if (cur_sig >= 41 && cur_sig <= 50)
+		ret_sig = 80 + ((cur_sig - 40)*2);
+	else if (cur_sig >= 31 && cur_sig <= 40)
+		ret_sig = 66 + (cur_sig - 30);
+	else if (cur_sig >= 21 && cur_sig <= 30)
+		ret_sig = 54 + (cur_sig - 20);
+	else if (cur_sig >= 10 && cur_sig <= 20)
+		ret_sig = 42 + (((cur_sig - 10) * 2) / 3);
+	else if (cur_sig >= 5 && cur_sig <= 9)
+		ret_sig = 22 + (((cur_sig - 5) * 3) / 2);
+	else if (cur_sig >= 1 && cur_sig <= 4)
+		ret_sig = 6 + (((cur_sig - 1) * 3) / 2);
+	else
+		ret_sig = cur_sig;
+	return ret_sig;
+}
+
+static s32  translate2dbm(u8 signal_strength_idx)
+{
+	s32	signal_power; /*  in dBm. */
+
+	/*  Translate to dBm (x=0.5y-95). */
+	signal_power = (s32)((signal_strength_idx + 1) >> 1);
+	signal_power -= 95;
+
+	return signal_power;
+}
+
+static void query_rx_phy_status(struct recv_frame_hdr *prframe, struct phy_stat *pphy_stat, bool bPacketMatchBSSID)
+{
+	struct phy_ofdm_rx_status_report_8192cd	*pOfdm_buf;
+	struct phy_cck_rx_status_report_8192cd *pCck_buf;
+	u8	i, max_spatial_stream, evm;
+	s8	rx_pwr[4], rx_pwr_all=0;
+	u8	pwdb_all;
+	u32	rssi,total_rssi=0;
+	u8	bcck_rate=0, rf_rx_num = 0, cck_highpwr = 0;
+	struct rtw_adapter				*padapter = prframe->adapter;
+	struct rx_pkt_attrib	*pattrib = &prframe->attrib;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	u8	tmp_rxsnr;
+	s8	rx_snrX;
+	struct	mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+
+	bcck_rate=(pattrib->mcs_rate<=3? 1:0);
+
+	/*  Record it for next packet processing */
+	pattrib->rx_mimo_signal_qual[0]= -1;
+	pattrib->rx_mimo_signal_qual[1]= -1;
+
+	if (bcck_rate) /* CCK */
+	{
+		u8 report;
+
+		/*  CCK Driver info Structure is not the same as OFDM packet. */
+		pCck_buf = (struct phy_cck_rx_status_report_8192cd *)pphy_stat;
+
+		/*  */
+		/*  (1)Hardware does not provide RSSI for CCK */
+		/*  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) */
+		/*  */
+
+		if (padapter->pwrctrlpriv.rf_pwrstate == rf_on)
+			cck_highpwr = (u8)pHalData->bCckHighPower;
+		else
+			cck_highpwr = false;
+
+		if (!cck_highpwr)
+		{
+			report = pCck_buf->cck_agc_rpt&0xc0;
+			report = report>>6;
+			switch (report)
+			{
+				/*  03312009 modified by cosa */
+				/*  Modify the RF RNA gain value to -40, -20, -2, 14 by Jenyu's suggestion */
+				/*  Note: different RF with the different RNA gain. */
+				case 0x3:
+					rx_pwr_all = (-46) - (pCck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x2:
+					rx_pwr_all = (-26) - (pCck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x1:
+					rx_pwr_all = (-12) - (pCck_buf->cck_agc_rpt & 0x3e);
+					break;
+				case 0x0:
+					rx_pwr_all = (16) - (pCck_buf->cck_agc_rpt & 0x3e);
+					break;
+			}
+		}
+		else
+		{
+			report = pCck_buf->cck_agc_rpt & 0x60;
+			report = report>>5;
+			switch (report)
+			{
+				case 0x3:
+					rx_pwr_all = (-46) - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x2:
+					rx_pwr_all = (-26)- ((pCck_buf->cck_agc_rpt & 0x1f)<<1);
+					break;
+				case 0x1:
+					rx_pwr_all = (-12) - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+				case 0x0:
+					rx_pwr_all = (16) - ((pCck_buf->cck_agc_rpt & 0x1f)<<1) ;
+					break;
+			}
+		}
+
+		pwdb_all= query_rx_pwr_percentage(rx_pwr_all);
+		{
+			/*  CCK gain is smaller than OFDM/MCS gain, */
+			/*  so we add gain diff by experiences, the val is 6 */
+			pwdb_all+=6;
+			if (pwdb_all > 100)
+				pwdb_all = 100;
+			/*  modify the offset to make the same gain index with OFDM. */
+			if (pwdb_all > 34 && pwdb_all <= 42)
+				pwdb_all -= 2;
+			else if (pwdb_all > 26 && pwdb_all <= 34)
+				pwdb_all -= 6;
+			else if (pwdb_all > 14 && pwdb_all <= 26)
+				pwdb_all -= 8;
+			else if (pwdb_all > 4 && pwdb_all <= 14)
+				pwdb_all -= 4;
+		}
+
+		pattrib->rxpwdb_all = pwdb_all;
+		pattrib->recvsignalpower = rx_pwr_all;
+		padapter->recvpriv.rxpwdb = rx_pwr_all;
+
+		/*  */
+		/*  (3) Get Signal Quality (EVM) */
+		/*  */
+		if (bPacketMatchBSSID)
+		{
+			u8	sq;
+
+			if (pHalData->CustomerID == RT_CID_819x_Lenovo)
+			{
+				/*  mapping to 5 bars for vista signal strength */
+				/*  signal quality in driver will be displayed to signal strength */
+				/*  in vista. */
+				if (pwdb_all >= 50)
+					sq = 100;
+				else if (pwdb_all >= 35 && pwdb_all < 50)
+					sq = 80;
+				else if (pwdb_all >= 22 && pwdb_all < 35)
+					sq = 60;
+				else if (pwdb_all >= 18 && pwdb_all < 22)
+					sq = 40;
+				else
+					sq = 20;
+			}
+			else
+			{
+				if (pwdb_all> 40)
+				{
+					sq = 100;
+				}
+				else
+				{
+					sq = pCck_buf->SQ_rpt;
+
+					if (pCck_buf->SQ_rpt > 64)
+						sq = 0;
+					else if (pCck_buf->SQ_rpt < 20)
+						sq= 100;
+					else
+						sq = ((64-sq) * 100) / 44;
+
+				}
+			}
+
+			pattrib->signal_qual=sq;
+			pattrib->rx_mimo_signal_qual[0]=sq;
+			pattrib->rx_mimo_signal_qual[1]=(-1);
+		}
+	}
+	else /* OFDM/HT */
+	{
+		pOfdm_buf = (struct phy_ofdm_rx_status_report_8192cd *)pphy_stat;
+
+		/*  */
+		/*  (1)Get RSSI for HT rate */
+		/*  */
+		for (i=0; i<pHalData->NumTotalRFPath; i++)
+		{
+			/*  2008/01/30 MH we will judge RF RX path now. */
+			if (pHalData->bRFPathRxEnable[i])
+				rf_rx_num++;
+
+			rx_pwr[i] = ((pOfdm_buf->trsw_gain_X[+i]&0x3F)*2) - 110;
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+			{
+				if (bPacketMatchBSSID)
+					padapter->recvpriv.RxRssi[i] = rx_pwr[i];
+			}
+			else
+				padapter->recvpriv.RxRssi[i] = rx_pwr[i];
+			/* Translate DBM to percentage. */
+			pattrib->rx_rssi[i] = rssi = query_rx_pwr_percentage(rx_pwr[i]);
+			total_rssi += rssi;
+
+			RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], rssi));
+
+			/* Get Rx snr value in DB */
+			tmp_rxsnr = pOfdm_buf->rxsnr_X[i];
+			rx_snrX = (s8)(tmp_rxsnr);
+			rx_snrX >>= 1;
+			padapter->recvpriv.RxSNRdB[i] =  (int)rx_snrX;
+
+			/* Record Signal Strength for next packet */
+			if (bPacketMatchBSSID)
+			{
+
+				/* The following is for lenovo signal strength in vista */
+				if (pHalData->CustomerID == RT_CID_819x_Lenovo)
+				{
+					u8	SQ;
+
+					if (i == 0)
+					{
+						/*  mapping to 5 bars for vista signal strength */
+						/*  signal quality in driver will be displayed to signal strength */
+						/*  in vista. */
+						if (rssi >= 50)
+							SQ = 100;
+						else if (rssi >= 35 && rssi < 50)
+							SQ = 80;
+						else if (rssi >= 22 && rssi < 35)
+							SQ = 60;
+						else if (rssi >= 18 && rssi < 22)
+							SQ = 40;
+						else
+							SQ = 20;
+						/* DbgPrint("ofdm/mcs RSSI=%d\n", RSSI); */
+						pattrib->signal_qual = SQ;
+						/* DbgPrint("ofdm/mcs SQ = %d\n", pRfd->Status.SignalQuality); */
+					}
+				}
+			}
+		}
+
+		/*  */
+		/*  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive) */
+		/*  */
+		rx_pwr_all = (((pOfdm_buf->pwdb_all) >> 1)& 0x7f) -106;
+		pwdb_all = query_rx_pwr_percentage(rx_pwr_all);
+
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("PWDB_ALL=%d\n",	pwdb_all));
+
+		pattrib->rxpwdb_all = pwdb_all;	/* for DIG/rate adaptive */
+		pattrib->recvsignalpower = rx_pwr_all;
+		padapter->recvpriv.rxpwdb = rx_pwr_all;
+
+		/*  */
+		/*  (3)EVM of HT rate */
+		/*  */
+		if (pHalData->CustomerID != RT_CID_819x_Lenovo)
+		{
+			if (pattrib->rxht &&  pattrib->mcs_rate >=20 && pattrib->mcs_rate<=27)
+				max_spatial_stream = 2; /* both spatial stream make sense */
+			else
+				max_spatial_stream = 1; /* only spatial stream 1 makes sense */
+
+			for (i=0; i<max_spatial_stream; i++)
+			{
+				/*  Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment */
+				/*  fill most significant bit to "zero" when doing shifting operation which may change a negative */
+				/*  value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore. */
+				evm = evm_db2percentage((pOfdm_buf->rxevm_X[i] /*/ 2*/));/* dbm */
+
+				RT_TRACE(_module_rtl871x_recv_c_, _drv_err_, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
+					pattrib->mcs_rate, pOfdm_buf->rxevm_X[i], "%",evm));
+
+				if (bPacketMatchBSSID)
+				{
+					if (i==0) /*  Fill value in RFD, Get the first spatial stream only */
+					{
+						pattrib->signal_qual = (u8)(evm & 0xff);
+					}
+					pattrib->rx_mimo_signal_qual[i] = (u8)(evm & 0xff);
+				}
+			}
+
+		}
+
+		/*  */
+		/*  4. Record rx statistics for debug */
+		/*  */
+
+	}
+
+	/* UI BSS List signal strength(in percentage), make it good looking, from 0~100. */
+	/* It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp(). */
+	if (bcck_rate)
+	{
+		pattrib->signal_strength=(u8)signal_scale_mapping(padapter, pwdb_all);
+	}
+	else
+	{
+		if (rf_rx_num != 0)
+		{
+			pattrib->signal_strength= (u8)(signal_scale_mapping(padapter, total_rssi/=rf_rx_num));
+		}
+	}
+}
+
+static void process_rssi(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
+{
+	u32	last_rssi, tmp_val;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct signal_stat * signal_stat = &padapter->recvpriv.signal_strength_data;
+
+	{
+		if (signal_stat->update_req) {
+			signal_stat->total_num = 0;
+			signal_stat->total_val = 0;
+			signal_stat->update_req = 0;
+		}
+
+		signal_stat->total_num++;
+		signal_stat->total_val  += pattrib->signal_strength;
+		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
+	}
+}/*  Process_UI_RSSI_8192S */
+
+static void process_PWDB(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
+{
+	int	UndecoratedSmoothedPWDB;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
+	struct rx_pkt_attrib	*pattrib= &prframe->attrib;
+	struct sta_info		*psta = prframe->psta;
+
+	if (psta)
+	{
+		UndecoratedSmoothedPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+	}
+	else
+	{
+		UndecoratedSmoothedPWDB = pdmpriv->UndecoratedSmoothedPWDB;
+	}
+
+	{
+		if (UndecoratedSmoothedPWDB == 0) /*  initialize */
+		{
+			UndecoratedSmoothedPWDB = pattrib->rxpwdb_all;
+		}
+
+		if (pattrib->rxpwdb_all > (u32)UndecoratedSmoothedPWDB)
+		{
+			UndecoratedSmoothedPWDB =
+					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(pattrib->rxpwdb_all)) /(Rx_Smooth_Factor);
+
+			UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB + 1;
+		}
+		else
+		{
+			UndecoratedSmoothedPWDB =
+					(((UndecoratedSmoothedPWDB)*(Rx_Smooth_Factor-1)) +
+					(pattrib->rxpwdb_all)) /(Rx_Smooth_Factor);
+		}
+
+		if (psta)
+		{
+			psta->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+		}
+		else
+		{
+			pdmpriv->UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+		}
+	}
+}
+
+static void process_link_qual(struct rtw_adapter *padapter,struct recv_frame_hdr *prframe)
+{
+	u32	last_evm=0,  tmpVal;
+	struct rx_pkt_attrib *pattrib;
+	struct signal_stat * signal_stat;
+
+	if (prframe == NULL || padapter==NULL) {
+		return;
+	}
+
+	pattrib = &prframe->attrib;
+	signal_stat = &padapter->recvpriv.signal_qual_data;
+
+	if (signal_stat->update_req) {
+		signal_stat->total_num = 0;
+		signal_stat->total_val = 0;
+		signal_stat->update_req = 0;
+	}
+
+	signal_stat->total_num++;
+	signal_stat->total_val  += pattrib->signal_qual;
+	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
+
+}/*  Process_UiLinkQuality8192S */
+
+static void process_phy_info(struct rtw_adapter *padapter, struct recv_frame_hdr *prframe)
+{
+	struct recv_frame_hdr *precvframe = (struct recv_frame_hdr *)prframe;
+
+	/*  */
+	/*  Check RSSI */
+	/*  */
+	process_rssi(padapter, precvframe);
+	/*  */
+	/*  Check PWDB. */
+	/*  */
+	process_PWDB(padapter, precvframe);
+	/*  */
+	/*  Check EVM */
+	/*  */
+	process_link_qual(padapter,  precvframe);
+}
+
+void rtl8192d_translate_rx_signal_stuff(struct recv_frame_hdr *precvframe, struct phy_stat *pphy_info)
+{
+	struct rx_pkt_attrib	*pattrib = &precvframe->attrib;
+	struct rtw_adapter				*padapter = precvframe->adapter;
+	u8	bPacketMatchBSSID =false;
+	u8	bPacketToSelf = false;
+	u8	bPacketBeacon = false;
+
+	if ((pattrib->physt) && (pphy_info != NULL))
+	{
+		bPacketMatchBSSID = ((!IsFrameTypeCtrl(precvframe->rx_data)) && !(pattrib->icv_err) && !(pattrib->crc_err) &&
+			_rtw_memcmp(get_hdr_bssid(precvframe->rx_data), get_my_bssid(&padapter->mlmeextpriv.mlmext_info.network), ETH_ALEN));
+
+		bPacketToSelf = bPacketMatchBSSID &&  (_rtw_memcmp(get_da(precvframe->rx_data), myid(&padapter->eeprompriv), ETH_ALEN));
+
+		bPacketBeacon =bPacketMatchBSSID && (GetFrameSubType(precvframe->rx_data) ==  WIFI_BEACON);
+
+		query_rx_phy_status(precvframe, pphy_info, bPacketMatchBSSID);
+
+		precvframe->psta = NULL;
+		if (bPacketMatchBSSID && check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)
+		{
+			u8 *sa;
+			struct sta_info *psta=NULL;
+			struct sta_priv *pstapriv = &padapter->stapriv;
+
+			sa = get_sa(precvframe->rx_data);
+
+			psta = rtw_get_stainfo(pstapriv, sa);
+			if (psta)
+			{
+				precvframe->psta = psta;
+				process_phy_info(padapter, precvframe);
+			}
+		}
+		else if (bPacketToSelf || bPacketBeacon)
+		{
+			if (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+			{
+				u8 *sa;
+				struct sta_info *psta=NULL;
+				struct sta_priv *pstapriv = &padapter->stapriv;
+
+				sa = get_sa(precvframe->rx_data);
+
+				psta = rtw_get_stainfo(pstapriv, sa);
+				if (psta)
+				{
+					precvframe->psta = psta;
+				}
+			}
+
+			process_phy_info(padapter, precvframe);
+		}
+	}
+}
+
+void rtl8192d_query_rx_desc_status(struct recv_frame_hdr *precvframe, struct recv_stat *pdesc)
+{
+	struct rx_pkt_attrib	*pattrib = &precvframe->attrib;
+
+	/* Offset 0 */
+	pattrib->physt = (u8)((le32_to_cpu(pdesc->rxdw0) >> 26) & 0x1);
+	pattrib->pkt_len =  (u16)(le32_to_cpu(pdesc->rxdw0)&0x00003fff);
+	pattrib->drvinfo_sz = (u8)((le32_to_cpu(pdesc->rxdw0) >> 16) & 0xf) * 8;/* uint 2^3 = 8 bytes */
+
+	pattrib->shift_sz = (u8)((le32_to_cpu(pdesc->rxdw0) >> 24) & 0x3);
+
+	pattrib->crc_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 14) & 0x1);
+	pattrib->icv_err = (u8)((le32_to_cpu(pdesc->rxdw0) >> 15) & 0x1);
+	pattrib->qos = (u8)((le32_to_cpu(pdesc->rxdw0) >> 23) & 0x1);/*  Qos data, wireless lan header length is 26 */
+	pattrib->bdecrypted = (le32_to_cpu(pdesc->rxdw0) & BIT(27))? 0:1;
+
+	/* Offset 4 */
+	pattrib->mfrag = (u8)((le32_to_cpu(pdesc->rxdw1) >> 27) & 0x1);/* more fragment bit */
+
+	/* Offset 8 */
+	pattrib->frag_num = (u8)((le32_to_cpu(pdesc->rxdw2) >> 12) & 0xf);/* fragmentation number */
+
+	/* Offset 12 */
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+	if (le32_to_cpu(pdesc->rxdw3) & BIT(13)) {
+		pattrib->tcpchk_valid = 1; /*  valid */
+		if (le32_to_cpu(pdesc->rxdw3) & BIT(11)) {
+			pattrib->tcp_chkrpt = 1; /*  correct */
+		}
+		else
+			pattrib->tcp_chkrpt = 0; /*  incorrect */
+
+		if (le32_to_cpu(pdesc->rxdw3) & BIT(12))
+			pattrib->ip_chkrpt = 1; /*  correct */
+		else
+			pattrib->ip_chkrpt = 0; /*  incorrect */
+	}
+	else {
+		pattrib->tcpchk_valid = 0; /*  invalid */
+	}
+#endif
+
+	pattrib->mcs_rate=(u8)((le32_to_cpu(pdesc->rxdw3))&0x3f);
+	pattrib->rxht=(u8)((le32_to_cpu(pdesc->rxdw3) >>6)&0x1);
+
+	/* Offset 16 */
+	/* Offset 20 */
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192d_xmit.c b/drivers/net/wireless/rtl8192du/hal/rtl8192d_xmit.c
new file mode 100644
index 0000000..22f1ad7
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192d_xmit.c
@@ -0,0 +1,56 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192D_XMIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtl8192d_hal.h>
+
+void dump_txrpt_ccx_8192d(void *buf)
+{
+	struct txrpt_ccx_8192d *txrpt_ccx = buf;
+
+	DBG_8192D("%s:\n"
+		"retry_cnt:%u, rsvd_0:%u, rts_retry_cnt:%u, rsvd_1:%u\n"
+		"ccx_qtime:%u, missed_pkt_num:%u, rsvd_4:%u\n"
+		"mac_id:%u, des1_fragssn:%u\n"
+		"rpt_pkt_num:%u, pkt_drop:%u, lifetime_over:%u, retry_over:%u\n"
+		"edca_tx_queue:%u, rsvd_7:%u, bmc:%u, pkt_ok:%u, init_ccx:%u\n"
+		, __func__
+		, txrpt_ccx->retry_cnt, txrpt_ccx->rsvd_0, txrpt_ccx->rts_retry_cnt, txrpt_ccx->rsvd_1
+		, txrpt_ccx_qtime_8192d(txrpt_ccx), txrpt_ccx->missed_pkt_num, txrpt_ccx->rsvd_4
+		, txrpt_ccx->mac_id, txrpt_ccx->des1_fragssn
+		, txrpt_ccx->rpt_pkt_num, txrpt_ccx->pkt_drop, txrpt_ccx->lifetime_over, txrpt_ccx->retry_over
+		, txrpt_ccx->edca_tx_queue, txrpt_ccx->rsvd_7, txrpt_ccx->bmc, txrpt_ccx->pkt_ok, txrpt_ccx->int_ccx
+	);
+}
+
+void handle_txrpt_ccx_8192d(struct rtw_adapter *adapter, void *buf)
+{
+	struct txrpt_ccx_8192d *txrpt_ccx = buf;
+
+	#ifdef DBG_CCX
+	dump_txrpt_ccx_8192d(buf);
+	#endif
+
+	if (txrpt_ccx->int_ccx) {
+		if (txrpt_ccx->pkt_ok)
+			rtw_ack_tx_done(&adapter->xmitpriv, RTW_SCTX_DONE_SUCCESS);
+		else
+			rtw_ack_tx_done(&adapter->xmitpriv, RTW_SCTX_DONE_CCX_PKT_FAIL);
+	}
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192du_led.c b/drivers/net/wireless/rtl8192du/hal/rtl8192du_led.c
new file mode 100644
index 0000000..78ea371
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192du_led.c
@@ -0,0 +1,2425 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#include "drv_types.h"
+#include "rtl8192d_hal.h"
+#include <rtl8192d_led.h>
+
+/*  */
+/*	Constant. */
+/*  */
+
+/*  */
+/*  Default LED behavior. */
+/*  */
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA		1000
+#define LED_BLINK_LINK_INTERVAL_ALPHA			500		/* 500 */
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180	/* 150 */
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+/*  */
+/*  LED object. */
+/*  */
+
+/*  */
+/*	Prototype of protected function. */
+/*  */
+
+static void BlinkTimerCallback(unsigned long data);
+
+static void
+BlinkWorkItemCallback(
+	struct work_struct *work
+	);
+
+static void
+ResetLedStatus(struct LED_871X *	pLed) {
+	pLed->CurrLedState = RTW_LED_OFF; /*  Current LED state. */
+	pLed->bLedOn = false; /*  true if LED is ON, false if LED is OFF. */
+
+	pLed->bLedBlinkInProgress = false; /*  true if it is blinking, false o.w.. */
+	pLed->bLedNoLinkBlinkInProgress = false;
+	pLed->bLedLinkBlinkInProgress = false;
+	pLed->bLedStartToLinkBlinkInProgress = false;
+	pLed->bLedScanBlinkInProgress = false;
+	pLed->bLedWPSBlinkInProgress = false;
+	pLed->BlinkTimes = 0; /*  Number of times to toggle led state for blinking. */
+	pLed->BlinkingLedState = LED_UNKNOWN; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
+}
+
+/*  */
+/*  LED_819xUsb routines. */
+/*  */
+
+/*  */
+/*	Description: */
+/*		Initialize an struct LED_871X object. */
+/*  */
+
+static void InitLed871x(struct rtw_adapter *padapter,
+	struct LED_871X *		pLed,
+	enum LED_PIN_871X	LedPin
+	)
+{
+	pLed->padapter = padapter;
+
+	pLed->LedPin = LedPin;
+
+	pLed->CurrLedState = RTW_LED_OFF;
+	pLed->bLedOn = false;
+
+	pLed->bLedBlinkInProgress = false;
+	pLed->BlinkTimes = 0;
+	pLed->BlinkingLedState = LED_UNKNOWN;
+
+	_init_timer(&(pLed->BlinkTimer), padapter->pnetdev, BlinkTimerCallback, pLed);
+
+	_init_workitem(&(pLed->BlinkWorkItem), BlinkWorkItemCallback, pLed);
+}
+
+/*  */
+/*	Description: */
+/*		DeInitialize an struct LED_871X object. */
+/*  */
+static void DeInitLed871x(struct LED_871X *pLed)
+{
+	/* call _cancel_workitem_sync(&(pLed->BlinkWorkItem)) */
+    /* before _cancel_timer_ex(&(pLed->BlinkTimer)) to */
+    /* avoid led timer restarting when driver is removed */
+
+	_cancel_workitem_sync(&(pLed->BlinkWorkItem));
+	_cancel_timer_ex(&(pLed->BlinkTimer));
+	/*  We should reset bLedBlinkInProgress if we cancel the LedControlTimer, 2005.03.10, by rcnjko. */
+	ResetLedStatus(pLed);
+}
+
+/*  */
+/*	Description: */
+/*		Turn on LED according to LedPin specified. */
+/*  */
+
+static void SwLedOn(struct rtw_adapter *padapter, struct LED_871X *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
+	{
+		return;
+	}
+
+	switch (pLed->LedPin)
+	{
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+			rtw_write8(padapter, REG_LEDCFG2, LedCfg&0xf0); /*  SW control led0 on. */
+
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg = rtw_read8(padapter, (REG_LEDCFG2 + 1));
+			rtw_write8(padapter, (REG_LEDCFG2 + 1), LedCfg&0x0f); /*  SW control led1 on. */
+
+			break;
+
+		default:
+			break;
+	}
+
+	pLed->bLedOn = true;
+}
+
+/*  */
+/*	Description: */
+/*		Turn off LED according to LedPin specified. */
+/*  */
+static void SwLedOff(struct rtw_adapter *padapter, struct LED_871X *pLed)
+{
+	u8	LedCfg;
+
+	if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
+	{
+             return;
+	}
+
+	switch (pLed->LedPin)
+	{
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			LedCfg = rtw_read8(padapter, REG_LEDCFG2);
+			LedCfg &= 0xf0; /*  Set to software control. */
+			rtw_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
+
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg = rtw_read8(padapter, (REG_LEDCFG2+1));
+			LedCfg &= 0x0f; /*  Set to software control. */
+			rtw_write8(padapter, (REG_LEDCFG2+1), (LedCfg|BIT3));
+
+			break;
+
+		default:
+			break;
+	}
+
+	pLed->bLedOn = false;
+}
+
+/*  */
+/*	Description: */
+/*		Implementation of LED blinking behavior. */
+/*		It toggle off LED and schedule corresponding timer if necessary. */
+/*  */
+static void SwLedBlink(struct LED_871X *pLed)
+{
+	struct rtw_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8				bStopBlinking = false;
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	/*  Determine if we shall change LED state again. */
+	pLed->BlinkTimes--;
+	switch (pLed->CurrLedState)
+	{
+
+	case LED_BLINK_NORMAL:
+		if (pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = true;
+		}
+		break;
+
+	case LED_BLINK_StartToBlink:
+		if (check_fwstate(pmlmepriv, _FW_LINKED) && check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+		{
+			bStopBlinking = true;
+		}
+		if (check_fwstate(pmlmepriv, _FW_LINKED) &&
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) || check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))
+		{
+			bStopBlinking = true;
+		}
+		else if (pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = true;
+		}
+		break;
+
+	case LED_BLINK_WPS:
+		if (pLed->BlinkTimes == 0)
+		{
+			bStopBlinking = true;
+		}
+		break;
+
+	default:
+		bStopBlinking = true;
+		break;
+
+	}
+
+	if (bStopBlinking)
+	{
+		if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+		{
+			SwLedOff(padapter, pLed);
+		}
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (pLed->bLedOn == false))
+		{
+			SwLedOn(padapter, pLed);
+		}
+		else if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) &&  pLed->bLedOn == true)
+		{
+			SwLedOff(padapter, pLed);
+		}
+
+		pLed->BlinkTimes = 0;
+		pLed->bLedBlinkInProgress = false;
+	}
+	else
+	{
+		/*  Assign LED state to toggle. */
+		if (pLed->BlinkingLedState == RTW_LED_ON)
+			pLed->BlinkingLedState = RTW_LED_OFF;
+		else
+			pLed->BlinkingLedState = RTW_LED_ON;
+
+		/*  Schedule a timer to toggle LED state. */
+		switch (pLed->CurrLedState)
+		{
+		case LED_BLINK_NORMAL:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+
+		case LED_BLINK_SLOWLY:
+		case LED_BLINK_StartToBlink:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS:
+			{
+				if (pLed->BlinkingLedState == RTW_LED_ON)
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+				else
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+			break;
+
+		default:
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			break;
+		}
+	}
+}
+
+static void SwLedBlink1(struct LED_871X *pLed)
+{
+	struct rtw_adapter				*padapter = pLed->padapter;
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	struct LED_871X *			pLed1 = &(ledpriv->SwLed1);
+	u8					bStopBlinking = false;
+
+	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	if (pHalData->CustomerID == RT_CID_DEFAULT)
+	{
+		if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+		{
+			if (!pLed1->bSWLedCtrl)
+			{
+				SwLedOn(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			}
+			else if (!pLed1->bLedOn)
+				SwLedOn(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn on pLed1\n"));
+		}
+		else
+		{
+			if (!pLed1->bSWLedCtrl)
+			{
+				SwLedOff(padapter, pLed1);
+				pLed1->bSWLedCtrl = true;
+			}
+			else if (pLed1->bLedOn)
+				SwLedOff(padapter, pLed1);
+			RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (): turn off pLed1\n"));
+		}
+	}
+
+	switch (pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_NORMAL:
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->bLedLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->bLedNoLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->bLedLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->bLedNoLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->BlinkTimes = 0;
+				pLed->bLedBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	/* WPS success */
+			if (pLed->BlinkingLedState == RTW_LED_ON)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = false;
+			}
+			else
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->bLedLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_NORMAL;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+			break;
+
+		default:
+			break;
+	}
+}
+
+static void SwLedBlink2(struct LED_871X *pLed)
+{
+	struct rtw_adapter				*padapter = pLed->padapter;
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+	u8					bStopBlinking = false;
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch (pLed->CurrLedState)
+	{
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop scan blink CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					SwLedOff(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("stop CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+}
+
+static void SwLedBlink3(struct LED_871X *pLed)
+{
+	struct rtw_adapter			*padapter = pLed->padapter;
+	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	u8				bStopBlinking = false;
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		if (pLed->CurrLedState != LED_BLINK_WPS_STOP)
+			SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch (pLed->CurrLedState)
+	{
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+					if (!pLed->bLedOn)
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== true)
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+
+					if (!pLed->bLedOn)
+						SwLedOn(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				else if (check_fwstate(pmlmepriv, _FW_LINKED)== false)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+
+					if (pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_WPS_STOP:	/* WPS success */
+			if (pLed->BlinkingLedState == RTW_LED_ON)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+				bStopBlinking = false;
+			}
+			else
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+					SwLedOn(padapter, pLed);
+					RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+				}
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+			break;
+
+		default:
+			break;
+	}
+}
+
+static void SwLedBlink4(struct LED_871X *pLed)
+{
+	struct rtw_adapter			*padapter = pLed->padapter;
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct LED_871X *		pLed1 = &(ledpriv->SwLed1);
+	u8				bStopBlinking = false;
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	if (!pLed1->bLedWPSBlinkInProgress && pLed1->BlinkingLedState == LED_UNKNOWN)
+	{
+		pLed1->BlinkingLedState = RTW_LED_OFF;
+		pLed1->CurrLedState = RTW_LED_OFF;
+		SwLedOff(padapter, pLed1);
+	}
+
+	switch (pLed->CurrLedState)
+	{
+		case LED_BLINK_SLOWLY:
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_BLINK_StartToBlink:
+			if (pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = false;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->bLedNoLinkBlinkInProgress = false;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->bLedNoLinkBlinkInProgress = true;
+					pLed->CurrLedState = LED_BLINK_SLOWLY;
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+				}
+				pLed->bLedBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_BLINK_WPS:
+			if (pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+		case LED_BLINK_WPS_STOP:	/* WPS authentication fail */
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			break;
+
+		case LED_BLINK_WPS_STOP_OVERLAP:	/* WPS session overlap */
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				if (pLed->bLedOn)
+				{
+					pLed->BlinkTimes = 1;
+				}
+				else
+				{
+					bStopBlinking = true;
+				}
+			}
+
+			if (bStopBlinking)
+			{
+				pLed->BlinkTimes = 10;
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			else
+			{
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink4 CurrLedState %d\n", pLed->CurrLedState));
+
+}
+
+static void SwLedBlink5(struct LED_871X *pLed)
+{
+	struct rtw_adapter			*padapter = pLed->padapter;
+	u8				bStopBlinking = false;
+
+	/*  Change LED according to BlinkingLedState specified. */
+	if (pLed->BlinkingLedState == RTW_LED_ON)
+	{
+		SwLedOn(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn on\n", pLed->BlinkTimes));
+	}
+	else
+	{
+		SwLedOff(padapter, pLed);
+		RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Blinktimes (%d): turn off\n", pLed->BlinkTimes));
+	}
+
+	switch (pLed->CurrLedState)
+	{
+		case LED_SCAN_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+				}
+				else
+				{		pLed->CurrLedState = RTW_LED_ON;
+						pLed->BlinkingLedState = RTW_LED_ON;
+						if (!pLed->bLedOn)
+							_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		case LED_TXRX_BLINK:
+			pLed->BlinkTimes--;
+			if (pLed->BlinkTimes == 0)
+			{
+				bStopBlinking = true;
+			}
+
+			if (bStopBlinking)
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					pLed->CurrLedState = RTW_LED_OFF;
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					if (pLed->bLedOn)
+						SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					pLed->CurrLedState = RTW_LED_ON;
+					pLed->BlinkingLedState = RTW_LED_ON;
+					if (!pLed->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+
+				pLed->bLedBlinkInProgress = false;
+			}
+			else
+			{
+				if (padapter->pwrctrlpriv.rf_pwrstate != rf_on && padapter->pwrctrlpriv.rfoff_reason > RF_CHANGE_BY_PS)
+				{
+					SwLedOff(padapter, pLed);
+				}
+				else
+				{
+					 if (pLed->bLedOn)
+						pLed->BlinkingLedState = RTW_LED_OFF;
+					else
+						pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("SwLedBlink5 CurrLedState %d\n", pLed->CurrLedState));
+
+}
+
+/*  */
+/*	Description: */
+/*		Callback function of LED BlinkTimer, */
+/*		it just schedules to corresponding BlinkWorkItem. */
+/*  */
+static void
+BlinkTimerCallback(
+	unsigned long data
+	)
+{
+	struct LED_871X *	 pLed = (struct LED_871X *)data;
+	struct rtw_adapter		*padapter = pLed->padapter;
+
+	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
+       {
+             return;
+       }
+
+	_set_workitem(&(pLed->BlinkWorkItem));
+}
+
+/*  */
+/*	Description: */
+/*		Callback function of LED BlinkWorkItem. */
+/*		We dispatch acture LED blink action according to LedStrategy. */
+/*  */
+static void BlinkWorkItemCallback(struct work_struct *work)
+{
+	struct LED_871X *	 pLed = container_of(work, struct LED_871X, BlinkWorkItem);
+	struct led_priv	*ledpriv = &(pLed->padapter->ledpriv);
+	struct rtw_adapter		*padapter = pLed->padapter;
+
+	 if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
+       {
+             return;
+       }
+
+	switch (ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			SwLedBlink(pLed);
+			break;
+
+		case SW_LED_MODE1:
+			SwLedBlink1(pLed);
+			break;
+
+		case SW_LED_MODE2:
+			SwLedBlink2(pLed);
+			break;
+
+		case SW_LED_MODE3:
+			SwLedBlink3(pLed);
+			break;
+
+		case SW_LED_MODE4:
+			SwLedBlink4(pLed);
+			break;
+
+		case SW_LED_MODE5:
+			SwLedBlink5(pLed);
+			break;
+
+		default:
+			SwLedBlink(pLed);
+			break;
+	}
+}
+
+/*  */
+/*  Default LED behavior. */
+/*  */
+
+/*  */
+/*	Description: */
+/*		Implement each led action for SW_LED_MODE0. */
+/*		This is default strategy. */
+/*  */
+static void SwLedControlMode0(
+	struct rtw_adapter		*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct LED_871X *	pLed = &(ledpriv->SwLed1);
+
+	/*  Decide led state */
+	switch (LedAction)
+	{
+	case LED_CTL_TX:
+	case LED_CTL_RX:
+		if (pLed->bLedBlinkInProgress == false)
+		{
+			pLed->bLedBlinkInProgress = true;
+
+			pLed->CurrLedState = LED_BLINK_NORMAL;
+			pLed->BlinkTimes = 2;
+
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+		}
+		break;
+
+	case LED_CTL_START_TO_LINK:
+		if (pLed->bLedBlinkInProgress == false)
+		{
+			pLed->bLedBlinkInProgress = true;
+
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+			pLed->BlinkTimes = 24;
+
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+		}
+		else
+		{
+			pLed->CurrLedState = LED_BLINK_StartToBlink;
+		}
+		break;
+
+	case LED_CTL_LINK:
+		pLed->CurrLedState = RTW_LED_ON;
+		if (pLed->bLedBlinkInProgress == false)
+		{
+			SwLedOn(padapter, pLed);
+		}
+		break;
+
+	case LED_CTL_NO_LINK:
+		pLed->CurrLedState = RTW_LED_OFF;
+		if (pLed->bLedBlinkInProgress == false)
+		{
+			SwLedOff(padapter, pLed);
+		}
+		break;
+
+	case LED_CTL_POWER_OFF:
+		pLed->CurrLedState = RTW_LED_OFF;
+		pLed->BlinkingLedState = RTW_LED_OFF;
+
+		if (pLed->bLedBlinkInProgress)
+		{
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		SwLedOff(padapter, pLed);
+		break;
+
+	case LED_CTL_START_WPS:
+		if (pLed->bLedBlinkInProgress == false || pLed->CurrLedState == RTW_LED_ON)
+		{
+			pLed->bLedBlinkInProgress = true;
+
+			pLed->CurrLedState = LED_BLINK_WPS;
+			pLed->BlinkTimes = 20;
+
+			if (pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+			else
+			{
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LONG_INTERVAL);
+			}
+		}
+		break;
+
+	case LED_CTL_STOP_WPS:
+		if (pLed->bLedBlinkInProgress)
+		{
+			pLed->CurrLedState = RTW_LED_OFF;
+			_cancel_timer_ex(&(pLed->BlinkTimer));
+			pLed->bLedBlinkInProgress = false;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ /* ALPHA, added by chiyoko, 20090106 */
+static void SwLedControlMode1(
+	struct rtw_adapter		*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
+	struct led_priv		*ledpriv = &(padapter->ledpriv);
+	struct LED_871X *			pLed = &(ledpriv->SwLed0);
+	struct mlme_priv		*pmlmepriv = &(padapter->mlmepriv);
+
+	if (pHalData->CustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+
+	switch (LedAction)
+	{
+		case LED_CTL_START_TO_LINK:
+		case LED_CTL_NO_LINK:
+			if (pLed->bLedNoLinkBlinkInProgress == false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if (pLed->bLedLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			if (pLed->bLedLinkBlinkInProgress == false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_NORMAL;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_LINK_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			 if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+				;
+			 else if (pLed->bLedScanBlinkInProgress ==false)
+			 {
+				if (IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedScanBlinkInProgress = true;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+			if (pLed->bLedBlinkInProgress ==false)
+			{
+                            if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+                            {
+					return;
+                            }
+                            if (pLed->bLedNoLinkBlinkInProgress == true)
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedNoLinkBlinkInProgress = false;
+                            }
+                            if (pLed->bLedLinkBlinkInProgress == true)
+                            {
+                                _cancel_timer_ex(&(pLed->BlinkTimer));
+                                pLed->bLedLinkBlinkInProgress = false;
+                            }
+                            pLed->bLedBlinkInProgress = true;
+                            pLed->CurrLedState = LED_TXRX_BLINK;
+                            pLed->BlinkTimes = 2;
+                            if (pLed->bLedOn)
+                                pLed->BlinkingLedState = RTW_LED_OFF;
+                            else
+                                pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
+		case LED_CTL_START_WPS_BOTTON:
+			 if (pLed->bLedWPSBlinkInProgress ==false)
+			 {
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					 pLed->bLedLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				if (pLed->bLedScanBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = false;
+				}
+				pLed->bLedWPSBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+
+		case LED_CTL_STOP_WPS:
+			if (pLed->bLedNoLinkBlinkInProgress == true)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress == true)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				 pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress ==true)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress ==true)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+			}
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = true;
+			}
+
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if (pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+
+		case LED_CTL_STOP_WPS_FAIL:
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+
+			if (pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+
+			SwLedOff(padapter, pLed);
+			break;
+
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+ /* Arcadyan/Sitecom , added by chiyoko, 20090216 */
+static void SwLedControlMode2(
+	struct rtw_adapter				*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	 *ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction)
+	{
+		case LED_CTL_SITE_SURVEY:
+			 if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
+				;
+			 else if (pLed->bLedScanBlinkInProgress ==false)
+			 {
+				if (IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedScanBlinkInProgress = true;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			 }
+			break;
+
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = true;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			pLed->CurrLedState = RTW_LED_ON;
+			pLed->BlinkingLedState = RTW_LED_ON;
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
+		case LED_CTL_START_WPS_BOTTON:
+			if (pLed->bLedWPSBlinkInProgress ==false)
+			{
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				if (pLed->bLedScanBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = false;
+				}
+				pLed->bLedWPSBlinkInProgress = true;
+				pLed->CurrLedState = RTW_LED_ON;
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			 }
+			break;
+
+		case LED_CTL_STOP_WPS:
+			pLed->bLedWPSBlinkInProgress = false;
+			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else
+			{
+				pLed->CurrLedState = RTW_LED_ON;
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+			}
+			break;
+
+		case LED_CTL_STOP_WPS_FAIL:
+			pLed->bLedWPSBlinkInProgress = false;
+			if (padapter->pwrctrlpriv.rf_pwrstate != rf_on)
+			{
+				SwLedOff(padapter, pLed);
+			}
+			else
+			{
+				pLed->CurrLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+				RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+			}
+			break;
+
+		case LED_CTL_START_TO_LINK:
+		case LED_CTL_NO_LINK:
+			if (!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+  /* COREGA, added by chiyoko, 20090316 */
+static void SwLedControlMode3(
+	struct rtw_adapter				*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+
+	switch (LedAction)
+	{
+		case LED_CTL_SITE_SURVEY:
+			if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
+				;
+			else if (pLed->bLedScanBlinkInProgress ==false)
+			{
+				if (IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedScanBlinkInProgress = true;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+			if ((pLed->bLedBlinkInProgress ==false) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+
+				pLed->bLedBlinkInProgress = true;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_LINK:
+			if (IS_LED_WPS_BLINKING(pLed))
+				return;
+
+			pLed->CurrLedState = RTW_LED_ON;
+			pLed->BlinkingLedState = RTW_LED_ON;
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
+		case LED_CTL_START_WPS_BOTTON:
+			if (pLed->bLedWPSBlinkInProgress ==false)
+			{
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				if (pLed->bLedScanBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = false;
+				}
+				pLed->bLedWPSBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_STOP_WPS:
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+			else
+			{
+				pLed->bLedWPSBlinkInProgress = true;
+			}
+
+			pLed->CurrLedState = LED_BLINK_WPS_STOP;
+			if (pLed->bLedOn)
+			{
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA);
+			}
+			else
+			{
+				pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+
+			break;
+
+		case LED_CTL_STOP_WPS_FAIL:
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_START_TO_LINK:
+		case LED_CTL_NO_LINK:
+			if (!IS_LED_BLINKING(pLed))
+			{
+				pLed->CurrLedState = RTW_LED_OFF;
+				pLed->BlinkingLedState = RTW_LED_OFF;
+				_set_timer(&(pLed->BlinkTimer), 0);
+			}
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("CurrLedState %d\n", pLed->CurrLedState));
+}
+
+ /* Edimax-Belkin, added by chiyoko, 20090413 */
+static void SwLedControlMode4(
+	struct rtw_adapter				*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+	struct LED_871X *		pLed1 = &(ledpriv->SwLed1);
+
+	switch (LedAction)
+	{
+		case LED_CTL_START_TO_LINK:
+			if (pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+
+				pLed1->BlinkingLedState = RTW_LED_OFF;
+				pLed1->CurrLedState = RTW_LED_OFF;
+
+				if (pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+
+			if (pLed->bLedStartToLinkBlinkInProgress == false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				if (pLed->bLedNoLinkBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+
+				pLed->bLedStartToLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_StartToBlink;
+				if (pLed->bLedOn)
+				{
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;
+
+		case LED_CTL_LINK:
+		case LED_CTL_NO_LINK:
+			/* LED1 settings */
+			if (LedAction == LED_CTL_LINK)
+			{
+				if (pLed1->bLedWPSBlinkInProgress)
+				{
+					pLed1->bLedWPSBlinkInProgress = false;
+					_cancel_timer_ex(&(pLed1->BlinkTimer));
+
+					pLed1->BlinkingLedState = RTW_LED_OFF;
+					pLed1->CurrLedState = RTW_LED_OFF;
+
+					if (pLed1->bLedOn)
+						_set_timer(&(pLed->BlinkTimer), 0);
+				}
+			}
+
+			if (pLed->bLedNoLinkBlinkInProgress == false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+
+				pLed->bLedNoLinkBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_SLOWLY;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+				;
+			else if (pLed->bLedScanBlinkInProgress ==false)
+			{
+				if (IS_LED_WPS_BLINKING(pLed))
+					return;
+
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedScanBlinkInProgress = true;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+			if (pLed->bLedBlinkInProgress ==false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK || IS_LED_WPS_BLINKING(pLed))
+				{
+					return;
+				}
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				pLed->bLedBlinkInProgress = true;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_START_WPS: /* wait until xinpin finish */
+		case LED_CTL_START_WPS_BOTTON:
+			if (pLed1->bLedWPSBlinkInProgress)
+			{
+				pLed1->bLedWPSBlinkInProgress = false;
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+
+				pLed1->BlinkingLedState = RTW_LED_OFF;
+				pLed1->CurrLedState = RTW_LED_OFF;
+
+				if (pLed1->bLedOn)
+					_set_timer(&(pLed->BlinkTimer), 0);
+			}
+
+			if (pLed->bLedWPSBlinkInProgress ==false)
+			{
+				if (pLed->bLedNoLinkBlinkInProgress == true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedNoLinkBlinkInProgress = false;
+				}
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				if (pLed->bLedScanBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedScanBlinkInProgress = false;
+				}
+				pLed->bLedWPSBlinkInProgress = true;
+				pLed->CurrLedState = LED_BLINK_WPS;
+				if (pLed->bLedOn)
+				{
+					pLed->BlinkingLedState = RTW_LED_OFF;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_SLOWLY_INTERVAL);
+				}
+				else
+				{
+					pLed->BlinkingLedState = RTW_LED_ON;
+					_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+				}
+			}
+			break;
+
+		case LED_CTL_STOP_WPS:	/* WPS connect success */
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			break;
+
+		case LED_CTL_STOP_WPS_FAIL:		/* WPS authentication fail */
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			/* LED1 settings */
+			if (pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else
+				pLed1->bLedWPSBlinkInProgress = true;
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP;
+			if (pLed1->bLedOn)
+				pLed1->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed1->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+
+			break;
+
+		case LED_CTL_STOP_WPS_FAIL_OVERLAP:	/* WPS session overlap */
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed->bLedNoLinkBlinkInProgress = true;
+			pLed->CurrLedState = LED_BLINK_SLOWLY;
+			if (pLed->bLedOn)
+				pLed->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NO_LINK_INTERVAL_ALPHA);
+
+			/* LED1 settings */
+			if (pLed1->bLedWPSBlinkInProgress)
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+			else
+				pLed1->bLedWPSBlinkInProgress = true;
+
+			pLed1->CurrLedState = LED_BLINK_WPS_STOP_OVERLAP;
+			pLed1->BlinkTimes = 10;
+			if (pLed1->bLedOn)
+				pLed1->BlinkingLedState = RTW_LED_OFF;
+			else
+				pLed1->BlinkingLedState = RTW_LED_ON;
+			_set_timer(&(pLed->BlinkTimer), LED_BLINK_NORMAL_INTERVAL);
+
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+
+			if (pLed->bLedNoLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedNoLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedLinkBlinkInProgress = false;
+			}
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+			if (pLed->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedWPSBlinkInProgress = false;
+			}
+			if (pLed->bLedScanBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedScanBlinkInProgress = false;
+			}
+			if (pLed->bLedStartToLinkBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedStartToLinkBlinkInProgress = false;
+			}
+
+			if (pLed1->bLedWPSBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed1->BlinkTimer));
+				pLed1->bLedWPSBlinkInProgress = false;
+			}
+
+			pLed1->BlinkingLedState = LED_UNKNOWN;
+			SwLedOff(padapter, pLed);
+			SwLedOff(padapter, pLed1);
+			break;
+
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+/* Sercomm-Belkin, added by chiyoko, 20090415 */
+static void SwLedControlMode5(
+	struct rtw_adapter				*padapter,
+	enum LED_CTL_MODE		LedAction
+)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct LED_871X *		pLed = &(ledpriv->SwLed0);
+
+	if (pHalData->EEPROMCustomerID == RT_CID_819x_CAMEO)
+		pLed = &(ledpriv->SwLed1);
+
+	switch (LedAction)
+	{
+		case LED_CTL_POWER_ON:
+		case LED_CTL_NO_LINK:
+		case LED_CTL_LINK:	/* solid blue */
+			pLed->CurrLedState = RTW_LED_ON;
+			pLed->BlinkingLedState = RTW_LED_ON;
+
+			_set_timer(&(pLed->BlinkTimer), 0);
+			break;
+
+		case LED_CTL_SITE_SURVEY:
+			if ((pmlmepriv->LinkDetectInfo.bBusyTraffic) && (check_fwstate(pmlmepriv, _FW_LINKED)== true))
+				;
+			else if (pLed->bLedScanBlinkInProgress ==false)
+			{
+				if (pLed->bLedBlinkInProgress ==true)
+				{
+					_cancel_timer_ex(&(pLed->BlinkTimer));
+					pLed->bLedBlinkInProgress = false;
+				}
+				pLed->bLedScanBlinkInProgress = true;
+				pLed->CurrLedState = LED_SCAN_BLINK;
+				pLed->BlinkTimes = 24;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_SCAN_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_TX:
+		case LED_CTL_RX:
+			if (pLed->bLedBlinkInProgress ==false)
+			{
+				if (pLed->CurrLedState == LED_SCAN_BLINK)
+				{
+					return;
+				}
+				pLed->bLedBlinkInProgress = true;
+				pLed->CurrLedState = LED_TXRX_BLINK;
+				pLed->BlinkTimes = 2;
+				if (pLed->bLedOn)
+					pLed->BlinkingLedState = RTW_LED_OFF;
+				else
+					pLed->BlinkingLedState = RTW_LED_ON;
+				_set_timer(&(pLed->BlinkTimer), LED_BLINK_FASTER_INTERVAL_ALPHA);
+			}
+			break;
+
+		case LED_CTL_POWER_OFF:
+			pLed->CurrLedState = RTW_LED_OFF;
+			pLed->BlinkingLedState = RTW_LED_OFF;
+
+			if (pLed->bLedBlinkInProgress)
+			{
+				_cancel_timer_ex(&(pLed->BlinkTimer));
+				pLed->bLedBlinkInProgress = false;
+			}
+
+			SwLedOff(padapter, pLed);
+			break;
+
+		default:
+			break;
+
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("Led %d\n", pLed->CurrLedState));
+}
+
+/*  */
+/*	Description: */
+/*		Dispatch LED action according to pHalData->LedStrategy. */
+/*  */
+static void LedControl871x(
+	struct rtw_adapter				*padapter,
+	enum LED_CTL_MODE		LedAction
+	)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+       if ((padapter->bSurpriseRemoved == true) || (padapter->bDriverStopped == true))
+       {
+             return;
+       }
+
+	if (ledpriv->bRegUseLed == false)
+		return;
+
+	if (	padapter->pwrctrlpriv.rf_pwrstate != rf_on &&
+		(LedAction == LED_CTL_TX || LedAction == LED_CTL_RX ||
+		 LedAction == LED_CTL_SITE_SURVEY ||
+		 LedAction == LED_CTL_LINK ||
+		 LedAction == LED_CTL_NO_LINK ||
+		 LedAction == LED_CTL_POWER_ON))
+	{
+		return;
+	}
+
+	switch (ledpriv->LedStrategy)
+	{
+		case SW_LED_MODE0:
+			break;
+
+		case SW_LED_MODE1:
+			SwLedControlMode1(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE2:
+			SwLedControlMode2(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE3:
+			SwLedControlMode3(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE4:
+			SwLedControlMode4(padapter, LedAction);
+			break;
+
+		case SW_LED_MODE5:
+			SwLedControlMode5(padapter, LedAction);
+			break;
+
+		default:
+			break;
+	}
+
+	RT_TRACE(_module_rtl8712_led_c_,_drv_info_,("LedStrategy:%d, LedAction %d\n", ledpriv->LedStrategy,LedAction));
+}
+
+/*  */
+/*  Interface to manipulate LED objects. */
+/*  */
+
+/*  */
+/*	Description: */
+/*		Initialize all struct LED_871X objects. */
+/*  */
+void rtl8192du_InitSwLeds(struct rtw_adapter	*padapter)
+{
+	struct led_priv *pledpriv = &(padapter->ledpriv);
+
+	pledpriv->LedControlHandler = LedControl871x;
+
+	InitLed871x(padapter, &(pledpriv->SwLed0), LED_PIN_LED0);
+
+	InitLed871x(padapter,&(pledpriv->SwLed1), LED_PIN_LED1);
+}
+
+/*  */
+/*	Description: */
+/*		DeInitialize all LED_819xUsb objects. */
+/*  */
+void rtl8192du_DeInitSwLeds(struct rtw_adapter *padapter)
+{
+	struct led_priv	*ledpriv = &(padapter->ledpriv);
+
+	DeInitLed871x(&(ledpriv->SwLed0));
+	DeInitLed871x(&(ledpriv->SwLed1));
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192du_recv.c b/drivers/net/wireless/rtl8192du/hal/rtl8192du_recv.c
new file mode 100644
index 0000000..190fcb8
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192du_recv.c
@@ -0,0 +1,157 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192DU_RECV_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <mlme_osdep.h>
+#include <linux/ip.h>
+#include <linux/if_ether.h>
+#include <ethernet.h>
+#include <usb_ops.h>
+#include <wifi.h>
+#include <rtl8192d_hal.h>
+
+void rtl8192du_init_recvbuf(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
+{
+
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+
+	precvbuf->ref_cnt = 0;
+
+	if (precvbuf->pbuf)
+	{
+		precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pbuf;
+		precvbuf->pend = precvbuf->pdata + MAX_RECVBUF_SZ;
+	}
+}
+
+int	rtl8192du_init_recv_priv(struct rtw_adapter *padapter)
+{
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	int	i, res = _SUCCESS;
+	struct recv_buf *precvbuf;
+
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))rtl8192du_recv_tasklet,
+	     (unsigned long)padapter);
+
+	/* init recv_buf */
+	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
+
+	precvpriv->pallocated_recv_buf = kzalloc(NR_RECVBUFF *sizeof(struct recv_buf) + 4, GFP_KERNEL);
+	if (precvpriv->pallocated_recv_buf==NULL) {
+		res= _FAIL;
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("alloc recv_buf fail!\n"));
+		goto exit;
+	}
+
+	precvpriv->precv_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_recv_buf), 4);
+
+	precvbuf = (struct recv_buf*)precvpriv->precv_buf;
+
+	for (i=0; i < NR_RECVBUFF ; i++)
+	{
+		INIT_LIST_HEAD(&precvbuf->list);
+
+		_rtw_spinlock_init(&precvbuf->recvbuf_lock);
+
+		precvbuf->alloc_sz = MAX_RECVBUF_SZ;
+
+		res = rtw_os_recvbuf_resource_alloc(padapter, precvbuf);
+		if (res==_FAIL)
+			break;
+
+		precvbuf->ref_cnt = 0;
+		precvbuf->adapter =padapter;
+		precvbuf++;
+
+	}
+
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	{
+		int i;
+		SIZE_PTR tmpaddr=0;
+		SIZE_PTR alignment=0;
+		struct sk_buff *pskb=NULL;
+
+		skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+
+		for (i=0; i<NR_PREALLOC_RECV_SKB; i++)
+		{
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
+			pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+	#else
+			pskb = netdev_alloc_skb(padapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+	#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) */
+
+			if (pskb)
+			{
+				pskb->dev = padapter->pnetdev;
+
+				tmpaddr = (SIZE_PTR)pskb->data;
+				alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+				skb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));
+
+				skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+			}
+
+			pskb=NULL;
+
+		}
+	}
+#endif
+
+exit:
+
+	return res;
+}
+
+void rtl8192du_free_recv_priv (struct rtw_adapter *padapter)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		rtw_os_recvbuf_resource_free(padapter, precvbuf);
+		precvbuf++;
+	}
+
+	kfree(precvpriv->pallocated_recv_buf);
+
+	if (skb_queue_len(&precvpriv->rx_skb_queue))
+		DBG_8192D(KERN_WARNING "rx_skb_queue not empty\n");
+
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue)) {
+		DBG_8192D(KERN_WARNING "free_recv_skb_queue not empty, %d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+	}
+
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+#endif
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/rtl8192du_xmit.c b/drivers/net/wireless/rtl8192du/hal/rtl8192du_xmit.c
new file mode 100644
index 0000000..3d613d0
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/rtl8192du_xmit.c
@@ -0,0 +1,946 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RTL8192C_XMIT_C_
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+#include <rtl8192d_hal.h>
+#include <rtw_tdls.h>
+#include <rtw_tdls.h>
+
+s32	rtl8192du_init_xmit_priv(struct rtw_adapter *padapter)
+{
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+	     (void(*)(unsigned long))rtl8192du_xmit_tasklet,
+	     (unsigned long)padapter);
+	return _SUCCESS;
+}
+
+void	rtl8192du_free_xmit_priv(struct rtw_adapter *padapter)
+{
+}
+
+static u32 rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe)
+{
+	u32 addr;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	switch (pattrib->qsel) {
+	case 0:
+	case 3:
+		addr = BE_QUEUE_INX;
+		break;
+	case 1:
+	case 2:
+		addr = BK_QUEUE_INX;
+		break;
+	case 4:
+	case 5:
+		addr = VI_QUEUE_INX;
+		break;
+	case 6:
+	case 7:
+		addr = VO_QUEUE_INX;
+		break;
+	case 0x10:
+		addr = BCN_QUEUE_INX;
+		break;
+	case 0x11:/* BC/MC in PS (HIQ) */
+		addr = HIGH_QUEUE_INX;
+		break;
+	case 0x12:
+		addr = MGT_QUEUE_INX;
+		break;
+	default:
+		addr = BE_QUEUE_INX;
+		break;
+	}
+	return addr;
+}
+
+static int urb_zero_packet_chk(struct rtw_adapter *padapter, int sz)
+{
+	int blnSetTxDescOffset;
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
+
+	if (pdvobj->ishighspeed)
+	{
+		if (((sz + TXDESC_SIZE) % 512) == 0) {
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+	else
+	{
+		if (((sz + TXDESC_SIZE) % 64) == 0)		{
+			blnSetTxDescOffset = 1;
+		} else {
+			blnSetTxDescOffset = 0;
+		}
+	}
+
+	return blnSetTxDescOffset;
+}
+
+void rtl8192du_cal_txdesc_chksum(struct tx_desc	*ptxdesc)
+{
+		u16	*usPtr = (u16*)ptxdesc;
+		u32 count = 16;		/*  (32 bytes / 2 bytes per XOR) => 16 times */
+		u32 index;
+		u16 checksum = 0;
+
+		/* Clear first */
+		ptxdesc->txdw7 &= cpu_to_le32(0xffff0000);
+
+		for (index = 0 ; index < count ; index++) {
+			checksum = checksum ^ le16_to_cpu(*(__le16 *)(usPtr + index));
+		}
+
+		ptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);
+}
+
+static void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)
+{
+	if ((pattrib->encrypt > 0) && !pattrib->bswenc)
+	{
+		switch (pattrib->encrypt)
+		{
+			/* SEC_TYPE */
+			case _WEP40_:
+			case _WEP104_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+					break;
+			case _TKIP_:
+			case _TKIP_WTMIC_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);
+					break;
+			case _AES_:
+					ptxdesc->txdw1 |= cpu_to_le32((0x03<<22)&0x00c00000);
+					break;
+			case _NO_PRIVACY_:
+			default:
+					break;
+
+		}
+
+	}
+}
+
+static void fill_txdesc_vcs(struct pkt_attrib *pattrib, __le32 *pdw)
+{
+
+	switch (pattrib->vcs_mode)
+	{
+		case RTS_CTS:
+			*pdw |= cpu_to_le32(BIT(12));
+			break;
+		case CTS_TO_SELF:
+			*pdw |= cpu_to_le32(BIT(11));
+			break;
+		case NONE_VCS:
+		default:
+			break;
+	}
+
+	if (pattrib->vcs_mode) {
+		*pdw |= cpu_to_le32(BIT(13));
+
+		/*  Set RTS BW */
+		if (pattrib->ht_en)
+		{
+			*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(27)):0;
+
+			if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+				*pdw |= cpu_to_le32((0x01<<28)&0x30000000);
+			else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+				*pdw |= cpu_to_le32((0x02<<28)&0x30000000);
+			else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+				*pdw |= 0;
+			else
+				*pdw |= cpu_to_le32((0x03<<28)&0x30000000);
+		}
+	}
+}
+
+static void fill_txdesc_phy(struct pkt_attrib *pattrib, __le32 *pdw)
+{
+
+	if (pattrib->ht_en)
+	{
+		*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40)?	cpu_to_le32(BIT(25)):0;
+
+		if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+			*pdw |= cpu_to_le32((0x01<<20)&0x00300000);
+		else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+			*pdw |= cpu_to_le32((0x02<<20)&0x00300000);
+		else if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+			*pdw |= 0;
+		else
+			*pdw |= cpu_to_le32((0x03<<20)&0x00300000);
+	}
+}
+
+/*
+	Insert Early mode 's Content,8Byte
+Len1	Len0	Pkt_num
+Len4	Len3	Len2
+
+*/
+static void InsertEMContent(struct xmit_frame *pxmitframe, u8 *VirtualAddress)
+{
+	memset(VirtualAddress, 0, 8);
+	SET_EARLYMODE_PKTNUM(VirtualAddress, pxmitframe->EMPktNum);
+	SET_EARLYMODE_LEN0(VirtualAddress, pxmitframe->EMPktLen[0]);
+	SET_EARLYMODE_LEN1(VirtualAddress, pxmitframe->EMPktLen[1]);
+	SET_EARLYMODE_LEN2_1(VirtualAddress, pxmitframe->EMPktLen[2]&0xF);
+	SET_EARLYMODE_LEN2_2(VirtualAddress, pxmitframe->EMPktLen[2]>>4);
+	SET_EARLYMODE_LEN3(VirtualAddress, pxmitframe->EMPktLen[3]);
+	SET_EARLYMODE_LEN4(VirtualAddress, pxmitframe->EMPktLen[4]);
+}
+
+static s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bagg_pkt)
+{
+	int	pull=0;
+	uint	qsel;
+	struct rtw_adapter				*padapter = pxmitframe->padapter;
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(padapter);
+	struct dm_priv		*pdmpriv = &pHalData->dmpriv;
+#ifdef CONFIG_92D_AP_MODE
+	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
+#endif /* CONFIG_92D_AP_MODE */
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct pkt_attrib		*pattrib = &pxmitframe->attrib;
+	struct tx_desc		*ptxdesc = (struct tx_desc *)pmem;
+	int	bmcst = IS_MCAST(pattrib->ra);
+
+	if (padapter->registrypriv.mp_mode == 0) {
+		if ((false == bagg_pkt) && (urb_zero_packet_chk(padapter, sz)==0)) {
+		ptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);
+		pull = 1;
+		pxmitframe->pkt_offset --;
+		}
+	}
+
+	memset(ptxdesc, 0, sizeof(struct tx_desc));
+
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
+
+		qsel = (uint)(pattrib->qsel & 0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
+
+		fill_txdesc_sectype(pattrib, ptxdesc);
+
+		if (pattrib->ampdu_en==true) {
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(5));/* AGG EN */
+			/* Insert Early Mode Content after tx desc position. */
+			if ((pHalData->bEarlyModeEnable) && (true == bagg_pkt)) {
+				ptxdesc->txdw0 |= cpu_to_le32(((USB_HWDESC_HEADER_LEN-8) << OFFSET_SHT) & 0x00ff0000);/* 32 bytes for TX Desc */
+				if (pxmitframe->EMPktNum > 0) {
+					InsertEMContent(pxmitframe, pmem+TXDESC_SIZE);
+				}
+			}
+		}
+		else
+		{
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
+		}
+
+		/* offset 8 */
+
+		/* offset 12 */
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+
+		/* offset 16 , offset 20 */
+		if (pattrib->qos_en)
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(6));/* QoS */
+
+		if ((pattrib->ether_type != 0x888e) && (pattrib->ether_type != 0x0806) && (pattrib->dhcp_pkt != 1))
+		{
+		/* Non EAP & ARP & DHCP type data packet */
+
+			fill_txdesc_vcs(pattrib, &ptxdesc->txdw4);
+			fill_txdesc_phy(pattrib, &ptxdesc->txdw4);
+
+			ptxdesc->txdw4 |= cpu_to_le32(0x00000008);/* RTS Rate=24M */
+			ptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);/*  */
+
+			/* use REG_INIDATA_RATE_SEL value */
+			ptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);
+
+		}
+		else
+		{
+			/*  EAP data packet and ARP packet. */
+			/*  Use the 1M data rate to send the EAP/ARP packet. */
+			/*  This will maybe make the handshake smooth. */
+
+			ptxdesc->txdw1 |= cpu_to_le32(BIT(6));/* AGG BK */
+
+			ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
+
+			if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)
+				ptxdesc->txdw4 |= cpu_to_le32(BIT(24));/*  DATA_SHORT */
+
+			ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
+		}
+
+		/* offset 24 */
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+		if (pattrib->hw_tcp_csum == 1) {
+			u8 ip_hdr_offset = 32 + pattrib->hdrlen + pattrib->iv_len + 8;
+			ptxdesc->txdw7 = (1 << 31) | (ip_hdr_offset << 16);
+			DBG_8192D("ptxdesc->txdw7 = %08x\n", ptxdesc->txdw7);
+		}
+#endif
+	}
+	else if ((pxmitframe->frame_tag&0x0f)== MGNT_FRAMETAG)
+	{
+
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);
+
+		qsel = (uint)(pattrib->qsel&0x0000001f);
+		ptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);
+
+		ptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<< 16) & 0x000f0000);
+
+		/* offset 8 */
+
+		/* CCX-TXRPT ack for xmit mgmt frames. */
+		if (pxmitframe->ack_report) {
+			ptxdesc->txdw2 |= cpu_to_le32(BIT(19));
+			#ifdef DBG_CCX
+			DBG_8192D("%s set ccx\n", __func__);
+			#endif
+		}
+
+		/* offset 12 */
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+
+		/* offset 16 */
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
+
+		/* offset 20 */
+#ifdef CONFIG_92D_AP_MODE
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+			ptxdesc->txdw5 |= cpu_to_le32(BIT(17));/* retry limit enable */
+				ptxdesc->txdw5 |= cpu_to_le32(0x00180000);/* retry limit = 6 */
+		}
+#endif
+
+		ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
+	} else if ((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {
+		DBG_8192D("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
+	} else {
+		DBG_8192D("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
+
+		/* offset 4 */
+		ptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);/* CAM_ID(MAC_ID) */
+
+		ptxdesc->txdw1 |= cpu_to_le32((6<< 16) & 0x000f0000);/* raid */
+
+		/* offset 8 */
+
+		/* offset 12 */
+		ptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);
+
+		/* offset 16 */
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
+
+		/* offset 20 */
+		ptxdesc->txdw5 |= cpu_to_le32(ratetohwrate(pmlmeext->tx_rate));
+	}
+
+	/*  2009.11.05. tynli_test. Suggested by SD4 Filen for FW LPS. */
+	/*  (1) The sequence number of each non-Qos frame / broadcast / multicast / */
+	/*  mgnt frame should be controled by Hw because Fw will also send null data */
+	/*  which we cannot control when Fw LPS enable. */
+	/*  --> default enable non-Qos data sequense number. 2010.06.23. by tynli. */
+	/*  (2) Enable HW SEQ control for beacon packet, because we use Hw beacon. */
+	/*  (3) Use HW Qos SEQ to control the seq num of Ext port non-Qos packets. */
+	/*  2010.06.23. Added by tynli. */
+	if (!pattrib->qos_en)
+	{
+		ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+		ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
+	}
+
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);/* 32 bytes for TX Desc */
+
+	if (bmcst)
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
+	}
+
+	RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("offset0-txdesc=0x%x\n", ptxdesc->txdw0));
+
+	/* offset 4 */
+	/*  pkt_offset, unit:8 bytes padding */
+	if (pxmitframe->pkt_offset > 0)
+		ptxdesc->txdw1 |= cpu_to_le32((pxmitframe->pkt_offset << 26) &
+					      0x7c000000);
+
+	if (pxmitframe->agg_num > 1)
+		ptxdesc->txdw5 |= cpu_to_le32((pxmitframe->agg_num << 24) &
+					      0xff000000);
+
+	rtl8192du_cal_txdesc_chksum(ptxdesc);
+
+	return pull;
+}
+
+s32 rtw_dump_xframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	s32 ret = _SUCCESS;
+	s32 inner_ret = _SUCCESS;
+	int t, sz, w_sz, pull=0;
+	u8 *mem_addr;
+	u32 ff_hwaddr;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	if ((pxmitframe->frame_tag == DATA_FRAMETAG) &&
+	    (pxmitframe->attrib.ether_type != 0x0806) &&
+	    (pxmitframe->attrib.ether_type != 0x888e) &&
+	    (pxmitframe->attrib.dhcp_pkt != 1))
+		rtw_issue_addbareq_cmd(padapter, pxmitframe);
+
+	mem_addr = pxmitframe->buf_addr;
+
+       RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_dump_xframe()\n"));
+
+	for (t = 0; t < pattrib->nr_frags; t++) {
+		if (inner_ret != _SUCCESS && ret == _SUCCESS)
+			ret = _FAIL;
+
+		if (t != (pattrib->nr_frags - 1)) {
+			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("pattrib->nr_frags=%d\n", pattrib->nr_frags));
+
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
+		}
+		else /* no frag */
+		{
+			sz = pattrib->last_txcmdsz;
+		}
+
+		pull = update_txdesc(pxmitframe, mem_addr, sz, false);
+
+		if (pull)
+		{
+			mem_addr += PACKET_OFFSET_SZ; /* pull txdesc head */
+
+			pxmitframe->buf_addr = mem_addr;
+
+			w_sz = sz + TXDESC_SIZE;
+		}
+		else
+		{
+			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
+		}
+
+		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
+
+		inner_ret = rtw_write_port(padapter, ff_hwaddr, w_sz, (unsigned char*)pxmitbuf);
+
+		rtw_count_tx_stats(padapter, pxmitframe, sz);
+
+		RT_TRACE(_module_rtl871x_xmit_c_,_drv_info_,("rtw_write_port, w_sz=%d\n", w_sz));
+
+		mem_addr += w_sz;
+
+		mem_addr = (u8 *)RND4(((SIZE_PTR)(mem_addr)));
+
+	}
+
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+	if  (ret != _SUCCESS)
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);
+
+	return ret;
+}
+
+static u32 xmitframe_need_length(struct xmit_frame *pxmitframe)
+{
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	u32	len = 0;
+
+	/*  no consider fragement */
+	len = pattrib->hdrlen + pattrib->iv_len +
+		SNAP_SIZE + sizeof(u16) +
+		pattrib->pktlen +
+		((pattrib->bswenc) ? pattrib->icv_len : 0);
+
+	if (pattrib->encrypt ==_TKIP_)
+		len += 8;
+
+	return len;
+}
+
+static void UpdateEarlyModeInfo8192D(struct rtw_adapter *padapter,
+				     struct xmit_frame *pxmitframe,
+				     struct tx_servq *ptxservq)
+{
+	u32	len;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
+	struct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;
+
+	/* Some macaddr can't do early mode. */
+	if (MacAddr_isBcst(pattrib->dst) ||IS_MCAST(pattrib->dst) || !!pattrib->qos_en)
+		return;
+
+	pxmitframe->EMPktNum = 0;
+
+	/*  dequeue same priority packet from station tx queue */
+	spin_lock_bh(&pxmitpriv->lock);
+
+	xmitframe_phead = get_list_head(&ptxservq->sta_pending);
+	xmitframe_plist = xmitframe_phead->next;
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist) == false)&&(pxmitframe->EMPktNum < 5))
+	{
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+		xmitframe_plist = xmitframe_plist->next;
+
+		len = xmitframe_need_length(pxmitframe);
+		pxmitframe->EMPktLen[pxmitframe->EMPktNum] = len;
+		pxmitframe->EMPktNum++;
+	}
+	spin_unlock_bh(&pxmitpriv->lock);
+}
+
+#define IDEA_CONDITION 1	/*  check all packets before enqueue */
+s32 rtl8192du_xmitframe_complete(struct rtw_adapter *padapter, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	struct xmit_frame *pxmitframe = NULL;
+	struct xmit_frame *pfirstframe = NULL;
+
+	/*  aggregate variable */
+	struct hw_xmit	*phwxmit = pxmitpriv->hwxmits;
+	struct tx_servq	*ptxservq = NULL;
+
+	struct list_head *xmitframe_plist = NULL, *xmitframe_phead = NULL;
+
+	u32	pbuf=0; /*  next pkt address */
+	u32	pbuf_tail; /*  last pkt tail */
+	u32	len=0; /* packet length, except TXDESC_SIZE and PKT_OFFSET */
+	u32	aggMaxLength = MAX_XMITBUF_SZ;
+	u32	bulkSize = pHalData->UsbBulkOutSize;
+	u32	bulkPtr=0;
+	u8	descCount=0;
+	u8	ac_index;
+	u8	bfirst = true;/* first aggregation xmitframe */
+	u8	bulkstart = false;
+
+	/*  dump frame variable */
+	u32 ff_hwaddr;
+
+#ifndef IDEA_CONDITION
+	int res = _SUCCESS;
+#endif
+
+	RT_TRACE(_module_rtl8192c_xmit_c_, _drv_info_, ("+xmitframe_complete\n"));
+
+	/*  check xmitbuffer is ok */
+	if (pxmitbuf == NULL) {
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+		if (pxmitbuf == NULL) return false;
+	}
+
+	if (pHalData->MacPhyMode92D==SINGLEMAC_SINGLEPHY)
+		aggMaxLength = MAX_XMITBUF_SZ;
+	else
+		aggMaxLength = 0x3D00;
+
+	do {
+		/* 3 1. pick up first frame */
+		if (bfirst)
+		{
+			pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry);
+			if (pxmitframe == NULL) {
+				/*  no more xmit frame, release xmit buffer */
+				rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+				return false;
+			}
+
+			pxmitframe->pxmitbuf = pxmitbuf;
+			pxmitframe->buf_addr = pxmitbuf->pbuf;
+			pxmitbuf->priv_data = pxmitframe;
+
+			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET; /*  first frame of aggregation, reserve 2 offset for 512 alignment and early mode */
+
+			pfirstframe = pxmitframe;
+			spin_lock_bh(&pxmitpriv->lock);
+			ptxservq = rtw_get_sta_pending(padapter, pfirstframe->attrib.psta, pfirstframe->attrib.priority, (u8 *)(&ac_index));
+			spin_unlock_bh(&pxmitpriv->lock);
+		}
+		/* 3 2. aggregate same priority and same DA(AP or STA) frames */
+		else
+		{
+			/*  dequeue same priority packet from station tx queue */
+			spin_lock_bh(&pxmitpriv->lock);
+
+			if (_rtw_queue_empty(&ptxservq->sta_pending) == false)
+			{
+				xmitframe_phead = get_list_head(&ptxservq->sta_pending);
+				xmitframe_plist = xmitframe_phead->next;
+
+				pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+				len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + ((USB_92D_DUMMY_OFFSET - 1) * PACKET_OFFSET_SZ);
+				if (pbuf + _RND8(len) > aggMaxLength)
+				{
+					bulkstart = true;
+				}
+				else
+				{
+					list_del_init(&pxmitframe->list);
+					ptxservq->qcnt--;
+					phwxmit[ac_index].accnt--;
+
+					/* Remove sta node when there is no pending packets. */
+					if (_rtw_queue_empty(&ptxservq->sta_pending) == true)
+						list_del_init(&ptxservq->tx_pending);
+				}
+			}
+			else
+			{
+				bulkstart = true;
+			}
+
+			spin_unlock_bh(&pxmitpriv->lock);
+
+			if (bulkstart)
+			{
+				break;
+			}
+
+			pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
+
+			pxmitframe->agg_num = 0; /*  not first frame of aggregation */
+			pxmitframe->pkt_offset = USB_92D_DUMMY_OFFSET - 1; /*  not first frame of aggregation, reserve 1 offset for early mode */
+		}
+
+		if (pHalData->bEarlyModeEnable)
+			UpdateEarlyModeInfo8192D(padapter, pxmitframe,ptxservq);
+
+#ifdef IDEA_CONDITION
+		rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+#else
+		res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+		if (res == false) {
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+		/*  always return ndis_packet after rtw_xmitframe_coalesce */
+		rtw_os_xmit_complete(padapter, pxmitframe);
+
+		if (bfirst)
+		{
+			len = xmitframe_need_length(pfirstframe) + USB_HWDESC_HEADER_LEN;
+			pbuf_tail = len;
+			pbuf = _RND8(pbuf_tail);
+
+			descCount = 0;
+			bulkPtr = bulkSize;
+			bfirst = false;
+		}
+		else
+		{
+			update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->attrib.last_txcmdsz, true);
+
+			/*  don't need xmitframe any more */
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+			/*  handle pointer and stop condition */
+			pbuf_tail = pbuf + len;
+			pbuf = _RND8(pbuf_tail);
+
+			pfirstframe->agg_num++;
+			if (MAX_TX_AGG_PACKET_NUMBER == pfirstframe->agg_num)
+				break;
+		}
+
+		/*  check pkt amount in one bluk */
+		if (pbuf < bulkPtr)
+		{
+			descCount++;
+			if (descCount == pHalData->UsbTxAggDescNum)
+				break;
+		}
+		else
+		{
+			descCount = 0;
+			bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize; /*  round to next bulkSize */
+		}
+	} while (1);
+
+	if ((pfirstframe->attrib.ether_type != 0x0806) &&
+	    (pfirstframe->attrib.ether_type != 0x888e) &&
+	    (pfirstframe->attrib.dhcp_pkt != 1))
+	{
+		rtw_issue_addbareq_cmd(padapter, pfirstframe);
+	}
+
+	/* 3 3. update first frame txdesc */
+	if ((pbuf_tail % bulkSize) == 0) {
+		/*  remove 1 pkt_offset */
+		pbuf_tail -= PACKET_OFFSET_SZ;
+		pfirstframe->buf_addr += PACKET_OFFSET_SZ;
+		pfirstframe->pkt_offset--;
+	}
+	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->attrib.last_txcmdsz, true);
+
+	/* 3 4. write xmit buffer to USB FIFO */
+	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
+
+	rtw_write_port(padapter, ff_hwaddr, pbuf_tail, (u8*)pxmitbuf);
+
+	/* 3 5. update statisitc */
+	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
+	pbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);
+
+	rtw_count_tx_stats(padapter, pfirstframe, pbuf_tail);
+
+	rtw_free_xmitframe(pxmitpriv, pfirstframe);
+
+	return true;
+}
+
+static s32 xmitframe_direct(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	s32 res = _SUCCESS;
+
+	res = rtw_xmitframe_coalesce(padapter, pxmitframe->pkt, pxmitframe);
+	if (res == _SUCCESS) {
+		rtw_dump_xframe(padapter, pxmitframe);
+	}
+
+	return res;
+}
+
+/*	Return
+ *	true	dump packet directly
+ *	false	enqueue packet
+ */
+static s32 pre_xmitframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	s32 res;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	if (rtw_txframes_sta_ac_pending(padapter, pattrib) > 0
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		|| (dc_check_xmit(padapter)== false)
+#endif
+		)
+		goto enqueue;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+		goto enqueue;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+		goto enqueue;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+	if (pxmitbuf == NULL)
+		goto enqueue;
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+	pxmitbuf->priv_data = pxmitframe;
+
+	if (xmitframe_direct(padapter, pxmitframe) != _SUCCESS) {
+		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	}
+
+	return true;
+
+enqueue:
+	res = rtw_xmitframe_enqueue(padapter, pxmitframe);
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	if (res != _SUCCESS) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("pre_xmitframe: enqueue xmitframe fail\n"));
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+		/*  Trick, make the statistics correct */
+		pxmitpriv->tx_pkts--;
+		pxmitpriv->tx_drop++;
+		return true;
+	}
+
+	return false;
+}
+
+s32 rtl8192du_mgnt_xmit(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe)
+{
+	return rtw_dump_xframe(padapter, pmgntframe);
+}
+
+/*
+ * Return
+ *	true	dump packet directly ok
+ *	false	temporary can't transmit packets to hardware
+ */
+s32 rtl8192du_hal_xmit(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe)
+{
+	return pre_xmitframe(padapter, pxmitframe);
+}
+
+#ifdef  CONFIG_HOSTAPD_MLME
+
+static void rtl8192du_hostap_mgnt_xmit_cb(struct urb *urb)
+{
+	struct sk_buff *skb = (struct sk_buff *)urb->context;
+
+	dev_kfree_skb_any(skb);
+}
+
+s32 rtl8192du_hostap_mgnt_xmit_entry(struct rtw_adapter *padapter, struct sk_buff *pkt)
+{
+	u16 fc;
+	int rc, len, pipe;
+	unsigned int bmcst, tid, qsel;
+	struct sk_buff *skb, *pxmit_skb;
+	struct urb *urb;
+	unsigned char *pxmitbuf;
+	struct tx_desc *ptxdesc;
+	struct rtw_ieee80211_hdr *tx_hdr;
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
+	struct net_device *pnetdev = padapter->pnetdev;
+	struct hal_data_8192du  *pHalData = GET_HAL_DATA(padapter);
+	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+
+	skb = pkt;
+	len = skb->len;
+	tx_hdr = (struct rtw_ieee80211_hdr *)(skb->data);
+	fc = le16_to_cpu(tx_hdr->frame_ctl);
+	bmcst = IS_MCAST(tx_hdr->addr1);
+
+	if ((fc & RTW_IEEE80211_FCTL_FTYPE) != RTW_IEEE80211_FTYPE_MGMT)
+		goto _exit;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
+	pxmit_skb = dev_alloc_skb(len + TXDESC_SIZE);
+#else
+	pxmit_skb = netdev_alloc_skb(pnetdev, len + TXDESC_SIZE);
+#endif
+
+	if (!pxmit_skb)
+		goto _exit;
+
+	pxmitbuf = pxmit_skb->data;
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb) {
+		goto _exit;
+	}
+
+	/*  ----- fill tx desc ----- */
+	ptxdesc = (struct tx_desc *)pxmitbuf;
+	memset(ptxdesc, 0, sizeof(*ptxdesc));
+
+	/* offset 0 */
+	ptxdesc->txdw0 |= cpu_to_le32(len&0x0000ffff);
+	ptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);/* default = 32 bytes for TX Desc */
+	ptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);
+
+	if (bmcst)
+	{
+		ptxdesc->txdw0 |= cpu_to_le32(BIT(24));
+	}
+
+	/* offset 4 */
+	ptxdesc->txdw1 |= cpu_to_le32(0x00);/* MAC_ID */
+
+	ptxdesc->txdw1 |= cpu_to_le32((0x12<<QSEL_SHT)&0x00001f00);
+
+	ptxdesc->txdw1 |= cpu_to_le32((0x06<< 16) & 0x000f0000);/* b mode */
+
+	/* offset 8 */
+
+	/* offset 12 */
+	ptxdesc->txdw3 |= cpu_to_le32((le16_to_cpu(tx_hdr->seq_ctl)<<16)&0xffff0000);
+
+	/* offset 16 */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(8));/* driver uses rate */
+
+	/* offset 20 */
+
+	/* HW append seq */
+	ptxdesc->txdw4 |= cpu_to_le32(BIT(7)); /*  Hw set sequence number */
+	ptxdesc->txdw3 |= cpu_to_le32((8 <<28)); /* set bit3 to 1. Suugested by TimChen. 2009.12.29. */
+
+	rtl8192du_cal_txdesc_chksum(ptxdesc);
+	/*  ----- end of fill tx desc ----- */
+
+	/*  */
+	skb_put(pxmit_skb, len + TXDESC_SIZE);
+	pxmitbuf = pxmitbuf + TXDESC_SIZE;
+	memcpy(pxmitbuf, skb->data, len);
+
+	/*  ----- prepare urb for submit ----- */
+
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = usb_sndbulkpipe(pdvobj->pusbdev, pHalData->Queue2EPNum[(u8)MGT_QUEUE_INX]&0x0f);
+	usb_fill_bulk_urb(urb, pdvobj->pusbdev, pipe,
+		pxmit_skb->data, pxmit_skb->len, rtl8192du_hostap_mgnt_xmit_cb, pxmit_skb);
+
+	urb->transfer_flags |= URB_ZERO_PACKET;
+	usb_anchor_urb(urb, &phostapdpriv->anchored);
+	rc = usb_submit_urb(urb, GFP_ATOMIC);
+	if (rc < 0) {
+		usb_unanchor_urb(urb);
+		kfree_skb(skb);
+	}
+	usb_free_urb(urb);
+
+_exit:
+
+	dev_kfree_skb_any(skb);
+	return 0;
+}
+#endif
diff --git a/drivers/net/wireless/rtl8192du/hal/usb_halinit.c b/drivers/net/wireless/rtl8192du/hal/usb_halinit.c
new file mode 100644
index 0000000..c5fa1d6
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/usb_halinit.c
@@ -0,0 +1,5052 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _HCI_HAL_INIT_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <hal_intf.h>
+#include <rtw_efuse.h>
+
+#include <rtl8192d_hal.h>
+#include <rtl8192d_led.h>
+#include <usb_ops.h>
+#include <usb_hal.h>
+#include <usb_osintf.h>
+
+#if DISABLE_BB_RF
+	#define		HAL_MAC_ENABLE	0
+	#define		HAL_BB_ENABLE		0
+	#define		HAL_RF_ENABLE		0
+#else
+	#define		HAL_MAC_ENABLE	1
+	#define		HAL_BB_ENABLE		1
+	#define		HAL_RF_ENABLE		1
+#endif
+
+/* endpoint number 1, 2, 3, 4, 5 */
+/*  bult in : 1 */
+/*  bult out: 2 (High) */
+/*  bult out: 3 (Normal) for 3 out_ep, (Low) for 2 out_ep */
+/*  interrupt in: 4 */
+/*  bult out: 5 (Low) for 3 out_ep */
+
+static void
+_OneOutEpMapping(
+	struct hal_data_8192du *pHalData
+	)
+{
+	/* only endpoint number 0x02 */
+
+	pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+	pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+	pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[0];/* BE */
+	pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];/* BK */
+
+	pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+	pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+	pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+	pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
+}
+
+static void
+_TwoOutEpMapping(
+	struct hal_data_8192du	*pHalData,
+	bool			bWIFICfg
+	)
+{
+
+	if (bWIFICfg) { /*  Normal chip && wmm */
+
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA */
+		/*   0,		1,	0,	1,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number = 0x02), 1:L (end_number = 0x03) */
+
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[1];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[0];/* BK */
+
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
+
+	}
+	else {/* typical setting */
+
+		/* BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA */
+		/*   1,		1,	0,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number = 0x02), 1:L (end_number = 0x03) */
+
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[0];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[1];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];/* BK */
+
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
+
+	}
+}
+
+static void _ThreeOutEpMapping(
+	struct hal_data_8192du *pHalData,
+	bool			bWIFICfg
+	)
+{
+	if (bWIFICfg) {/* for WMM */
+
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA */
+		/*   1,		2,	1,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number = 0x02), 1:N(end_number = 0x03), 2:L (end_number = 0x05) */
+
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[1];/* BK */
+
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
+
+	}
+	else {/* typical setting */
+
+		/*	BK,	BE,	VI,	VO,	BCN,	CMD, MGT, HIGH, HCCA */
+		/*   2,		2,	1,	0,	0,	0,	0,	0,		0	}; */
+		/* 0:H(end_number = 0x02), 1:N(end_number = 0x03), 2:L (end_number = 0x05) */
+
+		pHalData->Queue2EPNum[0] = pHalData->RtBulkOutPipe[0];/* VO */
+		pHalData->Queue2EPNum[1] = pHalData->RtBulkOutPipe[1];/* VI */
+		pHalData->Queue2EPNum[2] = pHalData->RtBulkOutPipe[2];/* BE */
+		pHalData->Queue2EPNum[3] = pHalData->RtBulkOutPipe[2];/* BK */
+
+		pHalData->Queue2EPNum[4] = pHalData->RtBulkOutPipe[0];/* TS */
+		pHalData->Queue2EPNum[5] = pHalData->RtBulkOutPipe[0];/* MGT */
+		pHalData->Queue2EPNum[6] = pHalData->RtBulkOutPipe[0];/* BMC */
+		pHalData->Queue2EPNum[7] = pHalData->RtBulkOutPipe[0];/* BCN */
+	}
+}
+
+static bool
+_MappingOutEP(
+	struct rtw_adapter *	adapter,
+	u8		NumOutPipe
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+	bool	 bWIFICfg = (pregistrypriv->wifi_spec) ?true:false;
+
+	bool result = true;
+
+	switch (NumOutPipe)
+	{
+		case 2:
+			_TwoOutEpMapping(pHalData, bWIFICfg);
+			break;
+		case 3:
+			_ThreeOutEpMapping(pHalData, bWIFICfg);
+			break;
+		case 1:
+			_OneOutEpMapping(pHalData);
+			break;
+		default:
+			result = false;
+			break;
+	}
+
+	return result;
+}
+
+static void
+_ConfigChipOutEP(
+	struct rtw_adapter *	adapter,
+	u8		NumOutPipe
+	)
+{
+	u8			value8;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	pHalData->OutEpQueueSel = 0;
+	pHalData->OutEpNumber = 0;
+
+	/*  Normal and High queue */
+	if (pHalData->interfaceIndex == 0)
+		value8 = rtw_read8(adapter, REG_USB_High_NORMAL_Queue_Select_MAC0);
+	else
+		value8 = rtw_read8(adapter, REG_USB_High_NORMAL_Queue_Select_MAC1);
+
+	if (value8 & USB_NORMAL_SIE_EP_MASK) {
+		pHalData->OutEpQueueSel |= TX_SELE_HQ;
+		pHalData->OutEpNumber++;
+	}
+
+	if ((value8 >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK) {
+		pHalData->OutEpQueueSel |= TX_SELE_NQ;
+		pHalData->OutEpNumber++;
+	}
+
+	/*  Low queue */
+	if (pHalData->interfaceIndex == 0)
+		value8 = rtw_read8(adapter, (REG_USB_High_NORMAL_Queue_Select_MAC0+1));
+	else
+		value8 = rtw_read8(adapter, (REG_USB_High_NORMAL_Queue_Select_MAC1+1));
+
+	if (value8 & USB_NORMAL_SIE_EP_MASK) {
+		pHalData->OutEpQueueSel |= TX_SELE_LQ;
+		pHalData->OutEpNumber++;
+	}
+
+	/* add for 0xfe44 0xfe45 0xfe47 0xfe48 not validly */
+	switch (NumOutPipe) {
+		case 3:
+			pHalData->OutEpQueueSel = TX_SELE_HQ| TX_SELE_LQ|TX_SELE_NQ;
+			pHalData->OutEpNumber = 3;
+			break;
+		case 2:
+			pHalData->OutEpQueueSel = TX_SELE_HQ| TX_SELE_NQ;
+			pHalData->OutEpNumber = 2;
+			break;
+		case 1:
+			pHalData->OutEpQueueSel = TX_SELE_HQ;
+			pHalData->OutEpNumber = 1;
+			break;
+		default:
+			break;
+	}
+
+	/*  TODO: Error recovery for this case */
+	/* RT_ASSERT((NumOutPipe == pHalData->OutEpNumber), ("Out EP number isn't match! %d(Descriptor) != %d (SIE reg)\n", (u4Byte)NumOutPipe, (u4Byte)pHalData->OutEpNumber)); */
+}
+
+static bool HalUsbSetQueuePipeMapping8192DUsb(
+	struct rtw_adapter *	adapter,
+	u8		NumInPipe,
+	u8		NumOutPipe
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	bool			result		= false;
+
+	_ConfigChipOutEP(adapter, NumOutPipe);
+
+	/*  Normal chip with one IN and one OUT doesn't have interrupt IN EP. */
+	if (1 == pHalData->OutEpNumber) {
+		if (1 != NumInPipe) {
+			return result;
+		}
+	}
+
+	result = _MappingOutEP(adapter, NumOutPipe);
+
+	return result;
+}
+
+static void rtl8192du_interface_configure(struct rtw_adapter *padapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+
+	if (pdvobjpriv->ishighspeed == true)
+	{
+		pHalData->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;/* 512 bytes */
+	}
+	else
+	{
+		pHalData->UsbBulkOutSize = USB_FULL_SPEED_BULK_SIZE;/* 64 bytes */
+	}
+
+	pHalData->interfaceIndex = pdvobjpriv->InterfaceNumber;
+	pHalData->RtBulkInPipe = pdvobjpriv->ep_num[0];
+	pHalData->RtBulkOutPipe[0] = pdvobjpriv->ep_num[1];
+	pHalData->RtBulkOutPipe[1] = pdvobjpriv->ep_num[2];
+	pHalData->RtIntInPipe = pdvobjpriv->ep_num[3];
+	pHalData->RtBulkOutPipe[2] = pdvobjpriv->ep_num[4];
+	pHalData->UsbTxAggMode = 1;
+	pHalData->UsbTxAggDescNum = 0x4;	/*  only 4 bits */
+
+	pHalData->UsbRxAggMode = USB_RX_AGG_DMA;/*  USB_RX_AGG_DMA; */
+	pHalData->UsbRxAggBlockCount	= 8; /* unit : 512b */
+	pHalData->UsbRxAggBlockTimeout = 0x6;
+	pHalData->UsbRxAggPageCount	= 48; /* uint :128 b 0x0A;	10 = MAX_RX_DMA_BUFFER_SIZE/2/pHalData->UsbBulkOutSize */
+	pHalData->UsbRxAggPageTimeout = 0x6; /* 6, absolute time = 34ms/(2^6) */
+
+	HalUsbSetQueuePipeMapping8192DUsb(padapter,
+				pdvobjpriv->RtNumInPipes, pdvobjpriv->RtNumOutPipes);
+}
+
+static u8 _InitPowerOn(struct rtw_adapter *padapter)
+{
+	u8	ret = _SUCCESS;
+	u16	value16 = 0;
+	u8	value8 = 0;
+
+	/*  polling autoload done. */
+	u32	pollingCount = 0;
+
+	if (padapter->bSurpriseRemoved) {
+		return _FAIL;
+	}
+
+	pollingCount = 0;
+	do
+	{
+		if (rtw_read8(padapter, REG_APS_FSMCO) & PFM_ALDN) {
+			/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Autoload Done!\n")); */
+			break;
+		}
+
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\n")); */
+			return _FAIL;
+		}
+
+	}while (true);
+
+	/* For hardware power on sequence. */
+	/* 0.	RSV_CTRL 0x1C[7:0] = 0x00			unlock ISO/CLK/Power control register */
+	rtw_write8(padapter, REG_RSV_CTRL, 0x0);
+	/*  Power on when re-enter from IPS/Radio off/card disable */
+	rtw_write8(padapter, REG_SPS0_CTRL, 0x2b);/* enable SPS into PWM mode */
+	rtw_usleep_os(100);/* PlatformSleepUs(150);this is not necessary when initially power on */
+
+	value8 = rtw_read8(padapter, REG_LDOV12D_CTRL);
+	if (0 == (value8 & LDV12_EN)) {
+		value8 |= LDV12_EN;
+		rtw_write8(padapter, REG_LDOV12D_CTRL, value8);
+		/* RT_TRACE(COMP_INIT, DBG_LOUD, (" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x.\n", value8)); */
+		rtw_usleep_os(100);/* PlatformSleepUs(100);this is not necessary when initially power on */
+		value8 = rtw_read8(padapter, REG_SYS_ISO_CTRL);
+		value8 &= ~ISO_MD2PP;
+		rtw_write8(padapter, REG_SYS_ISO_CTRL, value8);
+	}
+
+	/*  auto enable WLAN */
+	pollingCount = 0;
+	value16 = rtw_read16(padapter, REG_APS_FSMCO);
+	value16 |= APFM_ONMAC;
+	rtw_write16(padapter, REG_APS_FSMCO, value16);
+
+	do
+	{
+		if (0 == (rtw_read16(padapter, REG_APS_FSMCO) & APFM_ONMAC)) {
+			/* RT_TRACE(COMP_INIT, DBG_LOUD, ("MAC auto ON okay!\n")); */
+			break;
+		}
+
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\n")); */
+			return _FAIL;
+		}
+
+	}while (true);
+
+	/*  release RF digital isolation */
+	value16 = rtw_read16(padapter, REG_SYS_ISO_CTRL);
+	value16 &= ~ISO_DIOR;
+	rtw_write16(padapter, REG_SYS_ISO_CTRL, value16);
+
+	/*  Enable MAC DMA/WMAC/SCHEDULE/SEC block */
+	value16 = rtw_read16(padapter, REG_CR);
+	value16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN
+				| PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);
+	rtw_write16(padapter, REG_CR, value16);
+
+	return ret;
+}
+
+static u16 CRC16(u8 data, u16 CRC)
+{
+	unsigned char shift_in, CRC_BIT15, DataBit, CRC_BIT11, CRC_BIT4 ;
+	int index;
+	unsigned short CRC_Result;
+
+	for (index = 0;index<8;index++)
+	{
+		CRC_BIT15 = ((CRC&BIT15) ? 1:0);
+		DataBit  = (data&(BIT0<<index) ? 1:0);
+		shift_in = CRC_BIT15^DataBit;
+		/* printf("CRC_BIT15 =%d, DataBit =%d, shift_in =%d\n", CRC_BIT15, DataBit, shift_in); */
+
+		CRC_Result = CRC<<1;
+		/* set BIT0 */
+		/*	printf("CRC =%x\n", CRC_Result); */
+		/* CRC bit 0 = shift_in, */
+		if (shift_in == 0)
+		{
+			CRC_Result&= (~BIT0);
+		}
+		else
+		{
+			CRC_Result|= BIT0;
+		}
+		/* printf("CRC =%x\n", CRC_Result); */
+
+		CRC_BIT11 = ((CRC&BIT11) ? 1:0)^shift_in;
+		if (CRC_BIT11 == 0)
+		{
+			CRC_Result&= (~BIT12);
+		}
+		else
+		{
+			CRC_Result|= BIT12;
+		}
+		/* printf("bit12 CRC =%x\n", CRC_Result); */
+
+		CRC_BIT4 = ((CRC&BIT4) ? 1:0)^shift_in;
+		if (CRC_BIT4 == 0)
+		{
+			CRC_Result&= (~BIT5);
+		}
+		else
+		{
+			CRC_Result|= BIT5;
+		}
+		/* printf("bit5 CRC =%x\n", CRC_Result); */
+
+		CRC = CRC_Result; /* repeat using the last result */
+	}
+
+	return CRC;
+}
+
+/*  */
+/*  */
+/* function name :calc_crc */
+/*  */
+/* input         : char* pattern , pattern size */
+/*  */
+/*  */
+static u16 calc_crc(u8 *pdata, int length)
+{
+/*     unsigned char data[2]={0xC6, 0xAA}; */
+	u16 CRC = 0xffff;
+	int i;
+
+	for (i = 0;i<length;i++)
+	{
+		CRC = CRC16(pdata[i], CRC);
+	}
+
+	CRC =~CRC;                  /* get 1' complement */
+	DBG_8192D("CRC =%x\n", CRC);
+	return CRC;
+}
+
+#ifdef CONFIG_WOWLAN
+static int rtw_wowlan_set_pattern(struct rtw_adapter *padapter , u8 *pbuf) {
+	struct pwrctrl_priv *pwrpriv =&padapter->pwrctrlpriv;
+	int res = 0, crc_idx;
+	u32 content = 0, cmd = 0;
+	u32 *pdata;
+	u8 config, crc, mc, bc, uc, idx, pattern_len, packet[200], packet_len, valid;
+	u16 crc_val = 0, i;
+
+	config = pbuf[0];
+	bc = config & BIT(3)?1:0;
+	mc = config & BIT(4)?1:0;
+	uc = config & BIT(5)?1:0;
+	idx = config & 0x7;
+	crc = config & BIT(6)?1:0;
+	valid = config & BIT(7)?1:0;
+	pattern_len = pbuf[1];
+	packet_len = pattern_len*8;
+	pdata = (u32 *)pbuf;
+
+	/*  Write to the Wakeup CAM */
+	/* offset 0 */
+	if (pattern_len>= 4) {
+		content = pdata[1];
+	}
+	else {
+		content = 0;
+	}
+	DBG_8192D("\nrtw_wowlan_set_pattern offset[0]  content  0x%x  [cpu_to_le32  0x%x]\n", content, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
+	pwrpriv->wowlan_pattern_context[idx][0]= __cpu_to_le32(content);
+	/* cmd = BIT(31)|BIT(16)|(idx+0); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 4 */
+	if (pattern_len>= 8) {
+		content = pdata[2];
+	}
+	else {
+		content = 0;
+	}
+	DBG_8192D("rtw_wowlan_set_pattern offset[4]  content  0x%x  [cpu_to_le32  0x%x]\n", content, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
+	pwrpriv->wowlan_pattern_context[idx][1]= __cpu_to_le32(content);
+
+	/* cmd = BIT(31)|BIT(16)|(idx+1); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 8 */
+	if (pattern_len>= 12) {
+		content = pdata[3];
+	}
+	else {
+		content = 0;
+	}
+	DBG_8192D("rtw_wowlan_set_pattern offset[8]  content  0x%x  [cpu_to_le32  0x%x]\n", content, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
+	pwrpriv->wowlan_pattern_context[idx][2]= __cpu_to_le32(content);
+	/* cmd = BIT(31)|BIT(16)|(idx+2); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	/* offset 12 */
+	if (pattern_len>= 16) {
+		content = pdata[4];
+	}
+	else {
+		content = 0;
+	}
+	DBG_8192D("rtw_wowlan_set_pattern offset[12]  content  0x%x  [cpu_to_le32  0x%x]\n", content, __cpu_to_le32(content));
+	/* rtw_write32(padapter, REG_WKFMCAM_RWD, __cpu_to_le32(content)); */
+	pwrpriv->wowlan_pattern_context[idx][3]= __cpu_to_le32(content);
+	/* cmd = BIT(31)|BIT(16)|(idx+3); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+
+	if (crc) {
+		/*  Have the CRC value */
+		crc_val =*(u16 *)(&pbuf[2]);
+		DBG_8192D("rtw_wowlan_set_pattern crc_val  0x%x\n", crc_val);
+		crc_val = __cpu_to_le16(crc_val);
+		DBG_8192D("rtw_wowlan_set_pattern crc_val  after 0x%x\n", crc_val);
+	}
+	else {
+		DBG_8192D("+rtw_wowlan_set_pattern   crc = 0[%x]  Should calculate the CRC\n", crc);
+		/*  calculate the CRC the write to the Wakeup CAM */
+		crc_idx = 0;
+		for (i = 0;i<packet_len;i++) {
+			if (pbuf[4+(i/8)]&(0x01<<(i%8)))
+			{
+				packet[crc_idx++]= pbuf[20+i];
+		/*		DBG_8192D("\n i =%d packet[i]=%x pbuf[20+i(%d)]=%x\n", i, packet[i], 20+i, pbuf[20+i]); */
+			}
+		}
+		crc_val = calc_crc(packet, crc_idx);
+		DBG_8192D("+rtw_wowlan_set_pattern   crc_val = 0x%.8x\n", crc_val);
+
+	}
+
+	/* offset 16 */
+	content = (valid<<31)| (bc<<26)|(mc<<25)|(uc<<24) |crc_val;
+	printk("rtw_wowlan_set_pattern offset[16]  content  0x%x\n", content);
+	rtw_write32(padapter, REG_WKFMCAM_RWD, content);
+	pwrpriv->wowlan_pattern_context[idx][4]= content;
+	/* cmd = BIT(31)|BIT(16)|(idx+4); */
+	/* rtw_write32(padapter, REG_WKFMCAM_CMD, cmd); */
+	pwrpriv->wowlan_pattern_idx|= BIT(idx);
+
+_rtw_wowlan_set_pattern_exit:
+	return res;
+}
+
+void rtw_wowlan_reload_pattern(struct rtw_adapter *padapter) {
+	struct pwrctrl_priv *pwrpriv =&padapter->pwrctrlpriv;
+	u32 content = 0, cmd = 0;
+	u8 idx;
+
+	for (idx = 0;idx<8;idx ++) {
+		if (pwrpriv->wowlan_pattern_idx & BIT(idx)) {
+			/* offset 0 */
+			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][0]);
+			cmd = BIT(31)|BIT(16)|(idx+0);
+			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+			/* offset 4 */
+			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][1]);
+			cmd = BIT(31)|BIT(16)|(idx+1);
+			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+			/* offset 8 */
+			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][2]);
+			cmd = BIT(31)|BIT(16)|(idx+2);
+			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+			/* offset 12 */
+			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][3]);
+			cmd = BIT(31)|BIT(16)|(idx+3);
+			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+			/* offset 16 */
+			rtw_write32(padapter, REG_WKFMCAM_RWD, pwrpriv->wowlan_pattern_context[idx][4]);
+			cmd = BIT(31)|BIT(16)|(idx+4);
+			rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+
+		}
+		DBG_8192D("print WOWCAM  idx =%d\n", idx);
+		cmd = BIT(31)|(idx+0);
+		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+		DBG_8192D("print WOWCAM  offset[0]  =%x\n", rtw_read32(padapter, REG_WKFMCAM_RWD));
+		cmd = BIT(31)|(idx+1);
+		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+		DBG_8192D("print WOWCAM  offset[1]  =%x\n", rtw_read32(padapter, REG_WKFMCAM_RWD));
+		cmd = BIT(31)|(idx+2);
+		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+		DBG_8192D("print WOWCAM  offset[2]  =%x\n", rtw_read32(padapter, REG_WKFMCAM_RWD));
+		cmd = BIT(31)|(idx+3);
+		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+		DBG_8192D("print WOWCAM  offset[3]  =%x\n", rtw_read32(padapter, REG_WKFMCAM_RWD));
+		cmd = BIT(31)|(idx+4);
+		rtw_write32(padapter, REG_WKFMCAM_CMD, cmd);
+		DBG_8192D("print WOWCAM  offset[4]  =%x\n", rtw_read32(padapter, REG_WKFMCAM_RWD));
+
+	}
+}
+#endif /* CONFIG_WOWLAN */
+
+/*  */
+/*  */
+/*  LLT R/W/Init function */
+/*  */
+/*  */
+static u8 _LLTWrite(
+	struct rtw_adapter *	adapter,
+	u32		address,
+	u32		data
+	)
+{
+	u8	status = _SUCCESS;
+	int	count = 0;
+	u32	value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);
+
+	rtw_write32(adapter, REG_LLT_INIT, value);
+
+	/* polling */
+	do{
+
+		value = rtw_read32(adapter, REG_LLT_INIT);
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
+			break;
+		}
+
+		if (count > POLLING_LLT_THRESHOLD) {
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling write LLT done at address %d!\n", address)); */
+			status = _FAIL;
+			break;
+		}
+	}while (count++);
+
+	return status;
+}
+
+static u8 _LLTRead(
+	struct rtw_adapter *	adapter,
+	u32		address
+	)
+{
+	int		count = 0;
+	u32		value = _LLT_INIT_ADDR(address) | _LLT_OP(_LLT_READ_ACCESS);
+
+	rtw_write32(adapter, REG_LLT_INIT, value);
+
+	/* polling and get value */
+	do{
+
+		value = rtw_read32(adapter, REG_LLT_INIT);
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
+			return (u8)value;
+		}
+
+		if (count > POLLING_LLT_THRESHOLD) {
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling read LLT done at address %d!\n", address)); */
+			break;
+		}
+	}while (count++);
+
+	return 0xFF;
+}
+
+static u8 InitLLTTable(
+	struct rtw_adapter *	adapter,
+	u32		boundary
+	)
+{
+	u8		status = _SUCCESS;
+	u32		i;
+	u32		txpktbuf_bndy = boundary;
+	u32		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	if (pHalData->MacPhyMode92D != SINGLEMAC_SINGLEPHY) {
+		/* for 92du two mac: The page size is different from 92c and 92s */
+		txpktbuf_bndy = TX_PAGE_BOUNDARY_DUAL_MAC;
+		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC;
+	}
+	else {
+		txpktbuf_bndy = boundary;
+		Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;
+		/* txpktbuf_bndy = 253; */
+		/* Last_Entry_Of_TxPktBuf = 255; */
+	}
+
+	for (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {
+		status = _LLTWrite(adapter, i , i + 1);
+		if (_SUCCESS != status) {
+			return status;
+		}
+	}
+
+	/*  end of list */
+	status = _LLTWrite(adapter, (txpktbuf_bndy - 1), 0xFF);
+	if (_SUCCESS != status) {
+		return status;
+	}
+
+	/*  Make the other pages as ring buffer */
+	/*  This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer. */
+	/*  Otherwise used as local loopback buffer. */
+	for (i = txpktbuf_bndy ; i < Last_Entry_Of_TxPktBuf ; i++) {
+		status = _LLTWrite(adapter, i, (i + 1));
+		if (_SUCCESS != status) {
+			return status;
+		}
+	}
+
+	/*  Let last entry point to the start entry of ring buffer */
+	status = _LLTWrite(adapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
+	if (_SUCCESS != status) {
+		return status;
+	}
+
+	return status;
+}
+
+/*  */
+/*  */
+/*	MAC init functions */
+/*  */
+/*  */
+static void _SetMacID(struct rtw_adapter *adapter, u8 *MacID)
+{
+	u32 i;
+	for (i = 0 ; i< MAC_ADDR_LEN ; i++) {
+#ifdef  CONFIG_CONCURRENT_MODE
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write32(adapter, REG_MACID1+i, MacID[i]);
+		else
+#endif
+		rtw_write32(adapter, REG_MACID+i, MacID[i]);
+	}
+}
+
+static void _SetBSSID( struct rtw_adapter *adapter, u8 *BSSID)
+{
+	u32 i;
+	for (i = 0 ; i< MAC_ADDR_LEN ; i++) {
+#ifdef  CONFIG_CONCURRENT_MODE
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write32(adapter, REG_BSSID1+i, BSSID[i]);
+		else
+#endif
+		rtw_write32(adapter, REG_BSSID+i, BSSID[i]);
+	}
+}
+
+/*  Shall USB interface init this? */
+static void _InitInterrupt(struct rtw_adapter *adapter)
+{
+	u32	value32;
+
+	/*  HISR - turn all on */
+	value32 = 0xFFFFFFFF;
+	rtw_write32(adapter, REG_HISR, value32);
+
+	/*  HIMR - turn all on */
+	rtw_write32(adapter, REG_HIMR, value32);
+}
+
+static void _InitQueueReservedPage(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+
+	u32			outEPNum	= (u32)pHalData->OutEpNumber;
+	u32			numHQ		= 0;
+	u32			numLQ		= 0;
+	u32			numNQ		= 0;
+	u32			numPubQ;
+	u32			value32;
+	u8			value8;
+	u32			txQPageNum, txQPageUnit, txQRemainPage;
+
+	if (!pregistrypriv->wifi_spec)
+	{
+		if (pHalData->MacPhyMode92D != SINGLEMAC_SINGLEPHY)
+		{
+			numPubQ = NORMAL_PAGE_NUM_PUBQ_92D_DUAL_MAC;
+			txQPageNum = TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC- numPubQ;
+		}
+		else
+		{
+			numPubQ = TEST_PAGE_NUM_PUBQ;
+			/* RT_ASSERT((numPubQ < TX_TOTAL_PAGE_NUMBER), ("Public queue page number is great than total tx page number.\n")); */
+			txQPageNum = TX_TOTAL_PAGE_NUMBER - numPubQ;
+		}
+
+		if ((pHalData->MacPhyMode92D != SINGLEMAC_SINGLEPHY)&&(outEPNum == 3))
+		{/*  temply for DMDP/DMSP Page allocate */
+			numHQ = NORMAL_PAGE_NUM_HPQ_92D_DUAL_MAC;
+			numLQ = NORMAL_PAGE_NUM_LPQ_92D_DUAL_MAC;
+			numNQ = NORMAL_PAGE_NUM_NORMALQ_92D_DUAL_MAC;
+		}
+		else
+		{
+			txQPageUnit = txQPageNum/outEPNum;
+			txQRemainPage = txQPageNum % outEPNum;
+
+			if (pHalData->OutEpQueueSel & TX_SELE_HQ) {
+				numHQ = txQPageUnit;
+			}
+			if (pHalData->OutEpQueueSel & TX_SELE_LQ) {
+				numLQ = txQPageUnit;
+			}
+			/*  HIGH priority queue always present in the configuration of 2 or 3 out-ep */
+			/*  so , remainder pages have assigned to High queue */
+			if ((outEPNum>1) && (txQRemainPage)) {
+				numHQ += txQRemainPage;
+			}
+
+			/*  NOTE: This step shall be proceed before writting REG_RQPN. */
+			if (pHalData->OutEpQueueSel & TX_SELE_NQ)
+				numNQ = txQPageUnit;
+
+			value8 = (u8)_NPQ(numNQ);
+			rtw_write8(adapter, REG_RQPN_NPQ, value8);
+		}
+	}
+	else { /* for WMM */
+		/*  92du wifi config only for SMSP */
+
+		numPubQ = (outEPNum == 2)?WMM_NORMAL_PAGE_NUM_PUBQ:WMM_NORMAL_PAGE_NUM_PUBQ_92D;
+
+		if (pHalData->OutEpQueueSel & TX_SELE_HQ)
+			numHQ = (outEPNum == 2)?WMM_NORMAL_PAGE_NUM_HPQ:WMM_NORMAL_PAGE_NUM_HPQ_92D;
+
+		if (pHalData->OutEpQueueSel & TX_SELE_LQ)
+			numLQ = (outEPNum == 2)?WMM_NORMAL_PAGE_NUM_LPQ:WMM_NORMAL_PAGE_NUM_LPQ_92D;
+
+		if (pHalData->OutEpQueueSel & TX_SELE_NQ) {
+			numNQ = (outEPNum == 2)?WMM_NORMAL_PAGE_NUM_NPQ:WMM_NORMAL_PAGE_NUM_NPQ_92D;
+			value8 = (u8)_NPQ(numNQ);
+			rtw_write8(adapter, REG_RQPN_NPQ, value8);
+		}
+	}
+
+	/*  TX DMA */
+	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
+	rtw_write32(adapter, REG_RQPN, value32);
+}
+
+static void _InitTxBufferBoundary(struct rtw_adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	struct hal_data_8192du *pHalData	= GET_HAL_DATA(adapter);
+
+	/* u16	txdmactrl; */
+	u8	txpktbuf_bndy;
+
+	if (!pregistrypriv->wifi_spec) {
+		txpktbuf_bndy = TX_PAGE_BOUNDARY;
+	}
+	else {/* for WMM */
+		txpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY;
+	}
+
+	if (pHalData->MacPhyMode92D != SINGLEMAC_SINGLEPHY)
+		txpktbuf_bndy = TX_PAGE_BOUNDARY_DUAL_MAC;
+
+	rtw_write8(adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TRXFF_BNDY, txpktbuf_bndy);
+	rtw_write8(adapter, REG_TDECTRL+1, txpktbuf_bndy);
+}
+
+static void _InitNormalChipRegPriority(struct rtw_adapter *adapter, u16 beQ,
+				       u16 bkQ, u16 viQ, u16 voQ,
+				       u16 mgtQ, u16 hiQ)
+{
+	u16 value16 = (rtw_read16(adapter, REG_TRXDMA_CTRL) & 0x7);
+
+	value16 |= _TXDMA_BEQ_MAP(beQ) | _TXDMA_BKQ_MAP(bkQ) |
+		   _TXDMA_VIQ_MAP(viQ) | _TXDMA_VOQ_MAP(voQ) |
+		   _TXDMA_MGQ_MAP(mgtQ) | _TXDMA_HIQ_MAP(hiQ);
+
+	rtw_write16(adapter, REG_TRXDMA_CTRL, value16);
+}
+
+static void _InitNormalChipOneOutEpPriority(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	u16	value = 0;
+	switch (pHalData->OutEpQueueSel) {
+	case TX_SELE_HQ:
+		value = QUEUE_HIGH;
+		break;
+	case TX_SELE_LQ:
+		value = QUEUE_LOW;
+		break;
+	case TX_SELE_NQ:
+		value = QUEUE_NORMAL;
+		break;
+	default:
+		break;
+	}
+
+	_InitNormalChipRegPriority(adapter, value, value, value,
+				   value, value, value);
+}
+
+static void _InitNormalChipTwoOutEpPriority(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	u16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;
+
+	u16	valueHi = 0;
+	u16	valueLow = 0;
+
+	switch (pHalData->OutEpQueueSel)
+	{
+		case (TX_SELE_HQ | TX_SELE_LQ):
+			valueHi = QUEUE_HIGH;
+			valueLow = QUEUE_LOW;
+			break;
+		case (TX_SELE_NQ | TX_SELE_LQ):
+			valueHi = QUEUE_NORMAL;
+			valueLow = QUEUE_LOW;
+			break;
+		case (TX_SELE_HQ | TX_SELE_NQ):
+			valueHi = QUEUE_HIGH;
+			valueLow = QUEUE_NORMAL;
+			break;
+		default:
+			/* RT_ASSERT(FALSE, ("Shall not reach here!\n")); */
+			break;
+	}
+
+	if (!pregistrypriv->wifi_spec) {
+		beQ		= valueLow;
+		bkQ		= valueLow;
+		viQ		= valueHi;
+		voQ		= valueHi;
+		mgtQ	= valueHi;
+		hiQ		= valueHi;
+	}
+	else {/* for WMM , CONFIG_OUT_EP_WIFI_MODE */
+		beQ		= valueLow;
+		bkQ		= valueHi;
+		viQ		= valueHi;
+		voQ		= valueLow;
+		mgtQ	= valueHi;
+		hiQ		= valueHi;
+	}
+
+	_InitNormalChipRegPriority(adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
+}
+
+static void _InitNormalChipThreeOutEpPriority(struct rtw_adapter *adapter)
+{
+	struct registry_priv *pregistrypriv = &adapter->registrypriv;
+	u16			beQ, bkQ, viQ, voQ, mgtQ, hiQ;
+
+	if (!pregistrypriv->wifi_spec) {/*  typical setting */
+		beQ		= QUEUE_LOW;
+		bkQ		= QUEUE_LOW;
+		viQ		= QUEUE_NORMAL;
+		voQ		= QUEUE_HIGH;
+		mgtQ	= QUEUE_HIGH;
+		hiQ		= QUEUE_HIGH;
+	}
+	else {/*  for WMM */
+		beQ		= QUEUE_LOW;
+		bkQ		= QUEUE_NORMAL;
+		viQ		= QUEUE_NORMAL;
+		voQ		= QUEUE_HIGH;
+		mgtQ	= QUEUE_HIGH;
+		hiQ		= QUEUE_HIGH;
+	}
+	_InitNormalChipRegPriority(adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
+}
+
+static void _InitQueuePriority(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	switch (pHalData->OutEpNumber) {
+	case 1:
+		_InitNormalChipOneOutEpPriority(adapter);
+		break;
+	case 2:
+		_InitNormalChipTwoOutEpPriority(adapter);
+		break;
+	case 3:
+		_InitNormalChipThreeOutEpPriority(adapter);
+		break;
+	default:
+		break;
+	}
+}
+
+static void _InitNetworkType(struct rtw_adapter *adapter)
+{
+	u32	value32;
+
+	value32 = rtw_read32(adapter, REG_CR);
+
+	/*  TODO: use the other function to set network type */
+#if RTL8191C_FPGA_NETWORKTYPE_ADHOC
+	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AD_HOC);
+#else
+	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
+#endif
+	rtw_write32(adapter, REG_CR, value32);
+}
+
+static void _InitTransferPageSize(struct rtw_adapter *adapter)
+{
+	/*  Tx page size is always 128. */
+
+	u8	value8;
+	value8 = _PSRX(PBP_128) | _PSTX(PBP_128);
+	rtw_write8(adapter, REG_PBP, value8);
+}
+
+static void
+_InitDriverInfoSize(
+	struct rtw_adapter *	adapter,
+	u8		drvInfoSize
+	)
+{
+	rtw_write8(adapter, REG_RX_DRVINFO_SZ, drvInfoSize);
+}
+
+static void _InitWMACSetting(struct rtw_adapter *adapter)
+{
+	/* u4Byte			value32; */
+	/* u16			value16; */
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
+	/* pHalData->ReceiveConfig = AAP | APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS; */
+
+	/*  don't turn on AAP, it will allow all packets to driver */
+	pHalData->ReceiveConfig = APM | AM | AB | CBSSID |CBSSID_BCN | APP_ICV | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
+
+#if (0 == RTL8192C_RX_PACKET_NO_INCLUDE_CRC)
+	pHalData->ReceiveConfig |= ACRC32;
+#endif
+
+	rtw_write32(adapter, REG_RCR, pHalData->ReceiveConfig);
+
+	/*  Accept all multicast address */
+	rtw_write32(adapter, REG_MAR, 0xFFFFFFFF);
+	rtw_write32(adapter, REG_MAR+4, 0xFFFFFFFF);
+}
+
+static void _InitAdaptiveCtrl(struct rtw_adapter *adapter)
+{
+	u16	value16;
+	u32	value32;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/*  Response Rate Set */
+	value32 = rtw_read32(adapter, REG_RRSR);
+	value32 &= ~RATE_BITMAP_ALL;
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+	{
+		value32 |= RATE_RRSR_WITHOUT_CCK;
+	}
+	else
+	{
+		value32 |= RATE_RRSR_CCK_ONLY_1M;
+	}
+	rtw_write32(adapter, REG_RRSR, value32);
+
+	/*  CF-END Threshold */
+	/* m_spIoBase->rtw_write8(REG_CFEND_TH, 0x1); */
+
+	/*  SIFS (used in NAV) */
+	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
+	rtw_write16(adapter, REG_SPEC_SIFS, value16);
+
+	/*  Retry Limit */
+	value16 = _LRL(0x30) | _SRL(0x30);
+	rtw_write16(adapter, REG_RL, value16);
+}
+
+static void _InitRateFallback(struct rtw_adapter *adapter)
+{
+	/*  Set Data Auto Rate Fallback Retry Count register. */
+	rtw_write32(adapter, REG_DARFRC, 0x00000000);
+	rtw_write32(adapter, REG_DARFRC+4, 0x10080404);
+	rtw_write32(adapter, REG_RARFRC, 0x04030201);
+	rtw_write32(adapter, REG_RARFRC+4, 0x08070605);
+}
+
+static void _InitEDCA(struct rtw_adapter *adapter)
+{
+	u16				value16;
+
+	/* disable EDCCA count down, to reduce collison and retry */
+	value16 = rtw_read16(adapter, REG_RD_CTRL);
+	value16 |= DIS_EDCA_CNT_DWN;
+	rtw_write16(adapter, REG_RD_CTRL, value16);
+
+	/*  Update SIFS timing.  ?????????? */
+	/* pHalData->SifsTime = 0x0e0e0a0a; */
+	/* rtw_hal_set_hwreg(adapter, HW_VAR_RESP_SIFS,  (pu1Byte)&pHalData->SifsTime); */
+	/*  SIFS for CCK Data ACK */
+	rtw_write8(adapter, REG_SIFS_CTX, 0xa);
+	/*  SIFS for CCK consecutive tx like CTS data! */
+	rtw_write8(adapter, REG_SIFS_CTX+1, 0xa);
+
+	/*  SIFS for OFDM Data ACK */
+	rtw_write8(adapter, REG_SIFS_TRX, 0xe);
+	/*  SIFS for OFDM consecutive tx like CTS data! */
+	rtw_write8(adapter, REG_SIFS_TRX+1, 0xe);
+
+	/*  Set CCK/OFDM SIFS */
+	rtw_write16(adapter, REG_SIFS_CTX, 0x0a0a); /*  CCK SIFS shall always be 10us. */
+	rtw_write16(adapter, REG_SIFS_TRX, 0x1010);
+
+	rtw_write16(adapter, REG_PROT_MODE_CTRL, 0x0204);
+
+	rtw_write32(adapter, REG_BAR_MODE_CTRL, 0x014004);
+
+	/*  TXOP */
+	rtw_write32(adapter, REG_EDCA_BE_PARAM, 0x005EA42B);
+	rtw_write32(adapter, REG_EDCA_BK_PARAM, 0x0000A44F);
+	rtw_write32(adapter, REG_EDCA_VI_PARAM, 0x005EA324);
+	rtw_write32(adapter, REG_EDCA_VO_PARAM, 0x002FA226);
+
+	/*  PIFS */
+	rtw_write8(adapter, REG_PIFS, 0x1C);
+
+	/* AGGR BREAK TIME Register */
+	rtw_write8(adapter, REG_AGGR_BREAK_TIME, 0x16);
+
+	rtw_write16(adapter, REG_NAV_PROT_LEN, 0x0040);
+
+	rtw_write8(adapter, REG_BCNDMATIM, 0x02);
+
+	rtw_write8(adapter, REG_ATIMWND, 0x02);
+}
+
+static void _InitAMPDUAggregation(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	/* rtw_write32(adapter, REG_AGGLEN_LMT, 0x99997631); */
+
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x88728841);
+	else if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY)
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x44444441);
+	else if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+		rtw_write32(adapter, REG_AGGLEN_LMT, 0x66525541);
+
+	rtw_write8(adapter, REG_AGGR_BREAK_TIME, 0x16);
+}
+
+static void _InitBeaconMaxError(struct rtw_adapter *adapter, bool InfraMode)
+{
+#ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
+	rtw_write8(adapter, REG_BCN_MAX_ERR,  0xFF);
+#endif
+}
+
+static void _InitRDGSetting(struct rtw_adapter *adapter)
+{
+	rtw_write8(adapter, REG_RD_CTRL, 0xFF);
+	rtw_write16(adapter, REG_RD_NAV_NXT, 0x200);
+	rtw_write8(adapter, REG_RD_RESP_PKT_TH, 0x05);
+}
+
+static void _InitRetryFunction(struct rtw_adapter *adapter)
+{
+	u8	value8;
+
+	value8 = rtw_read8(adapter, REG_FWHW_TXQ_CTRL);
+	value8 |= EN_AMPDU_RTY_NEW;
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL, value8);
+
+	/*  Set ACK timeout */
+	rtw_write8(adapter, REG_ACKTO, 0x40);
+}
+
+static void _InitUsbAggregationSetting(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8 valuedma;
+	u8 valueusb;
+	u32 value32;
+
+	if (adapter->registrypriv.wifi_spec)
+		pHalData->UsbTxAggMode = false;
+
+	if (pHalData->MacPhyMode92D!= SINGLEMAC_SINGLEPHY)
+		pHalData->UsbTxAggDescNum = 2;
+
+	if (pHalData->UsbTxAggMode) {
+		value32 = rtw_read32(adapter, REG_TDECTRL);
+		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
+		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
+
+		rtw_write32(adapter, REG_TDECTRL, value32);
+	}
+
+	/*  Rx aggregation setting */
+	if (pHalData->MacPhyMode92D!= SINGLEMAC_SINGLEPHY) {
+		pHalData->UsbRxAggPageCount	= 24;
+		pHalData->UsbRxAggPageTimeout = 0x6;
+	}
+	valuedma = rtw_read8(adapter, REG_TRXDMA_CTRL);
+	valueusb = rtw_read8(adapter, REG_USB_SPECIAL_OPTION);
+
+	switch (pHalData->UsbRxAggMode) {
+	case USB_RX_AGG_DMA:
+		valuedma |= RXDMA_AGG_EN;
+		valueusb &= ~USB_AGG_EN;
+		break;
+	case USB_RX_AGG_USB:
+		valuedma &= ~RXDMA_AGG_EN;
+		valueusb |= USB_AGG_EN;
+		break;
+	case USB_RX_AGG_DMA_USB:
+		valuedma |= RXDMA_AGG_EN;
+		valueusb |= USB_AGG_EN;
+		break;
+	case USB_RX_AGG_DISABLE:
+	default:
+		valuedma &= ~RXDMA_AGG_EN;
+		valueusb &= ~USB_AGG_EN;
+		break;
+	}
+
+	rtw_write8(adapter, REG_TRXDMA_CTRL, valuedma);
+	rtw_write8(adapter, REG_USB_SPECIAL_OPTION, valueusb);
+	switch (pHalData->UsbRxAggMode) {
+		case USB_RX_AGG_DMA:
+			rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			break;
+		case USB_RX_AGG_USB:
+			rtw_write8(adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			break;
+		case USB_RX_AGG_DMA_USB:
+			rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, pHalData->UsbRxAggPageCount);
+			rtw_write8(adapter, REG_USB_DMA_AGG_TO, pHalData->UsbRxAggPageTimeout);
+			rtw_write8(adapter, REG_USB_AGG_TH, pHalData->UsbRxAggBlockCount);
+			rtw_write8(adapter, REG_USB_AGG_TO, pHalData->UsbRxAggBlockTimeout);
+			break;
+		case USB_RX_AGG_DISABLE:
+		default:
+			/*  TODO: */
+			break;
+	}
+	switch (PBP_128) {
+	case PBP_128:
+		pHalData->HwRxPageSize = 128;
+		break;
+	case PBP_64:
+		pHalData->HwRxPageSize = 64;
+		break;
+	case PBP_256:
+		pHalData->HwRxPageSize = 256;
+		break;
+	case PBP_512:
+		pHalData->HwRxPageSize = 512;
+		break;
+	case PBP_1024:
+		pHalData->HwRxPageSize = 1024;
+		break;
+	default:
+		break;
+	}
+}
+
+static void _InitOperationMode(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8 regBwOpMode = 0, MinSpaceCfg = 0;
+
+	/* 1 This part need to modified according to the rate set we filtered!! */
+	/*  */
+	/*  Set RRSR, RATR, and REG_BWOPMODE registers */
+	/*  */
+	switch (pHalData->CurrentWirelessMode) {
+	case WIRELESS_MODE_B:
+		regBwOpMode = BW_OPMODE_20MHZ;
+		break;
+	case WIRELESS_MODE_A:
+		/* RT_ASSERT(FALSE, ("Error wireless a mode\n")); */
+		regBwOpMode = BW_OPMODE_5G |BW_OPMODE_20MHZ;
+		break;
+	case WIRELESS_MODE_G:
+		regBwOpMode = BW_OPMODE_20MHZ;
+		break;
+	case WIRELESS_MODE_UNKNOWN:
+	case WIRELESS_MODE_AUTO:
+		regBwOpMode = BW_OPMODE_20MHZ;
+		break;
+	case WIRELESS_MODE_N_24G:
+		/*  It support CCK rate by default. */
+		/*  CCK rate will be filtered out only when associated AP does not support it. */
+		regBwOpMode = BW_OPMODE_20MHZ;
+		break;
+	case WIRELESS_MODE_N_5G:
+		regBwOpMode = BW_OPMODE_5G;
+		break;
+	}
+
+	/*  Ziv ???????? */
+	rtw_write8(adapter, REG_BWOPMODE, regBwOpMode);
+
+	/*  For Min Spacing configuration. */
+	switch (pHalData->rf_type) {
+	case RF_1T2R:
+	case RF_1T1R:
+		MinSpaceCfg = (MAX_MSS_DENSITY_1T<<3);
+		break;
+	case RF_2T2R:
+	case RF_2T2R_GREEN:
+		MinSpaceCfg = (MAX_MSS_DENSITY_2T<<3);
+		break;
+	}
+
+	rtw_write8(adapter, REG_AMPDU_MIN_SPACE, MinSpaceCfg);
+}
+
+static void _InitSecuritySetting(struct rtw_adapter *adapter)
+{
+	invalidate_cam_all(adapter);
+}
+
+ static void _InitBeaconParameters(struct rtw_adapter *adapter)
+{
+	rtw_write16(adapter, REG_BCN_CTRL, 0x1010);
+
+	/* default value  for register 0x558 and 0x559 is  0x05 0x03
+	 * (92DU before bitfile0821)
+	 */
+	rtw_write16(adapter, REG_TBTT_PROHIBIT, 0x3c02);/*  ms */
+	rtw_write8(adapter, REG_DRVERLYINT, 0x05);/* ms */
+	rtw_write8(adapter, REG_BCNDMATIM, 0x03);
+
+	/* Change beacon AIFS to the largest number
+	 * beacause test chip does not detect contention
+	 * before sending beacon
+	 */
+	rtw_write16(adapter, REG_BCNTCFG, 0x660F);
+}
+
+static void _InitRFType(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+
+#if (DISABLE_BB_RF == 1)
+	pHalData->rf_chip	= RF_PSEUDO_11N;
+	pHalData->rf_type	= RF_1T1R;/*  RF_2T2R; */
+#else
+
+	pHalData->rf_chip	= RF_6052;
+
+	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY)
+	{
+		pHalData->rf_type = RF_1T1R;
+	}
+	else {/*  SMSP OR DMSP */
+		pHalData->rf_type = RF_2T2R;
+	}
+#endif
+}
+
+#if RTL8192CU_ADHOC_WORKAROUND_SETTING
+static void _InitAdhocWorkaroundParams(struct rtw_adapter *adapter)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	pHalData->RegBcnCtrlVal = rtw_read8(adapter, REG_BCN_CTRL);
+	pHalData->RegTxPause = rtw_read8(adapter, REG_TXPAUSE);
+	pHalData->RegFwHwTxQCtrl = rtw_read8(adapter, REG_FWHW_TXQ_CTRL+2);
+	pHalData->RegReg542 = rtw_read8(adapter, REG_TBTT_PROHIBIT+2);
+	pHalData->RegCR_1 = rtw_read8(adapter, REG_CR+1);
+}
+#endif
+
+static void
+_BeaconFunctionEnable(
+	struct rtw_adapter *		adapter,
+	bool			Enable,
+	bool			Linked
+	)
+{
+	/*  20100901 zhiyuan: Change original setting of BCN_CTRL(0x550) from */
+	/*  0x1a to 0x1b. Set BIT0 of this register disable ATIM  function. */
+	/*   enable ATIM function may invoke HW Tx stop operation. This may cause ping failed */
+	/*  sometimes in long run test. So just disable it now. */
+	/*  When ATIM function is disabled, High Queue should not use anymore. */
+	rtw_write8(adapter, REG_BCN_CTRL, 0x1b);
+	rtw_write8(adapter, REG_RD_CTRL+1, 0x6F);
+}
+
+/*  Set CCK and OFDM Block "ON" */
+static void _BBTurnOnBlock(
+	struct rtw_adapter *		adapter
+	)
+{
+	struct hal_data_8192du		*pHalData	= GET_HAL_DATA(adapter);
+#if (DISABLE_BB_RF)
+	return;
+#endif
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+		PHY_SetBBReg(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x2);
+	else
+		PHY_SetBBReg(adapter, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x3);
+}
+
+static void _RfPowerSave(
+	struct rtw_adapter *		adapter
+	)
+{
+	struct hal_data_8192du	*pHalData	= GET_HAL_DATA(adapter);
+	struct pwrctrl_priv		*pwrctrlpriv = &adapter->pwrctrlpriv;
+	u8			eRFPath;
+
+#if (DISABLE_BB_RF)
+	return;
+#endif
+
+	if (pwrctrlpriv->reg_rfoff == true) { /*  User disable RF via registry. */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): Turn off RF for RegRfOff.\n")); */
+		/* MgntActSet_RF_State(adapter, rf_off, RF_CHANGE_BY_SW, true); */
+		/*  Those action will be discard in MgntActSet_RF_State because off the same state */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (pHalData->bSlaveOfDMSP)
+			return;
+#endif
+		for (eRFPath = 0; eRFPath <pHalData->NumTotalRFPath; eRFPath++)
+			PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);
+	}
+	else if (pwrctrlpriv->rfoff_reason > RF_CHANGE_BY_PS) { /*  H/W or S/W RF OFF before sleep. */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): Turn off RF for RfOffReason(%ld).\n", pMgntInfo->RfOffReason)); */
+		/* MgntActSet_RF_State(adapter, rf_off, pMgntInfo->RfOffReason, true); */
+	}
+	else {
+		pwrctrlpriv->rf_pwrstate = rf_on;
+		pwrctrlpriv->rfoff_reason = 0;
+		/* if (adapter->bInSetPower || adapter->bResetInProgress) */
+		/*	PlatformUsbEnableInPipes(adapter); */
+		/* RT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("Initializeadapter8192CUsb(): RF is on.\n")); */
+	}
+}
+
+static void init_hwled(struct rtw_adapter *adapter)
+{
+	struct led_priv *pledpriv = &(adapter->ledpriv);
+
+	if (pledpriv->LedStrategy != HW_LED)
+			return;
+}
+
+#ifdef CONFIG_WOWLAN
+static void dump_wakup_reason(struct rtw_adapter *padapter)
+{
+	switch (rtw_read8(padapter, REG_WOWLAN_REASON))
+	{
+		case Rx_Pairwisekey:
+			DBG_8192D("Rx_Pairwisekey\n");
+			break;
+		case Rx_GTK:
+			DBG_8192D("Rx_GTK\n");
+			break;
+		case Rx_DisAssoc:
+			DBG_8192D("Rx_DisAssoc\n");
+			break;
+		case Rx_DeAuth:
+			DBG_8192D("Rx_DeAuth\n");
+			break;
+		case FWDecisionDisconnect:
+			DBG_8192D("FWDecisionDisconnect\n");
+			break;
+		case Rx_MagicPkt:
+			DBG_8192D("Rx_MagicPkt\n");
+			break;
+		case FinishBtFwPatch:
+			DBG_8192D("FinishBtFwPatch\n");
+			break;
+		default:
+			DBG_8192D("UNKNOW reason\n");
+			break;
+	}
+}
+#endif /* CONFIG_WOWLAN */
+
+static u32 rtl8192du_hal_init(struct rtw_adapter *padapter)
+{
+	u8	val8 = 0, tmpU1b;
+	u16	val16;
+	u32	boundary, i = 0,  status = _SUCCESS;
+#if SWLCK == 0
+	u32	j;
+#endif /* SWLCK == 0 */
+	struct hal_data_8192du  *pHalData = GET_HAL_DATA(padapter);
+	struct pwrctrl_priv		*pwrctrlpriv = &padapter->pwrctrlpriv;
+	struct registry_priv	*pregistrypriv = &padapter->registrypriv;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = padapter->pbuddy_adapter;
+#endif
+	u32 init_start_time = rtw_get_current_time();
+
+	padapter->init_adpt_in_progress = true;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (Buddyadapter != NULL)
+	{
+		if (Buddyadapter->bHaltInProgress)
+		{
+			for (i = 0;i<100;i++)
+			{
+				rtw_usleep_os(1000);
+				if (!Buddyadapter->bHaltInProgress)
+					break;
+			}
+
+			if (i == 100)
+			{
+				DBG_8192D("fail to initialization due to another adapter is in halt\n");
+				return _FAIL;
+			}
+		}
+	}
+#endif
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("--->Initializeadapter8192CUsb()\n")); */
+
+	if (padapter->bSurpriseRemoved)
+		return _FAIL;
+
+	/* Let the first starting mac load RF parameters and do LCK in this case, by wl */
+	if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+		ACQUIRE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+
+	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+
+	rtw_write8(padapter, REG_RSV_CTRL, 0x0);
+	val8 = rtw_read8(padapter, 0x0003);
+	val8 &= (~BIT7);
+	rtw_write8(padapter, 0x0003, val8);
+
+#ifdef CONFIG_WOWLAN
+	if (rtw_read8(padapter, REG_MCUFWDL)&BIT7)
+	{
+		u8 reg_val = 0;
+		rtl8192d_FirmwareSelfReset(padapter);
+		rtw_write8(padapter, REG_MCUFWDL, 0x00);
+		/* before BB reset should do clock gated */
+		rtw_write32(padapter, rFPGA0_XCD_RFParameter, rtw_read32(padapter, rFPGA0_XCD_RFParameter)|(BIT31));
+		/* reset BB */
+		reg_val = rtw_read8(padapter, REG_SYS_FUNC_EN);
+		reg_val &= ~(BIT(0) | BIT(1));
+		rtw_write8(padapter, REG_SYS_FUNC_EN, reg_val);
+		/* reset RF */
+		rtw_write8(padapter, REG_RF_CTRL, 0);
+		/* reset TRX path */
+		rtw_write16(padapter, REG_CR, 0);
+		/* reset MAC, Digital Core */
+		reg_val = rtw_read8(padapter, REG_SYS_FUNC_EN+1);
+		reg_val &= ~(BIT(4) | BIT(7));
+		rtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);
+		reg_val = rtw_read8(padapter, REG_SYS_FUNC_EN+1);
+		reg_val |= BIT(4) | BIT(7);
+		rtw_write8(padapter, REG_SYS_FUNC_EN+1, reg_val);
+	}
+#endif /* CONFIG_WOWLAN */
+	/* mac status: */
+	/* 0x81[4]:0 mac0 off, 1:mac0 on */
+	/* 0x82[4]:0 mac1 off, 1: mac1 on. */
+
+	/* For s3/s4 may reset mac, Reg0xf8 may be set to 0, so reset macphy control reg here. */
+	PHY_ConfigMacPhyMode92D(padapter);
+
+	PHY_SetPowerOnFor8192D(padapter);
+
+	status = _InitPowerOn(padapter);
+	if (status == _FAIL) {
+		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		goto exit;
+	}
+
+	if (!pregistrypriv->wifi_spec) {
+		boundary = TX_PAGE_BOUNDARY;
+	}
+	else {/*  for WMM */
+		boundary = WMM_NORMAL_TX_PAGE_BOUNDARY;
+	}
+
+	PHY_ConfigMacCoexist_RFPage92D(padapter);
+
+	status =  InitLLTTable(padapter, boundary);
+	if (status == _FAIL) {
+		RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));
+		RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		return status;
+	}
+
+#if ((1 == MP_DRIVER) ||  (0 == FW_PROCESS_VENDOR_CMD))
+
+	rtl8192d_PHY_InitRxSetting(padapter);
+	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+	DBG_8192D("%s(): Don't Download Firmware !!\n", __func__);
+	padapter->bFWReady = false;
+	pHalData->fw_ractrl = false;
+
+#else
+
+	status = FirmwareDownload92D(padapter, false);
+	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+	if (status == _FAIL) {
+		padapter->bFWReady = false;
+		pHalData->fw_ractrl = false;
+		DBG_8192D("fw download fail!\n");
+
+		/* return fail only when part number check fail, suggested by alex */
+		if (0xE0 == rtw_read8(padapter, 0x1c5))
+		{
+			if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+			&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+				|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+				RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+
+			goto exit;
+		}
+	}
+	else	{
+		padapter->bFWReady = true;
+		pHalData->fw_ractrl = true;
+		DBG_8192D("fw download ok!\n");
+	}
+
+#endif
+
+	pHalData->LastHMEBoxNum = 0;
+
+	if (pwrctrlpriv->reg_rfoff == true) {
+		pwrctrlpriv->rf_pwrstate = rf_off;
+	}
+
+	/*  Set RF type for BB/RF configuration */
+	_InitRFType(padapter);/* _ReadRFType() */
+
+	/*  Save target channel */
+	/*  <Roger_Notes> Current Channel will be updated again later. */
+
+#if (HAL_MAC_ENABLE == 1)
+	status = PHY_MACConfig8192D(padapter);
+	if (status == _FAIL)
+	{
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		goto exit;
+	}
+#endif
+
+	_InitQueueReservedPage(padapter);
+	_InitTxBufferBoundary(padapter);
+	_InitQueuePriority(padapter);
+	_InitTransferPageSize(padapter);
+
+	/*  Get Rx PHY status in order to report RSSI and others. */
+	_InitDriverInfoSize(padapter, DRVINFO_SZ);
+
+	_InitInterrupt(padapter);
+	hal_init_macaddr(padapter);/* set mac_address */
+	_InitNetworkType(padapter);/* set msr */
+	_InitWMACSetting(padapter);
+	_InitAdaptiveCtrl(padapter);
+	_InitEDCA(padapter);
+	_InitRateFallback(padapter);
+	_InitRetryFunction(padapter);
+	_InitUsbAggregationSetting(padapter);
+	_InitOperationMode(padapter);/* todo */
+	_InitBeaconParameters(padapter);
+	_InitAMPDUAggregation(padapter);
+	_InitBeaconMaxError(padapter, true);
+
+#if defined(CONFIG_CONCURRENT_MODE)
+
+#ifdef CONFIG_CHECK_AC_LIFETIME
+	/*  Enable lifetime check for the four ACs */
+	rtw_write8(padapter, REG_LIFETIME_EN, 0x0F);
+#endif	/*  CONFIG_CHECK_AC_LIFETIME */
+
+	rtw_write16(padapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);	/*  unit: 256us. 256ms */
+	rtw_write16(padapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);	/*  unit: 256us. 256ms */
+#endif	/*  CONFIG_CONCURRENT_MODE */
+
+	init_hwled(padapter);
+
+	if (pHalData->bRDGEnable)
+		_InitRDGSetting(padapter);
+
+	/*  Set Data Auto Rate Fallback Reg. */
+	for (i = 0 ; i < 4 ; i++)
+		rtw_write32(padapter, REG_ARFR0+i*4, 0x1f8ffff0);
+
+	if (pregistrypriv->wifi_spec) {
+		rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0);
+	} else {
+		if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY) {
+			if (pHalData->OutEpNumber == 2)  /*  suggested by chunchu */
+				rtw_write32(padapter, REG_FAST_EDCA_CTRL, 0x03066666);
+		       else
+				rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x8888);
+		} else {
+			rtw_write16(padapter, REG_FAST_EDCA_CTRL, 0x5555);
+		}
+	}
+
+	tmpU1b = rtw_read8(padapter, 0x605);
+	tmpU1b|= 0xf0;
+	rtw_write8(padapter, 0x605, tmpU1b);
+	rtw_write8(padapter, 0x55e, 0x30);
+	rtw_write8(padapter, 0x55f, 0x30);
+	rtw_write8(padapter, 0x606, 0x30);
+
+	/* for bitfile 0912/0923 zhiyuan 2009/09/23 */
+	/*  temp for high queue and mgnt Queue corrupt in time; */
+	/* it may cause hang when sw beacon use high_Q, other frame use mgnt_Q; or , sw beacon use mgnt_Q , other frame use high_Q; */
+	rtw_write8(padapter, 0x523, 0x10);
+	val16 = rtw_read16(padapter, 0x524);
+	val16|= BIT12;
+	rtw_write16(padapter, 0x524 , val16);
+
+	rtw_write8(padapter, REG_TXPAUSE, 0);
+
+	/*  suggested by zhouzhou   usb suspend  idle time count for bitfile0927  2009/10/09 zhiyuan */
+	val8 = rtw_read8(padapter, 0xfe56);
+	val8 |= (BIT0|BIT1);
+	rtw_write8(padapter, 0xfe56, val8);
+
+	if (pHalData->bEarlyModeEnable)
+	{
+		DBG_8192D("EarlyMode Enabled!!!\n");
+
+		tmpU1b = rtw_read8(padapter, 0x4d0);
+		tmpU1b = tmpU1b|0x1f;
+		rtw_write8(padapter, 0x4d0, tmpU1b);
+
+		rtw_write8(padapter, 0x4d3, 0x80);
+
+		tmpU1b = rtw_read8(padapter, 0x605);
+		tmpU1b = tmpU1b|0x40;
+		rtw_write8(padapter, 0x605, tmpU1b);
+	}
+	else
+	{
+		rtw_write8(padapter, 0x4d0, 0);
+	}
+
+	/*  */
+	/* d. Initialize BB related configurations. */
+	/*  */
+#if (HAL_BB_ENABLE == 1)
+	status = PHY_BBConfig8192D(padapter);
+	if (status == _FAIL)
+	{
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		goto exit;
+	}
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (pHalData->bSlaveOfDMSP)
+	{
+		DBG_8192D("slave of dmsp close phy1\n");
+		PHY_StopTRXBeforeChangeBand8192D(padapter);
+	}
+#endif
+
+	if (padapter->bFWReady && pHalData->FirmwareVersion >= 0x13)
+	{
+		pHalData->bReadRFbyFW = true;
+		DBG_8192D("Enable 92du query RF by FW.\n");
+	}
+	else
+	{
+		pHalData->bReadRFbyFW = false;
+	}
+
+	/*  92CU use 3-wire to r/w RF */
+	/*  */
+	/*  e. Initialize RF related configurations. */
+	/*  */
+	/*  2007/11/02 MH Before initalizing RF. We can not use FW to do RF-R/W. */
+	/* pHalData->Rf_Mode = RF_OP_By_SW_3wire; */
+#if (HAL_RF_ENABLE == 1)
+	/*  set before initialize RF, */
+	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
+
+	status = PHY_RFConfig8192D(padapter);
+	if (status == _FAIL)
+	{
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		goto exit;
+	}
+
+	/*  set default value after initialize RF, */
+	PHY_SetBBReg(padapter, rFPGA0_AnalogParameter4, 0x00f00000,  0);
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (!pHalData->bSlaveOfDMSP)
+#endif
+		PHY_UpdateBBRFConfiguration8192D(padapter, false);
+
+#endif
+
+#if RTL8192CU_ADHOC_WORKAROUND_SETTING
+	_InitAdhocWorkaroundParams(padapter);
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (!pHalData->bSlaveOfDMSP)
+#endif
+		_BBTurnOnBlock(padapter);
+
+	/* NicIFSetMacAddress(padapter, padapter->PermanentAddress); */
+
+	if (pHalData->CurrentBandType92D == BAND_ON_5G)
+	{
+		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_5G;
+	}
+	else
+	{
+		pHalData->CurrentWirelessMode = WIRELESS_MODE_N_24G;
+	}
+
+	_InitSecuritySetting(padapter);
+
+	_RfPowerSave(padapter);
+
+	/*  HW SEQ CTRL */
+	/* set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM. */
+	rtw_write8(padapter, REG_HWSEQ_CTRL, 0xFF);
+
+	/* schmitt trigger , improve tx evm for 92du, suggested by ynlin  12/03/2010 */
+	tmpU1b = rtw_read8(padapter, REG_AFE_XTAL_CTRL);
+	tmpU1b |= BIT1;
+	rtw_write8(padapter, REG_AFE_XTAL_CTRL, tmpU1b);
+
+	/* disable bar */
+	rtw_write32(padapter, REG_BAR_MODE_CTRL, 0xffff);
+
+	/* Nav limit , suggest by scott */
+	rtw_write8(padapter, 0x652, 0x0);
+	rtw_write8(padapter, 0xc87, 0x50);/* suggest by Jackson for CCA */
+
+#if (MP_DRIVER == 1)
+	padapter->mppriv.channel = pHalData->CurrentChannel;
+	MPT_Initializeadapter(padapter, padapter->mppriv.channel);
+	/* MPT_Initializeadapter(padapter, Channel); */
+#else /*  temply marked this for RF */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (!pHalData->bSlaveOfDMSP)
+#endif
+	{
+
+		/*  do IQK for 2.4G for better scan result, if current bandtype is 2.4G. */
+		if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+			rtl8192d_PHY_IQCalibrate(padapter);
+
+		rtl8192d_dm_CheckTXPowerTracking(padapter);
+
+		rtl8192d_PHY_LCCalibrate(padapter);
+		if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY
+		&& ((pHalData->interfaceIndex == 0 && pHalData->BandSet92D == BAND_ON_2_4G)
+			|| (pHalData->interfaceIndex == 1 && pHalData->BandSet92D == BAND_ON_5G)))
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForMac0_2G_Mac1_5G);
+		/* 5G and 2.4G must wait sometime to let RF LO ready */
+		/* by sherry 2010.06.28 */
+#if SWLCK == 0
+		{
+			u32 tmpRega, tmpRegb;
+			for (j = 0;j<10000;j++)
+			{
+				rtw_udelay_os(MAX_STALL_TIME);
+				if (pHalData->rf_type == RF_1T1R)
+				{
+					tmpRega = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_A, 0x2a, bMaskDWord);
+					if ((tmpRega&BIT11) == BIT11)
+						break;
+				}
+				else
+				{
+					tmpRega = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_A, 0x2a, bMaskDWord);
+					tmpRegb = PHY_QueryRFReg(padapter, (enum RF_RADIO_PATH_E)RF_PATH_B, 0x2a, bMaskDWord);
+					if (((tmpRega&BIT11) == BIT11)&&((tmpRegb&BIT11) == BIT11))
+						break;
+					/*  temply add for DMSP */
+					if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY&&(pHalData->interfaceIndex!= 0))
+						break;
+				}
+			}
+		}
+#endif
+	}
+#endif
+
+	PHY_InitPABias92D(padapter);
+
+	rtl8192d_InitHalDm(padapter);
+
+
+	rtw_write16(padapter, REG_BCN_CTRL, 0x1818);	/*  For 2 PORT TSF SYNC */
+
+	{
+	       u32					ulRegRead;
+		/* 3  */
+		/* 3 Set Loopback mode or Normal mode */
+		/* 3 */
+		/* 2006.12.13 by emily. Note!We should not merge these two CPU_GEN register writings */
+		/*	because setting of System_Reset bit reset MAC to default transmission mode. */
+		ulRegRead = rtw_read32(padapter, 0x100);	/* CPU_GEN  0x100 */
+
+		ulRegRead |= ulRegRead;
+
+		rtw_write32(padapter, 0x100, ulRegRead);
+
+		/*  2006.11.29. After reset cpu, we sholud wait for a second, otherwise, it may fail to write registers. Emily */
+		rtw_udelay_os(500);
+	}
+
+	RT_CLEAR_PS_LEVEL(pwrctrlpriv, RT_RF_OFF_LEVL_HALT_NIC);
+
+	if ((pregistrypriv->lowrate_two_xmit) &&
+	    (pHalData->MacPhyMode92D != DUALMAC_DUALPHY)) {
+		/* for Use 2 path Tx to transmit MCS0~7 and legacy mode */
+		/* Reg90C[30]= 1'b0 (OFDM TX by Reg, default PHY parameter) */
+		/* Reg80C[31]= 1'b0 (CCK TX by Reg, default PHYparameter) */
+		/* RegC8C = 0xa0e40000 (OFDM RX weighting) */
+		rtw_write32(padapter, 0x90C, rtw_read32(padapter, 0x90C)&(~BIT(30)));
+		rtw_write32(padapter, 0x80C, rtw_read32(padapter, 0x80C)&(~BIT(31)));
+		rtw_write32(padapter, 0xC8C, 0xa0e40000);
+	}
+
+	/* ack for xmit mgmt frames. */
+	rtw_write32(padapter, REG_FWHW_TXQ_CTRL, rtw_read32(padapter, REG_FWHW_TXQ_CTRL)|BIT(12));
+exit:
+	padapter->init_adpt_in_progress = false;
+
+	DBG_8192D("%s in %dms\n", __func__, rtw_get_passing_time_ms(init_start_time));
+
+#ifdef CONFIG_WOWLAN
+	if (padapter->pwrctrlpriv.wowlan_mode == true)
+		dump_wakup_reason(padapter);
+	{
+		u16 GPIO_val;
+		GPIO_val = rtw_read16(padapter, REG_GPIO_PIN_CTRL+1);
+		GPIO_val |= BIT(0)|BIT(8);
+		/* set GPIO 0 to high for Toshiba */
+		rtw_write16(padapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
+	}
+	/* prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron */
+	/* rtw_write8(padapter, REG_RSV_CTRL, 0x20); */
+	/* rtw_write8(padapter, REG_RSV_CTRL, 0x60); */
+#endif /*  CONFIG_WOWLAN */
+	return status;
+}
+
+static void
+_DisableGPIO(
+	struct rtw_adapter *	adapter
+	)
+{
+/***************************************
+j. GPIO_PIN_CTRL 0x44[31:0]= 0x000
+k. Value = GPIO_PIN_CTRL[7:0]
+l.  GPIO_PIN_CTRL 0x44[31:0] = 0x00FF0000 | (value <<8);  write external PIN level
+m. GPIO_MUXCFG 0x42 [15:0] = 0x0780
+n. LEDCFG 0x4C[15:0] = 0x8080
+***************************************/
+	u8	value8;
+	u16	value16;
+	u32	value32;
+
+	/* 1. Disable GPIO[7:0] */
+	rtw_write16(adapter, REG_GPIO_PIN_CTRL+2, 0x0000);
+	value32 = rtw_read32(adapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;
+	value8 = (u8) (value32&0x000000FF);
+	value32 |= ((value8<<8) | 0x00FF0000);
+	rtw_write32(adapter, REG_GPIO_PIN_CTRL, value32);
+
+	/* 2. Disable GPIO[10:8] */
+	rtw_write8(adapter, REG_MAC_PINMUX_CFG, 0x00);
+	value16 = rtw_read16(adapter, REG_GPIO_IO_SEL) & 0xFF0F;
+	value8 = (u8) (value16&0x000F);
+	value16 |= ((value8<<4) | 0x0780);
+	rtw_write16(adapter, REG_GPIO_IO_SEL, value16);
+
+	/* 3. Disable LED0 & 1 */
+	rtw_write16(adapter, REG_LEDCFG0, 0x8888);
+
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable GPIO and LED.\n")); */
+} /* end of _DisableGPIO() */
+static void
+_ResetFWDownloadRegister(
+	struct rtw_adapter *			adapter
+	)
+{
+	u32	value32;
+
+	value32 = rtw_read32(adapter, REG_MCUFWDL);
+	value32 &= ~(MCUFWDL_EN | MCUFWDL_RDY);
+	rtw_write32(adapter, REG_MCUFWDL, value32);
+}
+
+static int
+_DisableRF_AFE(
+	struct rtw_adapter *			adapter
+	)
+{
+	int		rtStatus = _SUCCESS;
+	u32			pollingCount = 0;
+	u8			value8;
+
+	/* disable RF/ AFE AD/DA */
+	value8 = APSDOFF;
+	rtw_write8(adapter, REG_APSD_CTRL, value8);
+
+#if (RTL8192CU_ASIC_VERIFICATION)
+
+	do
+	{
+		if (rtw_read8(adapter, REG_APSD_CTRL) & APSDOFF_STATUS) {
+			/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA Done!\n")); */
+			break;
+		}
+
+		if (pollingCount++ > POLLING_READY_TIMEOUT_COUNT) {
+			/* RT_TRACE(COMP_INIT, DBG_SERIOUS, ("Failed to polling APSDOFF_STATUS done!\n")); */
+			return _FAIL;
+		}
+
+	}while (true);
+
+#endif
+
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable RF, AFE, AD, DA.\n")); */
+	return rtStatus;
+}
+
+static void
+_ResetBB(
+	struct rtw_adapter *			adapter
+	)
+{
+	u16	value16;
+	/* before BB reset should do clock gated */
+	rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+	/* reset BB */
+	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
+	value16 &= ~(FEN_BBRSTB | FEN_BB_GLB_RSTn);
+	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset BB.\n")); */
+}
+
+static void
+_ResetMCU(
+	struct rtw_adapter *			adapter
+	)
+{
+	u16	value16;
+
+	/*  reset MCU */
+	value16 = rtw_read16(adapter, REG_SYS_FUNC_EN);
+	value16 &= ~FEN_CPUEN;
+	rtw_write16(adapter, REG_SYS_FUNC_EN, value16);
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Reset MCU.\n")); */
+}
+
+static void
+_DisableMAC_AFE_PLL(
+	struct rtw_adapter *			adapter
+	)
+{
+	u32	value32;
+
+	/* disable MAC/ AFE PLL */
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
+	value32 |= APDM_MAC;
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
+
+	value32 |= APFM_OFF;
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Disable MAC, AFE PLL.\n")); */
+}
+
+static void
+_AutoPowerDownToHostOff(
+	struct rtw_adapter *		adapter
+	)
+{
+	u32			value32;
+	rtw_write8(adapter, REG_SPS0_CTRL, 0x22);
+
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
+
+	value32 |= APDM_HOST;/* card disable */
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Auto Power Down to Host-off state.\n")); */
+
+	/*  set USB suspend */
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
+	value32 &= ~AFSM_PCIE;
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
+}
+
+static void
+_SetUsbSuspend(
+	struct rtw_adapter *			adapter
+	)
+{
+	u32			value32;
+
+	value32 = rtw_read32(adapter, REG_APS_FSMCO);
+
+	/*  set USB suspend */
+	value32 |= AFSM_HSUS;
+	rtw_write32(adapter, REG_APS_FSMCO, value32);
+
+	/* RT_ASSERT(0 == (rtw_read32(adapter, REG_APS_FSMCO) & BIT(12)), ("")); */
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Set USB suspend.\n")); */
+}
+
+static void
+_DisableRFAFEAndResetBB8192D(
+	struct rtw_adapter *			adapter
+	)
+{
+/**************************************
+a.	TXPAUSE 0x522[7:0] = 0xFF             Pause MAC TX queue
+b.	RF path 0 offset 0x00 = 0x00            disable RF
+c.	APSD_CTRL 0x600[7:0] = 0x40
+d.	SYS_FUNC_EN 0x02[7:0] = 0x16		reset BB state machine
+e.	SYS_FUNC_EN 0x02[7:0] = 0x14		reset BB state machine
+***************************************/
+       struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	u8	eRFPath = 0, value8 = 0;
+
+	PHY_SetBBReg(adapter, rFPGA0_AnalogParameter4, 0x00f00000,  0xf);
+	PHY_SetRFReg(adapter, (enum RF_RADIO_PATH_E)eRFPath, 0x0, bRFRegOffsetMask, 0x0);
+
+	value8 |= APSDOFF;
+	rtw_write8(adapter, REG_APSD_CTRL, value8);/* 0x40 */
+
+	/* testchip  should not do BB reset if another mac is alive; */
+	value8 = 0 ;
+	value8 |= (FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn);
+	rtw_write8(adapter, REG_SYS_FUNC_EN, value8);/* 0x16 */
+
+	if (pHalData->MacPhyMode92D!= SINGLEMAC_SINGLEPHY)
+	{
+		if (pHalData->interfaceIndex!= 0) {
+			/* before BB reset should do clock gated */
+			rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+			value8 &= (~FEN_BB_GLB_RSTn);
+			rtw_write8(adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
+		}
+	}
+	else {
+		/* before BB reset should do clock gated */
+		rtw_write32(adapter, rFPGA0_XCD_RFParameter, rtw_read32(adapter, rFPGA0_XCD_RFParameter)|(BIT31));
+		value8 &= (~FEN_BB_GLB_RSTn);
+		rtw_write8(adapter, REG_SYS_FUNC_EN, value8); /* 0x14 */
+	}
+
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> RF off and reset BB.\n")); */
+}
+
+static void
+_DisableRFAFEAndResetBB(
+	struct rtw_adapter *			adapter
+	)
+{
+	_DisableRFAFEAndResetBB8192D(adapter);
+}
+
+static void
+_ResetDigitalProcedure1(
+	struct rtw_adapter *			adapter,
+	bool				bWithoutHWSM
+	)
+{
+
+	struct hal_data_8192du  *pHalData = GET_HAL_DATA(adapter);
+
+	u8 retry_cnts = 0;
+	/*  2010/08/12 MH For USB SS, we can not stop 8051 when we are trying to */
+	/*  enter IPS/HW&SW radio off. For S3/S4/S5/Disable, we can stop 8051 because */
+	/*  we will init FW when power on again. */
+	if (rtw_read8(adapter, REG_MCUFWDL) & BIT1) { /* IF fw in RAM code, do reset */
+
+		if (adapter->bFWReady) {
+			rtw_write8(adapter, REG_FSIMR, 0x00);
+			/*  2010/08/25 MH Accordign to RD alfred's suggestion, we need to disable other */
+			/*  HRCV INT to influence 8051 reset. */
+			rtw_write8(adapter, REG_FWIMR, 0x20);
+			/*  2011/02/15 MH According to Alex's suggestion, close mask to prevent incorrect FW write operation. */
+			rtw_write8(adapter, REG_FTIMR, 0x00);
+
+			rtw_write8(adapter, REG_MCUFWDL, 0);
+			rtw_write8(adapter, REG_HMETFR+3, 0x20);/* 8051 reset by self */
+
+			while ((retry_cnts++ <100) && (FEN_CPUEN &rtw_read16(adapter, REG_SYS_FUNC_EN)))
+				rtw_udelay_os(50);/* us */
+
+			if (retry_cnts>= 100) {
+				rtw_write8(adapter, REG_FWIMR, 0x00);
+				/*  2010/08/31 MH According to Filen's info, if 8051 reset fail, reset MAC directly. */
+				rtw_write8(adapter, REG_SYS_FUNC_EN+1, 0x50);	/* Reset MAC and Enable 8051 */
+				rtw_mdelay_os(10);
+			} else {
+				DBG_8192D("=====> 8051 reset success (%d) .\n", retry_cnts);
+			}
+		}
+	} else {
+		DBG_8192D("=====> 8051 in ROM.\n");
+	}
+
+	#ifdef DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE
+	{
+		u8 val;
+		if ((val = rtw_read8(adapter, REG_MCUFWDL)))
+			DBG_8192D("DBG_SHOW_MCUFWDL_BEFORE_51_ENABLE %s:%d REG_MCUFWDL:0x%02x\n", __func__, __LINE__, val);
+	}
+	#endif
+
+	rtw_write8(adapter, REG_SYS_FUNC_EN+1, 0x54);	/* Reset MAC and Enable 8051 */
+	rtw_write8(adapter, REG_MCUFWDL, 0);
+
+	if (bWithoutHWSM) {
+	/*****************************
+		Without HW auto state machine
+	g.	SYS_CLKR 0x08[15:0] = 0x30A3			disable MAC clock
+	h.	AFE_PLL_CTRL 0x28[7:0] = 0x80			disable AFE PLL
+	i.	AFE_XTAL_CTRL 0x24[15:0] = 0x880F		gated AFE DIG_CLOCK
+	j.	SYS_ISO_CTRL 0x00[7:0] = 0xF9			isolated digital to PON
+	******************************/
+		/* rtw_write16(adapter, REG_SYS_CLKR, 0x30A3); */
+		rtw_write16(adapter, REG_SYS_CLKR, 0x70A3);/* modify to 0x70A3 by Scott. */
+		rtw_write8(adapter, REG_AFE_PLL_CTRL, 0x80);
+		rtw_write16(adapter, REG_AFE_XTAL_CTRL, 0x880F);
+		rtw_write8(adapter, REG_SYS_ISO_CTRL, 0xF9);
+	}
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Reset Digital.\n")); */
+}
+
+static void
+_ResetDigitalProcedure2(
+	struct rtw_adapter *			adapter
+)
+{
+/*****************************
+k.	SYS_FUNC_EN 0x03[7:0] = 0x44			disable ELDR runction
+l.	SYS_CLKR 0x08[15:0] = 0x3083			disable ELDR clock
+m.	SYS_ISO_CTRL 0x01[7:0] = 0x83			isolated ELDR to PON
+******************************/
+	rtw_write16(adapter, REG_SYS_CLKR, 0x70a3); /* modify to 0x70a3 by Scott. */
+	rtw_write8(adapter, REG_SYS_ISO_CTRL+1, 0x82); /* modify to 0x82 by Scott. */
+}
+
+static void
+_DisableAnalog(
+	struct rtw_adapter *			adapter,
+	bool			bWithoutHWSM
+	)
+{
+	u32 value16 = 0;
+	u8 value8 = 0;
+
+	if (bWithoutHWSM) {
+	/*****************************
+	n.	LDOA15_CTRL 0x20[7:0] = 0x04		disable A15 power
+	o.	LDOV12D_CTRL 0x21[7:0] = 0x54		disable digital core power
+	r.	When driver call disable, the ASIC will turn off remaining clock automatically
+	******************************/
+
+		rtw_write8(adapter, REG_LDOA15_CTRL, 0x04);
+		/* PlatformIOWrite1Byte(adapter, REG_LDOV12D_CTRL, 0x54); */
+
+		value8 = rtw_read8(adapter, REG_LDOV12D_CTRL);
+		value8 &= (~LDV12_EN);
+		rtw_write8(adapter, REG_LDOV12D_CTRL, value8);
+		/* RT_TRACE(COMP_INIT, DBG_LOUD, (" REG_LDOV12D_CTRL Reg0x21:0x%02x.\n", value8)); */
+	}
+
+/*****************************
+h.	SPS0_CTRL 0x11[7:0] = 0x23		enter PFM mode
+i.	APS_FSMCO 0x04[15:0] = 0x4802		set USB suspend
+******************************/
+	rtw_write8(adapter, REG_SPS0_CTRL, 0x23);
+
+	value16 |= (APDM_HOST | AFSM_HSUS |PFM_ALDN);
+	rtw_write16(adapter, REG_APS_FSMCO, value16);/* 0x4802 */
+
+	rtw_write8(adapter, REG_RSV_CTRL, 0x0e);
+
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("======> Disable Analog Reg0x04:0x%04x.\n", value16)); */
+}
+
+static bool
+CanGotoPowerOff92D(
+	struct rtw_adapter *			adapter
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	u8 u1bTmp;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+#endif
+
+	if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY)
+		return true;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (Buddyadapter != NULL)
+	{
+		if (Buddyadapter->init_adpt_in_progress)
+		{
+			DBG_8192D("do not power off during another adapter is initialization\n");
+			return false;
+		}
+	}
+#endif
+
+	if (pHalData->interfaceIndex == 0)
+	{	/*  query another mac status; */
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
+		u1bTmp&= MAC1_ON;
+	}
+	else
+	{
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		u1bTmp&= MAC0_ON;
+	}
+
+	/* 0x17[7]:1b' power off in process */
+	u1bTmp = rtw_read8(adapter, 0x17);
+	u1bTmp|= BIT7;
+	rtw_write8(adapter, 0x17, u1bTmp);
+
+	rtw_udelay_os(500);
+	/*  query another mac status; */
+	if (pHalData->interfaceIndex == 0)
+	{	/*  query another mac status; */
+		u1bTmp = rtw_read8(adapter, REG_MAC1);
+		u1bTmp&= MAC1_ON;
+	}
+	else
+	{
+		u1bTmp = rtw_read8(adapter, REG_MAC0);
+		u1bTmp&= MAC0_ON;
+	}
+	/* if another mac is alive, do not do power off */
+	if (u1bTmp)
+	{
+		u1bTmp = rtw_read8(adapter, 0x17);
+		u1bTmp&= (~BIT7);
+		rtw_write8(adapter, 0x17, u1bTmp);
+		return false;
+	}
+	return true;
+}
+
+static int
+CardDisableHWSM(/*  HW Auto state machine */
+	struct rtw_adapter *		adapter,
+	bool			resetMCU
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	int		rtStatus = _SUCCESS;
+	u8		value;
+
+	if (adapter->bSurpriseRemoved) {
+		return rtStatus;
+	}
+
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
+	rtw_udelay_os(500);
+	rtw_write8(adapter,	REG_CR, 0x0);
+
+	/*  RF Off Sequence ==== */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
+#endif
+		_DisableRFAFEAndResetBB(adapter);
+
+	if (!PHY_CheckPowerOffFor8192D(adapter))
+		return rtStatus;
+
+	/* 0x20:value 05-->04 */
+	rtw_write8(adapter, REG_LDOA15_CTRL, 0x04);
+	/* RF Control */
+	rtw_write8(adapter, REG_RF_CTRL, 0);
+
+	/*   ==== Reset digital sequence   ====== */
+	_ResetDigitalProcedure1(adapter, false);
+
+	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
+	_DisableGPIO(adapter);
+
+	/*   ==== Disable analog sequence === */
+	_DisableAnalog(adapter, false);
+
+	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+	value = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
+	value&= (~BIT7);
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, value);
+	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("======> Card disable finished.\n"));
+
+	return rtStatus;
+}
+
+static int
+CardDisableWithoutHWSM(/*  without HW Auto state machine */
+	struct rtw_adapter *		adapter
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	int		rtStatus = _SUCCESS;
+	u8		value;
+
+	if (adapter->bSurpriseRemoved) {
+		return rtStatus;
+	}
+
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
+	rtw_udelay_os(500);
+	rtw_write8(adapter,	REG_CR, 0x0);
+
+	/*  RF Off Sequence ==== */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (!pHalData->bSlaveOfDMSP || adapter->DualMacConcurrent == false)
+#endif
+		_DisableRFAFEAndResetBB(adapter);
+
+	/*  stop tx/rx */
+	rtw_write8(adapter, REG_TXPAUSE, 0xFF);
+	rtw_udelay_os(500);
+	rtw_write8(adapter,	REG_CR, 0x0);
+
+	if (!PHY_CheckPowerOffFor8192D(adapter))
+	{
+		return rtStatus;
+	}
+
+	/* 0x20:value 05-->04 */
+	rtw_write8(adapter, REG_LDOA15_CTRL, 0x04);
+	/* RF Control */
+	rtw_write8(adapter, REG_RF_CTRL, 0);
+
+	/*   ==== Reset digital sequence   ====== */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	_ResetDigitalProcedure1(adapter, false);
+#else
+	_ResetDigitalProcedure1(adapter, true);
+#endif
+
+	/*   ==== Pull GPIO PIN to balance level and LED control ====== */
+	_DisableGPIO(adapter);
+
+	/*   ==== Reset digital sequence   ====== */
+	_ResetDigitalProcedure2(adapter);
+
+	/*   ==== Disable analog sequence === */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	_DisableAnalog(adapter, false);
+#else
+	_DisableAnalog(adapter, true);
+#endif
+
+	ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+	value = rtw_read8(adapter, REG_POWER_OFF_IN_PROCESS);
+	value&= (~BIT7);
+	rtw_write8(adapter, REG_POWER_OFF_IN_PROCESS, value);
+	RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerOnAndPowerOff);
+
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("<====== Card Disable Without HWSM .\n")); */
+	return rtStatus;
+}
+
+static u32 rtl8192du_hal_deinit(struct rtw_adapter *padapter)
+ {
+	u8	u1bTmp;
+	u8	OpMode;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
+
+	if (RT_IN_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC))
+	{
+		DBG_8192D("Haltadapter8192DUsb(): Not to haltadapter if HW already halt\n");
+		return _FAIL;
+	}
+
+	padapter->bHaltInProgress = true;
+
+	OpMode = 0;
+	rtw_hal_set_hwreg(padapter, HW_VAR_MEDIA_STATUS, (u8 *)(&OpMode));
+
+	rtw_write16(padapter, REG_GPIO_MUXCFG, rtw_read16(padapter, REG_GPIO_MUXCFG)&(~BIT12));
+
+	if (/*adapter->bInUsbIfTest ||*/ !pHalData->bSupportRemoteWakeUp) {
+		if (padapter->bCardDisableWOHSM == false)
+			CardDisableHWSM(padapter, false);
+		else
+			CardDisableWithoutHWSM(padapter);
+	} else {
+
+		/*  Wake on WLAN */
+	}
+
+	if (pHalData->bInSetPower)
+	{
+		/* 0xFE10[4] clear before suspend	 suggested by zhouzhou */
+		u1bTmp = rtw_read8(padapter, 0xfe10);
+		u1bTmp&= (~BIT4);
+		rtw_write8(padapter, 0xfe10, u1bTmp);
+	}
+
+	RT_SET_PS_LEVEL(pwrpriv, RT_RF_OFF_LEVL_HALT_NIC);
+
+	rtw_led_control(padapter, LED_CTL_POWER_OFF);
+
+	padapter->bHaltInProgress = false;
+
+	return _SUCCESS;
+ }
+
+static unsigned int rtl8192du_inirp_init(struct rtw_adapter *padapter)
+{
+	u8 i;
+	struct recv_buf *precvbuf;
+	uint	status;
+	struct intf_hdl *pintfhdl =&padapter->iopriv.intf;
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+	_read_port = pintfhdl->io_ops._read_port;
+
+	status = _SUCCESS;
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("===> usb_inirp_init\n"));
+
+	precvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;
+
+	/* issue Rx irp to receive data */
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i<NR_RECVBUFF; i++)
+	{
+		if (_read_port(pintfhdl, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false)
+		{
+			RT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("usb_rx_init: usb_read_port error\n"));
+			status = _FAIL;
+			goto exit;
+		}
+
+		precvbuf++;
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+
+exit:
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("<=== usb_inirp_init\n"));
+	return status;
+}
+
+static unsigned int rtl8192du_inirp_deinit(struct rtw_adapter *padapter)
+{
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("\n ===> usb_rx_deinit\n"));
+
+	rtw_read_port_cancel(padapter);
+
+	RT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("\n <=== usb_rx_deinit\n"));
+
+	return _SUCCESS;
+}
+
+/*  */
+/*  */
+/*	EEPROM/EFUSE Content Parsing */
+/*  */
+/*  */
+
+static void
+_ReadPROMVersion(
+	struct rtw_adapter *	adapter,
+	u8*	PROMContent,
+	bool		AutoloadFail
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+
+	if (AutoloadFail) {
+		pHalData->EEPROMVersion = EEPROM_Default_Version;
+	}
+	else {
+		pHalData->EEPROMVersion = *(u8 *)&PROMContent[EEPROM_VERSION];
+	}
+}
+
+static u32 _GetChannelGroup(u32 channel)
+{
+
+	if (channel < 3) {	/*  Channel 1~3 */
+		return 0;
+	}
+	else if (channel < 9) { /*  Channel 4~9 */
+		return 1;
+	}
+
+	return 2;				/*  Channel 10~14 */
+}
+
+static void
+_ReadIDs(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	bool		AutoloadFail
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+
+	if (false == AutoloadFail) {
+		/*  VID, PID */
+		pHalData->EEPROMVID = le16_to_cpu(*(__le16 *)&PROMContent[EEPROM_VID]);
+		pHalData->EEPROMPID = le16_to_cpu(*(__le16 *)&PROMContent[EEPROM_PID]);
+
+		/*  Customer ID, 0x00 and 0xff are reserved for Realtek. */
+		pHalData->EEPROMCustomerID = *(u8 *)&PROMContent[EEPROM_CUSTOMER_ID];
+		pHalData->EEPROMSubCustomerID = *(u8 *)&PROMContent[EEPROM_SUBCUSTOMER_ID];
+
+	}
+	else {
+		pHalData->EEPROMVID	 = EEPROM_Default_VID;
+		pHalData->EEPROMPID	 = EEPROM_Default_PID;
+
+		/*  Customer ID, 0x00 and 0xff are reserved for Realtek. */
+		pHalData->EEPROMCustomerID	= EEPROM_Default_CustomerID;
+		pHalData->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
+
+	}
+
+	/*	Decide CustomerID according to VID/DID or EEPROM */
+	switch (pHalData->EEPROMCustomerID) {
+	case EEPROM_CID_WHQL:
+		break;
+	default:
+		pHalData->CustomerID = RT_CID_DEFAULT;
+		break;
+	}
+
+	DBG_8192D("EEPROMVID = 0x%04x\n", pHalData->EEPROMVID);
+	DBG_8192D("EEPROMPID = 0x%04x\n", pHalData->EEPROMPID);
+	DBG_8192D("EEPROMCustomerID : 0x%02x\n", pHalData->EEPROMCustomerID);
+	DBG_8192D("EEPROMSubCustomerID: 0x%02x\n", pHalData->EEPROMSubCustomerID);
+}
+
+static void
+_ReadMACAddress(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	bool		AutoloadFail
+	)
+{
+	struct hal_data_8192du		*pHalData = GET_HAL_DATA(adapter);
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+
+	/*  Dual MAC should assign diffrent MAC address , or, it is wil cause hang in single phy mode  zhiyuan 04/07/2010 */
+	/* Temply random assigh mac address for  efuse mac address not ready now */
+	if (AutoloadFail == false ) {
+		if (pHalData->interfaceIndex == 0) {
+			/* change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20 */
+			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC0_92D], ETH_ALEN);
+		}
+		else {
+			/* change to use memcpy, in order to avoid alignment issue. Baron 2011/6/20 */
+			memcpy(&pEEPROM->mac_addr, &PROMContent[EEPROM_MAC_ADDR_MAC1_92D], ETH_ALEN);
+		}
+
+		if (is_broadcast_mac_addr(pEEPROM->mac_addr) || is_multicast_mac_addr(pEEPROM->mac_addr))
+		{
+			/* Random assigh MAC address */
+			u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
+			if (pHalData->interfaceIndex == 1)
+				sMacAddr[5] = 0x01;
+			memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);
+		}
+	}
+	else
+	{
+		/* Random assigh MAC address */
+		u8 sMacAddr[MAC_ADDR_LEN] = {0x00, 0xE0, 0x4C, 0x81, 0x92, 0x00};
+		if (pHalData->interfaceIndex == 1) {
+			sMacAddr[5] = 0x01;
+		}
+		memcpy(pEEPROM->mac_addr, sMacAddr, ETH_ALEN);
+	}
+
+	DBG_8192D("MAC Address from EFUSE = %pM\n", pEEPROM->mac_addr);
+}
+
+static void
+hal_ReadMacPhyModeFromPROM92DU(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent
+)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	u8	MacPhyCrValue = 0;
+
+	MacPhyCrValue = PROMContent[EEPROM_ENDPOINT_SETTING];
+	if (MacPhyCrValue & BIT0)
+	{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		if (adapter->registrypriv.mac_phy_mode == 3)
+		{
+			pHalData->MacPhyMode92D = DUALMAC_SINGLEPHY;
+			adapter->DualMacConcurrent = true;
+		}
+		else
+		{
+			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
+			adapter->DualMacConcurrent = false;
+		}
+#else
+		pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
+		DBG_8192D("hal_ReadMacPhyModeFromPROM92DU:: MacPhyMode DUALMAC_DUALPHY\n");
+#endif
+
+		if (adapter->registrypriv.mac_phy_mode == 1)
+			pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
+		else	 if (adapter->registrypriv.mac_phy_mode == 2)
+			pHalData->MacPhyMode92D = DUALMAC_DUALPHY;
+	}
+	else
+	{
+		pHalData->MacPhyMode92D = SINGLEMAC_SINGLEPHY;
+	}
+
+	DBG_8192D("_ReadMacPhyModeFromPROM92DU(): MacPhyCrValue %d\n", MacPhyCrValue);
+}
+
+static void
+hal_ReadMacPhyMode_92D(
+	struct rtw_adapter *	adapter,
+	u8			*PROMContent,
+	bool		AutoloadFail
+)
+{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+	u8	Mac1EnableValue = 0;
+
+	if (AutoloadFail == true) {
+		Mac1EnableValue = rtw_read8(adapter, 0xFE64);
+		PHY_ReadMacPhyMode92D(adapter, AutoloadFail);
+
+		DBG_8192D("_ReadMacPhyMode(): AutoloadFail %d 0xFE64 = 0x%x\n", AutoloadFail, Mac1EnableValue);
+	}
+	else {
+		hal_ReadMacPhyModeFromPROM92DU(adapter, PROMContent);
+	}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+/* SMSP-->DMDP/DMSP wait for another adapter compeletes mode switc */
+
+/* get Dual Mac Mode from 0x2C for test chip and 0xF8 for normal chip */
+	ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
+	if (GlobalFirstConfigurationForNormalChip)
+	{
+		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
+		PHY_ConfigMacPhyMode92D(adapter);
+		ACQUIRE_GLOBAL_MUTEX(GlobalCounterForMutex);
+		GlobalFirstConfigurationForNormalChip = false;
+		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
+	}
+	else
+	{
+		RELEASE_GLOBAL_MUTEX(GlobalCounterForMutex);
+		PHY_ReadMacPhyMode92D(adapter, AutoloadFail);
+	}
+#else
+	PHY_ConfigMacPhyMode92D(adapter);
+#endif
+
+	PHY_ConfigMacPhyModeInfo92D(adapter);
+	rtl8192d_ResetDualMacSwitchVariables(adapter);
+}
+
+static void
+_ReadBoardType(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	bool		AutoloadFail
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	u8			boardType;
+
+	if (AutoloadFail) {
+		pHalData->rf_type = RF_2T2R;
+		pHalData->BluetoothCoexist = false;
+		return;
+	}
+
+	boardType = PROMContent[EEPROM_NORMAL_BoardType];
+	boardType &= BOARD_TYPE_NORMAL_MASK;
+	boardType >>= 5;
+}
+
+static void
+_ReadLEDSetting(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	bool		AutoloadFail
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	struct led_priv		*pledpriv = &(adapter->ledpriv);
+
+	/*  Led mode */
+	switch (pHalData->CustomerID)
+	{
+		case RT_CID_DEFAULT:
+			pledpriv->LedStrategy = SW_LED_MODE1;
+			pledpriv->bRegUseLed = true;
+			break;
+		default:
+			pledpriv->LedStrategy = SW_LED_MODE0;
+			break;
+	}
+
+	#ifdef CONFIG_FORCE_HW_LED
+	pledpriv->LedStrategy = HW_LED;
+	#endif
+}
+
+#ifdef CONFIG_WOWLAN
+static void
+_ReadWOWLAN(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	bool		AutoloadFail
+	)
+{
+	if (AutoloadFail)
+		adapter->pwrctrlpriv.bSupportRemoteWakeup = false;
+	else
+	{
+		/*  decide hw if support remote wakeup function */
+		/*  if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume */
+		adapter->pwrctrlpriv.bSupportRemoteWakeup = (PROMContent[EEPROM_Option_Setting] & BIT1)?true :false;
+		DBG_8192D("efuse remote wakeup =%d\n", adapter->pwrctrlpriv.bSupportRemoteWakeup);
+	}
+}
+#endif /* CONFIG_WOWLAN */
+
+static void _InitadapterVariablesByPROM(
+	struct rtw_adapter *	adapter,
+	u8*		PROMContent,
+	unsigned char AutoloadFail
+	)
+{
+	_ReadPROMVersion(adapter, PROMContent, AutoloadFail);
+	_ReadIDs(adapter, PROMContent, AutoloadFail);
+	_ReadMACAddress(adapter, PROMContent, AutoloadFail);
+	rtl8192d_ReadTxPowerInfo(adapter, PROMContent, AutoloadFail);
+	hal_ReadMacPhyMode_92D(adapter, PROMContent, AutoloadFail);
+	rtl8192d_EfuseParseChnlPlan(adapter, PROMContent, AutoloadFail);
+	_ReadBoardType(adapter, PROMContent, AutoloadFail);
+	_ReadLEDSetting(adapter, PROMContent, AutoloadFail);
+#ifdef CONFIG_WOWLAN
+	_ReadWOWLAN(adapter, PROMContent, AutoloadFail);
+#endif /* CONFIG_WOWLAN */
+}
+
+static void _ReadPROMContent(
+	struct rtw_adapter *		adapter
+	)
+{
+	struct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(adapter);
+	u8			PROMContent[HWSET_MAX_SIZE]={0};
+	u8			eeValue;
+	u32			i;
+
+	eeValue = rtw_read8(adapter, REG_9346CR);
+	/*  To check system boot selection. */
+	pEEPROM->EepromOrEfuse		= (eeValue & BOOT_FROM_EEPROM) ? true : false;
+	pEEPROM->bautoload_fail_flag	= (eeValue & EEPROM_EN) ? false : true;
+
+	DBG_8192D("Boot from %s, Autoload %s !\n", (pEEPROM->EepromOrEfuse ? "EEPROM" : "EFUSE"),
+				(pEEPROM->bautoload_fail_flag ? "Fail" : "OK"));
+
+	if (pEEPROM->bautoload_fail_flag == false) {
+		if (pEEPROM->EepromOrEfuse == true) {
+			/*  Read all Content from EEPROM or EFUSE. */
+		} else {
+			/*  Read EFUSE real map to shadow. */
+			ACQUIRE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+			EFUSE_ShadowMapUpdate(adapter, EFUSE_WIFI, false);
+			RELEASE_GLOBAL_MUTEX(GlobalMutexForPowerAndEfuse);
+			memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
+		}
+
+		/* Double check 0x8192 autoload status again */
+		if (RTL8192_EEPROM_ID != le16_to_cpu(*((__le16 *)PROMContent)))
+		{
+			pEEPROM->bautoload_fail_flag = true;
+			DBG_8192D("Autoload OK but EEPROM ID content is incorrect!!\n");
+		}
+
+	}
+	else if (pEEPROM->EepromOrEfuse == false)/* auto load fail */
+	{
+		memset(pEEPROM->efuse_eeprom_data, 0xff, HWSET_MAX_SIZE);
+		memcpy((void*)PROMContent, (void*)pEEPROM->efuse_eeprom_data, HWSET_MAX_SIZE);
+	}
+
+	_InitadapterVariablesByPROM(adapter, PROMContent, pEEPROM->bautoload_fail_flag);
+}
+
+static void
+_InitOtherVariable(
+	struct rtw_adapter *		adapter
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+
+	/*  2009/06/10 MH For 92S 1*1 = 1R/ 1*2&2*2 use 2R. We default set 1*1 use radio A */
+	/*  So if you want to use radio B. Please modify RF path enable bit for correct signal */
+	/*  strength calculate. */
+	if (pHalData->rf_type == RF_1T1R) {
+		pHalData->bRFPathRxEnable[0] = true;
+	}
+	else {
+		pHalData->bRFPathRxEnable[0] = pHalData->bRFPathRxEnable[1] = true;
+	}
+}
+
+static void
+_ReadRFType(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+
+#if DISABLE_BB_RF
+	pHalData->rf_chip = RF_PSEUDO_11N;
+#else
+	pHalData->rf_chip = RF_6052;
+#endif
+}
+
+static int _ReadadapterInfo8192DU(struct rtw_adapter *	adapter)
+{
+	u32 start = rtw_get_current_time();
+
+	DBG_8192D("====> %s\n", __func__);
+
+	_ReadRFType(adapter);
+	_ReadPROMContent(adapter);
+
+	_InitOtherVariable(adapter);
+
+	/* For 92DU Phy and Mac mode set , will initialize by EFUSE/EPPROM     zhiyuan 2010/03/25 */
+	DBG_8192D("<==== %s in %d ms\n", __func__, rtw_get_passing_time_ms(start));
+
+	return _SUCCESS;
+}
+
+static void ReadadapterInfo8192DU(struct rtw_adapter *adapter)
+{
+	/*  Read EEPROM size before call any EEPROM function */
+	adapter->EepromAddressSize = GetEEPROMSize8192D(adapter);
+
+	_ReadadapterInfo8192DU(adapter);
+}
+
+#define GPIO_DEBUG_PORT_NUM 0
+static void rtl8192du_trigger_gpio_0(struct rtw_adapter *padapter)
+{
+
+	u32 gpioctrl;
+	DBG_8192D("==> trigger_gpio_0...\n");
+	rtw_write16_async(padapter, REG_GPIO_PIN_CTRL, 0);
+	rtw_write8_async(padapter, REG_GPIO_PIN_CTRL+2, 0xFF);
+	gpioctrl = (BIT(GPIO_DEBUG_PORT_NUM)<<24)|(BIT(GPIO_DEBUG_PORT_NUM)<<16);
+	rtw_write32_async(padapter, REG_GPIO_PIN_CTRL, gpioctrl);
+	gpioctrl |= (BIT(GPIO_DEBUG_PORT_NUM)<<8);
+	rtw_write32_async(padapter, REG_GPIO_PIN_CTRL, gpioctrl);
+	DBG_8192D("<=== trigger_gpio_0...\n");
+}
+
+static void
+StopTxBeacon(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
+
+	DBG_8192D("StopTxBeacon\n");
+
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+	pHalData->RegFwHwTxQCtrl &= (~BIT6);
+	rtw_write8(adapter, REG_BCN_MAX_ERR, 0xff);
+	rtw_write8(adapter, REG_TBTT_PROHIBIT+1, 0x64);
+}
+
+static void
+ResumeTxBeacon(
+	struct rtw_adapter *	adapter
+	)
+{
+	struct hal_data_8192du *	pHalData = GET_HAL_DATA(adapter);
+
+	DBG_8192D("ResumeTxBeacon\n");
+
+	rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+	pHalData->RegFwHwTxQCtrl |= BIT6;
+	rtw_write8(adapter, REG_BCN_MAX_ERR, 0x0a);
+	rtw_write8(adapter, REG_TBTT_PROHIBIT+1, 0x64);
+}
+
+/*  */
+/*  2010.11.17. Added by tynli. */
+/*  */
+static u8 SelectRTSInitialRate(struct rtw_adapter *adapter)
+{
+	struct sta_info		*psta;
+	struct mlme_priv		*pmlmepriv = &adapter->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+	struct sta_priv		*pstapriv = &adapter->stapriv;
+	u8	bUseProtection;
+	u16	BasicRateCfg = 0;
+	u8	SupportRateSet[NDIS_802_11_LENGTH_RATES_EX];
+	u8	RTSRateIndex = 0; /*  1M */
+	u8	LowestRateIdx = 0;
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+	if (psta == NULL)
+	{
+		return RTSRateIndex;
+	}
+
+	if (psta->rtsen || psta->cts2self)
+		bUseProtection = true;
+
+	memcpy(SupportRateSet, cur_network->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
+
+	halsetbratecfg(adapter, SupportRateSet, &BasicRateCfg);
+
+	if (bUseProtection &&
+		(!(pmlmeext->cur_wireless_mode == WIRELESS_11A|| pmlmeext->cur_wireless_mode == WIRELESS_11A_5N)))/*  5G not support cck rate */
+	{
+		/*  Use CCK rate */
+		BasicRateCfg &= 0xf; /* CCK rate */
+		while (BasicRateCfg > 0x1)
+		{
+			BasicRateCfg = (BasicRateCfg>> 1);
+			RTSRateIndex++;
+		}
+	}
+	else /* if (pMgntInfo->pHTInfo->CurrentOpMode) */
+	{
+		/* MacId 0: INFRA mode. */
+		if ((check_fwstate(pmlmepriv, _FW_LINKED) == true)&&(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
+		{
+			LowestRateIdx = rtw_read8(adapter, REG_INIDATA_RATE_SEL)&0x3f;
+		}
+
+		/*  Adjust RTS Init rate when the data rate is MCS0~2, 8~10 which is lower than 24M. */
+		if (LowestRateIdx == 12 || LowestRateIdx == 20) /* MCS0, MCS8 */
+		{
+			RTSRateIndex = 4; /*  6M */
+		}
+		else if (LowestRateIdx == 13 || LowestRateIdx == 14 ||
+			LowestRateIdx == 21 || LowestRateIdx == 22) /* MCS1, MCS2, MCS9, MCS10 */
+		{
+			RTSRateIndex = 6; /*  12M */
+		}
+		else
+		{
+			if (BasicRateCfg != 0)
+			{
+				/*  Select RTS Init rate */
+				while (BasicRateCfg > 0x1)
+				{
+					BasicRateCfg = (BasicRateCfg>> 1);
+					RTSRateIndex++;
+				}
+			}
+			else
+			{
+				RTSRateIndex = 4; /*  6M */
+			}
+		}
+
+	}
+
+	/* Set RTS init rate to Hw. */
+	return RTSRateIndex;
+}
+
+/*  */
+/*  Description: Selcet the RTS init rate and set the rate to HW. */
+/*  2010.11.25. Created by tynli. */
+/*  */
+static void SetRTSRateWorkItemCallback(void *pContext)
+{
+	struct rtw_adapter *adapter =  (struct rtw_adapter *)pContext;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8	NewRTSInitRate = 0;
+
+	NewRTSInitRate = SelectRTSInitialRate(adapter);
+	if (NewRTSInitRate != pHalData->RTSInitRate)
+	{
+		rtw_write8(adapter, REG_INIRTS_RATE_SEL, NewRTSInitRate);
+		pHalData->RTSInitRate = NewRTSInitRate;
+	}
+
+	DBG_8192D("HW_VAR_INIT_RTS_RATE: RateIndex(%d)\n", NewRTSInitRate);
+}
+
+static void hw_var_set_opmode(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	u8	val8;
+	u8	mode = *((u8 *)val);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->iface_type == IFACE_PORT1)
+	{
+		/*  disable Port1 TSF update */
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
+
+		/*  set net_type */
+		val8 = rtw_read8(adapter, MSR)&0x03;
+		val8 |= (mode<<2);
+		rtw_write8(adapter, MSR, val8);
+
+		/* reset TSF1 */
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
+
+		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
+
+		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
+			{
+				StopTxBeacon(adapter);
+			}
+
+			rtw_write8(adapter, REG_BCN_CTRL_1, 0x19);/* disable atim wnd */
+		}
+		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{
+			ResumeTxBeacon(adapter);
+			rtw_write8(adapter, REG_BCN_CTRL_1, 0x1a);
+		}
+		else if (mode == _HW_STATE_AP_)
+		{
+			ResumeTxBeacon(adapter);
+
+			rtw_write8(adapter, REG_BCN_CTRL_1, 0x12);
+
+			/* Set RCR */
+			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			/* enable to rx data frame */
+			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+			/* enable to rx ps-poll */
+			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
+
+			/* Beacon Control related register for first time */
+			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+			rtw_write8(adapter, REG_ATIMWND_1, 0x0a); /*  10ms for port1 */
+			rtw_write16(adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
+
+		       /* enable BCN1 Function for if2 */
+			/* don't enable update TSF1 for if2 (due to TSF update when beacon/probe rsp are received) */
+			rtw_write8(adapter, REG_BCN_CTRL_1, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+
+			DBG_8192D("%s()-%d: REG_BCN_CTRL_1 = %02x\n", __func__, __LINE__, rtw_read8(adapter, REG_BCN_CTRL_1));
+
+			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(adapter, REG_BCN_CTRL,
+					rtw_read8(adapter, REG_BCN_CTRL) & ~EN_BCN_FUNCTION);
+
+			/* dis BCN0 ATIM  WND if if1 is station */
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(0));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			/*  Reset TSF for STA+AP concurrent mode */
+			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
+				if (reset_tsf(adapter, IFACE_PORT1) == false)
+					DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
+						__func__, __LINE__);
+			}
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
+		}
+
+	}
+	else	/*  (adapter->iface_type == IFACE_PORT1) */
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		/*  disable Port0 TSF update */
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+
+		/*  set net_type */
+		val8 = rtw_read8(adapter, MSR)&0x0c;
+		val8 |= mode;
+		rtw_write8(adapter, MSR, val8);
+
+		/* reset TSF0 */
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
+
+		DBG_8192D("%s()-%d mode = %d\n", __func__, __LINE__, mode);
+
+		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+		{
+#ifdef CONFIG_CONCURRENT_MODE
+			if (!check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
+#endif /* CONFIG_CONCURRENT_MODE */
+			{
+				StopTxBeacon(adapter);
+			}
+
+			rtw_write8(adapter, REG_BCN_CTRL, 0x19);/* disable atim wnd */
+		}
+		else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+		{
+			ResumeTxBeacon(adapter);
+			rtw_write8(adapter, REG_BCN_CTRL, 0x1a);
+		}
+		else if (mode == _HW_STATE_AP_)
+		{
+			ResumeTxBeacon(adapter);
+
+			rtw_write8(adapter, REG_BCN_CTRL, 0x12);
+
+			/* Set RCR */
+			rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+			/* enable to rx data frame */
+			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+			/* enable to rx ps-poll */
+			rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
+
+			/* Beacon Control related register for first time */
+
+			rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+			rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+
+			rtw_write8(adapter, REG_ATIMWND, 0x0a); /*  10ms for port0 */
+			rtw_write16(adapter, REG_BCNTCFG, 0x00);
+			rtw_write16(adapter, REG_TBTT_PROHIBIT, 0xff04);
+			rtw_write16(adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);/*  +32767 (~32ms) */
+
+		        /* enable BCN0 Function for if1 */
+			/* don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received) */
+			rtw_write8(adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | EN_TXBCN_RPT|BIT(1)));
+
+#ifdef CONFIG_CONCURRENT_MODE
+			if (check_buddy_fwstate(adapter, WIFI_FW_NULL_STATE))
+				rtw_write8(adapter, REG_BCN_CTRL_1,
+					rtw_read8(adapter, REG_BCN_CTRL_1) & ~EN_BCN_FUNCTION);
+
+			/* dis BCN1 ATIM  WND if if2 is station */
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(0));
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+			/*  Reset TSF for STA+AP concurrent mode */
+			if (check_buddy_fwstate(adapter, (WIFI_STATION_STATE|WIFI_ASOC_STATE))) {
+				if (reset_tsf(adapter, IFACE_PORT0) == false)
+					DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
+						__func__, __LINE__);
+			}
+#endif /*  CONFIG_TSF_RESET_OFFLOAD */
+#endif /*  CONFIG_CONCURRENT_MODE */
+		}
+
+	}
+}
+
+static void hw_var_set_macaddr(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	u8 idx = 0;
+	u32 reg_macid;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->iface_type == IFACE_PORT1) {
+		reg_macid = REG_MACID1;
+	} else
+#endif
+	{
+		reg_macid = REG_MACID;
+	}
+
+	for (idx = 0 ; idx < 6; idx++)
+		rtw_write8(adapter, (reg_macid+idx), val[idx]);
+}
+
+static void hw_var_set_bssid(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	u8	idx = 0;
+	u32 reg_bssid;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->iface_type == IFACE_PORT1)
+	{
+		reg_bssid = REG_BSSID1;
+	}
+	else
+#endif
+	{
+		reg_bssid = REG_BSSID;
+	}
+
+	for (idx = 0 ; idx < 6; idx++)
+	{
+		rtw_write8(adapter, (reg_bssid+idx), val[idx]);
+	}
+}
+
+static void hw_var_set_bcn_func(struct rtw_adapter *adapter, u8 variable,
+				u8 *val)
+{
+	u32 bcn_ctrl_reg;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->iface_type == IFACE_PORT1)
+	{
+		bcn_ctrl_reg = REG_BCN_CTRL_1;
+
+		if (*((u8 *)val))
+		{
+			rtw_write8(adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+		}
+		else
+		{
+			rtw_write8(adapter, bcn_ctrl_reg, rtw_read8(adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));
+		}
+	}
+	else
+#endif
+	{
+		bcn_ctrl_reg = REG_BCN_CTRL;
+		if (*((u8 *)val))
+		{
+			rtw_write8(adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+		}
+		else
+		{
+			rtw_write8(adapter, bcn_ctrl_reg, (rtw_read8(adapter, bcn_ctrl_reg)&(~(EN_TXBCN_RPT))) | DIS_TSF_UDT0_NORMAL_CHIP);
+		}
+	}
+}
+
+static void hw_var_set_correct_tsf(struct rtw_adapter *adapter, u8 variable,
+				   u8 *val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	u64	tsf;
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
+
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		StopTxBeacon(adapter);
+	}
+
+	if (adapter->iface_type == IFACE_PORT1)
+	{
+		/* disable related TSF function */
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+
+		rtw_write32(adapter, REG_TSFTR1, tsf);
+		rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
+
+		/* enable related TSF function */
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		/*  Update buddy port's TSF(TBTT) if it is SoftAP for beacon TX issue! */
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
+			if (reset_tsf(adapter, IFACE_PORT0) == false)
+				DBG_8192D("ERROR! %s()-%d: Reset port0 TSF fail\n",
+					__func__, __LINE__);
+		}
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
+
+	}
+	else	/*  adapter->iface_type == IFACE_PORT1 */
+	{
+		/* disable related TSF function */
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
+		/*  disable TSF update instead! May induce burst beacon TX */
+
+		rtw_write32(adapter, REG_TSFTR, tsf);
+		rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
+
+		/* enable related TSF function */
+		rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
+
+		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)
+		) {
+			/* disable related TSF function */
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+			/*  disable TSF update instead! */
+
+			rtw_write32(adapter, REG_TSFTR1, tsf);
+			rtw_write32(adapter, REG_TSFTR1+4, tsf>>32);
+
+			/* enable related TSF function */
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(3));
+		}
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+		/*  Update buddy port's TSF if it is SoftAP for beacon TX issue! */
+		if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE
+			&& check_buddy_fwstate(adapter, WIFI_AP_STATE)) {
+			if (reset_tsf(adapter, IFACE_PORT1) == false)
+				DBG_8192D("ERROR! %s()-%d: Reset port1 TSF fail\n",
+					__func__, __LINE__);
+		}
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
+	}
+
+	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		ResumeTxBeacon(adapter);
+	}
+#endif	/*  CONFIG_CONCURRENT_MODE */
+}
+
+static void hw_var_set_mlme_disconnect(struct rtw_adapter *adapter,
+				       u8 variable, u8 *val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct rtw_adapter *pbuddy_adapter = adapter->pbuddy_adapter;
+
+	if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
+		rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
+
+	if (adapter->iface_type == IFACE_PORT1)
+	{
+		int i;
+		u8 reg_bcn_ctrl_1;
+
+		/*  a.Driver set 0x422 bit 6 = 0 */
+		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT6));
+		pHalData->RegFwHwTxQCtrl &= (~BIT6);
+
+#ifdef CONFIG_BEACON_DISABLE_OFFLOAD
+		u8 reg_bcn_disable_cnt = rtw_read8(adapter, REG_FW_BCN_DIS_CNT);
+		DBG_8192D("%s()-%d: reg_bcn_disable_cnt =%02x\n", __func__, __LINE__, reg_bcn_disable_cnt);
+
+		reg_bcn_ctrl_1 = rtw_read8(adapter, REG_BCN_CTRL_1);
+		DBG_8192D("%s()-%d: reg_bcn_ctrl_1 =%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
+
+		/*  b. driver set h2c cmd */
+		rtl8192c_dis_beacon_fun_cmd(adapter);
+
+		/*
+			  FW Job for port 0
+
+		   c. 8051 set nettype to ap
+		   d. 8051 check dma_int
+		   e. 8051 set nettype to no_link
+		   f.8051 dis_tsf_update   0x550 bit 4
+		   g.8051 reset  beacon function test count   0x553 bit0.
+		   h.8051 disable beacon function   0x550  bit3
+		   i. 8051 sent ready to driver
+
+		*/
+
+		/*  The worst case is 100 + 15 ms */
+		rtw_msleep_os(120);
+
+		for (i = 0; i< 10; i++) {
+			reg_bcn_ctrl_1 = rtw_read8(adapter, REG_BCN_CTRL_1);
+			if ((reg_bcn_ctrl_1 & BIT(3)) == 0) {
+				break;
+			}
+			DBG_8192D("%s()-%d: BEACON_DISABLE_OFFLOAD not finished! REG_BCN_CTRL_1 =%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
+			DBG_8192D("%s()-%d: reg_bcn_disable_cnt =%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_FW_BCN_DIS_CNT));
+			DBG_8192D("%s()-%d: REG_BCN_CTRL =%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_BCN_CTRL));
+			DBG_8192D("%s()-%d: FWISR =%08x\n", __func__, __LINE__, rtw_read32(adapter, REG_FWISR));
+			rtw_msleep_os(100);
+		}
+		DBG_8192D("%s()-%d: reg_bcn_disable_cnt =%02x\n", __func__, __LINE__, rtw_read8(adapter, REG_FW_BCN_DIS_CNT));
+		DBG_8192D("%s()-%d: reg_bcn_ctrl_1 =%02x\n", __func__, __LINE__, reg_bcn_ctrl_1);
+
+#else   /*  CONFIG_BEACON_DISABLE_OFFLOAD */
+
+		/* disable update TSF1 */
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)|BIT(4));
+
+		/* reset TSF1 */
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(1));
+
+		/*  disable Port1's beacon function */
+		rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(3)));
+
+#endif  /*  CONFIG_BEACON_DISABLE_OFFLOAD */
+
+		/*  j, Driver set 0x422 bit 6 = 1 */
+		rtw_write8(adapter, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT6);
+		pHalData->RegFwHwTxQCtrl |= BIT6;
+
+		/*  k. re_download beacon pkt */
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
+			set_tx_beacon_cmd(pbuddy_adapter);
+
+	}
+	else	/*  (adapter->iface_type == IFACE_PORT1) */
+	{
+		/* disable update TSF */
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+
+		/* reset TSF */
+		rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
+
+		/*  Can't disable Port0's beacon function due to it is used by RA */
+	}
+#endif
+}
+
+static void hw_var_set_mlme_sitesurvey(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	u32	value_rcr, rcr_clear_bit, reg_bcn_ctl;
+	u16	value_rxfltmap2;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv *pmlmepriv =&(adapter->mlmepriv);
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (adapter->iface_type == IFACE_PORT1)
+		reg_bcn_ctl = REG_BCN_CTRL_1;
+	else
+#endif
+		reg_bcn_ctl = REG_BCN_CTRL;
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+
+	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+#ifdef CONFIG_CONCURRENT_MODE
+		|| (check_buddy_fwstate(adapter, WIFI_AP_STATE) == true)
+#endif
+		)
+	{
+		rcr_clear_bit = RCR_CBSSID_BCN;
+	}
+	else
+	{
+		rcr_clear_bit = (RCR_CBSSID_BCN | RCR_CBSSID_DATA);
+	}
+
+	/*  Recieve all data frames */
+	value_rxfltmap2 = 0xFFFF;
+
+#else /* CONFIG_FIND_BEST_CHANNEL */
+
+	rcr_clear_bit = RCR_CBSSID_BCN;
+
+	/* config RCR to receive different BSSID & not to receive data frame */
+	value_rxfltmap2 = 0;
+
+#endif /* CONFIG_FIND_BEST_CHANNEL */
+
+	value_rcr = rtw_read32(adapter, REG_RCR);
+
+	if (*((u8 *)val))/* under sitesurvey */
+	{
+		pHalData->bLoadIMRandIQKSettingFor2G = false;
+
+		value_rcr &= ~(rcr_clear_bit);
+		rtw_write32(adapter, REG_RCR, value_rcr);
+
+		rtw_write16(adapter, REG_RXFLTMAP2, value_rxfltmap2);
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
+			/* disable update TSF */
+			rtw_write8(adapter, reg_bcn_ctl, rtw_read8(adapter, reg_bcn_ctl)|BIT(4));
+		}
+
+		/*  Save orignal RRSR setting. */
+		pHalData->RegRRSR = rtw_read16(adapter, REG_RRSR);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
+		{
+			StopTxBeacon(adapter);
+		}
+#endif
+	}
+	else/* sitesurvey done */
+	{
+		if (check_fwstate(pmlmepriv, _FW_LINKED) || check_fwstate(pmlmepriv, WIFI_AP_STATE)
+#ifdef CONFIG_CONCURRENT_MODE
+			|| check_buddy_fwstate(adapter, _FW_LINKED) || check_buddy_fwstate(adapter, WIFI_AP_STATE)
+#endif
+			)
+		{
+			/* enable to rx data frame */
+			rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+		}
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE |WIFI_ADHOC_MASTER_STATE)) {
+			/* enable update TSF */
+			rtw_write8(adapter, reg_bcn_ctl, rtw_read8(adapter, reg_bcn_ctl)&(~BIT(4)));
+		}
+
+		value_rcr |= rcr_clear_bit;
+		rtw_write32(adapter, REG_RCR, value_rcr);
+
+		/*  Restore orignal RRSR setting. */
+		rtw_write16(adapter, REG_RRSR, pHalData->RegRRSR);
+
+#ifdef CONFIG_CONCURRENT_MODE
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(adapter);
+		}
+#endif
+	}
+}
+
+static void hw_var_set_mlme_join(struct rtw_adapter *adapter,
+				 u8 variable, u8 *val)
+{
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	RetryLimit = 0x30;
+	u8	type = *((u8 *)val);
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+
+	if (type == 0) /*  prepare to join */
+	{
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
+		{
+			StopTxBeacon(adapter);
+		}
+
+		/* enable to rx data frame.Accept all data frame */
+		rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE))
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_BCN);
+		else
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		{
+			RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
+		}
+		else /*  Ad-hoc Mode */
+		{
+			RetryLimit = 0x7;
+		}
+
+		DBG_8192D("%s(): pHalData->bNeedIQK = true\n", __func__);
+		pHalData->bNeedIQK = true; /* for 92D IQK */
+	}
+	else if (type == 1) /* joinbss_event call back when join res < 0 */
+	{
+		if (check_buddy_mlmeinfo_state(adapter, _HW_STATE_NOLINK_))
+			rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
+
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(adapter);
+		}
+	}
+	else if (type == 2) /* sta add event call back */
+	{
+
+		/* enable update TSF */
+		if (adapter->iface_type == IFACE_PORT1)
+			rtw_write8(adapter, REG_BCN_CTRL_1, rtw_read8(adapter, REG_BCN_CTRL_1)&(~BIT(4)));
+		else
+			rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+		if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+		{
+			/* fixed beacon issue for 8191su........... */
+			rtw_write8(adapter, 0x542 , 0x02);
+			RetryLimit = 0x7;
+		}
+
+		if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+			check_buddy_fwstate(adapter, _FW_LINKED))
+		{
+			ResumeTxBeacon(adapter);
+		}
+
+	}
+
+	rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+
+#endif
+}
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+static void dc_hw_var_mlme_sitesurvey(struct rtw_adapter *adapter,
+				      u8 sitesurvey_state)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv;
+	struct mlme_ext_priv *pbuddy_mlmeext;
+
+	if ((Buddyadapter != NULL) &&
+		adapter->DualMacConcurrent == true)
+	{
+		pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
+		pbuddy_mlmeext = &Buddyadapter->mlmeextpriv;
+
+		if (sitesurvey_state)/* under sitesurvey */
+		{
+			if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+				check_buddy_fwstate(adapter, _FW_LINKED))
+			{
+				StopTxBeacon(Buddyadapter);
+			}
+
+			rtw_write16(adapter, REG_RRSR, 0x150);
+		}
+		else/* sitesurvey done */
+		{
+			if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+				check_buddy_fwstate(adapter, _FW_LINKED))
+			{
+				ResumeTxBeacon(Buddyadapter);
+			}
+		}
+	}
+}
+
+static void dc_hw_var_mlme_join(struct rtw_adapter *adapter, u8 join_state)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct rtw_adapter *Buddyadapter = adapter->pbuddy_adapter;
+	struct mlme_priv *pbuddy_mlmepriv;
+	struct mlme_ext_priv *pbuddy_mlmeext;
+
+	if ((Buddyadapter != NULL) &&
+		adapter->DualMacConcurrent == true)
+	{
+		pbuddy_mlmepriv = &(Buddyadapter->mlmepriv);
+		pbuddy_mlmeext = &Buddyadapter->mlmeextpriv;
+
+		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel ||
+			pmlmeext->cur_bwmode != pbuddy_mlmeext->cur_bwmode ||
+			pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset)
+		{
+			if (join_state == 0)/*  prepare to join */
+			{
+				if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+					check_buddy_fwstate(adapter, _FW_LINKED))
+				{
+					StopTxBeacon(Buddyadapter);
+				}
+			}
+			else/* join success or fail */
+			{
+				if (check_buddy_mlmeinfo_state(adapter, WIFI_FW_AP_STATE) &&
+					check_buddy_fwstate(adapter, _FW_LINKED))
+				{
+					ResumeTxBeacon(Buddyadapter);
+				}
+			}
+		}
+	}
+}
+#endif
+
+static void SetHwReg8192DU(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	switch (variable)
+	{
+		case HW_VAR_MEDIA_STATUS:
+			{
+				u8 val8;
+
+				val8 = rtw_read8(adapter, MSR)&0x0c;
+				val8 |= *((u8 *)val);
+				rtw_write8(adapter, MSR, val8);
+			}
+			break;
+		case HW_VAR_MEDIA_STATUS1:
+			{
+				u8 val8;
+
+				val8 = rtw_read8(adapter, MSR)&0x03;
+				val8 |= *((u8 *)val) <<2;
+				rtw_write8(adapter, MSR, val8);
+			}
+			break;
+		case HW_VAR_SET_OPMODE:
+#if defined(CONFIG_CONCURRENT_MODE)
+			hw_var_set_opmode(adapter, variable, val);
+#else /* CONFIG_CONCURRENT_MODE */
+			{
+				u8	val8;
+				u8	mode = *((u8 *)val);
+
+				if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_))
+				{
+					StopTxBeacon(adapter);
+					rtw_write8(adapter, REG_BCN_CTRL, 0x18);
+				}
+				else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/)
+				{
+					ResumeTxBeacon(adapter);
+					rtw_write8(adapter, REG_BCN_CTRL, 0x1a);
+				}
+				else if (mode == _HW_STATE_AP_)
+				{
+					ResumeTxBeacon(adapter);
+
+					rtw_write8(adapter, REG_BCN_CTRL, 0x12);
+
+					/* Set RCR */
+					rtw_write32(adapter, REG_RCR, 0x7000228e);/* CBSSID_DATA must set to 0 */
+					/* enable to rx data frame */
+					rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+					/* enable to rx ps-poll */
+					rtw_write16(adapter, REG_RXFLTMAP1, 0x0400);
+
+					/* Beacon Control related register for first time */
+					rtw_write8(adapter, REG_BCNDMATIM, 0x02); /*  2ms */
+					rtw_write8(adapter, REG_DRVERLYINT, 0x05);/*  5ms */
+					rtw_write8(adapter, REG_ATIMWND, 0x0a); /*  10ms */
+					rtw_write16(adapter, REG_BCNTCFG, 0x00);
+					rtw_write16(adapter, REG_TBTT_PROHIBIT, 0x6404);
+
+					/* reset TSF */
+					rtw_write8(adapter, REG_DUAL_TSF_RST, BIT(0));
+
+					/* enable TSF Function for if1 */
+					rtw_write8(adapter, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+
+					/* enable update TSF for if1 */
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+				}
+
+				val8 = rtw_read8(adapter, MSR)&0x0c;
+				val8 |= mode;
+				rtw_write8(adapter, MSR, val8);
+			}
+#endif /* CONFIG_CONCURRENT_MODE */
+			break;
+		case HW_VAR_MAC_ADDR:
+			hw_var_set_macaddr(adapter, variable, val);
+			break;
+		case HW_VAR_BSSID:
+#if defined(CONFIG_CONCURRENT_MODE)
+			hw_var_set_bssid(adapter, variable, val);
+#else /* CONFIG_CONCURRENT_MODE */
+			{
+				u8	idx = 0;
+				for (idx = 0 ; idx < 6; idx++)
+				{
+					rtw_write8(adapter, (REG_BSSID+idx), val[idx]);
+				}
+			}
+#endif /* CONFIG_CONCURRENT_MODE */
+			{
+#ifdef CONFIG_DUALMAC_CONCURRENT
+				struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+#endif
+				if (check_fwstate(&adapter->mlmepriv, WIFI_AP_STATE) == true)
+				{
+					DBG_8192D("%s(): pHalData->bNeedIQK = true\n", __func__);
+					pHalData->bNeedIQK = true; /* for 92D IQK */
+				}
+#ifdef CONFIG_DUALMAC_CONCURRENT
+				if ((Buddyadapter != NULL) && (pHalData->bSlaveOfDMSP))
+				{
+					if (check_fwstate(&Buddyadapter->mlmepriv, WIFI_AP_STATE) == true)
+						GET_HAL_DATA(Buddyadapter)->bNeedIQK = true; /* for 92D IQK */
+				}
+#endif
+			}
+			break;
+		case HW_VAR_INIT_DATA_RATE:
+			{
+				u8	init_data_rate = *((u8 *)val);
+#ifdef CONFIG_CONCURRENT_MODE
+				if (SECONDARY_ADAPTER == adapter->adapter_type) {
+					rtw_write8(adapter, REG_INIDATA_RATE_SEL+2, init_data_rate);
+					pdmpriv->INIDATA_RATE[2] = init_data_rate;
+					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 2\n", rtw_read8(adapter, REG_INIDATA_RATE_SEL));
+				}
+				else
+#endif
+				{
+					rtw_write8(adapter, REG_INIDATA_RATE_SEL, init_data_rate);
+					pdmpriv->INIDATA_RATE[0] = init_data_rate;
+					DBG_8192D("HW_VAR_INIT_DATA_RATE: Set Init Data Rate(%#x) for MACID 0\n", rtw_read8(adapter, REG_INIDATA_RATE_SEL));
+				}
+			}
+			break;
+		case HW_VAR_BASIC_RATE:
+			{
+				u16	BrateCfg = 0;
+				u8	RateIndex = 0, b2GBand = false;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+
+				/*  2007.01.16, by Emily */
+				/*  Select RRSR (in Legacy-OFDM and CCK) */
+				/*  For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate. */
+				/*  We do not use other rates. */
+				halsetbratecfg(adapter, val, &BrateCfg);
+
+				if (pHalData->CurrentBandType92D == BAND_ON_2_4G)
+					b2GBand = true;
+				else
+					b2GBand = false;
+
+				if (b2GBand)
+				{
+					/* CCK 2M ACK should be disabled for some BCM and Atheros AP IOT */
+					/* because CCK 2M has poor TXEVM */
+					/* CCK 5.5M & 11M ACK should be enabled for better performance */
+					pHalData->BasicRateSet = BrateCfg = (BrateCfg |0xd)& 0x15d;
+					BrateCfg |= 0x1; /*  default enable 1M ACK rate */
+				}
+				else /*  5G */
+				{
+					pHalData->BasicRateSet &= 0xFF0;
+					BrateCfg |= 0x10; /*  default enable 6M ACK rate */
+				}
+
+				DBG_8192D("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
+
+				/*  Set RRSR rate table. */
+				rtw_write8(adapter, REG_RRSR, BrateCfg&0xff);
+				rtw_write8(adapter, REG_RRSR+1, (BrateCfg>>8)&0xff);
+				rtw_write8(adapter, REG_RRSR+2, rtw_read8(adapter, REG_RRSR+2)&0xf0);
+
+				/*  Set RTS initial rate */
+				while (BrateCfg > 0x1) {
+					BrateCfg = (BrateCfg>> 1);
+					RateIndex++;
+				}
+				rtw_write8(adapter, REG_INIRTS_RATE_SEL, RateIndex);
+			}
+			break;
+		case HW_VAR_TXPAUSE:
+			rtw_write8(adapter, REG_TXPAUSE, *((u8 *)val));
+			break;
+		case HW_VAR_BCN_FUNC:
+			hw_var_set_bcn_func(adapter, variable, val);
+			break;
+		case HW_VAR_CORRECT_TSF:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_correct_tsf(adapter, variable, val);
+#else /* CONFIG_CONCURRENT_MODE */
+			{
+				u64	tsf;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+				tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) -1024; /* us */
+
+				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				{
+					StopTxBeacon(adapter);
+				}
+
+				/* disable related TSF function */
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(3)));
+
+				rtw_write32(adapter, REG_TSFTR, tsf);
+				rtw_write32(adapter, REG_TSFTR+4, tsf>>32);
+
+				/* enable related TSF function */
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(3));
+
+				if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+				{
+					ResumeTxBeacon(adapter);
+				}
+			}
+#endif /* CONFIG_CONCURRENT_MODE */
+			break;
+		case HW_VAR_CHECK_BSSID:
+			if (*((u8 *)val))
+			{
+				rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+			}
+			else
+			{
+				u32	val32;
+
+				val32 = rtw_read32(adapter, REG_RCR);
+
+				val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);
+
+				rtw_write32(adapter, REG_RCR, val32);
+			}
+			break;
+		case HW_VAR_MLME_DISCONNECT:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_mlme_disconnect(adapter, variable, val);
+#else /* CONFIG_CONCURRENT_MODE */
+			{
+				/* Set RCR to not to receive data frame when NO LINK state */
+				rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
+
+				/* reset TSF */
+				rtw_write8(adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+
+				/* disable update TSF */
+				rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)|BIT(4));
+			}
+#endif /* CONFIG_CONCURRENT_MODE */
+			break;
+		case HW_VAR_MLME_SITESURVEY:
+			hw_var_set_mlme_sitesurvey(adapter, variable,  val);
+#ifdef CONFIG_DUALMAC_CONCURRENT
+			dc_hw_var_mlme_sitesurvey(adapter, *((u8 *)val));
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+			break;
+		case HW_VAR_MLME_JOIN:
+#ifdef CONFIG_CONCURRENT_MODE
+			hw_var_set_mlme_join(adapter, variable,  val);
+#else /* CONFIG_CONCURRENT_MODE */
+			{
+				u8	RetryLimit = 0x30;
+				u8	type = *((u8 *)val);
+				struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+				struct rtw_adapter *	Buddyadapter = adapter->pbuddy_adapter;
+#endif
+
+				if (type == 0) /*  prepare to join */
+				{
+					/* enable to rx data frame.Accept all data frame */
+					rtw_write16(adapter, REG_RXFLTMAP2, 0xFFFF);
+
+					rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+
+					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+					{
+						RetryLimit = (pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;
+					}
+					else /*  Ad-hoc Mode */
+					{
+						RetryLimit = 0x7;
+					}
+
+					DBG_8192D("%s(): pHalData->bNeedIQK = true\n", __func__);
+					pHalData->bNeedIQK = true; /* for 92D IQK */
+#ifdef CONFIG_DUALMAC_CONCURRENT
+					if ((Buddyadapter != NULL) && (pHalData->bSlaveOfDMSP))
+					{
+						GET_HAL_DATA(Buddyadapter)->bNeedIQK = true; /* for 92D IQK */
+					}
+#endif
+				}
+				else if (type == 1) /* joinbss_event call back when join res < 0 */
+				{
+					/* config RCR to receive different BSSID & not to receive data frame during linking */
+
+					rtw_write16(adapter, REG_RXFLTMAP2, 0x00);
+				}
+				else if (type == 2) /* sta add event call back */
+				{
+					/* enable update TSF */
+					rtw_write8(adapter, REG_BCN_CTRL, rtw_read8(adapter, REG_BCN_CTRL)&(~BIT(4)));
+
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))
+					{
+						/* fixed beacon issue for 8191su........... */
+						RetryLimit = 0x7;
+					}
+				}
+
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+#ifdef CONFIG_DUALMAC_CONCURRENT
+				dc_hw_var_mlme_join(adapter, *((u8 *)val));
+#endif /* CONFIG_DUALMAC_CONCURRENT */
+			}
+#endif /* CONFIG_CONCURRENT_MODE */
+			break;
+
+		case HW_VAR_ON_RCR_AM:
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)|RCR_AM);
+			DBG_8192D("%s, %d, RCR = %x\n", __func__, __LINE__, rtw_read32(adapter, REG_RCR));
+			break;
+		case HW_VAR_OFF_RCR_AM:
+			rtw_write32(adapter, REG_RCR, rtw_read32(adapter, REG_RCR)& (~RCR_AM));
+			DBG_8192D("%s, %d, RCR = %x\n", __func__, __LINE__, rtw_read32(adapter, REG_RCR));
+			break;
+
+		case HW_VAR_BEACON_INTERVAL:
+			rtw_write16(adapter, REG_BCN_INTERVAL, *((u16 *)val));
+			break;
+		case HW_VAR_SLOT_TIME:
+			{
+				u8	u1bAIFS, aSifsTime;
+				struct mlme_ext_priv	*pmlmeext = &adapter->mlmeextpriv;
+				struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+				DBG_8192D("Set HW_VAR_SLOT_TIME: SlotTime(%#x)\n", val[0]);
+				rtw_write8(adapter, REG_SLOT, val[0]);
+
+				if (pmlmeinfo->WMM_enable == 0)
+				{
+					if (pmlmeext->cur_wireless_mode == WIRELESS_11B)
+						aSifsTime = 10;
+					else
+						aSifsTime = 16;
+
+					u1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);
+
+					/*  <Roger_EXP> Temporary removed, 2008.06.20. */
+					rtw_write8(adapter, REG_EDCA_VO_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_VI_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_BE_PARAM, u1bAIFS);
+					rtw_write8(adapter, REG_EDCA_BK_PARAM, u1bAIFS);
+				}
+			}
+			break;
+		case HW_VAR_ACK_PREAMBLE:
+			{
+				u8	regTmp;
+				u8	bShortPreamble = *((bool *)val);
+				/*  Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily) */
+				regTmp = (pHalData->nCur40MhzPrimeSC)<<5;
+				/* regTmp = 0; */
+				if (bShortPreamble)
+					regTmp |= 0x80;
+
+				rtw_write8(adapter, REG_RRSR+2, regTmp);
+			}
+			break;
+		case HW_VAR_SEC_CFG:
+#ifdef CONFIG_CONCURRENT_MODE
+			rtw_write8(adapter, REG_SECCFG, 0x0c |BIT(5));/* only enable tx enc and rx dec engine. */
+#else /* CONFIG_CONCURRENT_MODE */
+			rtw_write8(adapter, REG_SECCFG, *((u8 *)val));
+#endif /* CONFIG_CONCURRENT_MODE */
+			break;
+		case HW_VAR_DM_FLAG:
+			pdmpriv->DMFlag = *((u8 *)val);
+			break;
+		case HW_VAR_DM_FUNC_OP:
+			if (val[0])
+			{/*  save dm flag */
+				pdmpriv->DMFlag_tmp = pdmpriv->DMFlag;
+			}
+			else
+			{/*  restore dm flag */
+				pdmpriv->DMFlag = pdmpriv->DMFlag_tmp;
+			}
+			break;
+		case HW_VAR_DM_FUNC_SET:
+			pdmpriv->DMFlag |= *((u8 *)val);
+			break;
+		case HW_VAR_DM_FUNC_CLR:
+			pdmpriv->DMFlag &= *((u8 *)val);
+			break;
+		case HW_VAR_DM_INIT_PWDB:
+			pdmpriv->UndecoratedSmoothedPWDB = 0;
+			break;
+		case HW_VAR_CAM_EMPTY_ENTRY:
+			{
+				u8	ucIndex = *((u8 *)val);
+				u8	i;
+				u32	ulCommand = 0;
+				u32	ulContent = 0;
+				u32	ulEncAlgo = CAM_AES;
+
+				for (i = 0;i<CAM_CONTENT_COUNT;i++)
+				{
+					/*  filled id in CAM config 2 byte */
+					if (i == 0)
+					{
+						ulContent |= (ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
+					}
+					else
+					{
+						ulContent = 0;
+					}
+					/*  polling bit, and No Write enable, and address */
+					ulCommand = CAM_CONTENT_COUNT*ucIndex+i;
+					ulCommand = ulCommand | CAM_POLLINIG|CAM_WRITE;
+					/*  write content 0 is equall to mark invalid */
+					rtw_write32(adapter, WCAMI, ulContent);  /* delay_ms(40); */
+					rtw_write32(adapter, RWCAM, ulCommand);  /* delay_ms(40); */
+				}
+			}
+			break;
+		case HW_VAR_CAM_INVALID_ALL:
+			rtw_write32(adapter, RWCAM, BIT(31)|BIT(30));
+			break;
+		case HW_VAR_CAM_WRITE:
+			{
+				u32	cmd;
+				u32	*cam_val = (u32 *)val;
+				rtw_write32(adapter, WCAMI, cam_val[0]);
+
+				cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
+				rtw_write32(adapter, RWCAM, cmd);
+			}
+			break;
+		case HW_VAR_AC_PARAM_VO:
+			rtw_write32(adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_VI:
+			rtw_write32(adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_BE:
+			pHalData->AcParam_BE = ((u32 *)(val))[0];
+			rtw_write32(adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_AC_PARAM_BK:
+			rtw_write32(adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);
+			break;
+		case HW_VAR_ACM_CTRL:
+			{
+				u8	acm_ctrl = *((u8 *)val);
+				u8	AcmCtrl = rtw_read8(adapter, REG_ACMHWCTRL);
+
+				if (acm_ctrl > 1)
+					AcmCtrl = AcmCtrl | 0x1;
+
+				if (acm_ctrl & BIT(3))
+					AcmCtrl |= AcmHw_VoqEn;
+				else
+					AcmCtrl &= (~AcmHw_VoqEn);
+
+				if (acm_ctrl & BIT(2))
+					AcmCtrl |= AcmHw_ViqEn;
+				else
+					AcmCtrl &= (~AcmHw_ViqEn);
+
+				if (acm_ctrl & BIT(1))
+					AcmCtrl |= AcmHw_BeqEn;
+				else
+					AcmCtrl &= (~AcmHw_BeqEn);
+
+				DBG_8192D("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);
+				rtw_write8(adapter, REG_ACMHWCTRL, AcmCtrl);
+			}
+			break;
+		case HW_VAR_AMPDU_MIN_SPACE:
+			{
+				u8	MinSpacingToSet;
+				u8	SecMinSpace;
+
+				MinSpacingToSet = *((u8 *)val);
+				if (MinSpacingToSet <= 7)
+				{
+					switch (adapter->securitypriv.dot11PrivacyAlgrthm)
+					{
+						case _NO_PRIVACY_:
+						case _AES_:
+							SecMinSpace = 0;
+							break;
+
+						case _WEP40_:
+						case _WEP104_:
+						case _TKIP_:
+						case _TKIP_WTMIC_:
+							SecMinSpace = 6;
+							break;
+						default:
+							SecMinSpace = 7;
+							break;
+					}
+
+					if (MinSpacingToSet < SecMinSpace) {
+						MinSpacingToSet = SecMinSpace;
+					}
+
+					rtw_write8(adapter, REG_AMPDU_MIN_SPACE, (rtw_read8(adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);
+				}
+			}
+			break;
+		case HW_VAR_AMPDU_FACTOR:
+			{
+				u8	FactorToSet;
+				u32	RegToSet;
+				u8	*pTmpByte = NULL;
+				u8	index = 0;
+
+				RegToSet = 0xb972a841;
+				if (pHalData->MacPhyMode92D == SINGLEMAC_SINGLEPHY) {
+					RegToSet = 0x88728841;
+				}
+				else if (pHalData->MacPhyMode92D == DUALMAC_DUALPHY) {
+					RegToSet = 0x66525541;
+				}
+				else if (pHalData->MacPhyMode92D == DUALMAC_SINGLEPHY) {
+					RegToSet = 0x44444441;
+				}
+
+				FactorToSet = *((u8 *)val);
+				if (FactorToSet <= 3)
+				{
+					FactorToSet = (1<<(FactorToSet + 2));
+					if (FactorToSet>0xf)
+						FactorToSet = 0xf;
+
+					for (index = 0; index<4; index++)
+					{
+						pTmpByte = (u8 *)(&RegToSet) + index;
+
+						if ((*pTmpByte & 0xf0) > (FactorToSet<<4))
+							*pTmpByte = (*pTmpByte & 0x0f) | (FactorToSet<<4);
+
+						if ((*pTmpByte & 0x0f) > FactorToSet)
+							*pTmpByte = (*pTmpByte & 0xf0) | (FactorToSet);
+					}
+
+					rtw_write32(adapter, REG_AGGLEN_LMT, RegToSet);
+				}
+			}
+			break;
+		case HW_VAR_RXDMA_AGG_PG_TH:
+			{
+				u8	threshold = *((u8 *)val);
+				if (threshold == 0)
+				{
+					threshold = pHalData->UsbRxAggPageCount;
+				}
+				rtw_write8(adapter, REG_RXDMA_AGG_PG_TH, threshold);
+			}
+			break;
+		case HW_VAR_SET_RPWM:
+			{
+				u8	RpwmVal = (*(u8 *)val);
+				RpwmVal = RpwmVal & 0xf;
+
+				FillH2CCmd92D(adapter, H2C_PWRM, 1, (u8 *)(&RpwmVal));
+			}
+			break;
+		case HW_VAR_H2C_FW_PWRMODE:
+			rtl8192d_set_FwPwrMode_cmd(adapter, (*(u8 *)val));
+			break;
+		case HW_VAR_H2C_FW_JOINBSSRPT:
+			rtl8192d_set_FwJoinBssReport_cmd(adapter, (*(u8 *)val));
+			break;
+		case HW_VAR_INITIAL_GAIN:
+			{
+				struct DIG_T *dig_table = &pdmpriv->DM_DigTable;
+				u32		rx_gain = ((u32 *)(val))[0];
+
+				if (rx_gain == 0xff) {/* restore rx gain */
+					dig_table->curigvalue = dig_table->backupigvalue;
+					PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, dig_table->curigvalue);
+					PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, dig_table->curigvalue);
+				}
+				else {
+					dig_table->backupigvalue = dig_table->curigvalue;
+					PHY_SetBBReg(adapter, rOFDM0_XAAGCCore1, 0x7f, rx_gain);
+					PHY_SetBBReg(adapter, rOFDM0_XBAGCCore1, 0x7f, rx_gain);
+					dig_table->curigvalue = (u8)rx_gain;
+				}
+			}
+			break;
+		case HW_VAR_TRIGGER_GPIO_0:
+			rtl8192du_trigger_gpio_0(adapter);
+			break;
+		case HW_VAR_EFUSE_BYTES: /*  To set EFUE total used bytes, added by Roger, 2008.12.22. */
+			pHalData->EfuseUsedBytes = *((u16 *)val);
+			break;
+		case HW_VAR_FIFO_CLEARN_UP:
+			{
+				#define RW_RELEASE_EN		BIT18
+				#define RXDMA_IDLE			BIT17
+
+				struct pwrctrl_priv *pwrpriv = &adapter->pwrctrlpriv;
+				u8 trycnt = 100;
+
+				/* pause tx */
+				rtw_write8(adapter, REG_TXPAUSE, 0xff);
+
+				/* keep sn */
+				adapter->xmitpriv.nqos_ssn = rtw_read16(adapter, REG_NQOS_SEQ);
+
+				if (pwrpriv->bkeepfwalive != true)
+				{
+					/* RX DMA stop */
+					rtw_write32(adapter, REG_RXPKT_NUM, (rtw_read32(adapter, REG_RXPKT_NUM)|RW_RELEASE_EN));
+					do{
+						if (!(rtw_read32(adapter, REG_RXPKT_NUM)&RXDMA_IDLE))
+							break;
+					}while (trycnt--);
+					if (trycnt == 0)
+						DBG_8192D("Stop RX DMA failed......\n");
+
+					/* RQPN Load 0 */
+					rtw_write16(adapter, REG_RQPN_NPQ, 0x0);
+					rtw_write32(adapter, REG_RQPN, 0x80000000);
+					rtw_mdelay_os(10);
+				}
+
+			}
+			break;
+		case HW_VAR_WOWLAN:
+#ifdef CONFIG_WOWLAN
+			{
+				struct wowlan_ioctl_param *poidparam;
+
+				int res;
+
+				poidparam = (struct wowlan_ioctl_param *)val;
+				switch (poidparam->subcode) {
+					case WOWLAN_PATTERN_MATCH:
+						/* Turn on the Pattern Match feature */
+						DBG_8192D("\n PATTERN_MATCH poidparam->subcode_value =%d\n", poidparam->subcode_value);
+						if (poidparam->subcode_value == 1) {
+							adapter->pwrctrlpriv.wowlan_pattern = true;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_pattern =%x\n", __func__, adapter->pwrctrlpriv.wowlan_pattern);
+						}
+						else {
+							adapter->pwrctrlpriv.wowlan_pattern = false;
+						}
+						break;
+					case WOWLAN_MAGIC_PACKET:
+						/* Turn on the Magic Packet feature */
+						DBG_8192D("\n MAGIC_PACKET poidparam->subcode_value =%d\n", poidparam->subcode_value);
+						if (poidparam->subcode_value == 1) {
+							adapter->pwrctrlpriv.wowlan_magic = true;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_magic =%x\n", __func__, adapter->pwrctrlpriv.wowlan_magic);
+						}
+						else {
+							adapter->pwrctrlpriv.wowlan_magic = false;
+						}
+						break;
+					case WOWLAN_UNICAST:
+						/* Turn on the Unicast wakeup feature */
+						if (poidparam->subcode_value == 1) {
+							adapter->pwrctrlpriv.wowlan_unicast = true;
+						}
+						else {
+							adapter->pwrctrlpriv.wowlan_unicast = false;
+							DBG_8192D("%s adapter->pwrctrlpriv.wowlan_unicast =%x\n", __func__, adapter->pwrctrlpriv.wowlan_unicast);
+						}
+						break;
+					case WOWLAN_SET_PATTERN:
+						/* Setting the Pattern for wowlan */
+						res = rtw_wowlan_set_pattern(adapter, poidparam->pattern);
+						if (res)
+							DBG_8192D("rtw_wowlan_set_pattern retern value = 0x%x", res);
+						break;
+					case WOWLAN_DUMP_REG:
+						/* dump the WKFMCAM and WOW_CTRL register */
+
+						break;
+					case WOWLAN_ENABLE:
+						SetFwRelatedForWoWLAN8192DU(adapter, true);
+						/* Set Pattern */
+						if (adapter->pwrctrlpriv.wowlan_pattern == true)
+							rtw_wowlan_reload_pattern(adapter);
+						rtl8192d_set_wowlan_cmd(adapter);
+						rtw_msleep_os(10);
+						break;
+
+					case WOWLAN_DISABLE:
+						adapter->pwrctrlpriv.wowlan_mode = false;
+						rtl8192d_set_wowlan_cmd(adapter);
+						rtw_msleep_os(10);
+						break;
+
+					case WOWLAN_STATUS:
+						poidparam->wakeup_reason = rtw_read8(adapter, REG_WOWLAN_REASON);
+						DBG_8192D("wake on wlan reason 0x%02x\n", poidparam->wakeup_reason);
+						break;
+
+					case WOWLAN_DEBUG_RELOAD_FW:
+						break;
+					case WOWLAN_DEBUG_1:
+						{
+							u16 GPIO_val;
+							if (poidparam->subcode_value == 1)
+							{
+								GPIO_val = rtw_read16(adapter, REG_GPIO_PIN_CTRL+1);
+								GPIO_val |= BIT(0)|BIT(8);
+								/* set GPIO 0 to high for Toshiba */
+								rtw_write16(adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
+							}
+							else
+							{
+								GPIO_val = rtw_read16(adapter, REG_GPIO_PIN_CTRL+1);
+								GPIO_val |= BIT(8);
+								GPIO_val &= ~BIT(0);
+								/* set GPIO 0 to low for Toshiba */
+								rtw_write16(adapter, REG_GPIO_PIN_CTRL+1, GPIO_val);
+							}
+						}
+						break;
+					case WOWLAN_DEBUG_2:
+						{
+							u16 GPIO_val;
+							u8 reg = 0;
+#ifdef CONFIG_WOWLAN_MANUAL
+							if (poidparam->subcode_value == 1)
+							{
+
+								/* prevent 8051 to be reset by PERST# wake on wlan by Alex & Baron */
+								reg = rtw_read8(adapter, REG_RSV_CTRL);
+								rtw_write8(adapter, REG_RSV_CTRL, reg| BIT(5));
+								rtw_write8(adapter, REG_RSV_CTRL, reg| BIT(6)|BIT(5));
+								/* for Toshiba only, they should call rtw_suspend before suspend */
+								rtw_suspend_toshiba(adapter);
+							}
+							else
+							{
+								/* unmask usb se0 reset by Alex and DD */
+								reg = rtw_read8(adapter, 0xf8);
+								reg |= BIT(3)|BIT(4);
+								rtw_write8(adapter, 0xf8, reg);
+
+								/* for Toshiba only, they should call rtw_resume before resume */
+								rtw_resume_toshiba(adapter);
+								/* suggest by Scott */
+								reg = rtw_read8(adapter, REG_RSV_CTRL);
+								reg &= ~(BIT(5)|BIT(6));
+								rtw_write8(adapter, REG_RSV_CTRL, reg);
+
+							}
+#endif /* CONFIG_WOWLAN_MANUAL */
+						}
+						break;
+					default:
+						break;
+				}
+				if (adapter->pwrctrlpriv.wowlan_unicast||adapter->pwrctrlpriv.wowlan_magic || adapter->pwrctrlpriv.wowlan_pattern)
+					adapter->pwrctrlpriv.wowlan_mode = true;
+				else
+					adapter->pwrctrlpriv.wowlan_mode = false;
+			}
+			break;
+#endif /* CONFIG_WOWLAN */
+		case HW_VAR_CHECK_TXBUF:
+#if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
+			{
+				int i;
+				u8	RetryLimit = 0x01;
+
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+
+				for (i = 0;i<1000;i++)
+				{
+					if (rtw_read32(adapter, 0x200) != rtw_read32(adapter, 0x204))
+					{
+						rtw_msleep_os(10);
+					}
+					else
+					{
+						DBG_8192D("no packet in tx packet buffer (%d)\n", i);
+						break;
+					}
+				}
+
+				RetryLimit = 0x30;
+				rtw_write16(adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);
+
+			}
+#endif
+			break;
+		case HW_VAR_BCN_VALID:
+			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw */
+			rtw_write8(adapter, REG_TDECTRL+2, rtw_read8(adapter, REG_TDECTRL+2) | BIT0);
+			break;
+		default:
+			break;
+	}
+
+}
+
+static void GetHwReg8192DU(struct rtw_adapter *adapter, u8 variable, u8 *val)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+
+	switch (variable)
+	{
+		case HW_VAR_BASIC_RATE:
+			*((u16 *)(val)) = pHalData->BasicRateSet;
+			break;
+		case HW_VAR_TXPAUSE:
+			val[0] = rtw_read8(adapter, REG_TXPAUSE);
+			break;
+		case HW_VAR_BCN_VALID:
+			/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2 */
+			val[0] = (BIT0 & rtw_read8(adapter, REG_TDECTRL+2))?true:false;
+			break;
+		case HW_VAR_DM_FLAG:
+			val[0] = pHalData->dmpriv.DMFlag;
+			break;
+		case HW_VAR_RF_TYPE:
+			val[0] = pHalData->rf_type;
+			break;
+		case HW_VAR_FWLPS_RF_ON:
+			{
+				/* When we halt NIC, we should check if FW LPS is leave. */
+				u32	valRCR;
+
+				if (adapter->pwrctrlpriv.rf_pwrstate == rf_off)
+				{
+					/*  If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave, */
+					/*  because Fw is unload. */
+					val[0] = true;
+				}
+				else
+				{
+					valRCR = rtw_read32(adapter, REG_RCR);
+					valRCR &= 0x00070000;
+					if (valRCR)
+						val[0] = false;
+					else
+						val[0] = true;
+				}
+			}
+			break;
+		case HW_VAR_EFUSE_BYTES: /*  To get EFUE total used bytes, added by Roger, 2008.12.22. */
+			*((u16 *)(val)) = pHalData->EfuseUsedBytes;
+			break;
+		case HW_VAR_VID:
+			*((u16 *)(val)) = pHalData->EEPROMVID;
+			break;
+		case HW_VAR_PID:
+			*((u16 *)(val)) = pHalData->EEPROMPID;
+			break;
+		default:
+			break;
+	}
+
+}
+
+/*  */
+/*	Description: */
+/*		Query setting of specified variable. */
+/*  */
+static u8 GetHalDefVar8192DUsb(struct rtw_adapter *adapter, enum HAL_DEF_VARIABLE eVariable, void  *pValue)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8 bResult = true;
+
+	switch (eVariable) {
+	case HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:
+		*((int *)pValue) = pHalData->dmpriv.UndecoratedSmoothedPWDB;
+		break;
+	case HAL_DEF_DRVINFO_SZ:
+		*((u32*)pValue) = DRVINFO_SZ;
+		break;
+	case HAL_DEF_MAX_RECVBUF_SZ:
+		*((u32*)pValue) = MAX_RECVBUF_SZ;
+		break;
+	case HAL_DEF_RX_PACKET_OFFSET:
+		*((u32*)pValue) = RXDESC_SIZE + DRVINFO_SZ;
+		break;
+	case HAL_DEF_DBG_DM_FUNC:
+		*((u8*)pValue) = pHalData->dmpriv.DMFlag;
+		break;
+	default:
+		bResult = false;
+		break;
+	}
+	return bResult;
+}
+
+/*  */
+/*	Description: */
+/*		Change default setting of specified variable. */
+/*  */
+static u8 SetHalDefVar8192DUsb(
+	struct rtw_adapter *				adapter,
+	enum HAL_DEF_VARIABLE		eVariable,
+	void *pValue
+	)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(adapter);
+	u8 bResult = true;
+
+	switch (eVariable) {
+		case HAL_DEF_DBG_DM_FUNC:
+			{
+				u8 dm_func = *((u8*)pValue);
+				struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+				if (dm_func == 0) { /* disable all dynamic func */
+					pdmpriv->DMFlag = DYNAMIC_FUNC_DISABLE;
+					DBG_8192D("==> Disable all dynamic function...\n");
+				}
+				else if (dm_func == 1) {/* disable DIG */
+					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_DIG);
+					DBG_8192D("==> Disable DIG...\n");
+				}
+				else if (dm_func == 2) {/* disable High power */
+					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_HP);
+				}
+				else if (dm_func == 3) {/* disable tx power tracking */
+					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_SS);
+					DBG_8192D("==> Disable tx power tracking...\n");
+				}
+				else if (dm_func == 4) {/* disable BT coexistence */
+					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_BT);
+				}
+				else if (dm_func == 5) {/* disable antenna diversity */
+					pdmpriv->DMFlag &= (~DYNAMIC_FUNC_ANT_DIV);
+				}
+				else if (dm_func == 6) {/* turn on all dynamic func */
+					if (!(pdmpriv->DMFlag & DYNAMIC_FUNC_DIG))
+					{
+						struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+						struct DIG_T	*dig_table = &pdmpriv->DM_DigTable;
+						dig_table->preigvalue = rtw_read8(adapter, 0xc50);
+					}
+
+					pdmpriv->DMFlag |= (DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS|
+						DYNAMIC_FUNC_BT|DYNAMIC_FUNC_ANT_DIV) ;
+					DBG_8192D("==> Turn on all dynamic function...\n");
+				}
+			}
+			break;
+		default:
+			bResult = false;
+			break;
+	}
+
+	return bResult;
+}
+
+static u32  _update_92cu_basic_rate(struct rtw_adapter *padapter, unsigned int mask)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
+#endif
+	unsigned int BrateCfg = 0;
+
+#ifdef CONFIG_BT_COEXIST
+	if (	(pbtpriv->BT_Coexist) &&	(pbtpriv->BT_CoexistType == BT_CSR_BC4)	)
+	{
+		BrateCfg = mask  & 0x151;
+	}
+	else
+#endif
+	{
+		if (pHalData->VersionID != VERSION_TEST_CHIP_88C)
+			BrateCfg = mask  & 0x15F;
+		else	/* for 88CU 46PING setting, Disable CCK 2M, 5.5M, Others must tuning */
+			BrateCfg = mask  & 0x159;
+	}
+
+	BrateCfg |= 0x01; /*  default enable 1M ACK rate */
+
+	return BrateCfg;
+}
+
+static void _update_response_rate(struct rtw_adapter *padapter, unsigned int mask)
+{
+	u8	RateIndex = 0;
+	/*  Set RRSR rate table. */
+	rtw_write8(padapter, REG_RRSR, mask&0xff);
+	rtw_write8(padapter, REG_RRSR+1, (mask>>8)&0xff);
+
+	/*  Set RTS initial rate */
+	while (mask > 0x1)
+	{
+		mask = (mask>> 1);
+		RateIndex++;
+	}
+	rtw_write8(padapter, REG_INIRTS_RATE_SEL, RateIndex);
+}
+
+static void UpdateHalRAMask8192DUsb(struct rtw_adapter *padapter, u32 mac_id)
+{
+	u32	value[2];
+	u8	init_rate = 0;
+	u8	networkType, raid;
+	u32	mask;
+	u8	shortGIrate = false;
+	int	supportRateNum = 0;
+	struct sta_info	*psta;
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	*pbtpriv = &(pHalData->bt_coexist);
+#endif
+
+	if (mac_id >= NUM_STA)
+	{
+		return;
+	}
+
+	psta = pmlmeinfo->FW_sta_info[mac_id].psta;
+	if (psta == NULL)
+	{
+		return;
+	}
+
+	switch (mac_id) {
+	case 0:/*  for infra mode */
+#ifdef CONFIG_CONCURRENT_MODE
+	case 2:/*  first station uses macid = 0, second station uses macid = 2 */
+#endif /* CONFIG_CONCURRENT_MODE */
+		supportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);
+		networkType = judge_network_type(padapter, cur_network->SupportedRates, supportRateNum);
+		raid = networktype_to_raid(networkType);
+
+		mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+		mask |= (pmlmeinfo->HT_enable)? update_MSC_rate(&(pmlmeinfo->HT_caps)): 0;
+
+		mask |= ((raid<<28)&0xf0000000);
+
+		if (support_short_GI(padapter, &(pmlmeinfo->HT_caps)))
+		{
+			shortGIrate = true;
+		}
+
+		break;
+
+	case 1:/* for broadcast/multicast */
+		supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+		if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
+			networkType = WIRELESS_11B;
+		else
+			networkType = WIRELESS_11G;
+		raid = networktype_to_raid(networkType);
+
+		mask = update_basic_rate(cur_network->SupportedRates, supportRateNum);
+		mask |= ((raid<<28)&0xf0000000);
+
+		break;
+
+	default: /* for each sta in IBSS */
+		supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+		networkType = judge_network_type(padapter, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum);
+		raid = networktype_to_raid(networkType);
+
+		mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+		mask |= ((raid<<28)&0xf0000000);
+
+		/* todo: support HT in IBSS */
+
+		break;
+	}
+
+#ifdef CONFIG_BT_COEXIST
+	if ((pbtpriv->BT_Coexist) &&
+		(pbtpriv->BT_CoexistType == BT_CSR_BC4) &&
+		(pbtpriv->BT_CUR_State) &&
+		(pbtpriv->BT_Ant_isolation) &&
+		((pbtpriv->BT_Service == BT_SCO)||
+		(pbtpriv->BT_Service == BT_Busy)))
+		mask &= 0xffffcfc0;
+	else
+#endif
+		mask &= 0xffffffff;
+
+	init_rate = get_highest_rate_idx(mask)&0x3f;
+
+	if (pHalData->fw_ractrl == true)
+	{
+		value[0] = mask;
+		value[1] = mac_id | (shortGIrate?0x20:0x00) | 0x80;
+
+		DBG_8192D("update raid entry, mask = 0x%x, arg = 0x%x\n", value[0], value[1]);
+
+		FillH2CCmd92D(padapter, H2C_RA_MASK, 5, (u8 *)(&value));
+	}
+	else
+	{
+		if (shortGIrate == true)
+			init_rate |= BIT(6);
+
+		rtw_write8(padapter, (REG_INIDATA_RATE_SEL+mac_id), init_rate);
+	}
+
+	/* set ra_id */
+	psta->raid = raid;
+	psta->init_rate = init_rate;
+
+	/* set correct initial date rate for each mac_id */
+	pdmpriv->INIDATA_RATE[mac_id] = init_rate;
+}
+
+static void SetBeaconRelatedRegisters8192DUsb(struct rtw_adapter *padapter)
+{
+	u32	value32;
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	rtw_write8(padapter, REG_ATIMWND, 0x02);
+
+	rtw_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);
+
+	_InitBeaconParameters(padapter);
+
+	rtw_write8(padapter, REG_SLOT, 0x09);
+
+	/*  */
+	/*  Reset TSF Timer to zero, added by Roger. 2008.06.24 */
+	/*  */
+	value32 = rtw_read32(padapter, REG_TCR);
+	value32 &= ~TSFRST;
+	rtw_write32(padapter, REG_TCR, value32);
+
+	value32 |= TSFRST;
+	rtw_write32(padapter, REG_TCR, value32);
+
+	/*  NOTE: Fix test chip's bug (about contention windows's randomness) */
+	rtw_write8(padapter,  REG_RXTSF_OFFSET_CCK, 0x50);
+	rtw_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);
+
+	_BeaconFunctionEnable(padapter, true, true);
+
+	ResumeTxBeacon(padapter);
+
+	rtw_write8(padapter, REG_BCN_CTRL, rtw_read8(padapter, REG_BCN_CTRL)|BIT(1));
+}
+
+static void rtl8192du_init_default_value(struct rtw_adapter *padapter)
+{
+	struct hal_data_8192du *pHalData = GET_HAL_DATA(padapter);
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+
+	pHalData->CurrentWirelessMode = WIRELESS_MODE_AUTO;
+
+	/* init default value */
+	pHalData->fw_ractrl = false;
+	if (!pwrctrlpriv->bkeepfwalive)
+		pHalData->LastHMEBoxNum = 0;
+
+	pHalData->bEarlyModeEnable = 0;
+	pHalData->pwrGroupCnt = 0;
+
+	/* init dm default value */
+	pdmpriv->TM_Trigger = 0;
+	pdmpriv->prv_traffic_idx = 3;
+
+	rtl8192d_PHY_ResetIQKResult(padapter);
+}
+
+void rtl8192du_set_hal_ops(struct rtw_adapter *padapter)
+{
+	struct hal_ops	*pHalFunc = &padapter->HalFunc;
+
+	padapter->HalData = kzalloc(sizeof(struct hal_data_8192du), GFP_KERNEL);
+	if (padapter->HalData == NULL) {
+		DBG_8192D("cant not alloc memory for HAL DATA\n");
+	}
+	padapter->hal_data_sz = sizeof(struct hal_data_8192du);
+
+	pHalFunc->hal_init = &rtl8192du_hal_init;
+	pHalFunc->hal_deinit = &rtl8192du_hal_deinit;
+
+	pHalFunc->inirp_init = &rtl8192du_inirp_init;
+	pHalFunc->inirp_deinit = &rtl8192du_inirp_deinit;
+
+	pHalFunc->init_xmit_priv = &rtl8192du_init_xmit_priv;
+	pHalFunc->free_xmit_priv = &rtl8192du_free_xmit_priv;
+
+	pHalFunc->init_recv_priv = &rtl8192du_init_recv_priv;
+	pHalFunc->free_recv_priv = &rtl8192du_free_recv_priv;
+	pHalFunc->InitSwLeds = &rtl8192du_InitSwLeds;
+	pHalFunc->DeInitSwLeds = &rtl8192du_DeInitSwLeds;
+
+	pHalFunc->init_default_value = &rtl8192du_init_default_value;
+	pHalFunc->intf_chip_configure = &rtl8192du_interface_configure;
+	pHalFunc->read_adapter_info = &ReadadapterInfo8192DU;
+
+	pHalFunc->hal_dm_watchdog = &rtl8192d_HalDmWatchDog;
+
+	pHalFunc->SetHwRegHandler = &SetHwReg8192DU;
+	pHalFunc->GetHwRegHandler = &GetHwReg8192DU;
+	pHalFunc->GetHalDefVarHandler = &GetHalDefVar8192DUsb;
+	pHalFunc->SetHalDefVarHandler = &SetHalDefVar8192DUsb;
+
+	pHalFunc->UpdateRAMaskHandler = &UpdateHalRAMask8192DUsb;
+	pHalFunc->SetBeaconRelatedRegistersHandler = &SetBeaconRelatedRegisters8192DUsb;
+
+	pHalFunc->hal_xmit = &rtl8192du_hal_xmit;
+	pHalFunc->mgnt_xmit = &rtl8192du_mgnt_xmit;
+
+#ifdef CONFIG_HOSTAPD_MLME
+	pHalFunc->hostap_mgnt_xmit_entry = &rtl8192du_hostap_mgnt_xmit_entry;
+#endif
+
+	rtl8192d_set_hal_ops(pHalFunc);
+
+}
diff --git a/drivers/net/wireless/rtl8192du/hal/usb_ops_linux.c b/drivers/net/wireless/rtl8192du/hal/usb_ops_linux.c
new file mode 100644
index 0000000..01a7f43
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/hal/usb_ops_linux.c
@@ -0,0 +1,862 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _HCI_OPS_OS_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+#include <usb_ops.h>
+#include <recv_osdep.h>
+#include <rtl8192d_hal.h>
+
+static int usbctrl_vendorreq(struct intf_hdl *pintfhdl, u8 request, u16 value, u16 index, void *pdata, u16 len, u8 requesttype)
+{
+	struct rtw_adapter *padapter = pintfhdl->padapter ;
+	struct dvobj_priv  *pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device *udev = pdvobjpriv->pusbdev;
+
+	unsigned int pipe;
+	int status = 0;
+	u32 tmp_buflen=0;
+	u8 reqtype;
+	u8 *pIo_buf;
+	int vendorreq_times = 0;
+	u8 *tmp_buf;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type > PRIMARY_ADAPTER) {
+		padapter = padapter->pbuddy_adapter;
+		pdvobjpriv = adapter_to_dvobj(padapter);
+		udev = pdvobjpriv->pusbdev;
+	}
+#endif
+
+	if ((padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usbctrl_vendorreq:(padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		status = -EPERM;
+		goto exit;
+	}
+
+	if (len>MAX_VENDOR_REQ_CMD_SIZE) {
+		DBG_8192D("[%s] Buffer len error ,vendor request failed\n", __func__);
+		status = -EINVAL;
+		goto exit;
+	}
+
+	_enter_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex);
+
+	/*  Acquire IO memory for vendorreq */
+	pIo_buf = pdvobjpriv->usb_vendor_req_buf;
+
+	if (pIo_buf== NULL) {
+		DBG_8192D("[%s] pIo_buf == NULL\n", __func__);
+		status = -ENOMEM;
+		goto release_mutex;
+	}
+
+	while (++vendorreq_times<= MAX_USBCTRL_VENDORREQ_TIMES) {
+		memset(pIo_buf, 0, len);
+
+		if (requesttype == 0x01) {
+			pipe = usb_rcvctrlpipe(udev, 0);/* read_in */
+			reqtype =  REALTEK_USB_VENQT_READ;
+		} else {
+			pipe = usb_sndctrlpipe(udev, 0);/* write_out */
+			reqtype =  REALTEK_USB_VENQT_WRITE;
+			memcpy(pIo_buf, pdata, len);
+		}
+
+		status = rtw_usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT);
+
+		if (status == len) {   /*  Success this control transfer. */
+			rtw_reset_continual_urb_error(pdvobjpriv);
+			if (requesttype == 0x01) {
+				/* For Control read transfer, we have to copy
+				 * the read data from pIo_buf to pdata.
+				 */
+				memcpy(pdata, pIo_buf,  len);
+			}
+		} else { /*  error cases */
+			DBG_8192D("reg 0x%x, usb %s %u fail, status:%d value=0x%x, vendorreq_times:%d\n",
+				  value,(requesttype == 0x01) ? "read" : "write",
+				  len, status, *(u32 *)pdata, vendorreq_times);
+
+			if (status < 0) {
+				if (status == (-ESHUTDOWN) ||
+				    status == -ENODEV) {
+					padapter->bSurpriseRemoved = true;
+				} else {
+					#ifdef DBG_CONFIG_ERROR_DETECT
+					struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+					pHalData->srestpriv.Wifi_Error_Status = USB_VEN_REQ_CMD_FAIL;
+					#endif
+				}
+			} else { /*  status != len && status >= 0 */
+				if (status > 0) {
+					if (requesttype == 0x01) {
+						/* For Control read transfer,
+						 * we have to copy the read data
+						 * from pIo_buf to pdata.
+						 */
+						memcpy(pdata, pIo_buf,  len);
+					}
+				}
+			}
+
+			if (rtw_inc_and_chk_continual_urb_error(pdvobjpriv) == true) {
+				padapter->bSurpriseRemoved = true;
+				break;
+			}
+
+		}
+
+		/*  firmware download is checksumed, don't retry */
+		if ((value >= FW_8192D_START_ADDRESS && value <= FW_8192D_END_ADDRESS) || status == len)
+			break;
+
+	}
+
+	/*  release IO memory used by vendorreq */
+	kfree(tmp_buf);
+
+release_mutex:
+	_exit_critical_mutex(&pdvobjpriv->usb_vendor_req_mutex);
+exit:
+	return status;
+}
+
+static void usb_read_reg_rf_byfw(struct intf_hdl *pintfhdl, u16 byteCount, u32 registerIndex, void *buffer)
+{
+	u16	wPage = 0x0000, offset;
+	u32	BufferLengthRead;
+	struct rtw_adapter *	adapter = pintfhdl->padapter;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(adapter);
+	u8	RFPath=0,nPHY=0;
+
+	RFPath =(u8) ((registerIndex&0xff0000)>>16);
+
+	if (pHalData->interfaceIndex!=0)
+	{
+		nPHY = 1; /* MAC1 */
+		if (registerIndex&MAC1_ACCESS_PHY0)/*  MAC1 need to access PHY0 */
+			nPHY = 0;
+	}
+	else
+	{
+		if (registerIndex&MAC0_ACCESS_PHY1)
+			nPHY = 1;
+	}
+	registerIndex &= 0xFF;
+	wPage = ((nPHY<<7)|(RFPath<<5)|8)<<8;
+	offset = (u16)registerIndex;
+
+	/*  */
+	/*  IN a vendor request to read back MAC register. */
+	/*  */
+	usbctrl_vendorreq(pintfhdl, 0x05, offset, wPage, buffer, byteCount, 0x01);
+}
+
+static void usb_read_reg(struct intf_hdl *pintfhdl, u16 value, void *pdata, u16 len)
+{
+	struct rtw_adapter		*padapter = pintfhdl->padapter;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	u8	request;
+	u8	requesttype;
+	u16	index;
+
+	request = 0x05;
+	requesttype = 0x01;/* read_in */
+	index = 0;/* n/a */
+
+	if (pHalData->interfaceIndex!=0)
+	{
+		if (value<0x1000)
+			value|=0x4000;
+		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))
+			value &= 0xFFF;
+	}
+
+	usbctrl_vendorreq(pintfhdl, request, value, index, pdata, len, requesttype);
+}
+
+static int usb_write_reg(struct intf_hdl *pintfhdl, u16 value, void *pdata, u16 len)
+{
+	struct rtw_adapter		*padapter = pintfhdl->padapter;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	u8	request;
+	u8	requesttype;
+	u16	index;
+
+	request = 0x05;
+	requesttype = 0x00;/* write_out */
+	index = 0;/* n/a */
+
+	if (pHalData->interfaceIndex!=0)
+	{
+		if (value<0x1000)
+			value|=0x4000;
+		else if ((value&MAC1_ACCESS_PHY0) && !(value&0x8000))/*  MAC1 need to access PHY0 */
+			value &= 0xFFF;
+	}
+
+	return usbctrl_vendorreq(pintfhdl, request, value, index, pdata, len, requesttype);
+}
+
+static u8 usb_read8(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+
+	usb_read_reg(pintfhdl, wvalue, &data, len);
+
+	return (u8)(le32_to_cpu(data)&0x0ff);
+}
+
+static u16 usb_read16(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+
+	usb_read_reg(pintfhdl, wvalue, &data, len);
+
+	return (u16)(le32_to_cpu(data)&0xffff);
+}
+
+static u32 usb_read32(struct intf_hdl *pintfhdl, u32 addr)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+
+	if ((addr&0xff000000)>>24 == 0x66) {
+		usb_read_reg_rf_byfw(pintfhdl, len, addr, &data);
+	}
+	else {
+		usb_read_reg(pintfhdl, wvalue, &data, len);
+	}
+
+	return le32_to_cpu(data);
+}
+
+static int usb_write8(struct intf_hdl *pintfhdl, u32 addr, u8 val)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+	int ret;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+
+	data = cpu_to_le32(val & 0x000000ff);
+
+	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
+
+	return ret;
+}
+
+static int usb_write16(struct intf_hdl *pintfhdl, u32 addr, u16 val)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+	int ret;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+
+	data = cpu_to_le32(val & 0x0000ffff);
+
+	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
+
+	return ret;
+}
+
+static int usb_write32(struct intf_hdl *pintfhdl, u32 addr, u32 val)
+{
+	u16 wvalue;
+	u16 len;
+	__le32 data;
+	int ret;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = cpu_to_le32(val);
+
+	ret = usb_write_reg(pintfhdl, wvalue, &data, len);
+
+	return ret;
+}
+
+static int usb_writeN(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata)
+{
+	u16	wvalue;
+	u16	len;
+	u8	buf[VENDOR_CMD_MAX_DATA_LEN]={0};
+	int	ret;
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = length;
+	 memcpy(buf, pdata, len);
+
+	ret = usb_write_reg(pintfhdl, wvalue, buf, len);
+
+	return ret;
+}
+
+static s32 pre_recv_entry(struct recv_frame_hdr *precvframe, struct recv_stat *prxstat, struct phy_stat *pphy_info)
+{
+	s32 ret=_SUCCESS;
+#ifdef CONFIG_CONCURRENT_MODE
+	u8 *primary_myid, *secondary_myid, *paddr1;
+	struct recv_frame_hdr	*precvframe_if2 = NULL;
+	struct rtw_adapter *primary_padapter = precvframe->adapter;
+	struct rtw_adapter *secondary_padapter = primary_padapter->pbuddy_adapter;
+	struct recv_priv *precvpriv = &primary_padapter->recvpriv;
+	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
+	u8	*pbuf = precvframe->rx_data;
+
+	if (!secondary_padapter)
+		return ret;
+
+	paddr1 = GetAddr1Ptr(precvframe->rx_data);
+
+	if (IS_MCAST(paddr1) == false)/* unicast packets */
+	{
+		secondary_myid = myid(&secondary_padapter->eeprompriv);
+
+		if (_rtw_memcmp(paddr1, secondary_myid, ETH_ALEN))
+		{
+			/* change to secondary interface */
+			precvframe->adapter = secondary_padapter;
+		}
+
+	}
+	else /*  Handle BC/MC Packets */
+	{
+		u8 clone = true;
+
+		if (true == clone)
+		{
+			/* clone/copy to if2 */
+			u8 shift_sz = 0;
+			u32 alloc_sz, skb_len;
+			struct sk_buff *pkt_copy = NULL;
+			struct rx_pkt_attrib *pattrib = NULL;
+
+			precvframe_if2 = rtw_alloc_recvframe(pfree_recv_queue);
+			if (precvframe_if2)
+			{
+				precvframe_if2->adapter = secondary_padapter;
+
+				INIT_LIST_HEAD(&precvframe_if2->list);
+				precvframe_if2->precvbuf = NULL;	/* can't access the precvbuf for new arch. */
+				precvframe_if2->len=0;
+
+				memcpy(&precvframe_if2->attrib, &precvframe->attrib, sizeof(struct rx_pkt_attrib));
+
+				pattrib = &precvframe_if2->attrib;
+
+				/*	Modified by Albert 20101213 */
+				/*	For 8 bytes IP header alignment. */
+				if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
+				{
+					shift_sz = 6;
+				}
+				else
+				{
+					shift_sz = 0;
+				}
+
+				skb_len = pattrib->pkt_len;
+
+				/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
+				/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
+				if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
+					if (skb_len <= 1650)
+						alloc_sz = 1664;
+					else
+						alloc_sz = skb_len + 14;
+				}
+				else {
+					alloc_sz = skb_len;
+					/*	6 is for IP header 8 bytes alignment in QoS packet case. */
+					/*	8 is for skb->data 4 bytes alignment. */
+					alloc_sz += 14;
+				}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
+				pkt_copy = dev_alloc_skb(alloc_sz);
+#else
+				pkt_copy = netdev_alloc_skb(secondary_padapter->pnetdev, alloc_sz);
+#endif
+				if (pkt_copy)
+				{
+					pkt_copy->dev = secondary_padapter->pnetdev;
+					precvframe_if2->pkt = pkt_copy;
+					precvframe_if2->rx_head = pkt_copy->data;
+					precvframe_if2->rx_end = pkt_copy->data + alloc_sz;
+					skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
+					skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
+					memcpy(pkt_copy->data, pbuf, skb_len);
+					precvframe_if2->rx_data = precvframe_if2->rx_tail = pkt_copy->data;
+				}
+
+				recvframe_put(precvframe_if2, skb_len);
+				/* recvframe_pull(precvframe_if2, drvinfo_sz + RXDESC_SIZE); */
+
+				rtl8192d_translate_rx_signal_stuff(precvframe_if2, pphy_info);
+
+				ret = rtw_recv_entry(precvframe_if2);
+
+			}
+
+		}
+
+	}
+
+	rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
+
+	ret = rtw_recv_entry(precvframe);
+
+#endif
+
+	return ret;
+}
+
+static int recvbuf2recvframe(struct rtw_adapter *padapter, struct sk_buff *pskb)
+{
+	u8	*pbuf;
+	u8	shift_sz = 0;
+	u16	pkt_cnt;
+	u32	pkt_offset, skb_len, alloc_sz;
+	int	transfer_len;
+	struct recv_stat	*prxstat;
+	struct phy_stat	*pphy_info = NULL;
+	struct sk_buff *pkt_copy = NULL;
+	struct recv_frame_hdr	*precvframe = NULL;
+	struct rx_pkt_attrib	*pattrib = NULL;
+	struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+	struct __queue *pfree_recv_queue = &precvpriv->free_recv_queue;
+
+	transfer_len = pskb->len;
+	pbuf = pskb->data;
+
+	prxstat = (struct recv_stat *)pbuf;
+	pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+
+	do{
+		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_,
+			 ("recvbuf2recvframe: rxdesc=offsset 0:0x%08x, 4:0x%08x, 8:0x%08x, C:0x%08x\n",
+			  prxstat->rxdw0, prxstat->rxdw1, prxstat->rxdw2, prxstat->rxdw4));
+
+		prxstat = (struct recv_stat *)pbuf;
+
+		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
+		if (precvframe==NULL)
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: precvframe==NULL\n"));
+			DBG_8192D("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __func__, __LINE__);
+			goto _exit_recvbuf2recvframe;
+		}
+
+		INIT_LIST_HEAD(&precvframe->list);
+		precvframe->precvbuf = NULL;	/* can't access the precvbuf for new arch. */
+		precvframe->len=0;
+
+		rtl8192d_query_rx_desc_status(precvframe, prxstat);
+
+		pattrib = &precvframe->attrib;
+		if (pattrib->physt)
+		{
+			pphy_info = (struct phy_stat *)(pbuf + RXDESC_OFFSET);
+		}
+
+		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
+
+		if ((pattrib->pkt_len<=0) || (pkt_offset>transfer_len))
+		{
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("recvbuf2recvframe: pkt_len<=0\n"));
+			DBG_8192D("%s()-%d: RX Warning!\n", __func__, __LINE__);
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+			goto _exit_recvbuf2recvframe;
+		}
+
+		/*	Modified by Albert 20101213 */
+		/*	For 8 bytes IP header alignment. */
+		if (pattrib->qos)	/*	Qos data, wireless lan header length is 26 */
+		{
+			shift_sz = 6;
+		}
+		else
+		{
+			shift_sz = 0;
+		}
+
+		skb_len = pattrib->pkt_len;
+
+		/*  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet. */
+		/*  modify alloc_sz for recvive crc error packet by thomas 2011-06-02 */
+		if ((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
+			if (skb_len <= 1650)
+				alloc_sz = 1664;
+			else
+				alloc_sz = skb_len + 14;
+		}
+		else {
+			alloc_sz = skb_len;
+			/*	6 is for IP header 8 bytes alignment in QoS packet case. */
+			/*	8 is for skb->data 4 bytes alignment. */
+			alloc_sz += 14;
+		}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
+		pkt_copy = dev_alloc_skb(alloc_sz);
+#else
+		pkt_copy = netdev_alloc_skb(padapter->pnetdev, alloc_sz);
+#endif
+		if (pkt_copy)
+		{
+			precvframe->pkt = pkt_copy;
+			precvframe->rx_head = pkt_copy->data;
+			precvframe->rx_end = pkt_copy->data + alloc_sz;
+			skb_reserve(pkt_copy, 8 - ((SIZE_PTR)(pkt_copy->data) & 7));/* force pkt_copy->data at 8-byte alignment address */
+			skb_reserve(pkt_copy, shift_sz);/* force ip_hdr at 8-byte alignment address according to shift_sz. */
+			memcpy(pkt_copy->data, (pbuf + pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE), skb_len);
+			precvframe->rx_data = precvframe->rx_tail = pkt_copy->data;
+		}
+		else
+		{
+			precvframe->pkt = skb_clone(pskb, GFP_ATOMIC);
+			if (pkt_copy)
+			{
+				precvframe->rx_head = precvframe->rx_data = precvframe->rx_tail = pbuf;
+				precvframe->rx_end = pbuf + alloc_sz;
+			}
+			else
+			{
+				DBG_8192D("recvbuf2recvframe: skb_clone fail\n");
+				rtw_free_recvframe(precvframe, pfree_recv_queue);
+				goto _exit_recvbuf2recvframe;
+			}
+		}
+
+		recvframe_put(precvframe, skb_len);
+
+		switch (pHalData->UsbRxAggMode) {
+		case USB_RX_AGG_DMA:
+		case USB_RX_AGG_DMA_USB:
+			pkt_offset = (u16)_RND128(pkt_offset);
+			break;
+			case USB_RX_AGG_USB:
+			pkt_offset = (u16)_RND4(pkt_offset);
+			break;
+		case USB_RX_AGG_DISABLE:
+		default:
+			break;
+		}
+#ifdef CONFIG_CONCURRENT_MODE
+		if (rtw_buddy_adapter_up(padapter)) {
+			if (pre_recv_entry(precvframe, prxstat, pphy_info) != _SUCCESS)
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: recv_entry(precvframe) != _SUCCESS\n"));
+		} else {
+			rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
+			if (rtw_recv_entry(precvframe) != _SUCCESS)
+				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+		}
+#else
+		rtl8192d_translate_rx_signal_stuff(precvframe, pphy_info);
+		if (rtw_recv_entry(precvframe) != _SUCCESS)
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvbuf2recvframe: rtw_recv_entry(precvframe) != _SUCCESS\n"));
+#endif /* CONFIG_CONCURRENT_MODE */
+		pkt_cnt--;
+
+		transfer_len -= pkt_offset;
+		pbuf += pkt_offset;
+		precvframe = NULL;
+		pkt_copy = NULL;
+
+		if (transfer_len > 0 && pkt_cnt == 0)
+			pkt_cnt = (le32_to_cpu(prxstat->rxdw2)>>16) & 0xff;
+
+	}while ((transfer_len>0) && (pkt_cnt>0));
+
+_exit_recvbuf2recvframe:
+
+	return _SUCCESS;
+}
+
+void rtl8192du_recv_tasklet(void *priv)
+{
+	struct sk_buff *pskb;
+	struct rtw_adapter		*padapter = (struct rtw_adapter*)priv;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue)))
+	{
+		if ((padapter->bDriverStopped == true)||(padapter->bSurpriseRemoved== true))
+		{
+			DBG_8192D("recv_tasklet => bDriverStopped or bSurpriseRemoved\n");
+			dev_kfree_skb_any(pskb);
+			break;
+		}
+
+		recvbuf2recvframe(padapter, pskb);
+
+#ifdef CONFIG_PREALLOC_RECV_SKB
+
+		skb_reset_tail_pointer(pskb);
+		pskb->len = 0;
+
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+
+#else
+		dev_kfree_skb_any(pskb);
+#endif
+
+	}
+}
+
+static void usb_read_port_complete(struct urb *purb, struct pt_regs *regs)
+{
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *)purb->context;
+	struct rtw_adapter			*padapter =(struct rtw_adapter *)precvbuf->adapter;
+	struct recv_priv	*precvpriv = &padapter->recvpriv;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete!!!\n"));
+
+	precvpriv->rx_pending_cnt --;
+
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped||padapter->bReadPortCancel)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)\n", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+
+	#ifdef CONFIG_PREALLOC_RECV_SKB
+		precvbuf->reuse = true;
+	#else
+		if (precvbuf->pskb) {
+			DBG_8192D("==> free skb(%p)\n",precvbuf->pskb);
+			dev_kfree_skb_any(precvbuf->pskb);
+		}
+	#endif
+
+		return;
+	}
+
+	if (purb->status==0)/* SUCCESS */
+	{
+		if ((purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE))
+		{
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: (purb->actual_length > MAX_RECVBUF_SZ) || (purb->actual_length < RXDESC_SIZE)\n"));
+			precvbuf->reuse = true;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		} else {
+			precvbuf->transfer_len = purb->actual_length;
+
+			skb_put(precvbuf->pskb, purb->actual_length);
+			skb_queue_tail(&precvpriv->rx_skb_queue, precvbuf->pskb);
+
+			if (skb_queue_len(&precvpriv->rx_skb_queue)<=1)
+				tasklet_schedule(&precvpriv->recv_tasklet);
+
+			precvbuf->pskb = NULL;
+			precvbuf->reuse = false;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+		}
+	} else {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete : purb->status(%d) != 0\n", purb->status));
+
+		DBG_8192D("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
+
+		switch (purb->status) {
+		case -EINVAL:
+		case -EPIPE:
+		case -ENODEV:
+		case -ESHUTDOWN:
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bSurpriseRemoved=TRUE\n"));
+		case -ENOENT:
+			padapter->bDriverStopped=true;
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete:bDriverStopped=TRUE\n"));
+			break;
+		case -EPROTO:
+		case -EOVERFLOW:
+			precvbuf->reuse = true;
+			rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+			break;
+		case -EINPROGRESS:
+			DBG_8192D("ERROR: URB IS IN PROGRESS!/n");
+			break;
+		default:
+			break;
+		}
+
+	}
+
+}
+
+static u32 usb_read_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+	int err, pipe;
+	SIZE_PTR tmpaddr=0;
+	SIZE_PTR alignment=0;
+	u32 ret = _SUCCESS;
+	struct urb *purb = NULL;
+	struct recv_buf	*precvbuf = (struct recv_buf *)rmem;
+	struct rtw_adapter *adapter = pintfhdl->padapter;
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(adapter);
+	struct recv_priv	*precvpriv = &adapter->recvpriv;
+	struct usb_device	*pusbd = pdvobj->pusbdev;
+
+	if (adapter->bDriverStopped || adapter->bSurpriseRemoved ||
+	    adapter->pwrctrlpriv.pnp_bstop_trx) {
+		RT_TRACE(_module_hci_ops_os_c_, _drv_err_,
+			 ("usb_read_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		return _FAIL;
+	}
+
+	if (!precvbuf) {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port:precvbuf ==NULL\n"));
+		return _FAIL;
+	}
+#ifdef CONFIG_PREALLOC_RECV_SKB
+	if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+		if (NULL != (precvbuf->pskb = skb_dequeue(&precvpriv->free_recv_skb_queue)))
+			precvbuf->reuse = true;
+	}
+#endif
+
+	if (precvbuf != NULL) {
+		rtl8192du_init_recvbuf(adapter, precvbuf);
+
+		/* re-assign for linux based on skb */
+		if ((precvbuf->reuse == false) || (precvbuf->pskb == NULL)) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)) /*  http://www.mail-archive.com/netdev@vger.kernel.org/msg17214.html */
+			precvbuf->pskb = dev_alloc_skb(MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#else
+			precvbuf->pskb = netdev_alloc_skb(adapter->pnetdev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+#endif
+			if (precvbuf->pskb == NULL) {
+				RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("init_recvbuf(): alloc_skb fail!\n"));
+				return _FAIL;
+			}
+
+			tmpaddr = (SIZE_PTR)precvbuf->pskb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(precvbuf->pskb, (RECVBUFF_ALIGN_SZ - alignment));
+
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+		}
+		else/* reuse skb */
+		{
+			precvbuf->phead = precvbuf->pskb->head;
+			precvbuf->pdata = precvbuf->pskb->data;
+			precvbuf->ptail = skb_tail_pointer(precvbuf->pskb);
+			precvbuf->pend = skb_end_pointer(precvbuf->pskb);
+			precvbuf->pbuf = precvbuf->pskb->data;
+
+			precvbuf->reuse = false;
+		}
+
+		precvpriv->rx_pending_cnt++;
+
+		purb = precvbuf->purb;
+
+		/* translate DMA FIFO addr to pipehandle */
+		pipe = ffaddr2pipehdl(pdvobj, addr);
+
+		usb_fill_bulk_urb(purb, pusbd, pipe,
+						precvbuf->pbuf,
+						MAX_RECVBUF_SZ,
+						usb_read_port_complete,
+						precvbuf);/* context is precvbuf */
+
+		err = usb_submit_urb(purb, GFP_ATOMIC);
+		if ((err) && (err != (-EPERM))) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("cannot submit rx in-token(err=0x%.8x), URB_STATUS =0x%.8x", err, purb->status));
+			DBG_8192D("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n",err,purb->status);
+			ret = _FAIL;
+		}
+	}
+
+	return ret;
+}
+
+void rtl8192du_xmit_tasklet(void *priv)
+{
+	int ret = false;
+	struct rtw_adapter *padapter = (struct rtw_adapter*)priv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_UNDER_SURVEY) == true
+#ifdef CONFIG_DUALMAC_CONCURRENT
+		|| (dc_check_xmit(padapter)== false)
+#endif
+		)
+		return;
+
+	while (1) {
+		if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved)) {
+			DBG_8192D("xmit_tasklet => bDriverStopped or bSurpriseRemoved\n");
+			break;
+		}
+
+		ret = rtl8192du_xmitframe_complete(padapter, pxmitpriv, NULL);
+
+		if (ret == false)
+			break;
+	}
+}
+
+void rtl8192du_set_intf_ops(struct _io_ops	*pops)
+{
+
+	memset((u8 *)pops, 0, sizeof(struct _io_ops));
+
+	pops->_read8 = &usb_read8;
+	pops->_read16 = &usb_read16;
+	pops->_read32 = &usb_read32;
+	pops->_read_mem = &usb_read_mem;
+	pops->_read_port = &usb_read_port;
+
+	pops->_write8 = &usb_write8;
+	pops->_write16 = &usb_write16;
+	pops->_write32 = &usb_write32;
+	pops->_writeN = &usb_writeN;
+
+	pops->_write_mem = &usb_write_mem;
+	pops->_write_port = &usb_write_port;
+
+	pops->_read_port_cancel = &usb_read_port_cancel;
+	pops->_write_port_cancel = &usb_write_port_cancel;
+}
diff --git a/drivers/net/wireless/rtl8192du/include/autoconf.h b/drivers/net/wireless/rtl8192du/include/autoconf.h
new file mode 100644
index 0000000..a9967d4
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/autoconf.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+/*
+ * Public  General Config
+ */
+#define AUTOCONF_INCLUDED
+#define DRV_NAME "r8192du"
+#define DRIVERVERSION	"v4.2.1_7122.20130408"
+
+#define CONFIG_SET_SCAN_DENY_TIMER
+
+/*
+ * Internal  General Config
+ */
+/* define CONFIG_PWRCTRL	1 */
+/* define CONFIG_H2CLBK	1 */
+
+#define CONFIG_EMBEDDED_FWIMG	1
+/* define CONFIG_FILE_FWIMG */
+
+#ifdef CONFIG_WAKE_ON_WLAN
+#define CONFIG_WOWLAN 1
+#endif /* CONFIG_WAKE_ON_WLAN */
+#define CONFIG_R871X_TEST	1
+
+#define CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+
+#define CONFIG_80211N_HT	1
+
+#define CONFIG_RECV_REORDERING_CTRL	1
+
+#define CONFIG_IPS	1
+//#define CONFIG_LPS	1
+
+#define CONFIG_92D_AP_MODE 1
+#define CONFIG_NATIVEAP_MLME 1
+#ifndef CONFIG_NATIVEAP_MLME
+	#define CONFIG_HOSTAPD_MLME	1
+#endif
+#define CONFIG_FIND_BEST_CHANNEL	1
+
+#define CONFIG_DFS	1
+
+#define CONFIG_LAYER2_ROAMING
+#define CONFIG_LAYER2_ROAMING_RESUME
+/* define CONFIG_SET_SCAN_DENY_TIMER */
+#define RTW_NOTCH_FILTER 0 /* 0:Disable, 1:Enable,*/
+
+//#define CONFIG_CONCURRENT_MODE 1
+#ifdef CONFIG_CONCURRENT_MODE
+	#define CONFIG_TSF_RESET_OFFLOAD 1			/*  For 2 PORT TSF SYNC. */
+#endif	/*  CONFIG_CONCURRENT_MODE */
+
+#define CONFIG_80211D
+
+/* Interface  Related Config */
+
+#define CONFIG_PREALLOC_RECV_SKB	1
+
+/*
+ * USB VENDOR REQ BUFFER ALLOCATION METHOD
+ * if not set we'll use function local variable (stack memory)
+ */
+
+/* HAL  Related Config */
+
+#define RTL8192C_RX_PACKET_NO_INCLUDE_CRC	1
+
+#define CONFIG_ONLY_ONE_OUT_EP_TO_LOW	0
+
+#define CONFIG_OUT_EP_WIFI_MODE	0
+
+#define RTL8192CU_ASIC_VERIFICATION	0	/*  For ASIC verification. */
+
+#define RTL8192CU_ADHOC_WORKAROUND_SETTING 1
+
+#define DISABLE_BB_RF	0
+
+#define RTL8191C_FPGA_NETWORKTYPE_ADHOC 0
+
+#define ANTENNA_SELECTION_STATIC_SETTING 0
+
+#define TX_POWER_FOR_5G_BAND				1	/* For 5G band TX Power */
+
+#define RTL8192D_EASY_SMART_CONCURRENT	0
+
+#define RTL8192D_DUAL_MAC_MODE_SWITCH	0
+
+#define SWLCK   1
+
+#define FW_PROCESS_VENDOR_CMD 1
+
+#define MP_DRIVER 0
+
+#define DBG 0
+
+#define CONFIG_DEBUG_RTL819X
+
+#define CONFIG_PROC_DEBUG 1
diff --git a/drivers/net/wireless/rtl8192du/include/basic_types.h b/drivers/net/wireless/rtl8192du/include/basic_types.h
new file mode 100644
index 0000000..2f1f365
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/basic_types.h
@@ -0,0 +1,183 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+#include <drv_conf.h>
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+#include <linux/types.h>
+
+#define FIELD_OFFSET(s,field)	((__kernel_ssize_t)&((s*)(0))->field)
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof(__kernel_size_t))
+#define MEM_ALIGNMENT_PADDING	(sizeof(__kernel_size_t) - 1)
+
+#define SIZE_PTR __kernel_size_t
+#define SSIZE_PTR __kernel_ssize_t
+
+/* port from fw by thomas */
+/*  TODO: Belows are Sync from SD7-Driver. It is necessary to check correctness */
+
+/*
+ *	Call endian free function when
+ *		1. Read/write packet content.
+ *		2. Before write integer to IO.
+ *		3. After read integer from IO.
+*/
+
+/* Convert little data endian to host ordering */
+#define EF1BYTE(_val)		\
+	((u8)(_val))
+#define EF2BYTE(_val)		\
+	(le16_to_cpu(_val))
+#define EF4BYTE(_val)		\
+	(le32_to_cpu(_val))
+
+/* Read data from memory */
+#define READEF1BYTE(_ptr)	\
+	EF1BYTE(*((u8 *)(_ptr)))
+/* Read le16 data from memory and convert to host ordering */
+#define READEF2BYTE(_ptr)	\
+	EF2BYTE(*(_ptr))
+#define READEF4BYTE(_ptr)	\
+	EF4BYTE(*(_ptr))
+
+/* Write data to memory */
+#define WRITEEF1BYTE(_ptr, _val)	\
+	((*((u8 *)(_ptr))) = EF1BYTE(_val))
+/* Write le data to memory in host ordering */
+#define WRITEEF2BYTE(_ptr, _val)	\
+	((*((u16 *)(_ptr))) = EF2BYTE(_val))
+#define WRITEEF4BYTE(_ptr, _val)	\
+	((*((u32 *)(_ptr))) = EF4BYTE(_val))
+
+/* Create a bit mask
+ * Examples:
+ * BIT_LEN_MASK_32(0) => 0x00000000
+ * BIT_LEN_MASK_32(1) => 0x00000001
+ * BIT_LEN_MASK_32(2) => 0x00000003
+ * BIT_LEN_MASK_32(32) => 0xFFFFFFFF
+ */
+#define BIT_LEN_MASK_32(__bitlen)	 \
+	(0xFFFFFFFF >> (32 - (__bitlen)))
+#define BIT_LEN_MASK_16(__bitlen)	 \
+	(0xFFFF >> (16 - (__bitlen)))
+#define BIT_LEN_MASK_8(__bitlen) \
+	(0xFF >> (8 - (__bitlen)))
+
+/* Create an offset bit mask
+ * Examples:
+ * BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
+ * BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
+ */
+#define BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_32(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_16(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_8(__bitlen) << (__bitoffset))
+
+/*Description:
+ * Return 4-byte value in host byte ordering from
+ * 4-byte pointer in little-endian system.
+ */
+#define LE_P4BYTE_TO_HOST_4BYTE(__pstart) \
+	(EF4BYTE(*((__le32 *)(__pstart))))
+#define LE_P2BYTE_TO_HOST_2BYTE(__pstart) \
+	(EF2BYTE(*((__le16 *)(__pstart))))
+#define LE_P1BYTE_TO_HOST_1BYTE(__pstart) \
+	(EF1BYTE(*((u8 *)(__pstart))))
+
+/*Description:
+Translate subfield (continuous bits in little-endian) of 4-byte
+value to host byte ordering.*/
+#define LE_BITS_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P4BYTE_TO_HOST_4BYTE(__pstart) >> (__bitoffset))  & \
+		BIT_LEN_MASK_32(__bitlen) \
+	)
+#define LE_BITS_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P2BYTE_TO_HOST_2BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_16(__bitlen) \
+	)
+#define LE_BITS_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P1BYTE_TO_HOST_1BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_8(__bitlen) \
+	)
+
+/* Description:
+ * Mask subfield (continuous bits in little-endian) of 4-byte value
+ * and return the result in 4-byte value in host byte ordering.
+ */
+#define LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P4BYTE_TO_HOST_4BYTE(__pstart)  & \
+		(~BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P2BYTE_TO_HOST_2BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P1BYTE_TO_HOST_1BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen)) \
+	)
+
+/* Description:
+ * Set subfield of little-endian 4-byte value to specified value.
+ */
+#define SET_BITS_TO_LE_4BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u32 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u32)__val) & BIT_LEN_MASK_32(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_2BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u16 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u16)__val) & BIT_LEN_MASK_16(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_1BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u8 *)(__pstart)) = EF1BYTE \
+	( \
+		LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u8)__val) & BIT_LEN_MASK_8(__bitlen)) << (__bitoffset)) \
+	);
+
+/*  Get the N-bytes aligment offset from the current length */
+#define	N_BYTE_ALIGMENT(__value, __aligment) ((__aligment == 1) ? \
+	(__value) : (((__value + __aligment - 1) / __aligment) * __aligment))
+
+#ifndef IEEE80211_WEP_IV_LEN
+#define IEEE80211_WEP_IV_LEN		4
+#define IEEE80211_WEP_ICV_LEN		4
+#define IEEE80211_CCMP_HDR_LEN		8
+#define IEEE80211_CCMP_MIC_LEN		8
+#define IEEE80211_TKIP_ICV_LEN		4
+#define IEEE80211_TKIP_IV_LEN		8
+#endif
+
+
+#endif /* __BASIC_TYPES_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/cmd_osdep.h b/drivers/net/wireless/rtl8192du/include/cmd_osdep.h
new file mode 100644
index 0000000..bae2fcb
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/cmd_osdep.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __CMD_OSDEP_H_
+#define __CMD_OSDEP_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+extern int _rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern int _rtw_init_evt_priv(struct evt_priv *pevtpriv);
+extern void _rtw_free_evt_priv (struct	evt_priv *pevtpriv);
+extern void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv);
+extern int _rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj);
+extern struct	cmd_obj	*_rtw_dequeue_cmd(struct __queue *queue);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/drv_conf.h b/drivers/net/wireless/rtl8192du/include/drv_conf.h
new file mode 100644
index 0000000..b0753ed
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/drv_conf.h
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+
+
+#ifdef CONFIG_ANDROID
+/* Some Android build will restart the UI while non-printable ascii is passed */
+/* between java and c/c++ layer (JNI). We force CONFIG_VALIDATE_SSID */
+/* for Android here. If you are sure there is no risk on your system about this, */
+/* mask this macro define to support non-printable ascii ssid. */
+/* define CONFIG_VALIDATE_SSID */
+/* Android expect dbm as the rx signal strength unit */
+#define CONFIG_SIGNAL_DISPLAY_DBM
+#endif
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) && defined (CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+
+#if defined(CONFIG_ANDROID_POWER) && defined (CONFIG_RESUME_IN_WORKQUEUE)
+	#warning "You have CONFIG_ANDROID_POWER enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
+	#undef CONFIG_RESUME_IN_WORKQUEUE
+#endif
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE /* this can be removed, because there is no case for this... */
+	#if !defined(CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
+	#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
+	#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
+	#endif
+#endif
+
+#endif /*  __DRV_CONF_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/drv_types.h b/drivers/net/wireless/rtl8192du/include/drv_types.h
new file mode 100644
index 0000000..60fe398
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/drv_types.h
@@ -0,0 +1,406 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*-------------------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+
+enum {
+	UP_LINK,
+	DOWN_LINK,
+};
+
+#ifdef CONFIG_80211N_HT
+#include <rtw_ht.h>
+#endif
+
+#include <rtw_cmd.h>
+#include <wlan_bssdef.h>
+#include <rtw_xmit.h>
+#include <rtw_recv.h>
+#include <hal_intf.h>
+#include <hal_com.h>
+#include <rtw_qos.h>
+#include <rtw_security.h>
+#include <rtw_pwrctrl.h>
+#include <rtw_io.h>
+#include <rtw_eeprom.h>
+#include <sta_info.h>
+#include <rtw_mlme.h>
+#include <rtw_debug.h>
+#include <rtw_rf.h>
+#include <rtw_event.h>
+#include <rtw_led.h>
+#include <rtw_mlme_ext.h>
+#include <rtw_p2p.h>
+#include <rtw_tdls.h>
+#include <rtw_ap.h>
+
+#ifdef CONFIG_DRVEXT_MODULE
+#include <drvext_api.h>
+#endif
+
+#include "ioctl_cfg80211.h"
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+#define SPEC_DEV_ID_ASSIGN_IFNAME BIT(5)
+
+struct specific_device_id{
+
+	u32		flags;
+	u16		idVendor;
+	u16		idProduct;
+};
+
+struct registry_priv {
+	u8	chip_version;
+	u8	rfintfs;
+	u8	lbkmode;
+	u8	hci;
+	struct ndis_802_11_ssid	ssid;
+	u8	network_mode;	/* infra, ad-hoc, auto */
+	u8	channel;/* ad-hoc support requirement */
+	u8	wireless_mode;/* A, B, G, auto */
+	u8	scan_mode;/* active, passive */
+	u8	radio_enable;
+	u8	preamble;/* long, short, auto */
+	u8	vrtl_carrier_sense;/* Enable, Disable, Auto */
+	u8	vcs_type;/* RTS/CTS, CTS-to-self */
+	u16	rts_thresh;
+	u16	frag_thresh;
+	u8	adhoc_tx_pwr;
+	u8	soft_ap;
+	u8	power_mgnt;
+	u8	ips_mode;
+	u8	smart_ps;
+	u8	long_retry_lmt;
+	u8	short_retry_lmt;
+	u16	busy_thresh;
+	u8	ack_policy;
+	u8	mp_mode;
+	u8	software_encrypt;
+	u8	software_decrypt;
+
+	u8	acm_method;
+	  /* UAPSD */
+	u8	wmm_enable;
+	u8	uapsd_enable;
+	u8	uapsd_max_sp;
+	u8	uapsd_acbk_en;
+	u8	uapsd_acbe_en;
+	u8	uapsd_acvi_en;
+	u8	uapsd_acvo_en;
+
+	struct wlan_bssid_ex dev_network;
+
+#ifdef CONFIG_80211N_HT
+	u8	ht_enable;
+	u8	cbw40_enable;
+	u8	ampdu_enable;/* for tx */
+	u8	rx_stbc;
+	u8	ampdu_amsdu;/* A-MPDU Supports A-MSDU is permitted */
+#endif
+	u8	lowrate_two_xmit;
+
+	u8	rf_config ;
+	u8	low_power ;
+
+	u8	wifi_spec;/*  !turbo_mode */
+
+	u8	channel_plan;
+#ifdef CONFIG_BT_COEXIST
+	u8	bt_iso;
+	u8	bt_sco;
+	u8	bt_ampdu;
+#endif
+	bool	bAcceptAddbaReq;
+
+	u8	antdiv_cfg;
+
+	u8	usbss_enable;/* 0:disable,1:enable */
+	u8	hwpdn_mode;/* 0:disable,1:enable,2:decide by EFUSE config */
+	u8	hwpwrp_detect;/* 0:disable,1:enable */
+
+	u8	hw_wps_pbc;/* 0:disable,1:enable */
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+	char	adaptor_info_caching_file_path[PATH_LENGTH_MAX];
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+	u8	max_roaming_times; /*  the max number driver will try to roaming */
+#endif
+
+	u8  special_rf_path; /* 0: 2T2R ,1: only turn on path A 1T1R, 2: only turn on path B 1T1R */
+	u8	mac_phy_mode; /* 0:by efuse, 1:smsp, 2:dmdp, 3:dmsp. */
+
+#ifdef CONFIG_80211D
+	u8 enable80211d;
+#endif
+
+	u8 ifname[16];
+	u8 if2name[16];
+
+	u8 notch_filter;
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+	u8 ext_iface_num;/* primary/secondary iface is excluded */
+#endif
+};
+
+
+/* For registry parameters */
+#define RGTRY_OFT(field) ((u32)FIELD_OFFSET(struct registry_priv, field))
+#define RGTRY_SZ(field)   sizeof(((struct registry_priv*) 0)->field)
+#define BSSID_OFT(field) ((u32)FIELD_OFFSET(struct wlan_bssid_ex, field))
+#define BSSID_SZ(field)   sizeof(((struct wlan_bssid_ex *) 0)->field)
+
+#define MAX_CONTINUAL_URB_ERR 4
+
+#define GET_PRIMARY_ADAPTER(padapter) (((struct rtw_adapter *)padapter)->dvobj->if1)
+
+#ifdef CONFIG_CONCURRENT_MODE
+#define GET_IFACE_NUMS(padapter) (((struct rtw_adapter *)padapter)->dvobj->iface_nums)
+#define GET_ADAPTER(padapter, iface_id) (((struct rtw_adapter *)padapter)->dvobj->padapters[iface_id])
+#endif /* CONFIG_CONCURRENT_MODE */
+
+enum _IFACE_ID {
+	IFACE_ID0, /* maping to PRIMARY_ADAPTER */
+	IFACE_ID1, /* maping to SECONDARY_ADAPTER */
+	IFACE_ID2,
+	IFACE_ID3,
+	IFACE_ID_MAX,
+};
+
+struct dvobj_priv {
+	struct rtw_adapter *if1; /* PRIMARY_ADAPTER */
+	struct rtw_adapter *if2; /* SECONDARY_ADAPTER */
+
+	/* for local/global synchronization */
+	_mutex hw_init_mutex;
+	_mutex h2c_fwcmd_mutex;
+	_mutex setch_mutex;
+	_mutex setbw_mutex;
+
+	unsigned char	oper_channel; /* saved channel info when call set_channel_bw */
+	unsigned char	oper_bwmode;
+	unsigned char	oper_ch_offset;/* PRIME_CHNL_OFFSET */
+
+#ifdef CONFIG_CONCURRENT_MODE
+	/* extend to support mulitu interface */
+	struct rtw_adapter *padapters[IFACE_ID_MAX];
+	u8 iface_nums; /*  total number of ifaces used runtime */
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	/* For 92D, DMDP have 2 interface. */
+	u8	InterfaceNumber;
+	u8	NumInterfaces;
+	u8	DualMacMode;
+	u8	irq_alloc;
+
+/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef INTF_DATA
+	INTF_DATA intf_data;
+#endif
+
+/*-------- below is for USB INTERFACE --------*/
+
+	u8	nr_endpoint;
+	u8	ishighspeed;
+	u8	RtNumInPipes;
+	u8	RtNumOutPipes;
+	int	ep_num[5]; /* endpoint number */
+	int	RegUsbSS;
+	struct  semaphore usb_suspend_sema;
+	_mutex  usb_vendor_req_mutex;
+	u8 *usb_alloc_vendor_req_buf;
+	u8 *usb_vendor_req_buf;
+	struct usb_interface *pusbintf;
+	struct usb_device *pusbdev;
+	ATOMIC_T continual_urb_error;
+};
+
+static struct device *dvobj_to_dev(struct dvobj_priv *dvobj)
+{
+	/* todo: get interface type from dvobj and the return the dev accordingly */
+	return &dvobj->pusbintf->dev;
+}
+
+enum _IFACE_TYPE {
+	IFACE_PORT0, /* mapping to port0 for C/D series chips */
+	IFACE_PORT1, /* mapping to port1 for C/D series chip */
+	MAX_IFACE_PORT,
+};
+
+enum _ADAPTER_TYPE {
+	PRIMARY_ADAPTER,
+	SECONDARY_ADAPTER,
+	MAX_ADAPTER = 0xFF,
+};
+
+enum DRIVER_STATE {
+	DRIVER_NORMAL = 0,
+	DRIVER_DISAPPEAR = 1,
+	DRIVER_REPLACE_DONGLE = 2,
+};
+
+struct rt_firmware_92d;
+
+struct rtw_adapter {
+	struct rt_firmware_92d *firmware;
+	int	DriverState;/*  for disable driver using module, use dongle to replace module. */
+	int	pid[3];/* process id from UI, 0:wps, 1:hostapd, 2:dhcpcd */
+	int	bDongle;/* build-in module or external dongle */
+	u16	chip_type;
+	u16	HardwareType;
+	u16	interface_type;/* USB,SDIO,PCI */
+
+	struct dvobj_priv *dvobj;
+	struct	mlme_priv mlmepriv;
+	struct	mlme_ext_priv mlmeextpriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	struct	io_priv	iopriv;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	struct	registry_priv	registrypriv;
+	struct	pwrctrl_priv	pwrctrlpriv;
+	struct	eeprom_priv eeprompriv;
+	struct	led_priv	ledpriv;
+
+#ifdef CONFIG_DRVEXT_MODULE
+	struct	drvext_priv	drvextpriv;
+#endif
+
+#ifdef CONFIG_92D_AP_MODE
+	struct	hostapd_priv	*phostapdpriv;
+#endif
+
+	struct cfg80211_wifidirect_info	cfg80211_wdinfo;
+	u32	setband;
+	struct wifidirect_info	wdinfo;
+
+	void *HalData;
+	u32 hal_data_sz;
+	struct hal_ops	HalFunc;
+
+	s32	bDriverStopped;
+	s32	bSurpriseRemoved;
+	s32  bCardDisableWOHSM;
+
+	u32	IsrContent;
+	u32	ImrContent;
+
+	u8	EepromAddressSize;
+	u8	hw_init_completed;
+	u8	bDriverIsGoingToUnload;
+	u8	init_adpt_in_progress;
+	u8	bHaltInProgress;
+
+	void *cmdThread;
+	void *evtThread;
+	void *xmitThread;
+	void *recvThread;
+
+	void (*intf_start)(struct rtw_adapter *adapter);
+	void (*intf_stop)(struct rtw_adapter *adapter);
+
+	struct net_device *pnetdev;
+
+	/*  used by rtw_rereg_nd_name related function */
+	struct rereg_nd_name_data {
+		struct net_device *old_pnetdev;
+		char old_ifname[IFNAMSIZ];
+		u8 old_ips_mode;
+		u8 old_bRegUseLed;
+	} rereg_nd_name_priv;
+
+	int bup;
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+	struct proc_dir_entry *dir_dev;/*  for proc directory */
+	struct wireless_dev *rtw_wdev;
+
+	int net_closed;
+
+	u8 bFWReady;
+	u8 bReadPortCancel;
+	u8 bWritePortCancel;
+	u8 bRxRSSIDisplay;
+	/* 	Added by Albert 2012/07/26 */
+	/* 	The driver will write the initial gain everytime when running in the DM_Write_DIG function. */
+	u8 bForceWriteInitGain;
+	/* 	Added by Albert 2012/10/26 */
+	/* 	The driver will show up the desired channel number when this flag is 1. */
+	u8 bNotifyChannelChange;
+#ifdef CONFIG_AUTOSUSPEND
+	u8	bDisableAutosuspend;
+#endif
+
+	/* pbuddy_adapter is used only in  two inteface case, (iface_nums=2 in struct dvobj_priv) */
+	/* PRIMARY_ADAPTER's buddy is SECONDARY_ADAPTER */
+	/* SECONDARY_ADAPTER's buddy is PRIMARY_ADAPTER */
+	/* for iface_id > SECONDARY_ADAPTER(IFACE_ID1), refer to padapters[iface_id]  in struct dvobj_priv */
+	/* and their pbuddy_adapter is PRIMARY_ADAPTER. */
+	/* for PRIMARY_ADAPTER(IFACE_ID0) can directly refer to if1 in struct dvobj_priv */
+	struct rtw_adapter *pbuddy_adapter;
+
+#if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
+	u8 isprimary; /* is primary adapter or not */
+	/* notes: */
+	/*  if isprimary is true, the adapter_type value is 0, iface_id is IFACE_ID0 for PRIMARY_ADAPTER */
+	/*  if isprimary is false, the adapter_type value is 1, iface_id is IFACE_ID1 for SECONDARY_ADAPTER */
+	/*  refer to iface_id if iface_nums>2 and isprimary is false and the adapter_type value is 0xff. */
+	u8 adapter_type;/* used only in  two inteface case(PRIMARY_ADAPTER and SECONDARY_ADAPTER) . */
+	u8 iface_type; /* interface port type, it depends on HW port */
+
+	/* extend to support multi interface */
+       /* IFACE_ID0 is equals to PRIMARY_ADAPTER */
+       /* IFACE_ID1 is equals to SECONDARY_ADAPTER */
+	u8 iface_id;
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	u8 DualMacConcurrent; /*  1: DMSP 0:DMDP */
+#endif
+};
+
+#define adapter_to_dvobj(adapter) (adapter->dvobj)
+
+int rtw_handle_dualmac(struct rtw_adapter *adapter, bool init);
+
+__inline static u8 *myid(struct eeprom_priv *peepriv)
+{
+	return (peepriv->mac_addr);
+}
+
+#endif /* __DRV_TYPES_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/ethernet.h b/drivers/net/wireless/rtl8192du/include/ethernet.h
new file mode 100644
index 0000000..62796ba
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/ethernet.h
@@ -0,0 +1,37 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*! \file */
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH			6		/*  Ethernet Address Length */
+#define ETHERNET_HEADER_SIZE			14		/*  Ethernet Header Length */
+#define LLC_HEADER_SIZE				6		/*  LLC Header Length */
+#define TYPE_LENGTH_FIELD_SIZE			2		/*  Type/Length Size */
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		/*  Minimum Ethernet Packet Size */
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	/*  Maximum Ethernet Packet Size */
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01)!=0)		/*  Is Multicast Address? */
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+					((u8 *)(_pAddr))[0]==0xff	&&		\
+					((u8 *)(_pAddr))[1]==0xff	&&		\
+					((u8 *)(_pAddr))[2]==0xff	&&		\
+					((u8 *)(_pAddr))[3]==0xff	&&		\
+					((u8 *)(_pAddr))[4]==0xff	&&		\
+					((u8 *)(_pAddr))[5]==0xff		)	/*  Is Broadcast Address? */
+
+
+#endif /*  #ifndef __INC_ETHERNET_H */
diff --git a/drivers/net/wireless/rtl8192du/include/h2clbk.h b/drivers/net/wireless/rtl8192du/include/h2clbk.h
new file mode 100644
index 0000000..af0d662
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/h2clbk.h
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+
+#define _H2CLBK_H_
+
+
+#include <rtl8711_spec.h>
+#include <TypeDef.h>
+
+
+void _lbk_cmd(PADAPTER adapter);
+
+void _lbk_rsp(PADAPTER adapter);
+
+void _lbk_evt(PADAPTER adapter);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
diff --git a/drivers/net/wireless/rtl8192du/include/hal8192dphycfg.h b/drivers/net/wireless/rtl8192du/include/hal8192dphycfg.h
new file mode 100644
index 0000000..d146e89
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/hal8192dphycfg.h
@@ -0,0 +1,421 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*****************************************************************************
+ *
+ * Module:	__INC_HAL8192DPHYCFG_H
+ *
+ *
+ * Note:
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *		Data		Who		Remark
+ *      08/07/2007  MHC		1. Porting from 9x series PHYCFG.h.
+ *							2. Reorganize code architecture.
+ *
+ *****************************************************************************/
+ /* Check to see if the file has been included already.  */
+#ifndef __INC_HAL8192DPHYCFG_H
+#define __INC_HAL8192DPHYCFG_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		/* us */
+#define AntennaDiversityValue	0x80	/* adapter->bSoftwareAntennaDiversity ? 0x00:0x80) */
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM			10
+#define IQK_BB_REG_NUM_92C	9
+#define IQK_BB_REG_NUM_92D	10
+#define IQK_BB_REG_NUM_test	6
+#define index_mapping_NUM		13
+#define Rx_index_mapping_NUM	15
+#define AVG_THERMAL_NUM		8
+#define IQK_Matrix_REG_NUM	8
+#define IQK_Matrix_Settings_NUM	1+24+21
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+enum swchnl_cmdid {
+	cmdid_end,
+	cmdid_settxpowerlevel,
+	cmdid_bbregwrite10,
+	cmdid_writeportulong,
+	cmdid_writeportushort,
+	cmdid_writeportuchar,
+	cmdid_rf_writereg,
+};
+
+
+/* 1. Switch channel related */
+struct sw_chnl_cmd {
+	enum swchnl_cmdid	cmdid;
+	u32			Para1;
+	u32			Para2;
+	u32			msDelay;
+};
+
+enum HW90_BLOCK {
+	HW90_BLOCK_MAC = 0,
+	HW90_BLOCK_PHY0 = 1,
+	HW90_BLOCK_PHY1 = 2,
+	HW90_BLOCK_RF = 3,
+	HW90_BLOCK_MAXIMUM = 4, /*  Never use this */
+};
+
+/* vivi added this for read parameter from header, 20100908 */
+enum RF_CONTENT {
+	radioa_txt = 0x1000,
+	radiob_txt = 0x1001,
+	radioc_txt = 0x1002,
+	radiod_txt = 0x1003
+};
+
+#define	RF_PATH_MAX			2
+
+enum WIRELESS_MODE {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20
+};
+
+
+#define CHANNEL_MAX_NUMBER		14+24+21	/*  14 is the max channel number */
+#define CHANNEL_GROUP_MAX		3+9	/*  ch1~3, ch4~9, ch10~14 total three groups */
+#define MAX_PG_GROUP 13
+
+#define	CHANNEL_GROUP_MAX_2G		3
+#define	CHANNEL_GROUP_IDX_5GL		3
+#define	CHANNEL_GROUP_IDX_5GM		6
+#define	CHANNEL_GROUP_IDX_5GH		9
+#define	CHANNEL_GROUP_MAX_5G		9
+#define	CHANNEL_MAX_NUMBER_2G		14
+
+enum BaseBand_Config_Type {
+	BaseBand_Config_PHY_REG = 0,			/* Radio Path A */
+	BaseBand_Config_AGC_TAB = 1,			/* Radio Path B */
+};
+
+enum MACPHY_MODE_8192D {
+	SINGLEMAC_SINGLEPHY,
+	DUALMAC_DUALPHY,
+	DUALMAC_SINGLEPHY,
+};
+
+enum MACPHY_MODE_CHANGE_ACTION {
+	DMDP2DMSP = 0,
+	DMSP2DMDP = 1,
+	DMDP2SMSP = 2,
+	SMSP2DMDP = 3,
+	DMSP2SMSP = 4,
+	SMSP2DMSP = 5,
+	MAXACTION
+};
+
+enum BAND_TYPE {
+	BAND_ON_2_4G = 0,
+	BAND_ON_5G,
+	BAND_ON_BOTH,
+	BANDMAX
+};
+
+enum PHY_Rate_Tx_Power_Offset_Area {
+	RA_OFFSET_LEGACY_OFDM1,
+	RA_OFFSET_LEGACY_OFDM2,
+	RA_OFFSET_HT_OFDM1,
+	RA_OFFSET_HT_OFDM2,
+	RA_OFFSET_HT_OFDM3,
+	RA_OFFSET_HT_OFDM4,
+	RA_OFFSET_HT_CCK,
+};
+
+
+/* BB/RF related */
+enum RF_TYPE_8190P {
+	RF_TYPE_MIN,	/*  0 */
+	RF_8225=1,			/*  1 11b/g RF for verification only */
+	RF_8256=2,			/*  2 11b/g/n */
+	RF_8258=3,			/*  3 11a/b/g/n RF */
+	RF_6052=4,		/*  4 11b/g/n RF */
+	/*  TODO: We should remove this psudo PHY RF after we get new RF. */
+	RF_PSEUDO_11N=5,	/*  5, It is a temporality RF. */
+};
+
+struct bb_register_def {
+	u32 rfintfs;		/*  set software control: */
+				/* 		0x870~0x877[8 bytes] */
+	u32 rfintfi;		/*  readback data: */
+				/* 		0x8e0~0x8e7[8 bytes] */
+	u32 rfintfo;		/*  output data: */
+				/* 		0x860~0x86f [16 bytes] */
+	u32 rfintfe;		/*  output enable: */
+				/* 		0x860~0x86f [16 bytes] */
+	u32 rf3wireOffset;	/*  LSSI data: */
+				/* 		0x840~0x84f [16 bytes] */
+	u32 rfLSSI_Select;	/*  BB Band Select: */
+				/* 		0x878~0x87f [8 bytes] */
+	u32 rfTxGainStage;	/*  Tx gain stage: */
+				/* 		0x80c~0x80f [4 bytes] */
+	u32 rfHSSIPara1;	/*  wire parameter control1 : */
+				/* 		0x820~0x823,0x828~0x82b, 0x830~0x833, 0x838~0x83b [16 bytes] */
+	u32 rfHSSIPara2;	/*  wire parameter control2 : */
+				/* 		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes] */
+	u32 rfSwitchControl;	/* Tx Rx antenna control : */
+				/* 		0x858~0x85f [16 bytes] */
+	u32 rfAGCControl1;	/* AGC parameter control1 : */
+				/* 		0xc50~0xc53,0xc58~0xc5b, 0xc60~0xc63, 0xc68~0xc6b [16 bytes] */
+	u32 rfAGCControl2;	/* AGC parameter control2 : */
+				/* 		0xc54~0xc57,0xc5c~0xc5f, 0xc64~0xc67, 0xc6c~0xc6f [16 bytes] */
+	u32 rfRxIQImbalance;	/* OFDM Rx IQ imbalance matrix : */
+				/* 		0xc14~0xc17,0xc1c~0xc1f, 0xc24~0xc27, 0xc2c~0xc2f [16 bytes] */
+	u32 rfRxAFE;		/* Rx IQ DC ofset and Rx digital filter, Rx DC notch filter : */
+				/* 		0xc10~0xc13,0xc18~0xc1b, 0xc20~0xc23, 0xc28~0xc2b [16 bytes] */
+	u32 rfTxIQImbalance;	/* OFDM Tx IQ imbalance matrix */
+				/* 		0xc80~0xc83,0xc88~0xc8b, 0xc90~0xc93, 0xc98~0xc9b [16 bytes] */
+	u32 rfTxAFE;		/* Tx IQ DC Offset and Tx DFIR type */
+				/* 		0xc84~0xc87,0xc8c~0xc8f, 0xc94~0xc97, 0xc9c~0xc9f [16 bytes] */
+	u32 rfLSSIReadBack;	/* LSSI RF readback data SI mode */
+				/* 		0x8a0~0x8af [16 bytes] */
+	u32 rfLSSIReadBackPi;	/* LSSI RF readback data PI mode 0x8b8-8bc for Path A and B */
+};
+
+struct antenna_select_ofdm {
+	u32			r_tx_antenna:4;
+	u32			r_ant_l:4;
+	u32			r_ant_non_ht:4;
+	u32			r_ant_ht1:4;
+	u32			r_ant_ht2:4;
+	u32			r_ant_ht_s1:4;
+	u32			r_ant_non_ht_s1:4;
+	u32			OFDM_TXSC:2;
+	u32			Reserved:2;
+};
+
+struct antenna_select_cck {
+	u8			r_cckrx_enable_2:2;
+	u8			r_cckrx_enable:2;
+	u8			r_ccktx_enable:4;
+};
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+/* Added for TX Power */
+/* u8 GetRightChnlPlace(u8 chnl); */
+u8 rtl8192d_GetRightChnlPlaceforIQK(u8 chnl);
+u8 rtl8192d_getChnlGroupfromArray(u8 chnl);
+/*--------------------------Exported Function prototype---------------------*/
+/*  */
+/*  BB and RF register read/write */
+/*  */
+void	rtl8192d_PHY_SetBBReg1Byte(	struct rtw_adapter *	adapter,
+								u32		RegAddr,
+								u32		BitMask,
+								u32		Data	);
+u32	rtl8192d_PHY_QueryBBReg(	struct rtw_adapter *	adapter,
+								u32		RegAddr,
+								u32		BitMask	);
+void	rtl8192d_PHY_SetBBReg(	struct rtw_adapter *	adapter,
+								u32		RegAddr,
+								u32		BitMask,
+								u32		Data	);
+u32	rtl8192d_PHY_QueryRFReg(	struct rtw_adapter *			adapter,
+								enum RF_RADIO_PATH_E	eRFPath,
+								u32				RegAddr,
+								u32				BitMask	);
+void	rtl8192d_PHY_SetRFReg(	struct rtw_adapter *			adapter,
+								enum RF_RADIO_PATH_E	eRFPath,
+								u32				RegAddr,
+								u32				BitMask,
+								u32				Data	);
+
+/*  */
+/*  Initialization related function */
+/*  */
+/* MAC/BB/RF HAL config */
+int	PHY_MACConfig8192D(	struct rtw_adapter *	adapter	);
+int	PHY_BBConfig8192D(	struct rtw_adapter *	adapter	);
+int	PHY_RFConfig8192D(	struct rtw_adapter *	adapter	);
+/* RF config */
+int	rtl8192d_PHY_ConfigRFWithHeaderFile(	struct rtw_adapter *			adapter,
+						enum RF_CONTENT			Content,
+						enum RF_RADIO_PATH_E	eRFPath);
+/* BB/RF readback check for making sure init OK */
+int	rtl8192d_PHY_CheckBBAndRFOK(	struct rtw_adapter *			adapter,
+				enum HW90_BLOCK		CheckBlock,
+				enum RF_RADIO_PATH_E	eRFPath	 );
+/* Read initi reg value for tx power setting. */
+void	rtl8192d_PHY_GetHWRegOriginalValue(	struct rtw_adapter *		adapter	);
+
+/*  */
+/*  RF Power setting */
+/*  */
+
+/*  */
+/*  BB TX Power R/W */
+/*  */
+void	PHY_GetTxPowerLevel8192D(	struct rtw_adapter *		adapter,
+											u32*		powerlevel	);
+void	PHY_SetTxPowerLevel8192D(	struct rtw_adapter *		adapter,
+											u8			channel	);
+bool	PHY_UpdateTxPowerDbm8192D(	struct rtw_adapter *	adapter,
+											int		powerInDbm	);
+
+/*  */
+/*  Switch bandwidth for 8192S */
+/*  */
+void	PHY_SetBWMode8192D(	struct rtw_adapter *			adapter,
+			enum HT_CHANNEL_WIDTH	ChnlWidth,
+									unsigned char	Offset	);
+
+/*  */
+/*  Set FW CMD IO for 8192S. */
+/*  */
+
+/*  */
+/*  Set A2 entry to fw for 8192S */
+/*  */
+extern	void FillA2Entry8192C(		struct rtw_adapter *			adapter,
+										u8				index,
+										u8*				val);
+
+
+/*  */
+/*  channel switch related funciton */
+/*  */
+void	PHY_SwChnl8192D(	struct rtw_adapter *		adapter,
+									u8			channel	);
+				/*  Call after initialization */
+void	PHY_SwChnlPhy8192D(	struct rtw_adapter *		adapter,
+									u8			channel	);
+
+extern void ChkFwCmdIoDone(	struct rtw_adapter *	adapter);
+
+/*  */
+/*  IQ calibrate */
+/*  */
+void	rtl8192d_PHY_IQCalibrate(	struct rtw_adapter *	adapter);
+
+
+/*  */
+/*  LC calibrate */
+/*  */
+void	rtl8192d_PHY_LCCalibrate(struct rtw_adapter *	adapter);
+
+/*  */
+/*  AP calibrate */
+/*  */
+void	rtl8192d_PHY_APCalibrate(struct rtw_adapter *	adapter, char		delta);
+
+extern	void
+PHY_SwitchEphyParameter(
+	struct rtw_adapter *			adapter
+	);
+
+extern	void
+PHY_EnableHostClkReq(
+	struct rtw_adapter *			adapter
+	);
+
+bool
+SetAntennaConfig92C(
+	struct rtw_adapter *	adapter,
+	u8		DefaultAnt
+	);
+
+void
+PHY_StopTRXBeforeChangeBand8192D(
+	  struct rtw_adapter *		adapter
+);
+
+void
+PHY_UpdateBBRFConfiguration8192D(
+	struct rtw_adapter * adapter,
+	bool bisBandSwitch
+);
+
+void PHY_ReadMacPhyMode92D(
+	struct rtw_adapter *	adapter,
+	bool	AutoloadFail
+);
+
+void PHY_ConfigMacPhyMode92D(
+	struct rtw_adapter *	adapter
+);
+
+void PHY_ConfigMacPhyModeInfo92D(
+	struct rtw_adapter *	adapter
+);
+
+void PHY_ConfigMacCoexist_RFPage92D(
+	struct rtw_adapter *	adapter
+);
+
+void
+rtl8192d_PHY_InitRxSetting(
+	struct rtw_adapter * adapter
+);
+
+void
+rtl8192d_PHY_ResetIQKResult(
+	struct rtw_adapter * adapter
+);
+
+
+void
+rtl8192d_PHY_SetRFPathSwitch(struct rtw_adapter *	adapter, bool		bMain);
+
+void
+HalChangeCCKStatus8192D(
+	struct rtw_adapter *	adapter,
+	bool		bCCKDisable
+);
+
+void PHY_InitPABias92D(struct rtw_adapter * adapter);
+
+/*--------------------------Exported Function prototype---------------------*/
+
+#define PHY_SetBBReg1Byte(adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg1Byte((adapter), (RegAddr), (BitMask), (Data))
+#define PHY_QueryBBReg(adapter, RegAddr, BitMask) rtl8192d_PHY_QueryBBReg((adapter), (RegAddr), (BitMask))
+#define PHY_SetBBReg(adapter, RegAddr, BitMask, Data) rtl8192d_PHY_SetBBReg((adapter), (RegAddr), (BitMask), (Data))
+#define PHY_QueryRFReg(adapter, eRFPath, RegAddr, BitMask) rtl8192d_PHY_QueryRFReg((adapter), (eRFPath), (RegAddr), (BitMask))
+#define PHY_SetRFReg(adapter, eRFPath, RegAddr, BitMask, Data) rtl8192d_PHY_SetRFReg((adapter), (eRFPath), (RegAddr), (BitMask), (Data))
+
+#define PHY_SetMacReg	PHY_SetBBReg
+
+#endif	/*  __INC_HAL8192SPHYCFG_H */
diff --git a/drivers/net/wireless/rtl8192du/include/hal8192dphyreg.h b/drivers/net/wireless/rtl8192du/include/hal8192dphyreg.h
new file mode 100644
index 0000000..a9991bc
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/hal8192dphyreg.h
@@ -0,0 +1,1162 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+/*****************************************************************************
+ *
+ * Module:	__INC_HAL8192DPHYREG_H
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *		Data		Who		Remark
+ *      08/07/2007  MHC		1. Porting from 9x series PHYCFG.h.
+ *							2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __INC_HAL8192DPHYREG_H
+#define __INC_HAL8192DPHYREG_H
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*  */
+/*        8192S Regsiter offset definition */
+/*  */
+
+/*  */
+/*  BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00 */
+/*  3. RF register 0x00-2E */
+/*  4. Bit Mask for BB/RF register */
+/*  5. Other defintion for BB/RF R/W */
+/*  */
+
+
+/*  */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  1. Page1(0x100) */
+/*  */
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+/*  */
+/*  2. Page2(0x200) */
+/*  */
+/*  The following two definition are only used for USB interface. */
+#define		RF_BB_CMD_ADDR				0x02c0	/*  RF/BB read/write command address. */
+#define		RF_BB_CMD_DATA				0x02c4	/*  RF/BB read/write command data. */
+
+/*  */
+/*  3. Page8(0x800) */
+/*  */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC RF BW Setting?? */
+
+#define		rFPGA0_TxInfo				0x804	/*  Status report?? */
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	/*  Set TX PWR init gain? */
+
+#define		rFPGA0_RFTiming1			0x810	/*  Useless now */
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	/*  RF 3 wire register */
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+
+#define		rFPGA0_RFWakeUpParameter		0x850	/*  Useless now */
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	/*  RF Channel switch */
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/*  RF Channel switch */
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/*  RF Interface Software Control */
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	/*  RF Parameter */
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	/*  Crystal cap setting RF-R/W protection for parameter4?? */
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888
+#define		rFPGA0_AdDaClockEn			0x888	/*  enable ad/da clock1 for dual-phy */
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/*  Tranceiver LSSI Readback */
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	/*  Useless now */
+#define		TransceiverA_HSPI_Readback	0x8b8	/*  Transceiver A HSPI Readback */
+#define		TransceiverB_HSPI_Readback	0x8bc	/*  Transceiver B HSPI Readback */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/*  Useless now RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/*  Useless now */
+
+/*  */
+/*  4. Page9(0x900) */
+/*  */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/*  Useless now */
+#define		rFPGA1_DebugSelect			0x908	/*  Useless now */
+#define		rFPGA1_TxInfo				0x90c	/*  Useless now Status report?? */
+
+/*  */
+/*  5. PageA(0xA00) */
+/*  */
+/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	/*  Disable init gain now Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/*  Disable init gain now Init gain */
+
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
+#define		rCCK0_TRSSIReport			0xa50
+#define		rCCK0_RxReport				0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */
+
+/*  */
+/*  PageB(0xB00) */
+/*  */
+#define		rPdp_AntA					0xb00
+#define		rPdp_AntA_4				0xb04
+#define		rPdp_AntA_8				0xb08
+#define		rPdp_AntA_C				0xb0c
+#define		rPdp_AntA_10					0xb10
+#define		rPdp_AntA_14					0xb14
+#define		rPdp_AntA_18					0xb18
+#define		rPdp_AntA_1C					0xb1c
+#define		rPdp_AntA_20					0xb20
+#define		rPdp_AntA_24					0xb24
+
+#define		rConfig_Pmpd_AntA			0xb28
+#define		rConfig_ram64x16				0xb2c
+
+#define		rBndA						0xb30
+#define		rHssiPar						0xb34
+
+#define		rConfig_AntA					0xb68
+#define		rConfig_AntB					0xb6c
+
+#define		rPdp_AntB					0xb70
+#define		rPdp_AntB_4					0xb74
+#define		rPdp_AntB_8					0xb78
+#define		rPdp_AntB_C					0xb7c
+#define		rPdp_AntB_10					0xb80
+#define		rPdp_AntB_14					0xb84
+#define		rPdp_AntB_18					0xb88
+#define		rPdp_AntB_1C					0xb8c
+#define		rPdp_AntB_20					0xb90
+#define		rPdp_AntB_24					0xb94
+
+#define		rConfig_Pmpd_AntB			0xb98
+
+#define		rBndB						0xba0
+
+#define		rAPK							0xbd8
+#define		rPm_Rx0_AntA				0xbdc
+#define		rPm_Rx1_AntA				0xbe0
+#define		rPm_Rx2_AntA				0xbe4
+#define		rPm_Rx3_AntA				0xbe8
+#define		rPm_Rx0_AntB				0xbec
+#define		rPm_Rx1_AntB				0xbf0
+#define		rPm_Rx2_AntB				0xbf4
+#define		rPm_Rx3_AntB				0xbf8
+
+/*  */
+/*  6. PageC(0xC00) */
+/*  */
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
+#define		rOFDM0_XBRxAFE				0xc18
+#define		rOFDM0_XBRxIQImbalance		0xc1c
+#define		rOFDM0_XCRxAFE				0xc20
+#define		rOFDM0_XCRxIQImbalance		0xc24
+#define		rOFDM0_XDRxAFE				0xc28
+#define		rOFDM0_XDRxIQImbalance		0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  /* PD,BW & SBD	DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /*  energy CCA */
+
+#define		rOFDM0_XAAGCCore1			0xc50	/*  DIG */
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	/*  TX PWR TRACK and DIG */
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE					0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+
+#define		rOFDM0_RxIQExtAnta			0xca0
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+
+/*  */
+/*  7. PageD(0xD00) */
+/*  */
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	/*  No setting now */
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
+
+#define		rOFDM_ShortCFOAB				0xdac	/*  No setting now */
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1			0xdc4
+#define		rOFDM_PWMeasure2			0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+/*  */
+/*  8. PageE(0xE00) */
+/*  */
+#define		rTxAGC_A_Rate18_06			0xe00
+#define		rTxAGC_A_Rate54_24			0xe04
+#define		rTxAGC_A_CCK1_Mcs32			0xe08
+#define		rTxAGC_A_Mcs03_Mcs00			0xe10
+#define		rTxAGC_A_Mcs07_Mcs04			0xe14
+#define		rTxAGC_A_Mcs11_Mcs08			0xe18
+#define		rTxAGC_A_Mcs15_Mcs12			0xe1c
+
+#define		rTxAGC_B_Rate18_06			0x830
+#define		rTxAGC_B_Rate54_24			0x834
+#define		rTxAGC_B_CCK1_55_Mcs32		0x838
+#define		rTxAGC_B_Mcs03_Mcs00			0x83c
+#define		rTxAGC_B_Mcs07_Mcs04			0x848
+#define		rTxAGC_B_Mcs11_Mcs08			0x84c
+#define		rTxAGC_B_Mcs15_Mcs12			0x868
+#define		rTxAGC_B_CCK11_A_CCK2_11		0x86c
+
+#define		rFPGA0_IQK						0xe28
+#define		rTx_IQK_Tone_A					0xe30
+#define		rRx_IQK_Tone_A					0xe34
+#define		rTx_IQK_PI_A					0xe38
+#define		rRx_IQK_PI_A					0xe3c
+
+#define		rTx_IQK							0xe40
+#define		rRx_IQK							0xe44
+#define		rIQK_AGC_Pts					0xe48
+#define		rIQK_AGC_Rsp					0xe4c
+#define		rTx_IQK_Tone_B					0xe50
+#define		rRx_IQK_Tone_B					0xe54
+#define		rTx_IQK_PI_B					0xe58
+#define		rRx_IQK_PI_B					0xe5c
+#define		rIQK_AGC_Cont					0xe60
+
+#define		rBlue_Tooth						0xe6c
+#define		rRx_Wait_CCA					0xe70
+#define		rTx_CCK_RFON					0xe74
+#define		rTx_CCK_BBON					0xe78
+#define		rTx_OFDM_RFON					0xe7c
+#define		rTx_OFDM_BBON					0xe80
+#define		rTx_To_Rx						0xe84
+#define		rTx_To_Tx						0xe88
+#define		rRx_CCK							0xe8c
+
+#define		rTx_Power_Before_IQK_A		0xe94
+#define		rTx_Power_After_IQK_A			0xe9c
+
+#define		rRx_Power_Before_IQK_A		0xea0
+#define		rRx_Power_Before_IQK_A_2		0xea4
+#define		rRx_Power_After_IQK_A			0xea8
+#define		rRx_Power_After_IQK_A_2		0xeac
+
+#define		rTx_Power_Before_IQK_B		0xeb4
+#define		rTx_Power_After_IQK_B			0xebc
+
+#define		rRx_Power_Before_IQK_B		0xec0
+#define		rRx_Power_Before_IQK_B_2		0xec4
+#define		rRx_Power_After_IQK_B			0xec8
+#define		rRx_Power_After_IQK_B_2		0xecc
+
+#define		rRx_OFDM						0xed0
+#define		rRx_Wait_RIFS					0xed4
+#define		rRx_TO_Rx						0xed8
+#define		rStandby						0xedc
+#define		rSleep							0xee0
+#define		rPMPD_ANAEN					0xeec
+
+/*  */
+/*  7. RF Register 0x00-0x2E (RF 8256) */
+/*     RF-0222D 0x00-3F */
+/*  */
+/* Zebra1 */
+#define		rZebra1_HSSIEnable				0x0	/*  Useless now */
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	/*  RF channel switch */
+
+/* endif */
+#define		rZebra1_TxGain					0x8	/*  Useless now */
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+/* Zebra4 */
+#define		rGlobalCtrl						0	/*  Useless now */
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/*  Useless now */
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+/*  */
+/*  RL6052 Register definition */
+/*  */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
+#define		RF_BS_PA_APSET_G1_G4		0x03
+#define		RF_BS_PA_APSET_G5_G8		0x04
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_IPA_G					0x09	/*  */
+#define		RF_TXBIAS_G				0x0A
+#define		RF_TXPA_AG					0x0B
+#define		RF_IPA_A					0x0C	/*  */
+#define		RF_TXBIAS_A				0x0D
+#define		RF_BS_PA_APSET_G9_G11	0x0E
+#define		RF_BS_IQGEN				0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/*  RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/*  RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x42	/*  */
+
+#define		RF_SYN_G1					0x25	/*  RF TX Power control */
+#define		RF_SYN_G2					0x26	/*  RF TX Power control */
+#define		RF_SYN_G3					0x27	/*  RF TX Power control */
+#define		RF_SYN_G4					0x28	/*  RF TX Power control */
+#define		RF_SYN_G5					0x29	/*  RF TX Power control */
+#define		RF_SYN_G6					0x2A	/*  RF TX Power control */
+#define		RF_SYN_G7					0x2B	/*  RF TX Power control */
+#define		RF_SYN_G8					0x2C	/*  RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/*  RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/*  RF TX PA control */
+#define		RF_TXPA_G2					0x32	/*  RF TX PA control */
+#define		RF_TXPA_G3					0x33	/*  RF TX PA control */
+#define		RF_LOBF_9					0x38
+#define		RF_RXRF_A3					0x3C	/*  */
+#define		RF_TRSW					0x3F
+
+#define		RF_TXRF_A2					0x41
+#define		RF_TXPA_G4					0x46
+#define		RF_TXPA_A4					0x4B
+
+/*  */
+/* Bit Mask */
+/*  */
+/*  1. Page1(0x100) */
+#define		bBBResetB						0x100	/*  Useless now? */
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define			IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+/*  2. Page8(0x800) */
+#define		bRFMOD							0x1	/*  Reg 0x800 rFPGA0_RFMOD */
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase				0x10000	/*  Useless now */
+#define		bOFDMTxDACPhase				0x40000
+#define		bXATxAGC					0x3f
+
+#define		bAntennaSelect				0x0300
+
+#define		bXBTxAGC					0xf00	/*  Reg 80c rFPGA0_TxGainStage */
+#define		bXCTxAGC					0xf000
+#define		bXDTxAGC					0xf0000
+
+#define		bPAStart					0xf0000000	/*  Useless now */
+#define		bTRStart					0x00f00000
+#define		bRFStart					0x0000f000
+#define		bBBStart					0x000000f0
+#define		bBBCCKStart				0x0000000f
+#define		bPAEnd						0xf          /* Reg0x814 */
+#define		bTREnd						0x0f000000
+#define		bRFEnd						0x000f0000
+#define		bCCAMask					0x000000f0   /* T2R */
+#define		bR2RCCAMask				0x00000f00
+#define		bHSSI_R2TDelay				0xf8000000
+#define		bHSSI_T2RDelay				0xf80000
+#define		bContTxHSSI				0x400     /* chane gain at continue Tx */
+#define		bIGFromCCK				0x200
+#define		bAGCAddress				0x3f
+#define		bRxHPTx						0x7000
+#define		bRxHPT2R					0x38000
+#define		bRxHPCCKIni				0xc0000
+#define		bAGCTxCode				0xc00000
+#define		bAGCRxCode				0x300000
+
+#define		b3WireDataLength			0x800	/*  Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
+#define		b3WireAddressLength			0x400
+
+#define		b3WireRFPowerDown			0x1	/*  Useless now */
+/* define bHWSISelect				0x8 */
+#define		b5GPAPEPolarity				0x40000000
+#define		b2GPAPEPolarity				0x80000000
+#define		bRFSW_TxDefaultAnt			0x3
+#define		bRFSW_TxOptionAnt			0x30
+#define		bRFSW_RxDefaultAnt			0x300
+#define		bRFSW_RxOptionAnt			0x3000
+#define		bRFSI_3WireData				0x1
+#define		bRFSI_3WireClock			0x2
+#define		bRFSI_3WireLoad				0x4
+#define		bRFSI_3WireRW				0x8
+#define		bRFSI_3Wire					0xf
+
+#define		bRFSI_RFENV				0x10	/*  Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+
+#define		bRFSI_TRSW				0x20	/*  Useless now */
+#define		bRFSI_TRSWB				0x40
+#define		bRFSI_ANTSW				0x100
+#define		bRFSI_ANTSWB				0x200
+#define		bRFSI_PAPE					0x400
+#define		bRFSI_PAPE5G				0x800
+#define		bBandSelect					0x1
+#define		bHTSIG2_GI					0x80
+#define		bHTSIG2_Smoothing			0x01
+#define		bHTSIG2_Sounding			0x02
+#define		bHTSIG2_Aggreaton			0x08
+#define		bHTSIG2_STBC				0x30
+#define		bHTSIG2_AdvCoding			0x40
+#define		bHTSIG2_NumOfHTLTF		0x300
+#define		bHTSIG2_CRC8				0x3fc
+#define		bHTSIG1_MCS				0x7f
+#define		bHTSIG1_BandWidth			0x80
+#define		bHTSIG1_HTLength			0xffff
+#define		bLSIG_Rate					0xf
+#define		bLSIG_Reserved				0x10
+#define		bLSIG_Length				0x1fffe
+#define		bLSIG_Parity					0x20
+#define		bCCKRxPhase				0x4
+
+#define		bLSSIReadAddress			0x7f800000   /*  T65 RF */
+
+#define		bLSSIReadEdge				0x80000000   /* LSSI "Read" edge signal */
+
+#define		bLSSIReadBackData			0xfffff		/*  T65 RF */
+
+#define		bLSSIReadOKFlag				0x1000	/*  Useless now */
+#define		bCCKSampleRate				0x8       /* 0: 44MHz, 1:88MHz */
+#define		bRegulator0Standby			0x1
+#define		bRegulatorPLLStandby			0x2
+#define		bRegulator1Standby			0x4
+#define		bPLLPowerUp				0x8
+#define		bDPLLPowerUp				0x10
+#define		bDA10PowerUp				0x20
+#define		bAD7PowerUp				0x200
+#define		bDA6PowerUp				0x2000
+#define		bXtalPowerUp				0x4000
+#define		b40MDClkPowerUP				0x8000
+#define		bDA6DebugMode				0x20000
+#define		bDA6Swing					0x380000
+
+#define		bADClkPhase				0x4000000	/*  Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+
+#define		b80MClkDelay				0x18000000	/*  Useless */
+#define		bAFEWatchDogEnable			0x20000000
+
+#define		bXtalCap01					0xc0000000	/*  Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define		bXtalCap23					0x3
+#define		bXtalCap92x					0x0f000000
+#define			bXtalCap					0x0f000000
+
+#define		bIntDifClkEnable			0x400	/*  Useless */
+#define		bExtSigClkEnable			0x800
+#define		bBandgapMbiasPowerUp		0x10000
+#define		bAD11SHGain				0xc0000
+#define		bAD11InputRange				0x700000
+#define		bAD11OPCurrent				0x3800000
+#define		bIPathLoopback				0x4000000
+#define		bQPathLoopback				0x8000000
+#define		bAFELoopback				0x10000000
+#define		bDA10Swing				0x7e0
+#define		bDA10Reverse				0x800
+#define		bDAClkSource				0x1000
+#define		bAD7InputRange				0x6000
+#define		bAD7Gain					0x38000
+#define		bAD7OutputCMMode			0x40000
+#define		bAD7InputCMMode				0x380000
+#define		bAD7Current					0xc00000
+#define		bRegulatorAdjust			0x7000000
+#define		bAD11PowerUpAtTx			0x1
+#define		bDA10PSAtTx				0x10
+#define		bAD11PowerUpAtRx			0x100
+#define		bDA10PSAtRx				0x1000
+#define		bCCKRxAGCFormat				0x200
+#define		bPSDFFTSamplepPoint			0xc000
+#define		bPSDAverageNum				0x3000
+#define		bIQPathControl				0xc00
+#define		bPSDFreq					0x3ff
+#define		bPSDAntennaPath				0x30
+#define		bPSDIQSwitch				0x40
+#define		bPSDRxTrigger				0x400000
+#define		bPSDTxTrigger				0x80000000
+#define		bPSDSineToneScale			0x7f000000
+#define		bPSDReport					0xffff
+
+/*  3. Page9(0x900) */
+#define		bOFDMTxSC				0x30000000	/*  Useless */
+#define		bCCKTxOn					0x1
+#define		bOFDMTxOn				0x2
+#define		bDebugPage				0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem				0xff   /* reset debug page and LWord */
+#define		bAntL					0x10
+#define		bAntNonHT					0x100
+#define		bAntHT1					0x1000
+#define		bAntHT2						0x10000
+#define		bAntHT1S1					0x100000
+#define		bAntNonHTS1				0x1000000
+
+/*  4. PageA(0xA00) */
+#define		bCCKBBMode				0x3	/*  Useless */
+#define		bCCKTxPowerSaving		0x80
+#define		bCCKRxPowerSaving		0x40
+
+#define		bCCKSideBand			0x10	/*  Reg 0xa00 rCCK0_System 20/40 switch */
+
+#define		bCCKScramble			0x8	/*  Useless */
+#define		bCCKAntDiversity		0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel			0x0800
+#define		bCCKISICancel			0x0400
+#define		bCCKMatchFilter			0x0200
+#define		bCCKEqualizer			0x0100
+#define		bCCKPreambleDetect		0x800000
+#define		bCCKFastFalseCCA		0x400000
+#define		bCCKChEstStart			0x300000
+#define		bCCKCCACount			0x080000
+#define		bCCKcs_lim				0x070000
+#define		bCCKBistMode			0x80000000
+#define		bCCKCCAMask			0x40000000
+#define		bCCKTxDACPhase		0x4
+#define		bCCKRxADCPhase		0x20000000   /* r_rx_clk */
+#define		bCCKr_cp_mode0		0x0100
+#define		bCCKTxDCOffset			0xf0
+#define		bCCKRxDCOffset			0xf
+#define		bCCKCCAMode			0xc000
+#define		bCCKFalseCS_lim			0x3f00
+#define		bCCKCS_ratio			0xc00000
+#define		bCCKCorgBit_sel			0x300000
+#define		bCCKPD_lim				0x0f0000
+#define		bCCKNewCCA			0x80000000
+#define		bCCKRxHPofIG			0x8000
+#define		bCCKRxIG				0x7f00
+#define		bCCKLNAPolarity			0x800000
+#define		bCCKRx1stGain			0x7f0000
+#define		bCCKRFExtend			0x20000000 /* CCK Rx Iinital gain polarity */
+#define		bCCKRxAGCSatLevel		0x1f000000
+#define		bCCKRxAGCSatCount		0xe0
+#define		bCCKRxRFSettle			0x1f       /* AGCsamp_dly */
+#define		bCCKFixedRxAGC			0x8000
+#define		bCCKAntennaPolarity		0x2000
+#define		bCCKTxFilterType		0x0c00
+#define		bCCKRxAGCReportType	0x0300
+#define		bCCKRxDAGCEn			0x80000000
+#define		bCCKRxDAGCPeriod		0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery		0x800000
+#define		bCCKTxC0				0x3f0000
+#define		bCCKTxC1				0x3f000000
+#define		bCCKTxC2				0x3f
+#define		bCCKTxC3				0x3f00
+#define		bCCKTxC4				0x3f0000
+#define		bCCKTxC5				0x3f000000
+#define		bCCKTxC6				0x3f
+#define		bCCKTxC7				0x3f00
+#define		bCCKDebugPort			0xff0000
+#define		bCCKDACDebug			0x0f000000
+#define		bCCKFalseAlarmEnable	0x8000
+#define		bCCKFalseAlarmRead		0x4000
+#define		bCCKTRSSI				0x7f
+#define		bCCKRxAGCReport		0xfe
+#define		bCCKRxReport_AntSel	0x80000000
+#define		bCCKRxReport_MFOff		0x40000000
+#define		bCCKRxRxReport_SQLoss	0x20000000
+#define		bCCKRxReport_Pktloss	0x10000000
+#define		bCCKRxReport_Lockedbit	0x08000000
+#define		bCCKRxReport_RateError	0x04000000
+#define		bCCKRxReport_RxRate	0x03000000
+#define		bCCKRxFACounterLower	0xff
+#define		bCCKRxFACounterUpper	0xff000000
+#define		bCCKRxHPAGCStart		0xe000
+#define		bCCKRxHPAGCFinal		0x1c00
+#define		bCCKRxFalseAlarmEnable	0x8000
+#define		bCCKFACounterFreeze	0x4000
+#define		bCCKTxPathSel			0x10000000
+#define		bCCKDefaultRxPath		0xc000000
+#define		bCCKOptionRxPath		0x3000000
+
+/*  5. PageC(0xC00) */
+#define		bNumOfSTF				0x3	/*  Useless */
+#define		bShift_L					0xc0
+#define		bGI_TH					0xc
+#define		bRxPathA				0x1
+#define		bRxPathB				0x2
+#define		bRxPathC				0x4
+#define		bRxPathD				0x8
+#define		bTxPathA				0x1
+#define		bTxPathB				0x2
+#define		bTxPathC				0x4
+#define		bTxPathD				0x8
+#define		bTRSSIFreq				0x200
+#define		bADCBackoff				0x3000
+#define		bDFIRBackoff			0xc000
+#define		bTRSSILatchPhase		0x10000
+#define		bRxIDCOffset			0xff
+#define		bRxQDCOffset			0xff00
+#define		bRxDFIRMode			0x1800000
+#define		bRxDCNFType			0xe000000
+#define		bRXIQImb_A				0x3ff
+#define		bRXIQImb_B				0xfc00
+#define		bRXIQImb_C				0x3f0000
+#define		bRXIQImb_D				0xffc00000
+#define		bDC_dc_Notch			0x60000
+#define		bRxNBINotch			0x1f000000
+#define		bPD_TH					0xf
+#define		bPD_TH_Opt2			0xc000
+#define		bPWED_TH				0x700
+#define		bIfMF_Win_L			0x800
+#define		bPD_Option				0x1000
+#define		bMF_Win_L				0xe000
+#define		bBW_Search_L			0x30000
+#define		bwin_enh_L				0xc0000
+#define		bBW_TH					0x700000
+#define		bED_TH2				0x3800000
+#define		bBW_option				0x4000000
+#define		bRatio_TH				0x18000000
+#define		bWindow_L				0xe0000000
+#define		bSBD_Option				0x1
+#define		bFrame_TH				0x1c
+#define		bFS_Option				0x60
+#define		bDC_Slope_check		0x80
+#define		bFGuard_Counter_DC_L	0xe00
+#define		bFrame_Weight_Short	0x7000
+#define		bSub_Tune				0xe00000
+#define		bFrame_DC_Length		0xe000000
+#define		bSBD_start_offset		0x30000000
+#define		bFrame_TH_2			0x7
+#define		bFrame_GI2_TH			0x38
+#define		bGI2_Sync_en			0x40
+#define		bSarch_Short_Early		0x300
+#define		bSarch_Short_Late		0xc00
+#define		bSarch_GI2_Late		0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc				0x2
+#define		bCFOStartOffset			0xc
+#define		bCFOLookBack			0x70
+#define		bCFOSumWeight			0x80
+#define		bDAGCEnable			0x10000
+#define		bTXIQImb_A				0x3ff
+#define		bTXIQImb_B				0xfc00
+#define		bTXIQImb_C				0x3f0000
+#define		bTXIQImb_D				0xffc00000
+#define		bTxIDCOffset			0xff
+#define		bTxQDCOffset			0xff00
+#define		bTxDFIRMode			0x10000
+#define		bTxPesudoNoiseOn		0x4000000
+#define		bTxPesudoNoise_A		0xff
+#define		bTxPesudoNoise_B		0xff00
+#define		bTxPesudoNoise_C		0xff0000
+#define		bTxPesudoNoise_D		0xff000000
+#define		bCCADropOption			0x20000
+#define		bCCADropThres			0xfff00000
+#define		bEDCCA_H				0xf
+#define		bEDCCA_L				0xf0
+#define		bLambda_ED			0x300
+#define		bRxInitialGain			0x7f
+#define		bRxAntDivEn				0x80
+#define		bRxAGCAddressForLNA	0x7f00
+#define		bRxHighPowerFlow		0x8000
+#define		bRxAGCFreezeThres		0xc0000
+#define		bRxFreezeStep_AGC1	0x300000
+#define		bRxFreezeStep_AGC2	0xc00000
+#define		bRxFreezeStep_AGC3	0x3000000
+#define		bRxFreezeStep_AGC0	0xc000000
+#define		bRxRssi_Cmp_En			0x10000000
+#define		bRxQuickAGCEn			0x20000000
+#define		bRxAGCFreezeThresMode	0x40000000
+#define		bRxOverFlowCheckType	0x80000000
+#define		bRxAGCShift				0x7f
+#define		bTRSW_Tri_Only			0x80
+#define		bPowerThres			0x300
+#define		bRxAGCEn				0x1
+#define		bRxAGCTogetherEn		0x2
+#define		bRxAGCMin				0x4
+#define		bRxHP_Ini				0x7
+#define		bRxHP_TRLNA			0x70
+#define		bRxHP_RSSI				0x700
+#define		bRxHP_BBP1				0x7000
+#define		bRxHP_BBP2				0x70000
+#define		bRxHP_BBP3				0x700000
+#define		bRSSI_H					0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen				0x7f000000   /* the threshold for ant diversity */
+#define		bRxSettle_TRSW			0x7
+#define		bRxSettle_LNA			0x38
+#define		bRxSettle_RSSI			0x1c0
+#define		bRxSettle_BBP			0xe00
+#define		bRxSettle_RxHP			0x7000
+#define		bRxSettle_AntSW_RSSI	0x38000
+#define		bRxSettle_AntSW		0xc0000
+#define		bRxProcessTime_DAGC	0x300000
+#define		bRxSettle_HSSI			0x400000
+#define		bRxProcessTime_BBPPW	0x800000
+#define		bRxAntennaPowerShift	0x3000000
+#define		bRSSITableSelect		0xc000000
+#define		bRxHP_Final				0x7000000
+#define		bRxHTSettle_BBP			0x7
+#define		bRxHTSettle_HSSI		0x8
+#define		bRxHTSettle_RxHP		0x70
+#define		bRxHTSettle_BBPPW		0x80
+#define		bRxHTSettle_Idle		0x300
+#define		bRxHTSettle_Reserved	0x1c00
+#define		bRxHTRxHPEn			0x8000
+#define		bRxHTAGCFreezeThres	0x30000
+#define		bRxHTAGCTogetherEn	0x40000
+#define		bRxHTAGCMin			0x80000
+#define		bRxHTAGCEn				0x100000
+#define		bRxHTDAGCEn			0x200000
+#define		bRxHTRxHP_BBP			0x1c00000
+#define		bRxHTRxHP_Final		0xe0000000
+#define		bRxPWRatioTH			0x3
+#define		bRxPWRatioEn			0x4
+#define		bRxMFHold				0x3800
+#define		bRxPD_Delay_TH1		0x38
+#define		bRxPD_Delay_TH2		0x1c0
+#define		bRxPD_DC_COUNT_MAX	0x600
+/* define bRxMF_Hold               0x3800 */
+#define		bRxPD_Delay_TH			0x8000
+#define		bRxProcess_Delay		0xf0000
+#define		bRxSearchrange_GI2_Early	0x700000
+#define		bRxFrame_Guard_Counter_L	0x3800000
+#define		bRxSGI_Guard_L			0xc000000
+#define		bRxSGI_Search_L		0x30000000
+#define		bRxSGI_TH				0xc0000000
+#define		bDFSCnt0				0xff
+#define		bDFSCnt1				0xff00
+#define		bDFSFlag				0xf0000
+#define		bMFWeightSum			0x300000
+#define		bMinIdxTH				0x7f000000
+#define		bDAFormat				0x40000
+#define		bTxChEmuEnable		0x01000000
+#define		bTRSWIsolation_A		0x7f
+#define		bTRSWIsolation_B		0x7f00
+#define		bTRSWIsolation_C		0x7f0000
+#define		bTRSWIsolation_D		0x7f000000
+#define		bExtLNAGain				0x7c00
+
+/*  6. PageE(0xE00) */
+#define		bSTBCEn				0x4	/*  Useless */
+#define		bAntennaMapping		0x10
+#define		bNss					0x20
+#define		bCFOAntSumD			0x200
+#define		bPHYCounterReset		0x8000000
+#define		bCFOReportGet			0x4000000
+#define		bOFDMContinueTx		0x10000000
+#define		bOFDMSingleCarrier		0x20000000
+#define		bOFDMSingleTone		0x40000000
+/* define bRxPath1                 0x01 */
+/* define bRxPath2                 0x02 */
+/* define bRxPath3                 0x04 */
+/* define bRxPath4                 0x08 */
+/* define bTxPath1                 0x10 */
+/* define bTxPath2                 0x20 */
+#define		bHTDetect			0x100
+#define		bCFOEn				0x10000
+#define		bCFOValue			0xfff00000
+#define		bSigTone_Re		0x3f
+#define		bSigTone_Im		0x7f00
+#define		bCounter_CCA		0xffff
+#define		bCounter_ParityFail	0xffff0000
+#define		bCounter_RateIllegal		0xffff
+#define		bCounter_CRC8Fail	0xffff0000
+#define		bCounter_MCSNoSupport	0xffff
+#define		bCounter_FastSync	0xffff
+#define		bShortCFO			0xfff
+#define		bShortCFOTLength	12   /* total */
+#define		bShortCFOFLength	11   /* fraction */
+#define		bLongCFO			0x7ff
+#define		bLongCFOTLength	11
+#define		bLongCFOFLength	11
+#define		bTailCFO			0x1fff
+#define		bTailCFOTLength		13
+#define		bTailCFOFLength		12
+#define		bmax_en_pwdB		0xffff
+#define		bCC_power_dB		0xffff0000
+#define		bnoise_pwdB		0xffff
+#define		bPowerMeasTLength	10
+#define		bPowerMeasFLength	3
+#define		bRx_HT_BW			0x1
+#define		bRxSC				0x6
+#define		bRx_HT				0x8
+#define		bNB_intf_det_on		0x1
+#define		bIntf_win_len_cfg	0x30
+#define		bNB_Intf_TH_cfg		0x1c0
+#define		bRFGain				0x3f
+#define		bTableSel			0x40
+#define		bTRSW				0x80
+#define		bRxSNR_A			0xff
+#define		bRxSNR_B			0xff00
+#define		bRxSNR_C			0xff0000
+#define		bRxSNR_D			0xff000000
+#define		bSNREVMTLength		8
+#define		bSNREVMFLength		1
+#define		bCSI1st				0xff
+#define		bCSI2nd				0xff00
+#define		bRxEVM1st			0xff0000
+#define		bRxEVM2nd			0xff000000
+#define		bSIGEVM			0xff
+#define		bPWDB				0xff00
+#define		bSGIEN				0x10000
+
+#define		bSFactorQAM1		0xf	/*  Useless */
+#define		bSFactorQAM2		0xf0
+#define		bSFactorQAM3		0xf00
+#define		bSFactorQAM4		0xf000
+#define		bSFactorQAM5		0xf0000
+#define		bSFactorQAM6		0xf0000
+#define		bSFactorQAM7		0xf00000
+#define		bSFactorQAM8		0xf000000
+#define		bSFactorQAM9		0xf0000000
+#define		bCSIScheme			0x100000
+
+#define		bNoiseLvlTopSet		0x3	/*  Useless */
+#define		bChSmooth			0x4
+#define		bChSmoothCfg1		0x38
+#define		bChSmoothCfg2		0x1c0
+#define		bChSmoothCfg3		0xe00
+#define		bChSmoothCfg4		0x7000
+#define		bMRCMode			0x800000
+#define		bTHEVMCfg			0x7000000
+
+#define		bLoopFitType		0x1	/*  Useless */
+#define		bUpdCFO			0x40
+#define		bUpdCFOOffData		0x80
+#define		bAdvUpdCFO			0x100
+#define		bAdvTimeCtrl		0x800
+#define		bUpdClko			0x1000
+#define		bFC					0x6000
+#define		bTrackingMode		0x8000
+#define		bPhCmpEnable		0x10000
+#define		bUpdClkoLTF		0x20000
+#define		bComChCFO			0x40000
+#define		bCSIEstiMode		0x80000
+#define		bAdvUpdEqz			0x100000
+#define		bUChCfg				0x7000000
+#define		bUpdEqz			0x8000000
+
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn		0x20000000	/*  Useless */
+#define		bRxPesudoNoise_A		0xff
+#define		bRxPesudoNoise_B		0xff00
+#define		bRxPesudoNoise_C		0xff0000
+#define		bRxPesudoNoise_D		0xff000000
+#define		bPesudoNoiseState_A	0xffff
+#define		bPesudoNoiseState_B	0xffff0000
+#define		bPesudoNoiseState_C	0xffff
+#define		bPesudoNoiseState_D	0xffff0000
+
+/* 7. RF Register */
+/* Zebra1 */
+#define		bZebra1_HSSIEnable		0x8		/*  Useless */
+#define		bZebra1_TRxControl		0xc00
+#define		bZebra1_TRxGainSetting	0x07f
+#define		bZebra1_RxCorner		0xc00
+#define		bZebra1_TxChargePump	0x38
+#define		bZebra1_RxChargePump	0x7
+#define		bZebra1_ChannelNum	0xf80
+#define		bZebra1_TxLPFBW		0x400
+#define		bZebra1_RxLPFBW		0x600
+
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1	0x100	/*  Useless */
+#define		bRTL8256RegModeCtrl0	0x40
+#define		bRTL8256_TxLPFBW		0x18
+#define		bRTL8256_RxLPFBW		0x600
+
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW		0xc	/*  Useless */
+#define		bRTL8258_RxLPFBW		0xc00
+#define		bRTL8258_RSSILPFBW	0xc0
+
+
+/*  */
+/*  Other Definition */
+/*  */
+
+/* byte endable for sb_write */
+#define		bByte0				0x1	/*  Useless */
+#define		bByte1				0x2
+#define		bByte2				0x4
+#define		bByte3				0x8
+#define		bWord0				0x3
+#define		bWord1				0xc
+#define		bDWord				0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0			0xff	/*  Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define		bMaskByte1			0xff00
+#define		maskbyte2			0xff0000
+#define		bMaskByte3			0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord			0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMask12Bits			0xfff
+#define		bMaskH4Bits			0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK			0x3f3f3f3f
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
+#define			bRFRegOffsetMask		0xfffff
+
+/* MAC0 will wirte PHY1 */
+#define	MAC0_ACCESS_PHY1	0x4000
+/* MAC1 will wirte PHY0 */
+#define	MAC1_ACCESS_PHY0	0x2000
+
+#define		bEnable			0x1	/*  Useless */
+#define		bDisable		0x0
+
+#define		LeftAntenna		0x0	/*  Useless */
+#define		RightAntenna	0x1
+
+#define		tCheckTxStatus		500   /* 500ms Useless */
+#define		tUpdateRxCounter	100   /* 100ms */
+
+#define		rateCCK		0	/*  Useless */
+#define		rateOFDM	1
+#define		rateHT		2
+
+/* define Register-End */
+#define		bPMAC_End			0x1ff	/*  Useless */
+#define		bFPGAPHY0_End		0x8ff
+#define		bFPGAPHY1_End		0x9ff
+#define		bCCKPHY0_End		0xaff
+#define		bOFDMPHY0_End		0xcff
+#define		bOFDMPHY1_End		0xdff
+
+/* define max debug item in each debug page */
+/* define bMaxItem_FPGA_PHY0        0x9 */
+/* define bMaxItem_FPGA_PHY1        0x3 */
+/* define bMaxItem_PHY_11B          0x16 */
+/* define bMaxItem_OFDM_PHY0        0x29 */
+/* define bMaxItem_OFDM_PHY1        0x0 */
+
+#define		bPMACControl		0x0		/*  Useless */
+#define		bWMACControl		0x1
+#define		bWNICControl		0x2
+
+#define		PathA			0x0	/*  Useless */
+#define		PathB			0x1
+#define		PathC			0x2
+#define		PathD			0x3
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	/* __INC_HAL8192SPHYREG_H */
diff --git a/drivers/net/wireless/rtl8192du/include/hal8192duhwimg.h b/drivers/net/wireless/rtl8192du/include/hal8192duhwimg.h
new file mode 100644
index 0000000..d5aab93
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/hal8192duhwimg.h
@@ -0,0 +1,61 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8192DU_FW_IMG_H
+#define __INC_HAL8192DU_FW_IMG_H
+
+#include <basic_types.h>
+
+/*Created on  2011/11/11,  8: 8*/
+
+#define Rtl8192DUImgArrayLength 32302
+#define Rtl8192DUMainArrayLength 1
+extern const u8 Rtl8192DUFwMainArray[Rtl8192DUMainArrayLength];
+#define Rtl8192DUDataArrayLength 1
+extern const u8 Rtl8192DUFwDataArray[Rtl8192DUDataArrayLength];
+#define Rtl8192DUPHY_REG_2TArrayLength 372
+extern const u32 Rtl8192DUPHY_REG_2TArray[Rtl8192DUPHY_REG_2TArrayLength];
+#define Rtl8192DUPHY_REG_1TArrayLength 1
+extern const u32 Rtl8192DUPHY_REG_1TArray[Rtl8192DUPHY_REG_1TArrayLength];
+#define Rtl8192DUPHY_REG_Array_PGLength 624
+extern const u32 Rtl8192DUPHY_REG_Array_PG[Rtl8192DUPHY_REG_Array_PGLength];
+#define Rtl8192DUPHY_REG_Array_MPLength 14
+extern const u32 Rtl8192DUPHY_REG_Array_MP[Rtl8192DUPHY_REG_Array_MPLength];
+#define Rtl8192DURadioA_2TArrayLength 378
+extern const u32 Rtl8192DURadioA_2TArray[Rtl8192DURadioA_2TArrayLength];
+#define Rtl8192DURadioB_2TArrayLength 384
+extern const u32 Rtl8192DURadioB_2TArray[Rtl8192DURadioB_2TArrayLength];
+#define Rtl8192DURadioA_1TArrayLength 1
+extern const u32 Rtl8192DURadioA_1TArray[Rtl8192DURadioA_1TArrayLength];
+#define Rtl8192DURadioB_1TArrayLength 1
+extern const u32 Rtl8192DURadioB_1TArray[Rtl8192DURadioB_1TArrayLength];
+#define Rtl8192DURadioA_2T_intPAArrayLength 378
+extern const u32 Rtl8192DURadioA_2T_intPAArray[Rtl8192DURadioA_2T_intPAArrayLength];
+#define Rtl8192DURadioB_2T_intPAArrayLength 384
+extern const u32 Rtl8192DURadioB_2T_intPAArray[Rtl8192DURadioB_2T_intPAArrayLength];
+#define Rtl8192DUMAC_2T_ArrayLength 192
+extern const u32 Rtl8192DUMAC_2T_Array[Rtl8192DUMAC_2T_ArrayLength];
+#define Rtl8192DUAGCTAB_ArrayLength 386
+extern const u32 Rtl8192DUAGCTAB_Array[Rtl8192DUAGCTAB_ArrayLength];
+#define Rtl8192DUAGCTAB_5GArrayLength 194
+extern const u32 Rtl8192DUAGCTAB_5GArray[Rtl8192DUAGCTAB_5GArrayLength];
+#define Rtl8192DUAGCTAB_2GArrayLength 194
+extern const u32 Rtl8192DUAGCTAB_2GArray[Rtl8192DUAGCTAB_2GArrayLength];
+#define Rtl8192DUAGCTAB_2TArrayLength 1
+extern const u32 Rtl8192DUAGCTAB_2TArray[Rtl8192DUAGCTAB_2TArrayLength];
+#define Rtl8192DUAGCTAB_1TArrayLength 1
+extern const u32 Rtl8192DUAGCTAB_1TArray[Rtl8192DUAGCTAB_1TArrayLength];
+
+#endif /* __INC_HAL8192CU_FW_IMG_H */
diff --git a/drivers/net/wireless/rtl8192du/include/hal_com.h b/drivers/net/wireless/rtl8192du/include/hal_com.h
new file mode 100644
index 0000000..aa77f21
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/hal_com.h
@@ -0,0 +1,138 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_H__
+#define __HAL_COMMON_H__
+
+/* CCK */
+#define RATE_1M						BIT(0)
+#define RATE_2M						BIT(1)
+#define RATE_5_5M					BIT(2)
+#define RATE_11M					BIT(3)
+/* OFDM */
+#define RATE_6M						BIT(4)
+#define RATE_9M						BIT(5)
+#define RATE_12M					BIT(6)
+#define RATE_18M					BIT(7)
+#define RATE_24M					BIT(8)
+#define RATE_36M					BIT(9)
+#define RATE_48M					BIT(10)
+#define RATE_54M					BIT(11)
+/* MCS 1 Spatial Stream */
+#define RATE_MCS0					BIT(12)
+#define RATE_MCS1					BIT(13)
+#define RATE_MCS2					BIT(14)
+#define RATE_MCS3					BIT(15)
+#define RATE_MCS4					BIT(16)
+#define RATE_MCS5					BIT(17)
+#define RATE_MCS6					BIT(18)
+#define RATE_MCS7					BIT(19)
+/* MCS 2 Spatial Stream */
+#define RATE_MCS8					BIT(20)
+#define RATE_MCS9					BIT(21)
+#define RATE_MCS10					BIT(22)
+#define RATE_MCS11					BIT(23)
+#define RATE_MCS12					BIT(24)
+#define RATE_MCS13					BIT(25)
+#define RATE_MCS14					BIT(26)
+#define RATE_MCS15					BIT(27)
+
+/*  ALL CCK Rate */
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
+#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
+									RATR_36M|RATR_48M|RATR_54M
+#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
+									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
+#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
+									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
+
+/*------------------------------ Tx Desc definition Macro ------------------------*/
+/* pragma mark -- Tx Desc related definition. -- */
+/*  */
+/*  */
+/* 	Rate */
+/*  */
+/*  CCK Rates, TxHT = 0 */
+#define DESC_RATE1M				0x00
+#define DESC_RATE2M				0x01
+#define DESC_RATE5_5M				0x02
+#define DESC_RATE11M				0x03
+
+/*  OFDM Rates, TxHT = 0 */
+#define DESC_RATE6M				0x04
+#define DESC_RATE9M				0x05
+#define DESC_RATE12M				0x06
+#define DESC_RATE18M				0x07
+#define DESC_RATE24M				0x08
+#define DESC_RATE36M				0x09
+#define DESC_RATE48M				0x0a
+#define DESC_RATE54M				0x0b
+
+/*  MCS Rates, TxHT = 1 */
+#define DESC_RATEMCS0				0x0c
+#define DESC_RATEMCS1				0x0d
+#define DESC_RATEMCS2				0x0e
+#define DESC_RATEMCS3				0x0f
+#define DESC_RATEMCS4				0x10
+#define DESC_RATEMCS5				0x11
+#define DESC_RATEMCS6				0x12
+#define DESC_RATEMCS7				0x13
+#define DESC_RATEMCS8				0x14
+#define DESC_RATEMCS9				0x15
+#define DESC_RATEMCS10				0x16
+#define DESC_RATEMCS11				0x17
+#define DESC_RATEMCS12				0x18
+#define DESC_RATEMCS13				0x19
+#define DESC_RATEMCS14				0x1a
+#define DESC_RATEMCS15				0x1b
+#define DESC_RATEMCS15_SG			0x1c
+#define DESC_RATEMCS32				0x20
+
+/*  */
+/*  Global var */
+/*  */
+#define	OFDM_TABLE_SIZE_92C	37
+#define	OFDM_TABLE_SIZE_92D	43
+#define	CCK_TABLE_SIZE		33
+
+extern u32 OFDMSwingTable[OFDM_TABLE_SIZE_92D] ;
+
+extern u8 CCKSwingTable_Ch1_Ch13[CCK_TABLE_SIZE][8];
+
+extern u8 CCKSwingTable_Ch14 [CCK_TABLE_SIZE][8];
+
+#ifdef CONFIG_CHIP_VER_INTEGRATION
+void dump_chip_info(HAL_VERSION	ChipVersion);
+#endif
+
+u8	/* return the final channel plan decision */
+hal_com_get_channel_plan(
+	struct rtw_adapter * padapter,
+	u8 hw_channel_plan,	/* channel plan from HW (efuse/eeprom) */
+	u8 sw_channel_plan,	/* channel plan from SW (registry/module param) */
+	u8 def_channel_plan,	/* channel plan used when the former two is invalid */
+	bool		AutoLoadFail
+	);
+
+void	halsetbratecfg(struct rtw_adapter * adapter, u8 *mBratesOS, u16 *pBrateCfg);
+
+u8	ratetohwrate(u8 rate);
+
+void hal_init_macaddr(struct rtw_adapter *adapter);
+
+void c2h_evt_clear(struct rtw_adapter *adapter);
+s32 c2h_evt_read(struct rtw_adapter *adapter, u8 *buf);
+
+#endif /* __HAL_COMMON_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/hal_intf.h b/drivers/net/wireless/rtl8192du/include/hal_intf.h
new file mode 100644
index 0000000..2d3a3b8
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/hal_intf.h
@@ -0,0 +1,389 @@
+/******************************************************************************
+ *
+ *Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ *This program is free software; you can redistribute it and/or modify it
+ *under the terms of version 2 of the GNU General Public License as
+ *published by the Free Software Foundation.
+ *
+ *This program is distributed in the hope that it will be useful, but WITHOUT
+ *ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ *more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_INTF_H__
+#define __HAL_INTF_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+extern int rtw_ht_enable;
+
+enum RTL871X_HCI_TYPE {
+
+	RTW_SDIO,
+	RTW_USB,
+	RTW_PCIE
+};
+
+enum _CHIP_TYPE {
+
+	NULL_CHIP_TYPE,
+	RTL8712_8188S_8191S_8192S,
+	RTL8188C_8192C,
+	RTL8192D,
+	RTL8723A,
+	RTL8188E,
+	MAX_CHIP_TYPE
+};
+
+
+enum HW_VARIABLES {
+	HW_VAR_MEDIA_STATUS,
+	HW_VAR_MEDIA_STATUS1,
+	HW_VAR_SET_OPMODE,
+	HW_VAR_MAC_ADDR,
+	HW_VAR_BSSID,
+	HW_VAR_INIT_RTS_RATE,
+	HW_VAR_INIT_DATA_RATE,
+	HW_VAR_BASIC_RATE,
+	HW_VAR_TXPAUSE,
+	HW_VAR_BCN_FUNC,
+	HW_VAR_CORRECT_TSF,
+	HW_VAR_CHECK_BSSID,
+	HW_VAR_MLME_DISCONNECT,
+	HW_VAR_MLME_SITESURVEY,
+	HW_VAR_MLME_JOIN,
+	HW_VAR_ON_RCR_AM,
+	HW_VAR_OFF_RCR_AM,
+	HW_VAR_BEACON_INTERVAL,
+	HW_VAR_SLOT_TIME,
+	HW_VAR_RESP_SIFS,
+	HW_VAR_ACK_PREAMBLE,
+	HW_VAR_SEC_CFG,
+	HW_VAR_BCN_VALID,
+	HW_VAR_RF_TYPE,
+	HW_VAR_DM_FLAG,
+	HW_VAR_DM_FUNC_OP,
+	HW_VAR_DM_FUNC_SET,
+	HW_VAR_DM_FUNC_CLR,
+	HW_VAR_DM_INIT_PWDB,
+	HW_VAR_CAM_EMPTY_ENTRY,
+	HW_VAR_CAM_INVALID_ALL,
+	HW_VAR_CAM_WRITE,
+	HW_VAR_CAM_READ,
+	HW_VAR_AC_PARAM_VO,
+	HW_VAR_AC_PARAM_VI,
+	HW_VAR_AC_PARAM_BE,
+	HW_VAR_AC_PARAM_BK,
+	HW_VAR_ACM_CTRL,
+	HW_VAR_AMPDU_MIN_SPACE,
+	HW_VAR_AMPDU_FACTOR,
+	HW_VAR_RXDMA_AGG_PG_TH,
+	HW_VAR_SET_RPWM,
+	HW_VAR_H2C_FW_PWRMODE,
+	HW_VAR_H2C_FW_JOINBSSRPT,
+	HW_VAR_FWLPS_RF_ON,
+	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+	HW_VAR_TDLS_WRCR,
+	HW_VAR_TDLS_INIT_CH_SEN,
+	HW_VAR_TDLS_RS_RCR,
+	HW_VAR_TDLS_DONE_CH_SEN,
+	HW_VAR_INITIAL_GAIN,
+	HW_VAR_TRIGGER_GPIO_0,
+	HW_VAR_BT_SET_COEXIST,
+	HW_VAR_BT_ISSUE_DELBA,
+	HW_VAR_CURRENT_ANTENNA,
+	HW_VAR_ANTENNA_DIVERSITY_LINK,
+	HW_VAR_ANTENNA_DIVERSITY_SELECT,
+	HW_VAR_SWITCH_EPHY_WoWLAN,
+	HW_VAR_EFUSE_BYTES,
+	HW_VAR_FIFO_CLEARN_UP,
+	HW_VAR_CHECK_TXBUF,
+	HW_VAR_APFM_ON_MAC, /* Auto FSM to Turn On, include clock, isolation, power control for MAC only */
+	HW_VAR_WOWLAN,
+	HW_VAR_VID,
+	HW_VAR_PID,
+	HW_VAR_MBSSID_CAM_WRITE,
+	HW_VAR_MBSSID_CAM_CLEAR,
+	HW_VAR_RCR_MBSSID_EN,
+};
+
+enum HAL_DEF_VARIABLE {
+	HAL_DEF_UNDERCORATEDSMOOTHEDPWDB,
+	HAL_DEF_IS_SUPPORT_ANT_DIV,
+	HAL_DEF_CURRENT_ANTENNA,
+	HAL_DEF_DRVINFO_SZ,
+	HAL_DEF_MAX_RECVBUF_SZ,
+	HAL_DEF_RX_PACKET_OFFSET,
+	HAL_DEF_DBG_DUMP_RXPKT,/* for dbg */
+	HAL_DEF_DBG_DM_FUNC,/* for dbg */
+
+};
+
+enum HAL_INTF_PS_FUNC {
+	HAL_USB_SELECT_SUSPEND,
+	HAL_MAX_ID,
+};
+
+typedef s32 (*c2h_id_filter)(u8 id);
+
+struct hal_ops {
+	u32	(*hal_init)(struct rtw_adapter * adapter);
+	u32	(*hal_deinit)(struct rtw_adapter * adapter);
+
+	void	(*free_hal_data)(struct rtw_adapter * adapter);
+
+	u32	(*inirp_init)(struct rtw_adapter * adapter);
+	u32	(*inirp_deinit)(struct rtw_adapter * adapter);
+
+	s32	(*init_xmit_priv)(struct rtw_adapter * adapter);
+	void	(*free_xmit_priv)(struct rtw_adapter * adapter);
+
+	s32	(*init_recv_priv)(struct rtw_adapter * adapter);
+	void	(*free_recv_priv)(struct rtw_adapter * adapter);
+
+	void	(*InitSwLeds)(struct rtw_adapter * adapter);
+	void	(*DeInitSwLeds)(struct rtw_adapter * adapter);
+
+	void	(*dm_init)(struct rtw_adapter * adapter);
+	void	(*dm_deinit)(struct rtw_adapter * adapter);
+	void	(*read_chip_version)(struct rtw_adapter * adapter);
+
+	void	(*init_default_value)(struct rtw_adapter * adapter);
+
+	void	(*intf_chip_configure)(struct rtw_adapter * adapter);
+
+	void	(*read_adapter_info)(struct rtw_adapter * adapter);
+
+	void	(*enable_interrupt)(struct rtw_adapter * adapter);
+	void	(*disable_interrupt)(struct rtw_adapter * adapter);
+	s32	(*interrupt_handler)(struct rtw_adapter * adapter);
+
+	void	(*set_bwmode_handler)(struct rtw_adapter * adapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset);
+	void	(*set_channel_handler)(struct rtw_adapter * adapter, u8 channel);
+
+	void	(*hal_dm_watchdog)(struct rtw_adapter * adapter);
+
+	void	(*SetHwRegHandler)(struct rtw_adapter * adapter, u8	variable,u8* val);
+	void	(*GetHwRegHandler)(struct rtw_adapter * adapter, u8	variable,u8* val);
+
+	u8	(*GetHalDefVarHandler)(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
+	u8	(*SetHalDefVarHandler)(struct rtw_adapter * adapter, enum HAL_DEF_VARIABLE eVariable, void * pValue);
+
+	void	(*UpdateRAMaskHandler)(struct rtw_adapter * adapter, u32 mac_id);
+	void	(*SetBeaconRelatedRegistersHandler)(struct rtw_adapter * adapter);
+
+	void	(*Add_RateATid)(struct rtw_adapter * adapter, u32 bitmap, u8 arg);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+	u8	(*AntDivBeforeLinkHandler)(struct rtw_adapter * adapter);
+	void	(*AntDivCompareHandler)(struct rtw_adapter * adapter, struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src);
+#endif
+	u8	(*interface_ps_func)(struct rtw_adapter * adapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val);
+
+	s32	(*hal_xmit)(struct rtw_adapter * adapter, struct xmit_frame *pxmitframe);
+	s32	(*mgnt_xmit)(struct rtw_adapter * adapter, struct xmit_frame *pmgntframe);
+
+	u32	(*read_bbreg)(struct rtw_adapter * adapter, u32 RegAddr, u32 BitMask);
+	void	(*write_bbreg)(struct rtw_adapter * adapter, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*read_rfreg)(struct rtw_adapter * adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*write_rfreg)(struct rtw_adapter * adapter, enum RF_RADIO_PATH_E eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+#ifdef CONFIG_HOSTAPD_MLME
+	s32	(*hostap_mgnt_xmit_entry)(struct rtw_adapter * adapter, struct sk_buff *pkt);
+#endif
+	void (*EfusePowerSwitch)(struct rtw_adapter * adapter, u8 bWrite, u8 PwrState);
+	void (*ReadEFuse)(struct rtw_adapter * adapter, u8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf, bool bPseudoTest);
+	void (*EFUSEGetEfuseDefinition)(struct rtw_adapter * adapter, u8 efuseType, u8 type, void * *pOut, bool bPseudoTest);
+	u16	(*EfuseGetCurrentSize)(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
+	int	(*Efuse_PgPacketRead)(struct rtw_adapter * adapter, u8 offset, u8 *data, bool bPseudoTest);
+	int	(*Efuse_PgPacketWrite)(struct rtw_adapter * adapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+	u8	(*Efuse_WordEnableDataWrite)(struct rtw_adapter * adapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	void (*sreset_init_value)(struct rtw_adapter *padapter);
+	void (*sreset_reset_value)(struct rtw_adapter *padapter);
+	void (*silentreset)(struct rtw_adapter *padapter);
+	void (*sreset_xmit_status_check)(struct rtw_adapter *padapter);
+	void (*sreset_linked_status_check) (struct rtw_adapter *padapter);
+	u8 (*sreset_get_wifi_status)(struct rtw_adapter *padapter);
+#endif
+
+	void (*hal_notch_filter)(struct rtw_adapter *adapter, bool enable);
+	void (*hal_reset_security_engine)(struct rtw_adapter *adapter);
+
+	s32 (*c2h_handler)(struct rtw_adapter *padapter, struct c2h_evt_hdr *c2h_evt);
+	c2h_id_filter c2h_id_filter_ccx;
+};
+
+enum RT_EEPROM_TYPE {
+	EEPROM_93C46,
+	EEPROM_93C56,
+	EEPROM_BOOT_EFUSE,
+};
+
+#define USB_HIGH_SPEED_BULK_SIZE	512
+#define USB_FULL_SPEED_BULK_SIZE	64
+
+#define RF_CHANGE_BY_INIT	0
+#define RF_CHANGE_BY_IPS	BIT28
+#define RF_CHANGE_BY_PS		BIT29
+#define RF_CHANGE_BY_HW		BIT30
+#define RF_CHANGE_BY_SW		BIT31
+
+enum HARDWARE_TYPE {
+	HARDWARE_TYPE_RTL8180,
+	HARDWARE_TYPE_RTL8185,
+	HARDWARE_TYPE_RTL8187,
+	HARDWARE_TYPE_RTL8188,
+	HARDWARE_TYPE_RTL8190P,
+	HARDWARE_TYPE_RTL8192E,
+	HARDWARE_TYPE_RTL819xU,
+	HARDWARE_TYPE_RTL8192SE,
+	HARDWARE_TYPE_RTL8192SU,
+	HARDWARE_TYPE_RTL8192CE,
+	HARDWARE_TYPE_RTL8192CU,
+	HARDWARE_TYPE_RTL8192DE,
+	HARDWARE_TYPE_RTL8192DU,
+	HARDWARE_TYPE_RTL8723AE,
+	HARDWARE_TYPE_RTL8723AU,
+	HARDWARE_TYPE_RTL8723AS,
+	HARDWARE_TYPE_RTL8188EE,
+	HARDWARE_TYPE_RTL8188EU,
+	HARDWARE_TYPE_RTL8188ES,
+	HARDWARE_TYPE_MAX,
+};
+
+/*  */
+/*  RTL8192D Series */
+/*  */
+#define IS_HARDWARE_TYPE_8192DE(_adapter)			\
+		(((struct rtw_adapter *)_adapter)->HardwareType==HARDWARE_TYPE_RTL8192DE)
+#define IS_HARDWARE_TYPE_8192DU(_adapter)			\
+		(((struct rtw_adapter *)_adapter)->HardwareType==HARDWARE_TYPE_RTL8192DU)
+#define	IS_HARDWARE_TYPE_8192D(_adapter)			\
+		(IS_HARDWARE_TYPE_8192DE(_adapter) ||		\
+		 IS_HARDWARE_TYPE_8192DU(_adapter))
+
+#define GET_EEPROM_EFUSE_PRIV(priv)	(&priv->eeprompriv)
+
+#ifdef CONFIG_WOWLAN
+enum wowlan_subcode {
+	WOWLAN_PATTERN_MATCH = 1,
+	WOWLAN_MAGIC_PACKET  = 2,
+	WOWLAN_UNICAST       = 3,
+	WOWLAN_SET_PATTERN   = 4,
+	WOWLAN_DUMP_REG      = 5,
+	WOWLAN_ENABLE        = 6,
+	WOWLAN_DISABLE       = 7,
+	WOWLAN_STATUS		= 8,
+	WOWLAN_DEBUG_RELOAD_FW	= 9,
+	WOWLAN_DEBUG_1		=10,
+	WOWLAN_DEBUG_2		=11
+};
+
+struct wowlan_ioctl_param{
+	unsigned int subcode;
+	unsigned int subcode_value;
+	unsigned int wakeup_reason;
+	unsigned int len;
+	unsigned char pattern[0];
+};
+
+#define Rx_Pairwisekey				BIT(0)
+#define Rx_GTK					BIT(1)
+#define Rx_DisAssoc				BIT(2)
+#define Rx_DeAuth				BIT(3)
+#define FWDecisionDisconnect			BIT(4)
+#define Rx_MagicPkt				BIT(5)
+#define FinishBtFwPatch				BIT(7)
+
+#endif /*  CONFIG_WOWLAN */
+
+void rtw_hal_def_value_init(struct rtw_adapter *padapter);
+void rtw_hal_free_data(struct rtw_adapter *padapter);
+
+void rtw_hal_dm_init(struct rtw_adapter *padapter);
+void rtw_hal_dm_deinit(struct rtw_adapter *padapter);
+void rtw_hal_sw_led_init(struct rtw_adapter *padapter);
+void rtw_hal_sw_led_deinit(struct rtw_adapter *padapter);
+
+uint rtw_hal_init(struct rtw_adapter *padapter);
+uint rtw_hal_deinit(struct rtw_adapter *padapter);
+void rtw_hal_stop(struct rtw_adapter *padapter);
+
+void rtw_hal_set_hwreg(struct rtw_adapter * padapter, u8 variable, u8 *val);
+void rtw_hal_get_hwreg(struct rtw_adapter * padapter, u8 variable, u8 *val);
+
+void rtw_hal_chip_configure(struct rtw_adapter *padapter);
+void rtw_hal_read_chip_info(struct rtw_adapter *padapter);
+void rtw_hal_read_chip_version(struct rtw_adapter *padapter);
+
+u8 rtw_hal_set_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable,
+		       void *pValue);
+u8 rtw_hal_get_def_var(struct rtw_adapter *padapter, enum HAL_DEF_VARIABLE eVariable,
+		       void *pValue);
+
+void rtw_hal_enable_interrupt(struct rtw_adapter *padapter);
+void rtw_hal_disable_interrupt(struct rtw_adapter *padapter);
+
+u32 rtw_hal_inirp_init(struct rtw_adapter *padapter);
+u32 rtw_hal_inirp_deinit(struct rtw_adapter *padapter);
+
+u8 rtw_hal_intf_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id, u8* val);
+
+s32 rtw_hal_xmit(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtw_hal_mgnt_xmit(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe);
+
+s32 rtw_hal_init_xmit_priv(struct rtw_adapter *padapter);
+void rtw_hal_free_xmit_priv(struct rtw_adapter *padapter);
+
+s32 rtw_hal_init_recv_priv(struct rtw_adapter *padapter);
+void rtw_hal_free_recv_priv(struct rtw_adapter *padapter);
+
+void rtw_hal_update_ra_mask(struct rtw_adapter *padapter, u32 mac_id);
+void rtw_hal_add_ra_tid(struct rtw_adapter *padapter, u32 bitmap, u8 arg);
+
+void rtw_hal_bcn_related_reg_setting(struct rtw_adapter *padapter);
+
+u32 rtw_hal_read_bbreg(struct rtw_adapter *padapter, u32 RegAddr, u32 BitMask);
+void rtw_hal_write_bbreg(struct rtw_adapter *padapter, u32 RegAddr, u32 BitMask, u32 Data);
+u32 rtw_hal_read_rfreg(struct rtw_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask);
+void rtw_hal_write_rfreg(struct rtw_adapter *padapter, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+s32 rtw_hal_interrupt_handler(struct rtw_adapter *padapter);
+
+void rtw_hal_set_bwmode(struct rtw_adapter *padapter, enum HT_CHANNEL_WIDTH Bandwidth, u8 Offset);
+void rtw_hal_set_chan(struct rtw_adapter *padapter, u8 channel);
+
+void rtw_hal_dm_watchdog(struct rtw_adapter *padapter);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+u8 rtw_hal_antdiv_before_linked(struct rtw_adapter *padapter);
+void rtw_hal_antdiv_rssi_compared(struct rtw_adapter *padapter, struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src);
+#endif
+
+#ifdef CONFIG_HOSTAPD_MLME
+s32 rtw_hal_hostap_mgnt_xmit_entry(struct rtw_adapter *padapter, struct sk_buff *pkt);
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+void rtw_hal_sreset_init(struct rtw_adapter *padapter);
+void rtw_hal_sreset_reset(struct rtw_adapter *padapter);
+void rtw_hal_sreset_reset_value(struct rtw_adapter *padapter);
+void rtw_hal_sreset_xmit_status_check(struct rtw_adapter *padapter);
+void rtw_hal_sreset_linked_status_check(struct rtw_adapter *padapter);
+u8 rtw_hal_sreset_get_wifi_status(struct rtw_adapter *padapter);
+#endif
+
+void rtw_hal_notch_filter(struct rtw_adapter *adapter, bool enable);
+void rtw_hal_reset_security_engine(struct rtw_adapter *adapter);
+
+s32 rtw_hal_c2h_handler(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt);
+c2h_id_filter rtw_hal_c2h_id_filter_ccx(struct rtw_adapter *adapter);
+
+#endif /* __HAL_INTF_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/ieee80211.h b/drivers/net/wireless/rtl8192du/include/ieee80211.h
new file mode 100644
index 0000000..dd5d04e
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/ieee80211.h
@@ -0,0 +1,1232 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include "wifi.h"
+
+#include <linux/wireless.h>
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+#define ETH_TYPE_LEN		2
+#define PAYLOAD_TYPE_LEN	1
+
+#ifdef CONFIG_92D_AP_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON=16,
+	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
+	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
+	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
+	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
+	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
+	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
+	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE		BIT(0)
+#define WPA_CIPHER_WEP40	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP		BIT(3)
+#define WPA_CIPHER_CCMP		BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+extern u8 RTW_WPA_OUI_TYPE[] ;
+extern u16 RTW_WPA_VERSION ;
+extern u8 WPA_AUTH_KEY_MGMT_NONE[];
+extern u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 WPA_CIPHER_SUITE_NONE[];
+extern u8 WPA_CIPHER_SUITE_WEP40[];
+extern u8 WPA_CIPHER_SUITE_TKIP[];
+extern u8 WPA_CIPHER_SUITE_WRAP[];
+extern u8 WPA_CIPHER_SUITE_CCMP[];
+extern u8 WPA_CIPHER_SUITE_WEP104[];
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+
+extern u16 RSN_VERSION_BSD;
+extern u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern u8 RSN_CIPHER_SUITE_NONE[];
+extern u8 RSN_CIPHER_SUITE_WEP40[];
+extern u8 RSN_CIPHER_SUITE_TKIP[];
+extern u8 RSN_CIPHER_SUITE_WRAP[];
+extern u8 RSN_CIPHER_SUITE_CCMP[];
+extern u8 RSN_CIPHER_SUITE_WEP104[];
+
+enum RATR_TABLE_MODE {
+	RATR_INX_WIRELESS_NGB = 0,	/*  BGN 40 Mhz 2SS 1SS */
+	RATR_INX_WIRELESS_NG = 1,		/*  GN or N */
+	RATR_INX_WIRELESS_NB = 2,		/*  BGN 20 Mhz 2SS 1SS  or BN */
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_AC_N = 8,
+};
+
+enum NETWORK_TYPE
+{
+    WIRELESS_INVALID = 0,
+    /* Sub-Element */
+    WIRELESS_11B = BIT(0), /*  tx: cck only , rx: cck only, hw: cck */
+    WIRELESS_11G = BIT(1), /*  tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm */
+    WIRELESS_11A = BIT(2), /*  tx: ofdm only, rx: ofdm only, hw: ofdm only */
+    WIRELESS_11_24N = BIT(3), /*  tx: MCS only, rx: MCS & cck, hw: MCS & cck */
+    WIRELESS_11_5N = BIT(4), /*  tx: MCS only, rx: MCS & ofdm, hw: ofdm only */
+	/* WIRELESS_AUTO		= BIT(5), */
+	WIRELESS_AC		= BIT(6),
+
+    /* Combination */
+    WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), /*  tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm */
+    WIRELESS_11G_24N = (WIRELESS_11G|WIRELESS_11_24N), /*  tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm */
+    WIRELESS_11A_5N = (WIRELESS_11A|WIRELESS_11_5N), /*  tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
+    WIRELESS_11BG_24N = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N), /*  tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck */
+    WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), /*  tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only */
+    WIRELESS_11ABGN = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N),
+};
+
+#define SUPPORTED_24G_NETTYPE_MSK (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N)
+#define SUPPORTED_5G_NETTYPE_MSK (WIRELESS_11A | WIRELESS_11_5N)
+
+#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? true : false)
+#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? true : false)
+
+#define IsEnableHWCCK(NetType) IsSupported24G(NetType)
+#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? true : false)
+
+#define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
+#define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
+#define IsSupportedRxMCS(NetType) IsEnableHWOFDM(NetType)
+
+#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? true : false)
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? true : false)
+#define IsSupportedTxMCS(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? true : false)
+
+
+struct ieee_param {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	union {
+		struct {
+			u8 name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			u8 reserved[32];
+			u8 data[0];
+		} wpa_ie;
+	        struct{
+			int command;
+			int reason_code;
+		} mlme;
+		struct {
+			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
+			u8 set_tx;
+			u32 err;
+			u8 idx;
+			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			u8 key[0];
+		} crypt;
+#ifdef CONFIG_92D_AP_MODE
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			u8 tx_supp_rates[16];
+			struct rtw_ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			u8	reserved[2];/* for set max_num_sta */
+			u8	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;
+};
+
+#ifdef CONFIG_92D_AP_MODE
+struct ieee_param_ex {
+	u32 cmd;
+	u8 sta_addr[ETH_ALEN];
+	u8 data[0];
+};
+
+struct sta_data{
+	u16 aid;
+	u16 capability;
+	int flags;
+	u32 sta_set;
+	u8 tx_supp_rates[16];
+	u32 tx_supp_rates_len;
+	struct rtw_ieee80211_ht_cap ht_cap;
+	u64	rx_pkts;
+	u64	rx_bytes;
+	u64	rx_drops;
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64	tx_drops;
+};
+#endif
+
+
+#if WIRELESS_EXT < 17
+#define IW_QUAL_QUAL_INVALID   0x10
+#define IW_QUAL_LEVEL_INVALID  0x20
+#define IW_QUAL_NOISE_INVALID  0x40
+#define IW_QUAL_QUAL_UPDATED   0x1
+#define IW_QUAL_LEVEL_UPDATED  0x2
+#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	u8 mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	struct list_head list;
+};
+
+struct rtw_ieee80211_hdr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+} __attribute__ ((packed));
+
+
+struct rtw_ieee80211_hdr_qos {
+	__le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+	__le16	qc;
+}  __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr_qos {
+        __le16 frame_ctl;
+	__le16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	__le16 seq_ctl;
+	__le16     qc;
+}  __attribute__ ((packed));
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __attribute__ ((packed));
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0003
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS	0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_PROTECTED	0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+#define RTW_IEEE80211_FCTL_CTL_EXT	0x0f00
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+#define RTW_IEEE80211_FTYPE_EXT		0x000c
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+#define RTW_IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define RTW_IEEE80211_STYPE_CTL_EXT		0x0060
+#define RTW_IEEE80211_STYPE_BACK_REQ		0x0080
+#define RTW_IEEE80211_STYPE_BACK		0x0090
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK		0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_STYPE_QOS_DATA		0x0080
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
+#define RTW_IEEE80211_STYPE_QOS_NULLFUNC	0x00C0
+#define RTW_IEEE80211_STYPE_QOS_CFACK		0x00D0
+#define RTW_IEEE80211_STYPE_QOS_CFPOLL		0x00E0
+#define RTW_IEEE80211_STYPE_QOS_CFACKPOLL	0x00F0
+
+/* sequence control field */
+#define RTW_IEEE80211_SCTL_FRAG	0x000F
+#define RTW_IEEE80211_SCTL_SEQ	0xFFF0
+
+
+#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
+#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+struct ieee80211_snap_hdr {
+
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__ ((packed));
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
+#define WLAN_REASON_EXPIRATION_CHK 65535
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+/* EIDs defined by IEEE 802.11h - START */
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUITE 40
+#define WLAN_EID_IBSS_DFS 41
+/* EIDs defined by IEEE 802.11h - END */
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN			4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN			8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+        IEEE80211_CCK_RATE_5MB_MASK | \
+        IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+	IEEE80211_OFDM_RATE_9MB_MASK  | \
+	IEEE80211_OFDM_RATE_18MB_MASK | \
+	IEEE80211_OFDM_RATE_36MB_MASK | \
+	IEEE80211_OFDM_RATE_48MB_MASK | \
+	IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 received_channel;
+	u16 rate; /* in 100 kbps */
+	u8 mask;
+	u8 freq;
+	u16 len;
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	u32 first_frag_time;
+	uint seq;
+	uint last_frag;
+	uint qos;   /* jackson */
+	uint tid;	/* jackson */
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	uint tx_unicast_frames;
+	uint tx_multicast_frames;
+	uint tx_fragments;
+	uint tx_unicast_octets;
+	uint tx_multicast_octets;
+	uint tx_deferred_transmissions;
+	uint tx_single_retry_frames;
+	uint tx_multiple_retry_frames;
+	uint tx_retry_limit_exceeded;
+	uint tx_discards;
+	uint rx_unicast_frames;
+	uint rx_multicast_frames;
+	uint rx_fragments;
+	uint rx_unicast_octets;
+	uint rx_multicast_octets;
+	uint rx_fcs_errors;
+	uint rx_discards_no_buffer;
+	uint tx_discards_wrong_sa;
+	uint rx_discards_undecryptable;
+	uint rx_message_in_msg_fragments;
+	uint rx_message_in_bad_msg_fragments;
+};
+
+struct ieee80211_softmac_stats{
+	uint rx_ass_ok;
+	uint rx_ass_err;
+	uint rx_probe_rq;
+	uint tx_probe_rs;
+	uint tx_beacons;
+	uint rx_auth_rq;
+	uint rx_auth_rs_ok;
+	uint rx_auth_rs_err;
+	uint tx_auth_rq;
+	uint no_auth_rs;
+	uint no_ass_rs;
+	uint tx_ass_rq;
+	uint rx_ass_rq;
+	uint tx_probe_rq;
+	uint reassoc;
+	uint swtxstop;
+	uint swtxawake;
+};
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	u8 key_sizes[WEP_KEYS];
+	u8 keys[WEP_KEYS][WEP_KEY_LEN];
+	u8 level;
+	u16 flags;
+} __attribute__ ((packed));
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+struct ieee80211_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ieee80211_info_element {
+	u8 id;
+	u8 len;
+	u8 data[0];
+} __attribute__ ((packed));
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+struct ieee80211_authentication {
+	struct ieee80211_header_data header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+} __attribute__ ((packed));
+
+struct ieee80211_probe_response {
+	struct ieee80211_header_data header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ieee80211_info_element info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_probe_request {
+	struct ieee80211_header_data header;
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_request_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 listen_interval;
+	struct ieee80211_info_element_hdr info_element;
+} __attribute__ ((packed));
+
+struct ieee80211_assoc_response_frame {
+	struct rtw_ieee80211_hdr_3addr header;
+	u16 capability;
+	u16 status;
+	u16 aid;
+} __attribute__ ((packed));
+
+struct ieee80211_txb {
+	u8 nr_frags;
+	u8 encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+/* HZ / 2) */
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN (256)
+#define MAX_WPS_IE_LEN (512)
+#define MAX_P2P_IE_LEN (256)
+#define MAX_WFD_IE_LEN (128)
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+enum ieee80211_state {
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+
+static __inline int is_multicast_mac_addr(const u8 *addr)
+{
+        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+static __inline int is_broadcast_mac_addr(const u8 *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+/* Baron move to ieee80211.c */
+int ieee80211_is_empty_essid(const char *essid, int essid_len);
+int ieee80211_get_hdrlen(u16 fc);
+
+/* Action category code */
+enum rtw_ieee80211_category {
+	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	RTW_WLAN_CATEGORY_QOS = 1,
+	RTW_WLAN_CATEGORY_DLS = 2,
+	RTW_WLAN_CATEGORY_BACK = 3,
+	RTW_WLAN_CATEGORY_PUBLIC = 4, /* IEEE 802.11 public action frames */
+	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	RTW_WLAN_CATEGORY_FT = 6,
+	RTW_WLAN_CATEGORY_HT = 7,
+	RTW_WLAN_CATEGORY_SA_QUERY = 8,
+	RTW_WLAN_CATEGORY_TDLS = 12,
+	RTW_WLAN_CATEGORY_WMM = 17,
+	RTW_WLAN_CATEGORY_P2P = 0x7f,/* P2P action frames */
+};
+
+/* SPECTRUM_MGMT action code */
+enum rtw_ieee80211_spectrum_mgmt_actioncode {
+	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
+	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
+	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION{
+	ACT_PUBLIC_BSSCOEXIST = 0, /*  20/40 BSS Coexistence */
+	ACT_PUBLIC_DSE_ENABLE = 1,
+	ACT_PUBLIC_DSE_DEENABLE = 2,
+	ACT_PUBLIC_DSE_REG_LOCATION = 3,
+	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
+	ACT_PUBLIC_DSE_MSR_REQ = 5,
+	ACT_PUBLIC_DSE_MSR_RPRT = 6,
+	ACT_PUBLIC_MP = 7, /*  Measurement Pilot */
+	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
+	ACT_PUBLIC_VENDOR = 9, /*  for WIFI_DIRECT */
+	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
+	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
+	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
+	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
+	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
+	ACT_PUBLIC_LOCATION_TRACK = 15,
+	ACT_PUBLIC_MAX
+};
+
+/* BACK action code */
+enum rtw_ieee80211_back_actioncode {
+	RTW_WLAN_ACTION_ADDBA_REQ = 0,
+	RTW_WLAN_ACTION_ADDBA_RESP = 1,
+	RTW_WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum rtw_ieee80211_ht_actioncode {
+	RTW_WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       RTW_WLAN_ACTION_SM_PS = 1,
+       RTW_WLAN_ACTION_PSPM = 2,
+       RTW_WLAN_ACTION_PCO_PHASE = 3,
+       RTW_WLAN_ACTION_MIMO_CSI_MX = 4,
+       RTW_WLAN_ACTION_MIMO_NONCP_BF = 5,
+       RTW_WLAN_ACTION_MIMP_CP_BF = 6,
+       RTW_WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       RTW_WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum rtw_ieee80211_back_parties {
+	RTW_WLAN_BACK_RECIPIENT = 0,
+	RTW_WLAN_BACK_INITIATOR = 1,
+	RTW_WLAN_BACK_TIMER = 2,
+};
+
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#define WME_OUI_TYPE 2
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WME_VERSION 1
+
+#define WME_ACTION_CODE_SETUP_REQUEST 0
+#define WME_ACTION_CODE_SETUP_RESPONSE 1
+#define WME_ACTION_CODE_TEARDOWN 2
+
+#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
+#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
+#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
+
+#define WME_TSPEC_DIRECTION_UPLINK 0
+#define WME_TSPEC_DIRECTION_DOWNLINK 1
+#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+
+
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+/**
+ * enum rtw_ieee80211_channel_flags - channel flags
+ *
+ * Channel flags set by the regulatory control code.
+ *
+ * @RTW_IEEE80211_CHAN_DISABLED: This channel is disabled.
+ * @RTW_IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
+ *      on this channel.
+ * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
+ * @RTW_IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
+ * @RTW_IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
+ *      is not permitted.
+ * @RTW_IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
+ *      is not permitted.
+ */
+  enum rtw_ieee80211_channel_flags {
+          RTW_IEEE80211_CHAN_DISABLED         = 1<<0,
+          RTW_IEEE80211_CHAN_PASSIVE_SCAN     = 1<<1,
+          RTW_IEEE80211_CHAN_NO_IBSS          = 1<<2,
+          RTW_IEEE80211_CHAN_RADAR            = 1<<3,
+          RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1<<4,
+          RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1<<5,
+  };
+
+  #define RTW_IEEE80211_CHAN_NO_HT40 \
+          (RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)
+
+/* Represent channel details, subset of ieee80211_channel */
+struct rtw_ieee80211_channel {
+	u16 hw_value;
+	u32 flags;
+};
+
+#define CHAN_FMT \
+	"hw_value:%u, " \
+	"flags:0x%08x" \
+
+#define CHAN_ARG(channel) \
+	(channel)->hw_value \
+	, (channel)->flags \
+
+/* Parsed Information Elements */
+struct rtw_ieee802_11_elems {
+	u8 *ssid;
+	u8 ssid_len;
+	u8 *supp_rates;
+	u8 supp_rates_len;
+	u8 *fh_params;
+	u8 fh_params_len;
+	u8 *ds_params;
+	u8 ds_params_len;
+	u8 *cf_params;
+	u8 cf_params_len;
+	u8 *tim;
+	u8 tim_len;
+	u8 *ibss_params;
+	u8 ibss_params_len;
+	u8 *challenge;
+	u8 challenge_len;
+	u8 *erp_info;
+	u8 erp_info_len;
+	u8 *ext_supp_rates;
+	u8 ext_supp_rates_len;
+	u8 *wpa_ie;
+	u8 wpa_ie_len;
+	u8 *rsn_ie;
+	u8 rsn_ie_len;
+	u8 *wme;
+	u8 wme_len;
+	u8 *wme_tspec;
+	u8 wme_tspec_len;
+	u8 *wps_ie;
+	u8 wps_ie_len;
+	u8 *power_cap;
+	u8 power_cap_len;
+	u8 *supp_channels;
+	u8 supp_channels_len;
+	u8 *mdie;
+	u8 mdie_len;
+	u8 *ftie;
+	u8 ftie_len;
+	u8 *timeout_int;
+	u8 timeout_int_len;
+	u8 *ht_capabilities;
+	u8 ht_capabilities_len;
+	u8 *ht_operation;
+	u8 ht_operation_len;
+	u8 *vendor_ht_cap;
+	u8 vendor_ht_cap_len;
+};
+
+enum parse_res {
+	PARSE_OK = 0,
+	PARSE_UNK = 1,
+	PARSE_FAIL = -1
+};
+
+enum parse_res rtw_ieee802_11_parse_elems(u8 *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors);
+
+u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+u8 *rtw_set_ie(u8 *pbuf, int index, uint len, u8 *source, uint *frlen);
+
+enum secondary_ch_offset {
+	SCN = 0, /* no secondary channel */
+	SCA = 1, /* secondary channel above */
+	SCB = 3,  /* secondary channel below */
+};
+u8 secondary_ch_offset_to_hal_ch_offset(u8 ch_offset);
+u8 hal_ch_offset_to_secondary_ch_offset(u8 ch_offset);
+u8 *rtw_set_ie_ch_switch (u8 *buf, u32 *buf_len, u8 ch_switch_mode, u8 new_ch, u8 ch_switch_cnt);
+u8 *rtw_set_ie_secondary_ch_offset(u8 *buf, u32 *buf_len, u8 secondary_ch_offset);
+u8 *rtw_set_ie_mesh_ch_switch_parm(u8 *buf, u32 *buf_len, u8 ttl, u8 flags, u16 reason, u16 precedence);
+
+u8 *rtw_get_ie(u8*pbuf, int index, int *len, int limit);
+u8 *rtw_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
+int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len);
+
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) ;
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int rtw_get_wpa_cipher_suite(u8 *s);
+int rtw_get_wpa2_cipher_suite(u8 *s);
+int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+int rtw_parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher);
+
+int rtw_get_sec_ie(u8 *in_ie,uint in_len,u8 *rsn_ie,u16 *rsn_len,u8 *wpa_ie,u16 *wpa_len);
+
+u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
+u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
+u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_attr, u32 *len_attr);
+u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id ,u8 *buf_content, uint *len_content);
+
+/**
+ * for_each_ie - iterate over continuous IEs
+ * @ie:
+ * @buf:
+ * @buf_len:
+ */
+#define for_each_ie(ie, buf, buf_len) \
+	for (ie = (void*)buf; (((u8*)ie) - ((u8*)buf) + 1) < buf_len; ie = (void*)(((u8*)ie) + *(((u8*)ie)+1) + 2))
+
+void dump_ies(u8 *buf, u32 buf_len);
+void dump_wps_ie(u8 *ie, u32 ie_len);
+
+uint	rtw_get_rateset_len(u8	*rateset);
+
+struct registry_priv;
+int rtw_generate_ie(struct registry_priv *pregistrypriv);
+
+
+int rtw_get_bit_value_from_ieee_value(u8 val);
+
+uint	rtw_is_cckrates_included(u8 *rate);
+
+uint	rtw_is_cckratesonly_included(u8 *rate);
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
+
+void rtw_macaddr_cfg(u8 *mac_addr);
+
+u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI_20, u8 short_GI_40, unsigned char * MCS_rate);
+
+int rtw_action_frame_parse(const u8 *frame, u32 frame_len, u8* category, u8 *action);
+const char *action_public_str(u8 action);
+
+#endif /* IEEE80211_H */
diff --git a/drivers/net/wireless/rtl8192du/include/ieee80211_ext.h b/drivers/net/wireless/rtl8192du/include/ieee80211_ext.h
new file mode 100644
index 0000000..baa93f1
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/ieee80211_ext.h
@@ -0,0 +1,286 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+#define PMKID_LEN 16
+
+struct wpa_ie_hdr {
+	u8 elem_id;
+	u8 len;
+	u8 oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct wme_ac_parameter {
+#if defined(__LITTLE_ENDIAN)
+	/* byte 1 */
+	u8	aifsn:4,
+		acm:1,
+		aci:2,
+		reserved:1;
+
+	/* byte 2 */
+	u8	eCWmin:4,
+		eCWmax:4;
+#elif defined(__BIG_ENDIAN)
+	/* byte 1 */
+	u8	reserved:1,
+		aci:2,
+		acm:1,
+		aifsn:4;
+
+	/* byte 2 */
+	u8	eCWmax:4,
+		eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__ ((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	u8 oui[3];
+	u8 oui_type;
+	u8 oui_subtype;
+	u8 version;
+	u8 acInfo;
+	u8 reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__ ((packed));
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((u8 *) (a), (val))
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	u8 da[6];
+	u8 sa[6];
+	u8 bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			u8 variable[0];
+		}  __attribute__ ((packed)) auth;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			u8 current_ap[6];
+			/* followed by SSID and Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) reassoc_req;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			u8 variable[0];
+		}  __attribute__ ((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			u8 variable[0];
+		}  __attribute__ ((packed)) probe_resp;
+		struct {
+			u8 category;
+			union {
+				struct {
+					u8 action_code;
+					u8 dialog_token;
+					u8 status_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) wme_action;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  __attribute__ ((packed)) addba_req;
+				struct{
+					u8 action_code;
+					u8 dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  __attribute__ ((packed)) addba_resp;
+				struct{
+					u8 action_code;
+					u16 params;
+					u16 reason_code;
+				}  __attribute__ ((packed)) delba;
+				struct{
+					u8 action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					u8 variable[0];
+				}  __attribute__ ((packed)) plink_action;
+				struct{
+					u8 action_code;
+					u8 variable[0];
+				}  __attribute__ ((packed)) mesh_action;
+			} __attribute__ ((packed)) u;
+		}  __attribute__ ((packed)) action;
+	} __attribute__ ((packed)) u;
+}__attribute__ ((packed));
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/ioctl_cfg80211.h b/drivers/net/wireless/rtl8192du/include/ioctl_cfg80211.h
new file mode 100644
index 0000000..4eba12e
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/ioctl_cfg80211.h
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __IOCTL_CFG80211_H__
+#define __IOCTL_CFG80211_H__
+
+struct rtw_wdev_invit_info {
+	u8 token;
+	u8 flags;
+	u8 status;
+	u8 req_op_ch;
+	u8 rsp_op_ch;
+};
+
+#define rtw_wdev_invit_info_init(invit_info) \
+	do { \
+		(invit_info)->token = 0; \
+		(invit_info)->flags = 0x00; \
+		(invit_info)->status = 0xff; \
+		(invit_info)->req_op_ch = 0; \
+		(invit_info)->rsp_op_ch = 0; \
+	} while (0)
+
+
+struct rtw_wdev_priv
+{
+	struct wireless_dev *rtw_wdev;
+
+	struct rtw_adapter *padapter;
+
+	struct cfg80211_scan_request *scan_request;
+	spinlock_t scan_req_lock;
+
+	struct net_device *pmon_ndev;/* for monitor interface */
+	char ifname_mon[IFNAMSIZ + 1]; /* interface name for monitor interface */
+
+	u8 p2p_enabled;
+
+	u8 provdisc_req_issued;
+
+	struct rtw_wdev_invit_info invit_info;
+
+	u8 bandroid_scan;
+	bool block;
+	bool power_mgmt;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	ATOMIC_T ro_ch_to;
+	ATOMIC_T switch_ch_to;
+#endif
+
+};
+
+#define wdev_to_priv(w) ((struct rtw_wdev_priv *)(wdev_priv(w)))
+
+#define wiphy_to_adapter(x) (struct rtw_adapter *)(((struct rtw_wdev_priv*)wiphy_priv(x))->padapter)
+
+#define wiphy_to_wdev(x) (struct wireless_dev *)(((struct rtw_wdev_priv*)wiphy_priv(x))->rtw_wdev)
+
+int rtw_wdev_alloc(struct rtw_adapter *padapter, struct device *dev);
+void rtw_wdev_free(struct wireless_dev *wdev);
+void rtw_wdev_unregister(struct wireless_dev *wdev);
+
+void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter);
+
+void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter);
+
+void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter);
+void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter);
+void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted);
+
+#ifdef CONFIG_92D_AP_MODE
+void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter, unsigned char *da, unsigned short reason);
+#endif /* CONFIG_92D_AP_MODE */
+
+void rtw_cfg80211_issue_p2p_provision_request(struct rtw_adapter *padapter, const u8 *buf, size_t len);
+void rtw_cfg80211_rx_p2p_action_public(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_rx_action_p2p(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len);
+void rtw_cfg80211_rx_action(struct rtw_adapter *adapter, u8 *frame, uint frame_len, const char*msg);
+
+int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len, int type);
+
+bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter *adapter);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->pnetdev, freq, sig_dbm, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0))
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0, gfp)
+#else // kernel >= 3.18
+#define rtw_cfg80211_rx_mgmt(adapter, freq, sig_dbm, buf, len, gfp) cfg80211_rx_mgmt((adapter)->rtw_wdev, freq, sig_dbm, buf, len, 0)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, buf, len)
+#else
+#define rtw_cfg80211_send_rx_assoc(adapter, bss, buf, len) cfg80211_send_rx_assoc((adapter)->pnetdev, bss, buf, len)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->pnetdev, cookie, buf, len, ack, gfp)
+#else
+#define rtw_cfg80211_mgmt_tx_status(adapter, cookie, buf, len, ack, gfp) cfg80211_mgmt_tx_status((adapter)->rtw_wdev, cookie, buf, len, ack, gfp)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0))
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->pnetdev, cookie, chan, channel_type, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->pnetdev, cookie, chan, chan_type, gfp)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0))
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, channel_type, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, chan_type, gfp)
+#else
+#define rtw_cfg80211_ready_on_channel(adapter, cookie, chan, channel_type, duration, gfp)  cfg80211_ready_on_channel((adapter)->rtw_wdev, cookie, chan, duration, gfp)
+#define rtw_cfg80211_remain_on_channel_expired(adapter, cookie, chan, chan_type, gfp) cfg80211_remain_on_channel_expired((adapter)->rtw_wdev, cookie, chan, gfp)
+#endif
+
+#endif /* __IOCTL_CFG80211_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/mlme_osdep.h b/drivers/net/wireless/rtl8192du/include/mlme_osdep.h
new file mode 100644
index 0000000..c60fdf2
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/mlme_osdep.h
@@ -0,0 +1,34 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+void rtw_init_mlme_timer(struct rtw_adapter *padapter);
+void rtw_os_indicate_disconnect(struct rtw_adapter *adapter);
+void rtw_os_indicate_connect(struct rtw_adapter *adapter);
+void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted);
+void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie);
+
+void rtw_reset_securitypriv(struct rtw_adapter *adapter);
+void indicate_wx_scan_complete_event(struct rtw_adapter *padapter);
+u8 rtw_do_join(struct rtw_adapter *padapter);
+
+
+#endif	/* _MLME_OSDEP_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/mp_custom_oid.h b/drivers/net/wireless/rtl8192du/include/mp_custom_oid.h
new file mode 100644
index 0000000..e0518a9
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/mp_custom_oid.h
@@ -0,0 +1,349 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef	__CUSTOM_OID_H
+#define __CUSTOM_OID_H
+
+/*  by Owen */
+/*  0xFF818000 - 0xFF81802F		RTL8180 Mass Production Kit */
+/*  0xFF818500 - 0xFF81850F		RTL8185 Setup Utility */
+/*  0xFF818580 - 0xFF81858F		RTL8185 Phy Status Utility */
+
+/*  */
+
+/*  by Owen for Production Kit */
+/*  For Production Kit with Agilent Equipments */
+/*  in order to make our custom oids hopefully somewhat unique */
+/*  we will use 0xFF (indicating implementation specific OID) */
+/*                81(first byte of non zero Realtek unique identifier) */
+/*                80 (second byte of non zero Realtek unique identifier) */
+/*                XX (the custom OID number - providing 255 possible custom oids) */
+
+#define OID_RT_PRO_RESET_DUT				0xFF818000
+#define OID_RT_PRO_SET_DATA_RATE			0xFF818001
+#define OID_RT_PRO_START_TEST				0xFF818002
+#define OID_RT_PRO_STOP_TEST				0xFF818003
+#define OID_RT_PRO_SET_PREAMBLE				0xFF818004
+#define OID_RT_PRO_SET_SCRAMBLER			0xFF818005
+#define OID_RT_PRO_SET_FILTER_BB			0xFF818006
+#define OID_RT_PRO_SET_MANUAL_DIVERSITY_BB		0xFF818007
+#define OID_RT_PRO_SET_CHANNEL_DIRECT_CALL		0xFF818008
+#define OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL		0xFF818009
+#define OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL		0xFF81800A
+
+#define OID_RT_PRO_SET_TX_ANTENNA_BB			0xFF81800D
+#define OID_RT_PRO_SET_ANTENNA_BB			0xFF81800E
+#define OID_RT_PRO_SET_CR_SCRAMBLER			0xFF81800F
+#define OID_RT_PRO_SET_CR_NEW_FILTER			0xFF818010
+#define OID_RT_PRO_SET_TX_POWER_CONTROL			0xFF818011
+#define OID_RT_PRO_SET_CR_TX_CONFIG			0xFF818012
+#define OID_RT_PRO_GET_TX_POWER_CONTROL			0xFF818013
+#define OID_RT_PRO_GET_CR_SIGNAL_QUALITY		0xFF818014
+#define OID_RT_PRO_SET_CR_SETPOINT			0xFF818015
+#define OID_RT_PRO_SET_INTEGRATOR			0xFF818016
+#define OID_RT_PRO_SET_SIGNAL_QUALITY			0xFF818017
+#define OID_RT_PRO_GET_INTEGRATOR			0xFF818018
+#define OID_RT_PRO_GET_SIGNAL_QUALITY			0xFF818019
+#define OID_RT_PRO_QUERY_EEPROM_TYPE			0xFF81801A
+#define OID_RT_PRO_WRITE_MAC_ADDRESS			0xFF81801B
+#define OID_RT_PRO_READ_MAC_ADDRESS			0xFF81801C
+#define OID_RT_PRO_WRITE_CIS_DATA			0xFF81801D
+#define OID_RT_PRO_READ_CIS_DATA			0xFF81801E
+#define OID_RT_PRO_WRITE_POWER_CONTROL			0xFF81801F
+#define OID_RT_PRO_READ_POWER_CONTROL			0xFF818020
+#define OID_RT_PRO_WRITE_EEPROM				0xFF818021
+#define OID_RT_PRO_READ_EEPROM				0xFF818022
+#define OID_RT_PRO_RESET_TX_PACKET_SENT			0xFF818023
+#define OID_RT_PRO_QUERY_TX_PACKET_SENT			0xFF818024
+#define OID_RT_PRO_RESET_RX_PACKET_RECEIVED		0xFF818025
+#define OID_RT_PRO_QUERY_RX_PACKET_RECEIVED		0xFF818026
+#define OID_RT_PRO_QUERY_RX_PACKET_CRC32_ERROR		0xFF818027
+#define OID_RT_PRO_QUERY_CURRENT_ADDRESS		0xFF818028
+#define OID_RT_PRO_QUERY_PERMANENT_ADDRESS		0xFF818029
+#define OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS		0xFF81802A
+#define OID_RT_PRO_RECEIVE_PACKET			0xFF81802C
+/*  added by Owen on 04/08/03 for Cameo's request */
+#define OID_RT_PRO_WRITE_EEPROM_BYTE			0xFF81802D
+#define OID_RT_PRO_READ_EEPROM_BYTE			0xFF81802E
+#define OID_RT_PRO_SET_MODULATION			0xFF81802F
+/*  */
+
+/* Sean */
+#define OID_RT_DRIVER_OPTION				0xFF818080
+#define OID_RT_RF_OFF					0xFF818081
+#define OID_RT_AUTH_STATUS				0xFF818082
+
+/*  */
+#define OID_RT_PRO_SET_CONTINUOUS_TX			0xFF81800B
+#define OID_RT_PRO_SET_SINGLE_CARRIER_TX		0xFF81800C
+#define OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX		0xFF81802B
+#define OID_RT_PRO_SET_SINGLE_TONE_TX			0xFF818043
+/*  */
+
+
+/*  by Owen for RTL8185 Phy Status Report Utility */
+#define OID_RT_UTILITY_FALSE_ALARM_COUNTERS				0xFF818580
+#define OID_RT_UTILITY_SELECT_DEBUG_MODE				0xFF818581
+#define OID_RT_UTILITY_SELECT_SUBCARRIER_NUMBER				0xFF818582
+#define OID_RT_UTILITY_GET_RSSI_STATUS					0xFF818583
+#define OID_RT_UTILITY_GET_FRAME_DETECTION_STATUS			0xFF818584
+#define OID_RT_UTILITY_GET_AGC_AND_FREQUENCY_OFFSET_ESTIMATION_STATUS	0xFF818585
+#define OID_RT_UTILITY_GET_CHANNEL_ESTIMATION_STATUS			0xFF818586
+/*  */
+
+/*  by Owen on 03/09/19-03/09/22 for RTL8185 */
+#define OID_RT_WIRELESS_MODE				0xFF818500
+#define OID_RT_SUPPORTED_RATES				0xFF818501
+#define OID_RT_DESIRED_RATES				0xFF818502
+#define OID_RT_WIRELESS_MODE_STARTING_ADHOC		0xFF818503
+/*  */
+
+#define OID_RT_GET_CONNECT_STATE			0xFF030001
+#define OID_RT_RESCAN					0xFF030002
+#define OID_RT_SET_KEY_LENGTH				0xFF030003
+#define OID_RT_SET_DEFAULT_KEY_ID			0xFF030004
+
+#define OID_RT_SET_CHANNEL				0xFF010182
+#define OID_RT_SET_SNIFFER_MODE				0xFF010183
+#define OID_RT_GET_SIGNAL_QUALITY			0xFF010184
+#define OID_RT_GET_SMALL_PACKET_CRC			0xFF010185
+#define OID_RT_GET_MIDDLE_PACKET_CRC			0xFF010186
+#define OID_RT_GET_LARGE_PACKET_CRC			0xFF010187
+#define OID_RT_GET_TX_RETRY				0xFF010188
+#define OID_RT_GET_RX_RETRY				0xFF010189
+#define OID_RT_PRO_SET_FW_DIG_STATE			0xFF01018A/* S */
+#define OID_RT_PRO_SET_FW_RA_STATE			0xFF01018B/* S */
+
+#define OID_RT_GET_RX_TOTAL_PACKET			0xFF010190
+#define OID_RT_GET_TX_BEACON_OK				0xFF010191
+#define OID_RT_GET_TX_BEACON_ERR			0xFF010192
+#define OID_RT_GET_RX_ICV_ERR				0xFF010193
+#define OID_RT_SET_ENCRYPTION_ALGORITHM			0xFF010194
+#define OID_RT_SET_NO_AUTO_RESCAN			0xFF010195
+#define OID_RT_GET_PREAMBLE_MODE			0xFF010196
+#define OID_RT_GET_DRIVER_UP_DELTA_TIME			0xFF010197
+#define OID_RT_GET_AP_IP				0xFF010198
+#define OID_RT_GET_CHANNELPLAN				0xFF010199
+#define OID_RT_SET_PREAMBLE_MODE			0xFF01019A
+#define OID_RT_SET_BCN_INTVL				0xFF01019B
+#define OID_RT_GET_RF_VENDER				0xFF01019C
+#define OID_RT_DEDICATE_PROBE				0xFF01019D
+#define OID_RT_PRO_RX_FILTER_PATTERN			0xFF01019E
+
+#define OID_RT_GET_DCST_CURRENT_THRESHOLD		0xFF01019F
+
+#define OID_RT_GET_CCA_ERR				0xFF0101A0
+#define OID_RT_GET_CCA_UPGRADE_THRESHOLD		0xFF0101A1
+#define OID_RT_GET_CCA_FALLBACK_THRESHOLD		0xFF0101A2
+
+#define OID_RT_GET_CCA_UPGRADE_EVALUATE_TIMES		0xFF0101A3
+#define OID_RT_GET_CCA_FALLBACK_EVALUATE_TIMES		0xFF0101A4
+
+/*  by Owen on 03/31/03 for Cameo's request */
+#define OID_RT_SET_RATE_ADAPTIVE			0xFF0101A5
+/*  */
+#define OID_RT_GET_DCST_EVALUATE_PERIOD			0xFF0101A5
+#define OID_RT_GET_DCST_TIME_UNIT_INDEX			0xFF0101A6
+#define OID_RT_GET_TOTAL_TX_BYTES			0xFF0101A7
+#define OID_RT_GET_TOTAL_RX_BYTES			0xFF0101A8
+#define OID_RT_CURRENT_TX_POWER_LEVEL			0xFF0101A9
+#define OID_RT_GET_ENC_KEY_MISMATCH_COUNT		0xFF0101AA
+#define OID_RT_GET_ENC_KEY_MATCH_COUNT			0xFF0101AB
+#define OID_RT_GET_CHANNEL				0xFF0101AC
+
+#define OID_RT_SET_CHANNELPLAN				0xFF0101AD
+#define OID_RT_GET_HARDWARE_RADIO_OFF			0xFF0101AE
+#define OID_RT_CHANNELPLAN_BY_COUNTRY			0xFF0101AF
+#define OID_RT_SCAN_AVAILABLE_BSSID			0xFF0101B0
+#define OID_RT_GET_HARDWARE_VERSION			0xFF0101B1
+#define OID_RT_GET_IS_ROAMING				0xFF0101B2
+#define OID_RT_GET_IS_PRIVACY				0xFF0101B3
+#define OID_RT_GET_KEY_MISMATCH				0xFF0101B4
+#define OID_RT_SET_RSSI_ROAM_TRAFFIC_TH			0xFF0101B5
+#define OID_RT_SET_RSSI_ROAM_SIGNAL_TH			0xFF0101B6
+#define OID_RT_RESET_LOG				0xFF0101B7
+#define OID_RT_GET_LOG					0xFF0101B8
+#define OID_RT_SET_INDICATE_HIDDEN_AP			0xFF0101B9
+#define OID_RT_GET_HEADER_FAIL				0xFF0101BA
+#define OID_RT_SUPPORTED_WIRELESS_MODE			0xFF0101BB
+#define OID_RT_GET_CHANNEL_LIST				0xFF0101BC
+#define OID_RT_GET_SCAN_IN_PROGRESS			0xFF0101BD
+#define OID_RT_GET_TX_INFO				0xFF0101BE
+#define OID_RT_RF_READ_WRITE_OFFSET			0xFF0101BF
+#define OID_RT_RF_READ_WRITE				0xFF0101C0
+
+/*  For Netgear request. 2005.01.13, by rcnjko. */
+#define OID_RT_FORCED_DATA_RATE				0xFF0101C1
+#define OID_RT_WIRELESS_MODE_FOR_SCAN_LIST		0xFF0101C2
+/*  For Netgear request. 2005.02.17, by rcnjko. */
+#define OID_RT_GET_BSS_WIRELESS_MODE			0xFF0101C3
+/*  For AZ project. 2005.06.27, by rcnjko. */
+#define OID_RT_SCAN_WITH_MAGIC_PACKET			0xFF0101C4
+
+/*  Vincent 8185MP */
+#define OID_RT_PRO_RX_FILTER				0xFF0111C0
+
+/* Andy TEST */
+/* define OID_RT_PRO_WRITE_REGISTRY			0xFF0111C1 */
+/* define OID_RT_PRO_READ_REGISTRY			0xFF0111C2 */
+#define OID_CE_USB_WRITE_REGISTRY			0xFF0111C1
+#define OID_CE_USB_READ_REGISTRY			0xFF0111C2
+
+
+#define OID_RT_PRO_SET_INITIAL_GAIN			0xFF0111C3
+#define OID_RT_PRO_SET_BB_RF_STANDBY_MODE		0xFF0111C4
+#define OID_RT_PRO_SET_BB_RF_SHUTDOWN_MODE		0xFF0111C5
+#define OID_RT_PRO_SET_TX_CHARGE_PUMP			0xFF0111C6
+#define OID_RT_PRO_SET_RX_CHARGE_PUMP			0xFF0111C7
+#define OID_RT_PRO_RF_WRITE_REGISTRY			0xFF0111C8
+#define OID_RT_PRO_RF_READ_REGISTRY			0xFF0111C9
+#define OID_RT_PRO_QUERY_RF_TYPE			0xFF0111CA
+
+/*  AP OID */
+#define OID_RT_AP_GET_ASSOCIATED_STATION_LIST		0xFF010300
+#define OID_RT_AP_GET_CURRENT_TIME_STAMP		0xFF010301
+#define OID_RT_AP_SWITCH_INTO_AP_MODE			0xFF010302
+#define OID_RT_AP_SET_DTIM_PERIOD			0xFF010303
+#define OID_RT_AP_SUPPORTED				0xFF010304	/*  Determine if driver supports AP mode. 2004.08.27, by rcnjko. */
+#define OID_RT_AP_SET_PASSPHRASE			0xFF010305	/*  Set WPA-PSK passphrase into authenticator. 2005.07.08, byrcnjko. */
+
+/*  8187MP. 2004.09.06, by rcnjko. */
+#define OID_RT_PRO8187_WI_POLL				0xFF818780
+#define OID_RT_PRO_WRITE_BB_REG				0xFF818781
+#define OID_RT_PRO_READ_BB_REG				0xFF818782
+#define OID_RT_PRO_WRITE_RF_REG				0xFF818783
+#define OID_RT_PRO_READ_RF_REG				0xFF818784
+
+/*  Meeting House. added by Annie, 2005-07-20. */
+#define OID_RT_MH_VENDER_ID				0xFFEDC100
+
+/* 8711 MP OID added 20051230. */
+#define OID_RT_PRO8711_JOIN_BSS				0xFF871100/* S */
+
+#define OID_RT_PRO_READ_REGISTER			0xFF871101 /* Q */
+#define OID_RT_PRO_WRITE_REGISTER			0xFF871102 /* S */
+
+#define OID_RT_PRO_BURST_READ_REGISTER			0xFF871103 /* Q */
+#define OID_RT_PRO_BURST_WRITE_REGISTER			0xFF871104 /* S */
+
+#define OID_RT_PRO_WRITE_TXCMD				0xFF871105 /* S */
+
+#define OID_RT_PRO_READ16_EEPROM			0xFF871106 /* Q */
+#define OID_RT_PRO_WRITE16_EEPROM			0xFF871107 /* S */
+
+#define OID_RT_PRO_H2C_SET_COMMAND			0xFF871108 /* S */
+#define OID_RT_PRO_H2C_QUERY_RESULT			0xFF871109 /* Q */
+
+#define OID_RT_PRO8711_WI_POLL				0xFF87110A /* Q */
+#define OID_RT_PRO8711_PKT_LOSS				0xFF87110B /* Q */
+#define OID_RT_RD_ATTRIB_MEM				0xFF87110C/* Q */
+#define OID_RT_WR_ATTRIB_MEM				0xFF87110D/* S */
+
+
+/* Method 2 for H2C/C2H */
+#define OID_RT_PRO_H2C_CMD_MODE				0xFF871110 /* S */
+#define OID_RT_PRO_H2C_CMD_RSP_MODE			0xFF871111 /* Q */
+#define OID_RT_PRO_H2C_CMD_EVENT_MODE			0xFF871112 /* S */
+#define OID_RT_PRO_WAIT_C2H_EVENT			0xFF871113 /* Q */
+#define OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST		0xFF871114/* Q */
+
+#define OID_RT_PRO_SCSI_ACCESS_TEST			0xFF871115 /* Q, S */
+
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT		0xFF871116 /* S */
+#define OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN			0xFF871117 /* Q,S */
+#define OID_RT_RRO_RX_PKT_VIA_IOCTRL			0xFF871118 /* Q */
+#define OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL		0xFF871119 /* Q */
+
+#define OID_RT_RPO_SET_PWRMGT_TEST			0xFF87111A /* S */
+#define OID_RT_PRO_QRY_PWRMGT_TEST			0XFF87111B /* Q */
+#define OID_RT_RPO_ASYNC_RWIO_TEST			0xFF87111C /* S */
+#define OID_RT_RPO_ASYNC_RWIO_POLL			0xFF87111D /* Q */
+#define OID_RT_PRO_SET_RF_INTFS				0xFF87111E /* S */
+#define OID_RT_POLL_RX_STATUS				0xFF87111F /* Q */
+
+#define OID_RT_PRO_CFG_DEBUG_MESSAGE			0xFF871120 /* Q,S */
+#define OID_RT_PRO_SET_DATA_RATE_EX			0xFF871121/* S */
+#define OID_RT_PRO_SET_BASIC_RATE			0xFF871122/* S */
+#define OID_RT_PRO_READ_TSSI				0xFF871123/* S */
+#define OID_RT_PRO_SET_POWER_TRACKING			0xFF871124/* S */
+
+
+#define OID_RT_PRO_QRY_PWRSTATE				0xFF871150 /* Q */
+#define OID_RT_PRO_SET_PWRSTATE				0xFF871151 /* S */
+
+/* Method 2 , using workitem */
+#define OID_RT_SET_READ_REG				0xFF871181 /* S */
+#define OID_RT_SET_WRITE_REG				0xFF871182 /* S */
+#define OID_RT_SET_BURST_READ_REG			0xFF871183 /* S */
+#define OID_RT_SET_BURST_WRITE_REG			0xFF871184 /* S */
+#define OID_RT_SET_WRITE_TXCMD				0xFF871185 /* S */
+#define OID_RT_SET_READ16_EEPROM			0xFF871186 /* S */
+#define OID_RT_SET_WRITE16_EEPROM			0xFF871187 /* S */
+#define OID_RT_QRY_POLL_WKITEM				0xFF871188 /* Q */
+
+/* For SDIO INTERFACE only */
+#define OID_RT_PRO_SYNCPAGERW_SRAM			0xFF8711A0 /* Q, S */
+#define OID_RT_PRO_871X_DRV_EXT				0xFF8711A1
+
+/* For USB INTERFACE only */
+#define OID_RT_PRO_USB_VENDOR_REQ			0xFF8711B0 /* Q, S */
+#define OID_RT_PRO_SCSI_AUTO_TEST			0xFF8711B1 /* S */
+#define OID_RT_PRO_USB_MAC_AC_FIFO_WRITE		0xFF8711B2 /* S */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_READ			0xFF8711B3 /* Q */
+#define OID_RT_PRO_USB_MAC_RX_FIFO_POLLING		0xFF8711B4 /* Q */
+
+#define OID_RT_PRO_H2C_SET_RATE_TABLE			0xFF8711FB /* S */
+#define OID_RT_PRO_H2C_GET_RATE_TABLE			0xFF8711FC /* S */
+#define OID_RT_PRO_H2C_C2H_LBK_TEST			0xFF8711FE
+
+#define OID_RT_PRO_ENCRYPTION_CTRL			0xFF871200 /* Q, S */
+#define OID_RT_PRO_ADD_STA_INFO				0xFF871201 /* S */
+#define OID_RT_PRO_DELE_STA_INFO			0xFF871202 /* S */
+#define OID_RT_PRO_QUERY_DR_VARIABLE			0xFF871203 /* Q */
+
+#define OID_RT_PRO_RX_PACKET_TYPE			0xFF871204 /* Q, S */
+
+#define OID_RT_PRO_READ_EFUSE				0xFF871205 /* Q */
+#define OID_RT_PRO_WRITE_EFUSE				0xFF871206 /* S */
+#define OID_RT_PRO_RW_EFUSE_PGPKT			0xFF871207 /* Q, S */
+#define OID_RT_GET_EFUSE_CURRENT_SIZE			0xFF871208 /* Q */
+
+#define OID_RT_SET_BANDWIDTH				0xFF871209 /* S */
+#define OID_RT_SET_CRYSTAL_CAP				0xFF87120A /* S */
+
+#define OID_RT_SET_RX_PACKET_TYPE			0xFF87120B /* S */
+
+#define OID_RT_GET_EFUSE_MAX_SIZE			0xFF87120C /* Q */
+
+#define OID_RT_PRO_SET_TX_AGC_OFFSET			0xFF87120D /* S */
+
+#define OID_RT_PRO_SET_PKT_TEST_MODE			0xFF87120E /* S */
+
+#define OID_RT_PRO_FOR_EVM_TEST_SETTING			0xFF87120F /* S */
+
+#define OID_RT_PRO_GET_THERMAL_METER			0xFF871210 /* Q */
+
+#define OID_RT_RESET_PHY_RX_PACKET_COUNT		0xFF871211 /* S */
+#define OID_RT_GET_PHY_RX_PACKET_RECEIVED		0xFF871212 /* Q */
+#define OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR		0xFF871213 /* Q */
+
+#define OID_RT_SET_POWER_DOWN				0xFF871214 /* S */
+
+#define OID_RT_GET_POWER_MODE				0xFF871215 /* Q */
+
+#define OID_RT_PRO_EFUSE				0xFF871216 /* Q, S */
+#define OID_RT_PRO_EFUSE_MAP				0xFF871217 /* Q, S */
+
+#endif /* ifndef	__CUSTOM_OID_H */
diff --git a/drivers/net/wireless/rtl8192du/include/nic_spec.h b/drivers/net/wireless/rtl8192du/include/nic_spec.h
new file mode 100644
index 0000000..2a1b3c9
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/nic_spec.h
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif /*  __RTL8711_SPEC_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/osdep_intf.h b/drivers/net/wireless/rtl8192du/include/osdep_intf.h
new file mode 100644
index 0000000..47f7e9e
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/osdep_intf.h
@@ -0,0 +1,112 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+struct intf_priv {
+
+	u8 *intf_dev;
+	u32	max_iosz;	/* USB2.0: 128, USB1.1: 64, SDIO:64 */
+	u32	max_xmitsz; /* USB2.0: unlimited, SDIO:512 */
+	u32	max_recvsz; /* USB2.0: unlimited, SDIO:512 */
+
+	volatile u8 *io_rwmem;
+	volatile u8 *allocated_io_rwmem;
+	u32	io_wsz; /* unit: 4bytes */
+	u32	io_rsz;/* unit: 4bytes */
+	u8 intf_status;
+
+	void (*_bus_io)(u8 *priv);
+
+/*
+Under Sync. IRP (SDIO/USB)
+A protection mechanism is necessary for the io_rwmem(read/write protocol)
+
+Under Async. IRP (SDIO/USB)
+The protection mechanism is through the pending queue.
+*/
+
+	_mutex ioctl_mutex;
+
+	/*  when in USB, IO is through interrupt in/out endpoints */
+	struct usb_device	*udev;
+	struct urb *piorw_urb;
+	u8 io_irp_cnt;
+	u8 bio_irp_pending;
+	struct  semaphore io_retevt;
+	struct timer_list io_timer;
+	u8 bio_irp_timeout;
+	u8 bio_timer_cancel;
+};
+
+
+#ifdef CONFIG_R871X_TEST
+int rtw_start_pseudo_adhoc(struct rtw_adapter *padapter);
+int rtw_stop_pseudo_adhoc(struct rtw_adapter *padapter);
+#endif
+
+u8 rtw_init_drv_sw(struct rtw_adapter *padapter);
+u8 rtw_free_drv_sw(struct rtw_adapter *padapter);
+u8 rtw_reset_drv_sw(struct rtw_adapter *padapter);
+
+u32 rtw_start_drv_threads(struct rtw_adapter *padapter);
+void rtw_stop_drv_threads (struct rtw_adapter *padapter);
+void rtw_cancel_all_timer(struct rtw_adapter *padapter);
+
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname);
+struct net_device *rtw_init_netdev(struct rtw_adapter *padapter);
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+u16 rtw_recv_select_queue(struct sk_buff *skb);
+#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
+
+#ifdef CONFIG_PROC_DEBUG
+void rtw_proc_init_one(struct net_device *dev);
+void rtw_proc_remove_one(struct net_device *dev);
+#else /* CONFIG_PROC_DEBUG */
+static void rtw_proc_init_one(struct net_device *dev) {}
+static void rtw_proc_remove_one(struct net_device *dev) {}
+#endif /* CONFIG_PROC_DEBUG */
+
+void rtw_ips_dev_unload(struct rtw_adapter *padapter);
+#ifdef CONFIG_IPS
+int rtw_ips_pwr_up(struct rtw_adapter *padapter);
+void rtw_ips_pwr_down(struct rtw_adapter *padapter);
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+struct _io_ops;
+struct rtw_adapter *rtw_drv_if2_init(struct rtw_adapter *primary_padapter, char *name, void (*set_intf_ops)(struct _io_ops *pops));
+void rtw_drv_if2_free(struct rtw_adapter *if2);
+void rtw_drv_if2_stop(struct rtw_adapter *if2);
+#ifdef CONFIG_MULTI_VIR_IFACES
+struct dvobj_priv;
+_adapter *rtw_drv_add_vir_if (struct rtw_adapter *primary_padapter, char *name,	void (*set_intf_ops)(struct _io_ops *pops));
+void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj);
+void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj);
+#endif /* CONFIG_MULTI_VIR_IFACES */
+#endif
+
+void rtw_ndev_destructor(struct net_device *ndev);
+
+#endif	/* _OSDEP_INTF_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/osdep_service.h b/drivers/net/wireless/rtl8192du/include/osdep_service.h
new file mode 100644
index 0000000..a19282a
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/osdep_service.h
@@ -0,0 +1,586 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#include <drv_conf.h>
+#include <basic_types.h>
+
+#define _FAIL		0
+#define _SUCCESS	1
+#define RTW_RX_HANDLED 2
+
+	#include <linux/version.h>
+	#include <linux/spinlock.h>
+	#include <linux/compiler.h>
+	#include <linux/kernel.h>
+	#include <linux/errno.h>
+	#include <linux/init.h>
+	#include <linux/slab.h>
+	#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,5))
+	#include <linux/kref.h>
+#endif
+	#include <linux/netdevice.h>
+	#include <linux/skbuff.h>
+	#include <asm/uaccess.h>
+	#include <asm/byteorder.h>
+	#include <asm/atomic.h>
+	#include <asm/io.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+	#include <asm/semaphore.h>
+#else
+	#include <linux/semaphore.h>
+#endif
+	#include <linux/sem.h>
+	#include <linux/sched.h>
+	#include <linux/etherdevice.h>
+	#include <linux/wireless.h>
+	#include <net/iw_handler.h>
+	#include <linux/if_arp.h>
+	#include <linux/rtnetlink.h>
+	#include <linux/delay.h>
+	#include <linux/proc_fs.h>	/*  Necessary because we use the proc fs */
+	#include <linux/interrupt.h>	/*  for struct tasklet_struct */
+	#include <linux/ip.h>
+	#include <linux/kthread.h>
+
+        #include <net/ieee80211_radiotap.h>
+	#include <net/cfg80211.h>
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	#include <linux/in.h>
+	#include <linux/udp.h>
+#endif
+
+	#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+	#include <linux/usb_ch9.h>
+#else
+	#include <linux/usb/ch9.h>
+#endif
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
+#ifdef CONFIG_USB_SUSPEND
+#define CONFIG_AUTOSUSPEND	1
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+        *(u32 *)dst = *(const u32 *)src;
+        *(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+        u16 *a = (u16 *)dst;
+        const u16 *b = (const u16 *)src;
+
+        a[0] = b[0];
+        a[1] = b[1];
+        a[2] = b[2];
+#endif
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	#define _mutex	struct mutex
+#else
+	#define _mutex	struct semaphore
+#endif
+	struct	__queue	{
+		struct	list_head	queue;
+		spinlock_t	lock;
+	};
+
+	#define thread_exit() complete_and_exit(NULL, 0)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+/*  Porting from linux kernel, for compatible with old kernel. */
+static inline unsigned char *skb_tail_pointer(const struct sk_buff *skb)
+{
+	return skb->tail;
+}
+
+static inline void skb_reset_tail_pointer(struct sk_buff *skb)
+{
+	skb->tail = skb->data;
+}
+
+static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
+{
+	skb->tail = skb->data + offset;
+}
+
+static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
+{
+	return skb->end;
+}
+#endif
+
+static inline struct list_head *get_list_head(struct __queue *queue)
+{
+	return (&(queue->queue));
+}
+
+static inline void _enter_critical_mutex(_mutex *pmutex)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		mutex_lock(pmutex);
+#else
+		down(pmutex);
+#endif
+}
+
+
+static inline void _exit_critical_mutex(_mutex *pmutex)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		mutex_unlock(pmutex);
+#else
+		up(pmutex);
+#endif
+}
+
+static inline void _init_timer(struct timer_list *timer, struct net_device * nic_hdl, void *pfunc, void *cntx)
+{
+	timer->function = pfunc;
+	timer->data = (unsigned long)cntx;
+	init_timer(timer);
+}
+
+static inline void _set_timer(struct timer_list *timer,u32 delay_time)
+{
+	mod_timer(timer , (jiffies+(delay_time*HZ/1000)));
+}
+
+static inline void _cancel_timer(struct timer_list *timer,u8 *bcancelled)
+{
+	del_timer_sync(timer);
+	*bcancelled=  true;
+}
+
+#define RTW_TIMER_HDL_ARGS void *FunctionContext
+
+#define RTW_TIMER_HDL_NAME(name) rtw_##name##_timer_hdl
+#define RTW_DECLARE_TIMER_HDL(name) void RTW_TIMER_HDL_NAME(name)(RTW_TIMER_HDL_ARGS)
+
+
+static inline void _init_workitem(struct work_struct *pwork, void *pfunc, void * cntx)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	INIT_WORK(pwork, pfunc);
+#else
+	INIT_WORK(pwork, pfunc,pwork);
+#endif
+}
+
+static inline void _set_workitem(struct work_struct *pwork)
+{
+	schedule_work(pwork);
+}
+
+static inline void _cancel_workitem_sync(struct work_struct *pwork)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22))
+	cancel_work_sync(pwork);
+#else
+	flush_scheduled_work();
+#endif
+}
+
+/*  */
+/*  Global Mutex: can only be used at PASSIVE level. */
+/*  */
+
+#define ACQUIRE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+	while (atomic_inc_return((atomic_t *)&(_MutexCounter)) != 1)\
+	{                                                           \
+		atomic_dec((atomic_t *)&(_MutexCounter));        \
+		msleep(10);                          \
+	}                                                           \
+}
+
+#define RELEASE_GLOBAL_MUTEX(_MutexCounter)                              \
+{                                                               \
+	atomic_dec((atomic_t *)&(_MutexCounter));        \
+}
+
+static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	return (netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 0)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 1)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 2)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3)));
+#else
+	return netif_queue_stopped(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_wake_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_wake_all_queues(pnetdev);
+#else
+	netif_wake_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_start_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_start_all_queues(pnetdev);
+#else
+	netif_start_queue(pnetdev);
+#endif
+}
+
+static inline void rtw_netif_stop_queue(struct net_device *pnetdev)
+{
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	netif_tx_stop_all_queues(pnetdev);
+#else
+	netif_stop_queue(pnetdev);
+#endif
+}
+
+
+#ifndef BIT
+	#define BIT(x)	(1 << (x))
+#endif
+
+extern int RTW_STATUS_CODE(int error_code);
+
+/* flags used for rtw_update_mem_stat() */
+enum {
+	MEM_STAT_VIR_ALLOC_SUCCESS,
+	MEM_STAT_VIR_ALLOC_FAIL,
+	MEM_STAT_VIR_FREE,
+	MEM_STAT_PHY_ALLOC_SUCCESS,
+	MEM_STAT_PHY_ALLOC_FAIL,
+	MEM_STAT_PHY_FREE,
+	MEM_STAT_TX, /* used to distinguish TX/RX, asigned from caller */
+	MEM_STAT_TX_ALLOC_SUCCESS,
+	MEM_STAT_TX_ALLOC_FAIL,
+	MEM_STAT_TX_FREE,
+	MEM_STAT_RX, /* used to distinguish TX/RX, asigned from caller */
+	MEM_STAT_RX_ALLOC_SUCCESS,
+	MEM_STAT_RX_ALLOC_FAIL,
+	MEM_STAT_RX_FREE
+};
+
+#define rtw_update_mem_stat(flag, sz) do {} while (0)
+
+extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
+
+extern u32	rtw_is_list_empty(struct list_head *phead);
+extern void	rtw_list_insert_head(struct list_head *plist, struct list_head *phead);
+extern void	rtw_list_insert_tail(struct list_head *plist, struct list_head *phead);
+
+extern void	_rtw_init_sema(struct  semaphore *sema, int init_val);
+extern void	_rtw_free_sema(struct  semaphore *sema);
+extern void	_rtw_up_sema(struct  semaphore *sema);
+extern u32	_rtw_down_sema(struct  semaphore *sema);
+extern void	_rtw_mutex_init(_mutex *pmutex);
+extern void	_rtw_mutex_free(_mutex *pmutex);
+extern void	_rtw_spinlock_init(spinlock_t *plock);
+extern void	_rtw_spinlock_free(spinlock_t *plock);
+extern void	_rtw_spinlock(spinlock_t	*plock);
+extern void	_rtw_spinunlock(spinlock_t	*plock);
+extern void	_rtw_spinlock_ex(spinlock_t	*plock);
+extern void	_rtw_spinunlock_ex(spinlock_t	*plock);
+
+extern void	_rtw_init_queue(struct __queue *pqueue);
+extern u32	_rtw_queue_empty(struct __queue *pqueue);
+extern u32	rtw_end_of_queue_search(struct list_head *queue, struct list_head *pelement);
+
+extern u32	rtw_get_current_time(void);
+extern u32	rtw_systime_to_ms(u32 systime);
+extern u32	rtw_ms_to_systime(u32 ms);
+extern s32	rtw_get_passing_time_ms(u32 start);
+extern s32	rtw_get_time_interval_ms(u32 start, u32 end);
+
+extern void	rtw_sleep_schedulable(int ms);
+
+extern void	rtw_msleep_os(int ms);
+extern void	rtw_usleep_os(int us);
+
+extern u32	rtw_atoi(u8* s);
+
+#ifdef DBG_DELAY_OS
+#define rtw_mdelay_os(ms) _rtw_mdelay_os((ms), __func__, __LINE__)
+#define rtw_udelay_os(ms) _rtw_udelay_os((ms), __func__, __LINE__)
+extern void _rtw_mdelay_os(int ms, const char *func, const int line);
+extern void _rtw_udelay_os(int us, const char *func, const int line);
+#else
+extern void	rtw_mdelay_os(int ms);
+extern void	rtw_udelay_os(int us);
+#endif
+
+extern void rtw_yield_os(void);
+
+
+static inline unsigned char _cancel_timer_ex(struct timer_list *timer)
+{
+	return del_timer_sync(timer);
+}
+
+static __inline void thread_enter(char *name)
+{
+	#ifdef daemonize
+	daemonize("%s", name);
+	#endif
+	allow_signal(SIGTERM);
+}
+
+static inline void flush_signals_thread(void)
+{
+	if (signal_pending (current))
+		flush_signals(current);
+}
+
+static inline int res_to_status(int res)
+{
+	return res;
+}
+
+#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
+
+static inline u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
+
+	return val;
+
+}
+
+static inline u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
+
+	return val;
+
+}
+
+static inline u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
+
+	return val;
+
+}
+
+static inline u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
+
+	return val;
+
+}
+
+static inline u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
+
+	return val;
+
+}
+
+static inline u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+/* ifdef __GNUC__ */
+#define STRUCT_PACKED __attribute__ ((packed))
+
+/*  limitation of path length */
+	#define PATH_LENGTH_MAX PATH_MAX
+
+/*  Suspend lock prevent system from going suspend */
+#ifdef CONFIG_WAKELOCK
+#include <linux/wakelock.h>
+#elif defined(CONFIG_ANDROID_POWER)
+#include <linux/android_power.h>
+#endif
+
+extern void rtw_suspend_lock_init(void);
+extern void rtw_suspend_lock_uninit(void);
+extern void rtw_lock_suspend(void);
+extern void rtw_unlock_suspend(void);
+
+
+/* Atomic integer operations */
+	#define ATOMIC_T atomic_t
+
+extern void ATOMIC_SET(ATOMIC_T *v, int i);
+extern int ATOMIC_READ(ATOMIC_T *v);
+extern void ATOMIC_ADD(ATOMIC_T *v, int i);
+extern void ATOMIC_SUB(ATOMIC_T *v, int i);
+extern void ATOMIC_INC(ATOMIC_T *v);
+extern void ATOMIC_DEC(ATOMIC_T *v);
+extern int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
+extern int ATOMIC_INC_RETURN(ATOMIC_T *v);
+extern int ATOMIC_DEC_RETURN(ATOMIC_T *v);
+
+/* File operation APIs, just for linux now */
+int rtw_is_file_readable(char *path);
+int rtw_retrive_from_file(char *path, u8 __user *buf, u32 sz);
+int rtw_store_to_file(char *path, u8 __user *buf, u32 sz);
+
+
+struct rtw_netdev_priv_indicator {
+	void *priv;
+	u32 sizeof_priv;
+};
+struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv);
+extern struct net_device * rtw_alloc_etherdev(int sizeof_priv);
+
+#define rtw_netdev_priv(netdev) (((struct rtw_netdev_priv_indicator *)netdev_priv(netdev))->priv)
+
+extern void rtw_free_netdev(struct net_device * netdev);
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ndev->name
+#define ADPT_FMT "%s"
+#define ADPT_ARG(adapter) adapter->pnetdev->name
+#define FUNC_NDEV_FMT "%s(%s)"
+#define FUNC_NDEV_ARG(ndev) __func__, ndev->name
+#define FUNC_ADPT_FMT "%s(%s)"
+#define FUNC_ADPT_ARG(adapter) __func__, adapter->pnetdev->name
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#define rtw_signal_process(pid, sig) kill_pid(find_vpid((pid)),(sig), 1)
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
+#define rtw_signal_process(pid, sig) kill_proc((pid), (sig), 1)
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)) */
+
+extern u64 rtw_modular64(u64 x, u64 y);
+extern u64 rtw_division64(u64 x, u64 y);
+
+
+/* Macros for handling unaligned memory accesses */
+
+#define RTW_GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
+#define RTW_PUT_BE16(a, val)			\
+	do {					\
+		(a)[0] = ((u16) (val)) >> 8;	\
+		(a)[1] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_LE16(a) ((u16) (((a)[1] << 8) | (a)[0]))
+#define RTW_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
+			 ((u32) (a)[2]))
+#define RTW_PUT_BE24(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[2] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+#define RTW_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
+			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
+#define RTW_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
+			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
+			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
+			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
+#define RTW_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+#define RTW_GET_LE64(a) ((((u64) (a)[7]) << 56) | (((u64) (a)[6]) << 48) | \
+			 (((u64) (a)[5]) << 40) | (((u64) (a)[4]) << 32) | \
+			 (((u64) (a)[3]) << 24) | (((u64) (a)[2]) << 16) | \
+			 (((u64) (a)[1]) << 8) | ((u64) (a)[0]))
+
+void rtw_buf_free(u8 **buf, u32 *buf_len);
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len);
+
+struct rtw_cbuf {
+	u32 write;
+	u32 read;
+	u32 size;
+	void *bufs[0];
+};
+
+bool rtw_cbuf_full(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_empty(struct rtw_cbuf *cbuf);
+bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf);
+void *rtw_cbuf_pop(struct rtw_cbuf *cbuf);
+struct rtw_cbuf *rtw_cbuf_alloc(u32 size);
+void rtw_cbuf_free(struct rtw_cbuf *cbuf);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/recv_osdep.h b/drivers/net/wireless/rtl8192du/include/recv_osdep.h
new file mode 100644
index 0000000..0836eef
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/recv_osdep.h
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+int _rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtw_adapter *padapter);
+void _rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+s32  rtw_recv_entry(struct recv_frame_hdr *precv_frame);
+int rtw_recv_indicatepkt(struct rtw_adapter *adapter, struct recv_frame_hdr *precv_frame);
+void rtw_recv_returnpacket(struct net_device *cnxt, struct sk_buff *preturnedpkt);
+
+void rtw_hostapd_mlme_rx(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+void rtw_handle_tkip_mic_err(struct rtw_adapter *padapter, u8 bgroup);
+
+int	rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtw_adapter *padapter);
+void rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+int rtw_os_recv_resource_alloc(struct rtw_adapter *padapter, struct recv_frame_hdr *precvframe);
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv);
+
+int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf);
+int rtw_os_recvbuf_resource_free(struct rtw_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_os_read_port(struct rtw_adapter *padapter, struct recv_buf *precvbuf);
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_cmd.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_cmd.h
new file mode 100644
index 0000000..cc93a83
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_cmd.h
@@ -0,0 +1,132 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192D_CMD_H_
+#define __RTL8192D_CMD_H_
+
+
+/*  */
+/* 3				Host Message Box */
+/*  */
+
+/*  User Define Message [31:8] */
+
+/* _SETPWRMODE_PARM */
+#define SET_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+
+/* JOINBSSRPT_PARM */
+#define SET_H2CCMD_JOINBSSRPT_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+
+/* _RSVDPAGE_LOC */
+#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+
+/* P2P_PS_OFFLOAD */
+
+struct P2P_PS_Offload_t {
+ unsigned char Offload_En:1;
+ unsigned char role:1; /*  1: Owner, 0: Client */
+ unsigned char CTWindow_En:1;
+ unsigned char NoA0_En:1;
+ unsigned char NoA1_En:1;
+ unsigned char AllStaSleep:1; /*  Only valid in Owner */
+ unsigned char discovery:1;
+ unsigned char rsvd:1;
+};
+
+#define SET_H2CCMD_P2P_PS_OFFLOAD_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_CTW(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA0(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_NOA1(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+
+/*  Description: Determine the types of H2C commands that are the same in driver and Fw. */
+/*  Fisrt constructed by tynli. 2009.10.09. */
+enum RTL8192D_H2C_CMD {
+	H2C_AP_OFFLOAD = 0,		/*0*/
+	H2C_SETPWRMODE = 1,		/*1*/
+	H2C_JOINBSSRPT = 2,		/*2*/
+	H2C_RSVDPAGE = 3,
+	H2C_RSSI_REPORT = 5,
+	H2C_RA_MASK = 6,
+	H2C_P2P_PS_OFFLOAD = 8,
+	H2C_MAC_MODE_SEL = 9,
+	H2C_PWRM=15,
+#ifdef CONFIG_WOWLAN
+	H2C_WO_WLAN_CMD = 20,	/*  Wake on Wlan. */
+#endif /*  CONFIG_WOWLAN */
+	H2C_P2P_PS_CTW_CMD = 24,
+	H2C_PathDiv = 26,                  /* PathDiv--NeilChen--2011.07.15 */
+#ifdef CONFIG_WOWLAN
+	KEEP_ALIVE_CONTROL_CMD=31, /* keep alive for wake on wlan */
+	DISCONNECT_DECISION_CTRL_CMD=32,
+	REMOTE_WAKE_CTRL_CMD=34,
+#endif /*  CONFIG_WOWLAN */
+	H2C_92D_TSF_SYNC=36,
+	H2C_92D_RESET_TSF = 43,
+	H2C_CMD_MAX
+};
+
+struct cmd_msg_parm {
+	u8 eid; /* element id */
+	u8 sz; /*  sz */
+	u8 buf[6];
+};
+
+
+void	FillH2CCmd92D(struct rtw_adapter* padapter, u8 ElementID, u32 CmdLen, u8* pCmdBuffer);
+
+/*  host message to firmware cmd */
+void	rtl8192d_set_FwPwrMode_cmd(struct rtw_adapter*padapter, u8 Mode);
+void	rtl8192d_set_FwJoinBssReport_cmd(struct rtw_adapter* padapter, u8 mstatus);
+u8	rtl8192d_set_rssi_cmd(struct rtw_adapter*padapter, u8 *param);
+u8	rtl8192d_set_raid_cmd(struct rtw_adapter*padapter, u32 mask, u8 arg);
+void	rtl8192d_Add_RateATid(struct rtw_adapter * adapter, u32 bitmap, u8 arg);
+
+#ifdef CONFIG_TSF_RESET_OFFLOAD
+int reset_tsf(struct rtw_adapter * adapter, u8 reset_port);
+#endif	/*  CONFIG_TSF_RESET_OFFLOAD */
+
+#ifdef CONFIG_WOWLAN
+struct set_wowlan_parm {
+	u8	mode;
+	u8	gpio_index;
+	u8	gpio_duration;
+	u8  second_mode;
+	u8  reserve;
+};
+
+#define FW_WOWLAN_FUN_EN			BIT(0)
+#define FW_WOWLAN_PATTERN_MATCH		BIT(1)
+#define FW_WOWLAN_MAGIC_PKT			BIT(2)
+#define FW_WOWLAN_UNICAST			BIT(3)
+#define FW_WOWLAN_ALL_PKT_DROP		BIT(4)
+#define FW_WOWLAN_GPIO_ACTIVE		BIT(5)
+#define FW_WOWLAN_REKEY_WAKEUP		BIT(6)
+#define FW_WOWLAN_DEAUTH_WAKEUP		BIT(7)
+
+#define FW_WOWLAN_GPIO_WAKEUP_EN	BIT(0)
+#define FW_FW_PARSE_MAGIC_PKT		BIT(1)
+
+void rtl8192d_set_wowlan_cmd(struct rtw_adapter* padapter);
+void SetFwRelatedForWoWLAN8192DU(struct rtw_adapter*	padapter,u8 bHostIsGoingtoSleep);
+#endif /*  CONFIG_WOWLAN */
+
+#endif	/*  __RTL8192D_CMD_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_dm.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_dm.h
new file mode 100644
index 0000000..6481a83
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_dm.h
@@ -0,0 +1,384 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTL8192D_DM_H__
+#define __RTL8192D_DM_H__
+/*  */
+/*  Description: */
+/*  */
+/*  This file is for 92CE/92CU dynamic mechanism only */
+/*  */
+/*  */
+/*  */
+/*  */
+/*  Global var */
+/*  */
+
+extern u32 EDCAParam[maxAP][3] ;
+
+/*  */
+/*  structure and define */
+/*  */
+
+struct FALSE_ALARM_STATISTICS {
+	u32	Cnt_Parity_Fail;
+	u32	Cnt_Rate_Illegal;
+	u32	Cnt_Crc8_fail;
+	u32	Cnt_Mcs_fail;
+	u32	Cnt_Ofdm_fail;
+	u32	Cnt_Cck_fail;
+	u32	Cnt_all;
+	u32	Cnt_Fast_Fsync;
+	u32	Cnt_SB_Search_fail;
+};
+
+struct PS_T {
+	u8		preccastate;
+	u8		curccastate;
+
+	u8		prerfstate;
+	u8		currfstate;
+};
+
+struct DIG_T {
+	u8		dig_enable_flag;
+	u8		dig_ext_port_stage;
+
+	int		rssilowthresh;
+	int		rssihighthresh;
+
+	u32		falowthresh;
+	u32		fahighthresh;
+
+	u8		curstaconnectstate;
+	u8		prestaconnectstate;
+	u8		curmultistaconnectstate;
+
+	u8		preigvalue;
+	u8		curigvalue;
+	u8		backupigvalue;
+
+	char		backoffval;
+	char		backoffval_range_max;
+	char		backoffval_range_min;
+	u8		rx_gain_range_max;
+	u8		rx_gain_range_min;
+	u8		rssi_val_min;
+
+	u8		precckpdstate;
+	u8		curcckpdstate;
+
+	u8		largefahit;
+	u8		forbiddenigi;
+	u32		recover_cnt;
+	u8		rx_gain_range_min_nolink;
+};
+
+enum DM_DIG_OP_E {
+	DIG_TYPE_THRESH_HIGH	= 0,
+	DIG_TYPE_THRESH_LOW	= 1,
+	DIG_TYPE_BACKOFF	= 2,
+	DIG_TYPE_RX_GAIN_MIN	= 3,
+	DIG_TYPE_RX_GAIN_MAX	= 4,
+	DIG_TYPE_ENABLE		= 5,
+	DIG_TYPE_DISABLE	= 6,
+	DIG_OP_TYPE_MAX
+};
+
+enum DM_CCK_PDTH_E {
+	CCK_PD_STAGE_LOWRSSI = 0,
+	CCK_PD_STAGE_HIGHRSSI = 1,
+	CCK_PD_STAGE_MAX = 3,
+};
+
+enum DM_1R_CCA_E {
+	CCA_MIN = 0,
+	CCA_1R =1,
+	CCA_2R = 2,
+	CCA_MAX = 3,
+};
+
+enum DM_RF_E {
+	RF_Save =0,
+	RF_Normal = 1,
+	RF_MAX = 2,
+};
+
+enum DM_DIG_EXT_PORT_ALG_E {
+	DIG_EXT_PORT_STAGE_0 = 0,
+	DIG_EXT_PORT_STAGE_1 = 1,
+	DIG_EXT_PORT_STAGE_2 = 2,
+	DIG_EXT_PORT_STAGE_3 = 3,
+	DIG_EXT_PORT_STAGE_MAX = 4,
+};
+
+
+enum DM_DIG_CONNECT_E {
+	DIG_STA_DISCONNECT = 0,
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+};
+
+
+#define		DM_DIG_THRESH_HIGH			40
+#define		DM_DIG_THRESH_LOW			35
+
+#define		DM_FALSEALARM_THRESH_LOW	400
+#define		DM_FALSEALARM_THRESH_HIGH	1000
+
+#define		DM_DIG_MAX					0x3e
+#define		DM_DIG_MIN					0x1e
+
+#define		DM_DIG_FA_UPPER				0x32
+#define		DM_DIG_FA_LOWER				0x20
+
+/* vivi 92c&92d has different definition, 20110504 */
+/* this is for 92c */
+#define		DM_DIG_FA_TH0				0x200/* 0x20 */
+#define		DM_DIG_FA_TH1				0x300/* 0x100 */
+#define		DM_DIG_FA_TH2				0x400/* 0x200 */
+/* this is for 92d */
+#define		DM_DIG_FA_TH0_92D			0x100
+#define		DM_DIG_FA_TH1_92D			0x150
+#define		DM_DIG_FA_TH2_92D			0x250
+
+#define		DM_DIG_BACKOFF_MAX			12
+#define		DM_DIG_BACKOFF_MIN			(-4)
+#define		DM_DIG_BACKOFF_DEFAULT		10
+
+#define		RxPathSelection_SS_TH_low		30
+#define		RxPathSelection_diff_TH			18
+
+#define		DM_RATR_STA_INIT			0
+#define		DM_RATR_STA_HIGH			1
+#define		DM_RATR_STA_MIDDLE		2
+#define		DM_RATR_STA_LOW			3
+
+#define		CTSToSelfTHVal					30
+#define		RegC38_TH						20
+
+#define		WAIotTHVal						25
+
+/* Dynamic Tx Power Control Threshold */
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
+
+#define		TxHighPwrLevel_Normal		0
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+#define		TxHighPwrLevel_BT1			3
+#define		TxHighPwrLevel_BT2			4
+#define		TxHighPwrLevel_15			5
+#define		TxHighPwrLevel_35			6
+#define		TxHighPwrLevel_50			7
+#define		TxHighPwrLevel_70			8
+#define		TxHighPwrLevel_100			9
+
+#define		DM_Type_ByFW			0
+#define		DM_Type_ByDriver		1
+
+struct rate_adaptive {
+	u8				RateAdaptiveDisabled;
+	u8				RATRState;
+	u16				reserve;
+
+	u32				HighRSSIThreshForRA;
+	u32				High2LowRSSIThreshForRA;
+	u8				Low2HighRSSIThreshForRA40M;
+	u32				LowRSSIThreshForRA40M;
+	u8				Low2HighRSSIThreshForRA20M;
+	u32				LowRSSIThreshForRA20M;
+	u32				UpperRSSIThresholdRATR;
+	u32				MiddleRSSIThresholdRATR;
+	u32				LowRSSIThresholdRATR;
+	u32				LowRSSIThresholdRATR40M;
+	u32				LowRSSIThresholdRATR20M;
+	u8				PingRSSIEnable;	/* cosa add for Netcore long range ping issue */
+	u32				PingRSSIRATR;	/* cosa add for Netcore long range ping issue */
+	u32				PingRSSIThreshForRA;/* cosa add for Netcore long range ping issue */
+	u32				LastRATR;
+	u8				PreRATRState;
+};
+
+enum DM_SWAS_E {
+	Antenna_B = 1,
+	Antenna_A = 2,
+	Antenna_MAX = 3,
+};
+
+/*  20100514 Joseph: Add definition for antenna switching test after link. */
+/*  This indicates two different the steps. */
+/*  In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air. */
+/*  In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK */
+/*  with original RSSI to determine if it is necessary to switch antenna. */
+#define SWAW_STEP_PEAK		0
+#define SWAW_STEP_DETERMINE	1
+
+#define	TP_MODE		0
+#define	RSSI_MODE		1
+#define	TRAFFIC_LOW	0
+#define	TRAFFIC_HIGH	1
+
+/*  */
+/* Neil Chen---2011--06--15-- */
+/*  */
+/* 3 PathDiv */
+struct sw_antenna_switch {
+	u8		try_flag;
+	s32		PreRSSI;
+	u8		CurAntenna;
+	u8		PreAntenna;
+	u8		RSSI_Trying;
+	u8		TestMode;
+	u8		bTriggerAntennaSwitch;
+	u8		SelectAntennaMap;
+
+	/*  Before link Antenna Switch check */
+	u8		SWAS_NoLink_State;
+	u32		SWAS_NoLink_BK_Reg860;
+};
+
+/*  */
+
+struct	dm_priv
+{
+	u8	DM_Type;
+	u8	DMFlag, DMFlag_tmp;
+
+	/* for DIG */
+	u8	bDMInitialGainEnable;
+	struct DIG_T	DM_DigTable;
+
+	struct PS_T	DM_PSTable;
+
+	struct FALSE_ALARM_STATISTICS	falsealmcnt;
+
+	/* for rate adaptive, in fact,  88c/92c fw will handle this */
+	u8	bUseRAMask;
+	struct rate_adaptive RateAdaptive;
+
+	/* Upper and Lower Signal threshold for Rate Adaptive*/
+	int	UndecoratedSmoothedPWDB;
+	int	EntryMinUndecoratedSmoothedPWDB;
+	int	EntryMaxUndecoratedSmoothedPWDB;
+	int	MinUndecoratedPWDBForDM;
+	int	LastMinUndecoratedPWDBForDM;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	int	RssiValMinForAnotherMacOfDMSP;
+	u32	CurDigValueForAnotherMacOfDMSP;
+	bool		bWriteDigForAnotherMacOfDMSP;
+	bool		bChangeCCKPDStateForAnotherMacOfDMSP;
+	u8	CurCCKPDStateForAnotherMacOfDMSP;
+	bool		bChangeTxHighPowerLvlForAnotherMacOfDMSP;
+	u8	CurTxHighLvlForAnotherMacOfDMSP;
+#endif
+
+	/* for High Power */
+	u8	bDynamicTxPowerEnable;
+	u8	LastDTPLvl;
+	u8	DynamicTxHighPowerLvl;/* Add by Jacken Tx Power Control for Near/Far Range 2008/03/06 */
+
+	/* for tx power tracking */
+	u8	bTXPowerTracking;
+	u8	TXPowercount;
+	u8	bTXPowerTrackingInit;
+	u8	TxPowerTrackControl;	/* for mp mode, turn off txpwrtracking as default */
+	u8	TM_Trigger;
+
+	u8	ThermalMeter[2];	/*  ThermalMeter, index 0 for RFIC0, and 1 for RFIC1 */
+	u8	ThermalValue;
+	u8	ThermalValue_LCK;
+	u8	ThermalValue_IQK;
+	u8	ThermalValue_AVG[AVG_THERMAL_NUM];
+	u8	ThermalValue_AVG_index;
+	u8	ThermalValue_RxGain;
+	u8	ThermalValue_Crystal;
+	u8	Delta_IQK;
+	u8	Delta_LCK;
+	u8	bRfPiEnable;
+	u8	bReloadtxpowerindex;
+	u8	bDoneTxpower;
+
+	/* for APK */
+	u32	APKoutput[2][2];	/* path A/B; output1_1a/output1_2a */
+	u8	bAPKdone;
+	u8	bAPKThermalMeterIgnore;
+	bool		bDPKdone[2];
+	bool		bDPKstore;
+	bool		bDPKworking;
+	u8	OFDM_min_index_internalPA_DPK[2];
+	u8	TxPowerLevelDPK[2];
+
+	u32	RegA24;
+
+	/* for IQK */
+	u32	Reg874;
+	u32	RegC08;
+	u32	Reg88C;
+	u8	Reg522;
+	u8	Reg550;
+	u8	Reg551;
+	u32	Reg870;
+	u32	ADDA_backup[IQK_ADDA_REG_NUM];
+	u32	IQK_MAC_backup[IQK_MAC_REG_NUM];
+	u32	IQK_BB_backup[IQK_BB_REG_NUM];
+
+	u8	bCCKinCH14;
+
+	char	CCK_index;
+	char	OFDM_index[2];
+
+	struct sw_antenna_switch DM_SWAT_Table;
+
+	/* for TxPwrTracking */
+	int	RegE94;
+	int	RegE9C;
+	int	RegEB4;
+	int	RegEBC;
+#if MP_DRIVER == 1
+	u8	RegC04_MP;
+	u32	RegD04_MP;
+#endif
+	u32	TXPowerTrackingCallbackCnt;	/* cosa add for debug */
+
+	u32	prv_traffic_idx; /*  edca turbo */
+
+	u32	RegRF3C[2];	/* pathA / pathB */
+
+	/*  Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas */
+	u8	INIDATA_RATE[32];
+};
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+/* define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;} */
+
+
+/*  */
+/*  function prototype */
+/*  */
+void rtl8192d_init_dm_priv(struct rtw_adapter * adapter);
+void rtl8192d_deinit_dm_priv(struct rtw_adapter * adapter);
+void	rtl8192d_InitHalDm(struct rtw_adapter * adapter);
+void	rtl8192d_HalDmWatchDog(struct rtw_adapter * adapter);
+
+void rtl8192d_dm_CheckTXPowerTracking(struct rtw_adapter * adapter);
+
+#endif	/* __HAL8190PCIDM_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_hal.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_hal.h
new file mode 100644
index 0000000..1030a3f
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_hal.h
@@ -0,0 +1,717 @@
+/******************************************************************************
+ *
+ *Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ *This program is free software; you can redistribute it and/or modify it
+ *under the terms of version 2 of the GNU General Public License as
+ *published by the Free Software Foundation.
+ *
+ *This program is distributed in the hope that it will be useful, but WITHOUT
+ *ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ *more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192D_HAL_H__
+#define __RTL8192D_HAL_H__
+
+#include "hal_com.h"
+#include "rtl8192d_spec.h"
+#include "hal8192dphyreg.h"
+#include "hal8192dphycfg.h"
+#include "rtl8192d_rf.h"
+#include "rtl8192d_dm.h"
+#include "rtl8192d_recv.h"
+#include "rtl8192d_xmit.h"
+#include "rtl8192d_cmd.h"
+
+/*---------------------------Define Local Constant---------------------------*/
+/* Channel switch:The size of command tables for switch channel*/
+#define MAX_PRECMD_CNT 16
+#define MAX_RFDEPENDCMD_CNT 16
+#define MAX_POSTCMD_CNT 16
+
+#define MAX_DOZE_WAITING_TIMES_9x 64
+
+#define MAX_RF_IMR_INDEX 12
+#define MAX_RF_IMR_INDEX_NORMAL 13
+#define RF_REG_NUM_for_C_CUT_5G		6
+#define RF_REG_NUM_for_C_CUT_5G_internalPA	7
+#define RF_REG_NUM_for_C_CUT_2G		5
+#define RF_CHNL_NUM_5G			19
+#define RF_CHNL_NUM_5G_40M		17
+#define TARGET_CHNL_NUM_5G	221
+#define TARGET_CHNL_NUM_2G	14
+#define TARGET_CHNL_NUM_2G_5G	59
+#define CV_CURVE_CNT			64
+
+extern atomic_t GlobalMutexForGlobaladapterList;
+/* add mutex to solve the problem that reading efuse and power on/fw download do */
+/* on the same time */
+extern atomic_t GlobalMutexForMac0_2G_Mac1_5G;
+extern atomic_t GlobalMutexForPowerAndEfuse;
+extern atomic_t GlobalMutexForPowerOnAndPowerOff;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+extern atomic_t GlobalCounterForMutex;
+extern bool GlobalFirstConfigurationForNormalChip;
+#endif
+
+
+
+static u32	   RF_REG_FOR_5G_SWCHNL_NORMAL[MAX_RF_IMR_INDEX_NORMAL]={0,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x0};
+
+static u8	RF_REG_for_C_CUT_5G[RF_REG_NUM_for_C_CUT_5G] =
+			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G4,	RF_SYN_G5,	RF_SYN_G6};
+
+static u8	RF_REG_for_C_CUT_5G_internalPA[RF_REG_NUM_for_C_CUT_5G_internalPA] =
+			{0x0B,	0x48,	0x49,	0x4B,	0x03,	0x04,	0x0E};
+static u8	RF_REG_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] =
+			{RF_SYN_G1, RF_SYN_G2,	RF_SYN_G3,	RF_SYN_G7,	RF_SYN_G8};
+
+#if DBG
+static u32	RF_REG_MASK_for_C_CUT_2G[RF_REG_NUM_for_C_CUT_2G] =
+			{BIT19|BIT18|BIT17|BIT14|BIT1,	BIT10|BIT9,
+			BIT18|BIT17|BIT16|BIT1,		BIT2|BIT1,
+			BIT15|BIT14|BIT13|BIT12|BIT11};
+#endif	/* amy, temp remove */
+static u8	RF_CHNL_5G[RF_CHNL_NUM_5G] =
+			{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140};
+static u8	RF_CHNL_5G_40M[RF_CHNL_NUM_5G_40M] =
+			{38,42,46,50,54,58,62,102,106,110,114,118,122,126,130,134,138};
+
+static u32	RF_REG_Param_for_C_CUT_5G[5][RF_REG_NUM_for_C_CUT_5G] = {
+			{0xE43BE,	0xFC638,	0x77C0A,	0xDE471,	0xd7110,	0x8EB04},
+			{0xE43BE,	0xFC078,	0xF7C1A,	0xE0C71,	0xD7550,	0xAEB04},
+			{0xE43BF,	0xFF038,	0xF7C0A,	0xDE471,	0xE5550,	0xAEB04},
+			{0xE43BF,	0xFF079,	0xF7C1A,	0xDE471,	0xE5550,	0xAEB04},
+			{0xE43BF,	0xFF038,	0xF7C1A,	0xDE471,	0xd7550,	0xAEB04}};
+
+static u32	RF_REG_Param_for_C_CUT_2G[3][RF_REG_NUM_for_C_CUT_2G] = {
+			{0x643BC,	0xFC038,	0x77C1A,	0x41289,	0x01840},
+			{0x643BC,	0xFC038,	0x07C1A,	0x41289,	0x01840},
+			{0x243BC,	0xFC438,	0x07C1A,	0x4128B,	0x0FC41}};
+
+#if SWLCK == 1
+static u32 RF_REG_SYN_G4_for_C_CUT_2G = 0xD1C31&0x7FF;
+#endif
+
+static u32	RF_REG_Param_for_C_CUT_5G_internalPA[3][RF_REG_NUM_for_C_CUT_5G_internalPA] = {
+			{0x01a00,	0x40443,	0x00eb5,	0x89bec,	0x94a12,	0x94a12,	0x94a12},
+			{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a52,	0x94a52,	0x94a52},
+			{0x01800,	0xc0443,	0x00730,	0x896ee,	0x94a12,	0x94a12,	0x94a12}};
+
+
+
+/* mode][patha+b][reg] */
+static u32 RF_IMR_Param_Normal[1][3][MAX_RF_IMR_INDEX_NORMAL]={{
+	{0x70000,0x00ff0,0x4400f,0x00ff0,0x0,0x0,0x0,0x0,0x0,0x64888,0xe266c,0x00090,0x22fff},/*  channel 1-14. */
+	{0x70000,0x22880,0x4470f,0x55880,0x00070, 0x88000, 0x0,0x88080,0x70000,0x64a82,0xe466c,0x00090,0x32c9a}, /* path 36-64 */
+	{0x70000,0x44880,0x4477f,0x77880,0x00070, 0x88000, 0x0,0x880b0,0x0,0x64b82,0xe466c,0x00090,0x32c9a} /* 100 -165 */
+}
+};
+
+static u32 CurveIndex[TARGET_CHNL_NUM_2G_5G]={0};
+
+static u32 TargetChnl_5G[TARGET_CHNL_NUM_5G] = {
+25141,	25116,	25091,	25066,	25041,
+25016,	24991,	24966,	24941,	24917,
+24892,	24867,	24843,	24818,	24794,
+24770,	24765,	24721,	24697,	24672,
+24648,	24624,	24600,	24576,	24552,
+24528,	24504,	24480,	24457,	24433,
+24409,	24385,	24362,	24338,	24315,
+24291,	24268,	24245,	24221,	24198,
+24175,	24151,	24128,	24105,	24082,
+24059,	24036,	24013,	23990,	23967,
+23945,	23922,	23899,	23876,	23854,
+23831,	23809,	23786,	23764,	23741,
+23719,	23697,	23674,	23652,	23630,
+23608,	23586,	23564,	23541,	23519,
+23498,	23476,	23454,	23432,	23410,
+23388,	23367,	23345,	23323,	23302,
+23280,	23259,	23237,	23216,	23194,
+23173,	23152,	23130,	23109,	23088,
+23067,	23046,	23025,	23003,	22982,
+22962,	22941,	22920,	22899,	22878,
+22857,	22837,	22816,	22795,	22775,
+22754,	22733,	22713,	22692,	22672,
+22652,	22631,	22611,	22591,	22570,
+22550,	22530,	22510,	22490,	22469,
+22449,	22429,	22409,	22390,	22370,
+22350,	22336,	22310,	22290,	22271,
+22251,	22231,	22212,	22192,	22173,
+22153,	22134,	22114,	22095,	22075,
+22056,	22037,	22017,	21998,	21979,
+21960,	21941,	21921,	21902,	21883,
+21864,	21845,	21826,	21807,	21789,
+21770,	21751,	21732,	21713,	21695,
+21676,	21657,	21639,	21620,	21602,
+21583,	21565,	21546,	21528,	21509,
+21491,	21473,	21454,	21436,	21418,
+21400,	21381,	21363,	21345,	21327,
+21309,	21291,	21273,	21255,	21237,
+21219,	21201,	21183,	21166,	21148,
+21130,	21112,	21095,	21077,	21059,
+21042,	21024,	21007,	20989,	20972,
+25679,	25653,	25627,	25601,	25575,
+25549,	25523,	25497,	25471,	25446,
+25420,	25394,	25369,	25343,	25318,
+25292,	25267,	25242,	25216,	25191,
+25166	};
+
+static u32 TargetChnl_2G[TARGET_CHNL_NUM_2G] = {	/*  channel 1~14 */
+26084, 26030, 25976, 25923, 25869, 25816, 25764,
+25711, 25658, 25606, 25554, 25502, 25451, 25328
+};
+
+
+#include "hal8192duhwimg.h"
+
+#ifdef CONFIG_WOWLAN
+	#include "hal8192duhwimg_wowlan.h"
+#endif /* CONFIG_WOWLAN */
+	#define RTL819X_DEFAULT_RF_TYPE		RF_1T2R
+
+/*  */
+/* 		RTL8192DU From file */
+/*  */
+	#define RTL8192D_PHY_REG					"rtl8192DU\\PHY_REG.txt"
+	#define RTL8192D_PHY_REG_PG				"rtl8192DU\\PHY_REG_PG.txt"
+	#define RTL8192D_PHY_REG_MP				"rtl8192DU\\PHY_REG_MP.txt"
+
+	#define RTL8192D_AGC_TAB					"rtl8192DU\\AGC_TAB.txt"
+	#define RTL8192D_AGC_TAB_2G				"rtl8192DU\\AGC_TAB_2G.txt"
+	#define RTL8192D_AGC_TAB_5G				"rtl8192DU\\AGC_TAB_5G.txt"
+	#define RTL8192D_PHY_RADIO_A				"rtl8192DU\\radio_a.txt"
+	#define RTL8192D_PHY_RADIO_B				"rtl8192DU\\radio_b.txt"
+	#define RTL8192D_PHY_RADIO_A_intPA		"rtl8192DU\\radio_a_intPA.txt"
+	#define RTL8192D_PHY_RADIO_B_intPA		"rtl8192DU\\radio_b_intPA.txt"
+	#define RTL8192D_PHY_MACREG				"rtl8192DU\\MAC_REG.txt"
+
+/*  */
+/* 		RTL8192DU From header */
+/*  */
+
+#ifdef CONFIG_WOWLAN
+	#define Rtl8192D_FwWWImageArray				Rtl8192DUFwWWImgArray
+#endif /* CONFIG_WOWLAN */
+	/*  MAC/BB/PHY Array */
+	#define Rtl8192D_MAC_Array						Rtl8192DUMAC_2T_Array
+	#define Rtl8192D_AGCTAB_Array					Rtl8192DUAGCTAB_Array
+	#define Rtl8192D_AGCTAB_5GArray				Rtl8192DUAGCTAB_5GArray
+	#define Rtl8192D_AGCTAB_2GArray				Rtl8192DUAGCTAB_2GArray
+	#define Rtl8192D_AGCTAB_2TArray					Rtl8192DUAGCTAB_2TArray
+	#define Rtl8192D_AGCTAB_1TArray					Rtl8192DUAGCTAB_1TArray
+	#define Rtl8192D_PHY_REG_2TArray				Rtl8192DUPHY_REG_2TArray
+	#define Rtl8192D_PHY_REG_1TArray				Rtl8192DUPHY_REG_1TArray
+	#define Rtl8192D_PHY_REG_Array_PG				Rtl8192DUPHY_REG_Array_PG
+	#define Rtl8192D_PHY_REG_Array_MP				Rtl8192DUPHY_REG_Array_MP
+	#define Rtl8192D_RadioA_2TArray					Rtl8192DURadioA_2TArray
+	#define Rtl8192D_RadioA_1TArray					Rtl8192DURadioA_1TArray
+	#define Rtl8192D_RadioB_2TArray					Rtl8192DURadioB_2TArray
+	#define Rtl8192D_RadioB_1TArray					Rtl8192DURadioB_1TArray
+	#define Rtl8192D_RadioA_2T_intPAArray			Rtl8192DURadioA_2T_intPAArray
+	#define Rtl8192D_RadioB_2T_intPAArray			Rtl8192DURadioB_2T_intPAArray
+
+	/*  Array length */
+	#define Rtl8192D_FwImageArrayLength			Rtl8192DUImgArrayLength
+	#define Rtl8192D_MAC_ArrayLength				Rtl8192DUMAC_2T_ArrayLength
+	#define Rtl8192D_AGCTAB_5GArrayLength			Rtl8192DUAGCTAB_5GArrayLength
+	#define Rtl8192D_AGCTAB_2GArrayLength			Rtl8192DUAGCTAB_2GArrayLength
+	#define Rtl8192D_AGCTAB_2TArrayLength			Rtl8192DUAGCTAB_2TArrayLength
+	#define Rtl8192D_AGCTAB_1TArrayLength			Rtl8192DUAGCTAB_1TArrayLength
+	#define Rtl8192D_AGCTAB_ArrayLength			Rtl8192DUAGCTAB_ArrayLength
+	#define Rtl8192D_PHY_REG_2TArrayLength			Rtl8192DUPHY_REG_2TArrayLength
+	#define Rtl8192D_PHY_REG_1TArrayLength			Rtl8192DUPHY_REG_1TArrayLength
+	#define Rtl8192D_PHY_REG_Array_PGLength		Rtl8192DUPHY_REG_Array_PGLength
+	#define Rtl8192D_PHY_REG_Array_MPLength		Rtl8192DUPHY_REG_Array_MPLength
+	#define Rtl8192D_RadioA_2TArrayLength			Rtl8192DURadioA_2TArrayLength
+	#define Rtl8192D_RadioB_2TArrayLength			Rtl8192DURadioB_2TArrayLength
+	#define Rtl8192D_RadioA_2T_intPAArrayLength		Rtl8192DURadioA_2T_intPAArrayLength
+	#define Rtl8192D_RadioB_2T_intPAArrayLength		Rtl8192DURadioB_2T_intPAArrayLength
+
+	/*  The file name "_2T" is for 92CU, "_1T"  is for 88CU. Modified by tynli. 2009.11.24. */
+
+#define DRVINFO_SZ	4 /*  unit is 8bytes */
+#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
+
+/*  Check if FW header exists. Ignore the lower 4 bits in this case. */
+#define IS_FW_HEADER_EXIST(_fwhdr)				\
+	((le16_to_cpu(_fwhdr->Signature)&0xFFF0) == 0x92C0 ||	\
+	(le16_to_cpu(_fwhdr->Signature)&0xFFF0) == 0x88C0 ||	\
+	(le16_to_cpu(_fwhdr->Signature)&0xFFFF) == 0x92D0 ||	\
+	(le16_to_cpu(_fwhdr->Signature)&0xFFFF) == 0x92D1 ||	\
+	(le16_to_cpu(_fwhdr->Signature)&0xFFFF) == 0x92D2 ||	\
+	(le16_to_cpu(_fwhdr->Signature)&0xFFFF) == 0x92D3)
+
+/* Max FW len = 32k + 32(FW header length). */
+#define FW_8192D_SIZE		0x8020
+#define FW_8192D_START_ADDRESS	0x1000
+#define FW_8192D_END_ADDRESS	0x1FFF
+
+#define MAX_PAGE_SIZE		4096	/*  @ page : 4k bytes */
+
+struct rt_firmware_92d {
+	u8 *buffer;
+	u32 length;
+#ifdef CONFIG_WOWLAN
+	u8 *wowbuffer;
+	u32 wowlength;
+#endif /* CONFIG_WOWLAN */
+};
+
+/*  This structure must be careful with le byte-ordering */
+struct rt_8192d_firmware_hdr { /* 8-byte alinment required */
+	/*  LONG WORD 0 ---- */
+
+	/*  92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut;
+	 * 92C1: MP A-cut
+	 */
+	__le16		Signature;
+	u8		Category;	/*  AP/NIC and USB/PCI */
+	/* Reserved for different FW function indication, for further use when
+	 * driver needs to download different FW in different conditions
+	 */
+	u8		Function;
+	__le16		Version;		/*  FW Version */
+	u8		Subversion;	/*  FW Subversion, default 0x00 */
+	u8		Rsvd1;
+
+
+	/*  LONG WORD 1 ---- */
+	u8		Month;	/*  Release time Month field */
+	u8		Date;	/*  Release time Date field */
+	u8		Hour;	/*  Release time Hour field */
+	u8		Minute;	/*  Release time Minute field */
+	u16		RamCodeSize;	/*  The size of RAM code */
+	u16		Rsvd2;
+
+	/*  LONG WORD 2 ---- */
+	u32		SvnIdx;	/*  The SVN entry index */
+	u32		Rsvd3;
+
+	/*  LONG WORD 3 ---- */
+	u32		Rsvd4;
+	u32		Rsvd5;
+};
+
+#define DRIVER_EARLY_INT_TIME		0x05
+#define BCN_DMA_ATIME_INT_TIME		0x02
+
+/* Added for 92D IQK setting. */
+struct iqk_matrix_regs_setting {
+	bool		bIQKDone;
+	int		Value[1][IQK_Matrix_REG_NUM];
+};
+
+enum USB_RX_AGG_MODE {
+	USB_RX_AGG_DISABLE,
+	USB_RX_AGG_DMA,
+	USB_RX_AGG_USB,
+	USB_RX_AGG_DMA_USB
+};
+
+#define MAX_RX_DMA_BUFFER_SIZE	10240		/*  10K for 8192C RX DMA buf */
+
+#define TX_SELE_HQ		BIT(0)		/*  High Queue */
+#define TX_SELE_LQ		BIT(1)		/*  Low Queue */
+#define TX_SELE_NQ		BIT(2)		/*  Normal Queue */
+
+
+/* Note: We will divide number of page equally for each queue
+ * other than public queue!
+ */
+
+#define TX_TOTAL_PAGE_NUMBER		0xF8
+#define TX_PAGE_BOUNDARY		(TX_TOTAL_PAGE_NUMBER + 1)
+
+/*  For Normal Chip Setting */
+/*  (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
+#define NORMAL_PAGE_NUM_PUBQ		0x56
+
+
+/*  For Test Chip Setting */
+/*  (HPQ + LPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER */
+#define TEST_PAGE_NUM_PUBQ			0x89
+#define TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC		0x7A
+#define NORMAL_PAGE_NUM_PUBQ_92D_DUAL_MAC			0x5A
+#define NORMAL_PAGE_NUM_HPQ_92D_DUAL_MAC			0x10
+#define NORMAL_PAGE_NUM_LPQ_92D_DUAL_MAC			0x10
+#define NORMAL_PAGE_NUM_NORMALQ_92D_DUAL_MAC		0
+
+#define TX_PAGE_BOUNDARY_DUAL_MAC			(TX_TOTAL_PAGE_NUMBER_92D_DUAL_MAC + 1)
+
+/*  For Test Chip Setting */
+#define WMM_TEST_TX_TOTAL_PAGE_NUMBER	0xF5
+#define WMM_TEST_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
+
+#define WMM_TEST_PAGE_NUM_PUBQ		0xA3
+#define WMM_TEST_PAGE_NUM_HPQ		0x29
+#define WMM_TEST_PAGE_NUM_LPQ		0x29
+
+
+/* Note: For Normal Chip Setting ,modify later */
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER	0xF5
+#define WMM_NORMAL_TX_PAGE_BOUNDARY	(WMM_TEST_TX_TOTAL_PAGE_NUMBER + 1) /* F6 */
+
+#define WMM_NORMAL_PAGE_NUM_PUBQ		0xB0
+#define WMM_NORMAL_PAGE_NUM_HPQ		0x29
+#define WMM_NORMAL_PAGE_NUM_LPQ			0x1C
+#define WMM_NORMAL_PAGE_NUM_NPQ		0x1C
+
+#define WMM_NORMAL_PAGE_NUM_PUBQ_92D		0X65/* 0x82 */
+#define WMM_NORMAL_PAGE_NUM_HPQ_92D		0X30/* 0x29 */
+#define WMM_NORMAL_PAGE_NUM_LPQ_92D		0X30
+#define WMM_NORMAL_PAGE_NUM_NPQ_92D		0X30
+
+/*  */
+/* 	Chip specific */
+/*  */
+
+#define CHIP_BONDING_IDENTIFIER(_value)	(((_value)>>22)&0x3)
+#define CHIP_BONDING_92C_1T2R	0x1
+#define CHIP_BONDING_88C_USB_MCARD	0x2
+#define CHIP_BONDING_88C_USB_HP	0x1
+
+/*  */
+/*  2011.01.06. Define new structure of chip version for RTL8723 and so on. Added by tynli. */
+/*  */
+/*
+     | BIT15:12           |  BIT11:8        | BIT 7              |  BIT6:4  |      BIT3          | BIT2:0  |
+     |-------------+-----------+-----------+-------+-----------+-------|
+     | IC version(CUT)  | ROM version  | Manufacturer  | RF type  |  Chip type       | IC Type |
+     |                           |                      | TSMC/UMC    |              | TEST/NORMAL|             |
+*/
+/*  [15:12] IC version(CUT): A-cut=0, B-cut=1, C-cut=2, D-cut=3 */
+/*  [7] Manufacturer: TSMC=0, UMC=1 */
+/*  [6:4] RF type: 1T1R=0, 1T2R=1, 2T2R=2 */
+/*  [3] Chip type: TEST=0, NORMAL=1 */
+/*  [2:0] IC type: 81xxC=0, 8723=1, 92D=2 */
+
+#define CHIP_8723						BIT(0)
+#define CHIP_92D						BIT(1)
+#define NORMAL_CHIP					BIT(3)
+#define RF_TYPE_1T1R					(~(BIT(4)|BIT(5)|BIT(6)))
+#define RF_TYPE_1T2R					BIT(4)
+#define RF_TYPE_2T2R					BIT(5)
+#define CHIP_VENDOR_UMC				BIT(7)
+#define B_CUT_VERSION					BIT(12)
+#define C_CUT_VERSION					BIT(13)
+#define D_CUT_VERSION					((BIT(12)|BIT(13)))
+#define E_CUT_VERSION					BIT(14)
+
+
+/*  MASK */
+#define IC_TYPE_MASK					(BIT(0)|BIT(1)|BIT(2))
+#define CHIP_TYPE_MASK				BIT(3)
+#define RF_TYPE_MASK					(BIT(4)|BIT(5)|BIT(6))
+#define MANUFACTUER_MASK			BIT(7)
+#define ROM_VERSION_MASK				(BIT(11)|BIT(10)|BIT(9)|BIT(8))
+#define CUT_VERSION_MASK				(BIT(15)|BIT(14)|BIT(13)|BIT(12))
+
+/*  Get element */
+#define GET_CVID_IC_TYPE(version)			((version) & IC_TYPE_MASK)
+#define GET_CVID_CHIP_TYPE(version)			((version) & CHIP_TYPE_MASK)
+#define GET_CVID_RF_TYPE(version)			((version) & RF_TYPE_MASK)
+#define GET_CVID_MANUFACTUER(version)		((version) & MANUFACTUER_MASK)
+#define GET_CVID_ROM_VERSION(version)		((version) & ROM_VERSION_MASK)
+#define GET_CVID_CUT_VERSION(version)		((version) & CUT_VERSION_MASK)
+
+#define IS_81XXC(version)					((GET_CVID_IC_TYPE(version) == 0)? true : false)
+#define IS_8723_SERIES(version)				((GET_CVID_IC_TYPE(version) == CHIP_8723)? true : false)
+#define IS_92D(version)						((GET_CVID_IC_TYPE(version) == CHIP_92D)? true : false)
+#define IS_1T1R(version)						((GET_CVID_RF_TYPE(version))? false : true)
+#define IS_1T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? true : false)
+#define IS_2T2R(version)						((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? true : false)
+#define IS_CHIP_VENDOR_UMC(version)			((GET_CVID_MANUFACTUER(version))? true: false)
+
+#define IS_92C_SERIAL(version)					((IS_81XXC(version) && IS_2T2R(version)) ? true : false)
+#define IS_VENDOR_UMC_A_CUT(version)		((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
+#define IS_VENDOR_8723_A_CUT(version)		((IS_8723_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version)) ? false : true) : false)
+/*  <tynli_Note> 88/92C UMC B-cut vendor is set to TSMC so we need to check CHIP_VENDOR_UMC bit is not 1. */
+#define IS_81xxC_VENDOR_UMC_B_CUT(version)	((IS_CHIP_VENDOR_UMC(version)) ? ((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? true : false):false)
+#define IS_92D_SINGLEPHY(version)			((IS_92D(version)) ? (IS_2T2R(version) ? true: false) : false)
+
+#define IS_92D_C_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? true : false) : false)
+#define IS_92D_D_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? true : false) : false)
+#define IS_92D_E_CUT(version)				((IS_92D(version)) ? ((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? true : false) : false)
+#define IS_NORMAL_CHIP92D(version)		((GET_CVID_CHIP_TYPE(version)) ? true : false)
+
+enum VERSION_8192D {
+	VERSION_TEST_CHIP_88C = 0x0000,
+	VERSION_TEST_CHIP_92C = 0x0020,
+	VERSION_TEST_UMC_CHIP_8723 = 0x0081,
+	VERSION_NORMAL_TSMC_CHIP_88C = 0x0008,
+	VERSION_NORMAL_TSMC_CHIP_92C = 0x0028,
+	VERSION_NORMAL_TSMC_CHIP_92C_1T2R = 0x0018,
+	VERSION_NORMAL_UMC_CHIP_88C_A_CUT = 0x0088,
+	VERSION_NORMAL_UMC_CHIP_92C_A_CUT = 0x00a8,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT = 0x0098,
+	VERSION_NORMAL_UMC_CHIP_8723_1T1R_A_CUT = 0x0089,
+	VERSION_NORMAL_UMC_CHIP_8723_1T1R_B_CUT = 0x1089,
+	VERSION_NORMAL_UMC_CHIP_88C_B_CUT = 0x1088,
+	VERSION_NORMAL_UMC_CHIP_92C_B_CUT = 0x10a8,
+	VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT = 0x1090,
+	VERSION_TEST_CHIP_92D_SINGLEPHY= 0x0022,
+	VERSION_TEST_CHIP_92D_DUALPHY = 0x0002,
+	VERSION_NORMAL_CHIP_92D_SINGLEPHY= 0x002a,
+	VERSION_NORMAL_CHIP_92D_DUALPHY = 0x000a,
+	VERSION_NORMAL_CHIP_92D_C_CUT_SINGLEPHY = 0x202a,
+	VERSION_NORMAL_CHIP_92D_C_CUT_DUALPHY = 0x200a,
+	VERSION_NORMAL_CHIP_92D_D_CUT_SINGLEPHY = 0x302a,
+	VERSION_NORMAL_CHIP_92D_D_CUT_DUALPHY = 0x300a,
+	VERSION_NORMAL_CHIP_92D_E_CUT_SINGLEPHY = 0x402a,
+	VERSION_NORMAL_CHIP_92D_E_CUT_DUALPHY = 0x400a,
+};
+
+
+/*  */
+/* 	Channel Plan */
+/*  */
+enum ChannelPlan{
+	CHPL_FCC	= 0,
+	CHPL_IC		= 1,
+	CHPL_ETSI	= 2,
+	CHPL_SPA= 3,
+	CHPL_FRANCE	= 4,
+	CHPL_MKK	= 5,
+	CHPL_MKK1	= 6,
+	CHPL_ISRAEL	= 7,
+	CHPL_TELEC	= 8,
+	CHPL_GLOBAL	= 9,
+	CHPL_WORLD	= 10,
+};
+
+struct tx_power_info {
+	u8 CCKIndex[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40_1SIndex[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40_2SIndexDiff[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	s8 HT20IndexDiff[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 OFDMIndexDiff[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT40MaxOffset[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 HT20MaxOffset[RF_PATH_MAX][CHANNEL_GROUP_MAX];
+	u8 TSSI_A[3];
+	u8 TSSI_B[3];
+	u8 TSSI_A_5G[3];		/* 5GL/5GM/5GH */
+	u8 TSSI_B_5G[3];
+};
+
+#define EFUSE_REAL_CONTENT_LEN	1024
+#define EFUSE_MAP_LEN				256
+#define EFUSE_MAX_SECTION			32
+#define EFUSE_MAX_SECTION_BASE	16
+/*  <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section */
+/*  9bytes + 1byt + 5bytes and pre 1byte. */
+/*  For worst case: */
+/*  | 2byte|----8bytes----|1byte|--7bytes--| 92D */
+#define EFUSE_OOB_PROTECT_BYTES		18 /*  PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte. */
+
+enum PA_MODE {
+	PA_MODE_EXTERNAL = 0x00,
+	PA_MODE_INTERNAL_SP3T = 0x01,
+	PA_MODE_INTERNAL_SPDT = 0x02
+};
+
+/* Copy from rtl8192c */
+enum c2h_id_8192d {
+	C2H_DBG = 0,
+	C2H_TSF = 1,
+	C2H_AP_RPT_RSP = 2,
+	C2H_CCX_TX_RPT = 3,
+	C2H_BT_RSSI = 4,
+	C2H_BT_OP_MODE = 5,
+	C2H_EXT_RA_RPT = 6,
+	C2H_HW_INFO_EXCH = 10,
+	C2H_C2H_H2C_TEST = 11,
+	C2H_BT_INFO = 12,
+	C2H_BT_MP_INFO = 15,
+	MAX_C2HEVENT
+};
+
+struct hal_data_8192du {
+	enum VERSION_8192D	VersionID;
+
+	/*  add for 92D Phy mode/mac/Band mode */
+	enum MACPHY_MODE_8192D	MacPhyMode92D;
+	enum BAND_TYPE	CurrentBandType92D;	/* 0:2.4G, 1:5G */
+	enum BAND_TYPE	BandSet92D;
+	bool		bIsVS;
+
+	bool		bNOPG;
+
+	bool		bSupportRemoteWakeUp;
+	bool		bMasterOfDMSP;
+	bool		bSlaveOfDMSP;
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	bool		bInModeSwitchProcess;
+#endif
+
+	u16	CustomerID;
+
+	u16	FirmwareVersion;
+	u16	FirmwareVersionRev;
+	u16	FirmwareSubVersion;
+
+	/* current WIFI_PHY values */
+	u32	ReceiveConfig;
+	enum WIRELESS_MODE	CurrentWirelessMode;
+	enum HT_CHANNEL_WIDTH	CurrentChannelBW;
+	u8	CurrentChannel;
+	u8	nCur40MhzPrimeSC;/*  Control channel sub-carrier */
+	u16	BasicRateSet;
+
+	/* rf_ctrl */
+	u8	rf_chip;
+	u8	rf_type;
+	u8	NumTotalRFPath;
+
+	/*  */
+	/*  EEPROM setting. */
+	/*  */
+	u8	EEPROMVersion;
+	u16	EEPROMVID;
+	u16	EEPROMPID;
+	u16	EEPROMSVID;
+	u16	EEPROMSDID;
+	u8	EEPROMCustomerID;
+	u8	EEPROMSubCustomerID;
+	u8	EEPROMRegulatory;
+
+	u8	EEPROMThermalMeter;
+
+	u8	EEPROMC9;
+	u8	EEPROMCC;
+	u8	PAMode;
+
+	u8	TxPwrLevelCck[RF_PATH_MAX][CHANNEL_MAX_NUMBER_2G];
+	u8	TxPwrLevelHT40_1S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	/*  For HT 40MHZ pwr */
+	u8	TxPwrLevelHT40_2S[RF_PATH_MAX][CHANNEL_MAX_NUMBER];	/*  For HT 40MHZ pwr */
+	s8	TxPwrHt20Diff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];/*  HT 20<->40 Pwr diff */
+	u8	TxPwrLegacyHtDiff[RF_PATH_MAX][CHANNEL_MAX_NUMBER];/*  For HT<->legacy pwr diff */
+	/*  For power group */
+	u8	PwrGroupHT20[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
+	u8	PwrGroupHT40[RF_PATH_MAX][CHANNEL_MAX_NUMBER];
+
+	u8	LegacyHTTxPowerDiff;/*  Legacy to HT rate power diff */
+
+	u8	CrystalCap;	/*  CrystalCap. */
+
+#ifdef CONFIG_BT_COEXIST
+	struct btcoexist_priv	bt_coexist;
+#endif
+
+	/*  Read/write are allow for following hardware information variables */
+	u8	framesync;
+	u32	framesyncC34;
+	u8	framesyncMonitor;
+	u8	DefaultInitialGain[4];
+	u8	pwrGroupCnt;
+	u32	MCSTxPowerLevelOriginalOffset[MAX_PG_GROUP][16];
+	u32	CCKTxPowerLevelOriginalOffset;
+
+	u32	AntennaTxPath;					/*  Antenna path Tx */
+	u32	AntennaRxPath;					/*  Antenna path Rx */
+	u8	BluetoothCoexist;
+	u8	ExternalPA;
+	u8	InternalPA5G[2];	/* pathA / pathB */
+	u8	b1x1RecvCombine;	/*  for 1T1R receive combining */
+
+	u8	bCurrentTurboEDCA;
+	u32	AcParam_BE; /* Original parameter for BE, use for EDCA turbo. */
+
+	/*  The current Tx Power Level */
+	u8	CurrentCckTxPwrIdx;
+	u8	CurrentOfdm24GTxPwrIdx;
+
+	struct bb_register_def PHYRegDef[4];	/* Radio A/B/C/D */
+
+	bool		bRFPathRxEnable[4];	/*  We support 4 RF path now. */
+
+	u32	RfRegChnlVal[2];
+
+	u8	bCckHighPower;
+
+	bool		bPhyValueInitReady;
+
+	bool		bTXPowerDataReadFromEEPORM;
+
+	bool		bInSetPower;
+
+	/* RDG enable */
+	bool		bRDGEnable;
+
+	bool		bLoadIMRandIQKSettingFor2G;/*  True if IMR or IQK  have done  for 2.4G in scan progress */
+	bool		bNeedIQK;
+
+	bool		bLCKInProgress;
+
+	bool		bEarlyModeEnable;
+
+	struct iqk_matrix_regs_setting IQKMatrixRegSetting[IQK_Matrix_Settings_NUM];
+
+	/* for host message to fw */
+	u8	LastHMEBoxNum;
+	u8	fw_ractrl;
+	/*  Beacon function related global variable. */
+	u32	RegBcnCtrlVal;
+	u8	RegTxPause;
+	u8	RegFwHwTxQCtrl;
+	u8	RegReg542;
+	u8	RegCR_1;
+	struct dm_priv	dmpriv;
+	u8	FwRsvdPageStartOffset; /* 2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ. */
+
+	/* Query RF by FW */
+	bool		bReadRFbyFW;
+
+	/*  For 92C USB endpoint setting */
+	/*  */
+
+	u32	UsbBulkOutSize;
+
+	int	RtBulkOutPipe[3];
+	int	RtBulkInPipe;
+	int	RtIntInPipe;
+
+	/*  Add for dual MAC  0--Mac0 1--Mac1 */
+	u32	interfaceIndex;
+
+	u8	OutEpQueueSel;
+	u8	OutEpNumber;
+
+	u8	Queue2EPNum[8];/* for out endpoint number mapping */
+
+	u8	UsbTxAggMode;
+	u8	UsbTxAggDescNum;
+	u16	HwRxPageSize;				/*  Hardware setting */
+	u32	MaxUsbRxAggBlock;
+
+	enum USB_RX_AGG_MODE	UsbRxAggMode;
+	u8	UsbRxAggBlockCount;			/*  USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed */
+	u8	UsbRxAggBlockTimeout;
+	u8	UsbRxAggPageCount;			/*  8192C DMA page count */
+	u8	UsbRxAggPageTimeout;
+
+	u16	RegRRSR;
+
+	u16	EfuseUsedBytes;
+	u8	RTSInitRate;	 /*  2010.11.24.by tynli. */
+};
+
+#define GET_HAL_DATA(__adapter)	((struct hal_data_8192du *)((__adapter)->HalData))
+#define GET_RF_TYPE(priv)	(GET_HAL_DATA(priv)->rf_type)
+
+int FirmwareDownload92D(struct rtw_adapter * adapter,bool  bUsedWoWLANFw);
+void rtl8192d_FirmwareSelfReset(struct rtw_adapter * adapter);
+void rtl8192d_ReadChipVersion(struct rtw_adapter * adapter);
+void rtl8192d_EfuseParseChnlPlan(struct rtw_adapter * adapter, u8 *hwinfo, bool AutoLoadFail);
+void rtl8192d_ReadTxPowerInfo(struct rtw_adapter * adapter, u8* PROMContent, bool AutoLoadFail);
+void rtl8192d_ResetDualMacSwitchVariables(struct rtw_adapter * adapter);
+u8 GetEEPROMSize8192D(struct rtw_adapter * adapter);
+bool PHY_CheckPowerOffFor8192D(struct rtw_adapter * adapter);
+void PHY_SetPowerOnFor8192D(struct rtw_adapter * adapter);
+void rtl8192d_free_hal_data(struct rtw_adapter *padapter);
+void rtl8192d_set_hal_ops(struct hal_ops *pHalFunc);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_led.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_led.h
new file mode 100644
index 0000000..d17b952
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_led.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8192D_LED_H_
+#define __RTL8192D_LED_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+/*  */
+/*  Interface to manipulate LED objects. */
+/*  */
+void rtl8192du_InitSwLeds(struct rtw_adapter *padapter);
+void rtl8192du_DeInitSwLeds(struct rtw_adapter *padapter);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_recv.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_recv.h
new file mode 100644
index 0000000..98b1724
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_recv.h
@@ -0,0 +1,103 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8192D_RECV_H_
+#define _RTL8192D_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef CONFIG_SINGLE_RECV_BUF
+	#define NR_RECVBUFF (1)
+#else
+	#define NR_RECVBUFF (4)
+#endif /* CONFIG_SINGLE_RECV_BUF */
+	#define NR_PREALLOC_RECV_SKB (8)
+
+#define RECV_BLK_SZ 512
+#define RECV_BLK_CNT 16
+#define RECV_BLK_TH RECV_BLK_CNT
+
+#define MAX_RECVBUF_SZ (8192+1024) /*  8K+1k */
+
+#define RECV_BULK_IN_ADDR		0x80
+#define RECV_INT_IN_ADDR		0x81
+
+#define PHY_RSSI_SLID_WIN_MAX				100
+#define PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+struct phy_stat {
+	unsigned int phydw0;
+	unsigned int phydw1;
+	unsigned int phydw2;
+	unsigned int phydw3;
+	unsigned int phydw4;
+	unsigned int phydw5;
+	unsigned int phydw6;
+	unsigned int phydw7;
+};
+
+struct phy_ofdm_rx_status_report_8192cd {
+	unsigned char	trsw_gain_X[4];
+	unsigned char	pwdb_all;
+	unsigned char	cfosho_X[4];
+	unsigned char	cfotail_X[4];
+	unsigned char	rxevm_X[2];
+	unsigned char	rxsnr_X[4];
+	unsigned char	pdsnr_X[2];
+	unsigned char	csi_current_X[2];
+	unsigned char	csi_target_X[2];
+	unsigned char	sigevm;
+	unsigned char	max_ex_pwr;
+#ifdef __LITTLE_ENDIAN
+	unsigned char ex_intf_flg:1;
+	unsigned char sgi_en:1;
+	unsigned char rxsc:2;
+	unsigned char idle_long:1;
+	unsigned char r_ant_train_en:1;
+	unsigned char ANTSELB:1;
+	unsigned char ANTSEL:1;
+#else	/*  __BIG_ENDIAN */
+	unsigned char ANTSEL:1;
+	unsigned char ANTSELB:1;
+	unsigned char r_ant_train_en:1;
+	unsigned char idle_long:1;
+	unsigned char rxsc:2;
+	unsigned char sgi_en:1;
+	unsigned char ex_intf_flg:1;
+#endif
+} __packed;
+
+struct phy_cck_rx_status_report_8192cd {
+	/* For CCK rate descriptor. This is a signed 8:1 variable. LSB bit presend
+		0.5. And MSB 7 bts presend a signed value. Range from -64~+63.5. */
+	u8	adc_pwdb_X[4];
+	u8	SQ_rpt;
+	u8	cck_agc_rpt;
+};
+
+/*  Rx smooth factor */
+#define	Rx_Smooth_Factor (20)
+
+void rtl8192du_init_recvbuf(struct rtw_adapter *padapter, struct recv_buf *precvbuf);
+int	rtl8192du_init_recv_priv(struct rtw_adapter * padapter);
+void	rtl8192du_free_recv_priv(struct rtw_adapter * padapter);
+
+void rtl8192d_translate_rx_signal_stuff(struct recv_frame_hdr *precvframe, struct phy_stat *pphy_info);
+void rtl8192d_query_rx_desc_status(struct recv_frame_hdr *precvframe, struct recv_stat *pdesc);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_rf.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_rf.h
new file mode 100644
index 0000000..8244d89
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_rf.h
@@ -0,0 +1,91 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *
+ * Module:	rtl8192d_rf.h	(Header File)
+ *
+ * Note:	Collect every HAL RF type exter API or constant.
+ *
+ * Function:
+ *
+ * Export:
+ *
+ * Abbrev:
+ *
+ * History:
+ * Data			Who		Remark
+ *
+ * 09/25/2008	MHC		Create initial version.
+ *
+ *
+******************************************************************************/
+#ifndef _RTL8192D_RF_H_
+#define _RTL8192D_RF_H_
+/* Check to see if the file has been included already.  */
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*  */
+/*  For RF 6052 Series */
+/*  */
+#define		RF6052_MAX_TX_PWR			0x3F
+#define		RF6052_MAX_REG				0x3F
+#define		RF6052_MAX_PATH				2
+/*--------------------------Define Parameters-------------------------------*/
+
+
+/*------------------------------Define structure----------------------------*/
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+/*------------------------Export Marco Definition---------------------------*/
+
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+
+/*  */
+/*  RF RL6052 Series API */
+/*  */
+void		rtl8192d_PHY_RF6052SetBandwidth(
+										struct rtw_adapter *				adapter,
+					enum HT_CHANNEL_WIDTH		Bandwidth);
+void	rtl8192d_PHY_RF6052SetCckTxPower(
+										struct rtw_adapter *	adapter,
+										u8*		pPowerlevel);
+void	rtl8192d_PHY_RF6052SetOFDMTxPower(
+										struct rtw_adapter *	adapter,
+										u8*		pPowerLevel,
+										u8		Channel);
+int	PHY_RF6052_Config8192D(	struct rtw_adapter *		adapter	);
+
+bool	rtl8192d_PHY_EnableAnotherPHY(struct rtw_adapter * adapter, bool	 bMac0);
+
+void	rtl8192d_PHY_PowerDownAnotherPHY(struct rtw_adapter * adapter, bool bMac0);
+
+
+/*--------------------------Exported Function prototype---------------------*/
+
+
+#endif/* End of HalRf.h */
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_spec.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_spec.h
new file mode 100644
index 0000000..78ea431
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_spec.h
@@ -0,0 +1,1721 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __RTL8192D_SPEC_H__
+#define __RTL8192D_SPEC_H__
+
+#include <drv_conf.h>
+
+#ifndef BIT
+#define BIT(x)		(1 << (x))
+#endif
+
+#define BIT0		0x00000001
+#define BIT1		0x00000002
+#define BIT2		0x00000004
+#define BIT3		0x00000008
+#define BIT4		0x00000010
+#define BIT5		0x00000020
+#define BIT6		0x00000040
+#define BIT7		0x00000080
+#define BIT8		0x00000100
+#define BIT9		0x00000200
+#define BIT10	0x00000400
+#define BIT11	0x00000800
+#define BIT12	0x00001000
+#define BIT13	0x00002000
+#define BIT14	0x00004000
+#define BIT15	0x00008000
+#define BIT16	0x00010000
+#define BIT17	0x00020000
+#define BIT18	0x00040000
+#define BIT19	0x00080000
+#define BIT20	0x00100000
+#define BIT21	0x00200000
+#define BIT22	0x00400000
+#define BIT23	0x00800000
+#define BIT24	0x01000000
+#define BIT25	0x02000000
+#define BIT26	0x04000000
+#define BIT27	0x08000000
+#define BIT28	0x10000000
+#define BIT29	0x20000000
+#define BIT30	0x40000000
+#define BIT31	0x80000000
+
+
+/*  */
+/*        8192D Regsiter offset definition */
+/*  */
+
+
+/*  */
+/*  */
+/*  */
+
+/*  */
+/*  */
+/* 	0x0000h ~ 0x00FFh	System Configuration */
+/*  */
+/*  */
+#define REG_SYS_ISO_CTRL			0x0000
+#define REG_SYS_FUNC_EN			0x0002
+#define REG_APS_FSMCO				0x0004
+#define REG_SYS_CLKR				0x0008
+#define REG_9346CR					0x000A
+#define REG_EE_VPD					0x000C
+#define REG_AFE_MISC				0x0010
+#define REG_SPS0_CTRL				0x0011
+#define REG_POWER_OFF_IN_PROCESS 0x0017
+#define REG_SPS_OCP_CFG			0x0018
+#define REG_RSV_CTRL				0x001C
+#define REG_RF_CTRL					0x001F
+#define REG_LDOA15_CTRL			0x0020
+#define REG_LDOV12D_CTRL			0x0021
+#define REG_LDOHCI12_CTRL			0x0022
+#define REG_LPLDO_CTRL				0x0023
+#define REG_AFE_XTAL_CTRL			0x0024
+#define REG_AFE_PLL_CTRL			0x0028
+#define REG_MAC_PHY_CTRL			0x002c /* for 92d, DMDP,SMSP,DMSP contrl */
+#define REG_EFUSE_CTRL				0x0030
+#define REG_EFUSE_TEST				0x0034
+#define REG_PWR_DATA				0x0038
+#define REG_CAL_TIMER				0x003C
+#define REG_ACLK_MON				0x003E
+#define REG_GPIO_MUXCFG			0x0040
+/* define REG_GPIO_MUXCFG				0x0041 */
+#define REG_GPIO_IO_SEL				0x0042
+#define REG_MAC_PINMUX_CFG		0x0043
+#define REG_GPIO_PIN_CTRL			0x0044
+#define REG_GPIO_INTM				0x0048
+#define REG_LEDCFG0					0x004C
+#define REG_LEDCFG1					0x004D
+#define REG_LEDCFG2					0x004E
+#define REG_LEDCFG3					0x004F
+#define REG_FSIMR					0x0050
+#define REG_FSISR					0x0054
+
+#define REG_MCUFWDL				0x0080
+#ifdef CONFIG_WOWLAN
+#define REG_WOWLAN_REASON			0x00FC
+#endif /*  CONFIG_WOWLAN */
+#define REG_HMEBOX_EXT_0			0x0088
+#define REG_HMEBOX_EXT_1			0x008A
+#define REG_HMEBOX_EXT_2			0x008C
+#define REG_HMEBOX_EXT_3			0x008E
+
+#define REG_BIST_SCAN				0x00D0
+#define REG_BIST_RPT				0x00D4
+#define REG_BIST_ROM_RPT			0x00D8
+#define REG_USB_SIE_INTF			0x00E0
+#define REG_PCIE_MIO_INTF			0x00E4
+#define REG_PCIE_MIO_INTD			0x00E8
+#define REG_HPON_FSM				0x00EC
+#define REG_SYS_CFG					0x00F0
+#define REG_MAC_PHY_CTRL_NORMAL	0x00f8
+
+#define  REG_MAC0					0x0081
+#define  REG_MAC1					0x0053
+#define  FW_MAC0_ready				0x18
+#define  FW_MAC1_ready				0x1A
+#define  MAC0_ON					BIT7
+#define  MAC1_ON					BIT0
+#define  mac0_ready					BIT0
+#define  mac1_ready					BIT0
+
+
+/*  */
+/*  */
+/* 	0x0100h ~ 0x01FFh	MACTOP General Configuration */
+/*  */
+/*  */
+#define REG_CR						0x0100
+#define REG_PBP						0x0104
+#define REG_TRXDMA_CTRL			0x010C
+#define REG_TRXFF_BNDY				0x0114
+#define REG_TRXFF_STATUS			0x0118
+#define REG_RXFF_PTR				0x011C
+#define REG_HIMR					0x0120
+#define REG_HISR					0x0124
+#define REG_HIMRE					0x0128
+#define REG_HISRE					0x012C
+#define REG_CPWM					0x012F
+#define REG_FWIMR					0x0130
+#define REG_FWISR					0x0134
+#define REG_FTIMR					0x0138
+#define REG_PKTBUF_DBG_CTRL		0x0140
+#define REG_PKTBUF_DBG_DATA_L		0x0144
+#define REG_PKTBUF_DBG_DATA_H	0x0148
+
+#define REG_TC0_CTRL				0x0150
+#define REG_TC1_CTRL				0x0154
+#define REG_TC2_CTRL				0x0158
+#define REG_TC3_CTRL				0x015C
+#define REG_TC4_CTRL				0x0160
+#define REG_TCUNIT_BASE			0x0164
+#define REG_MBIST_START			0x0174
+#define REG_MBIST_DONE				0x0178
+#define REG_MBIST_FAIL				0x017C
+#define REG_C2HEVT_MSG_NORMAL	0x01A0
+#define REG_C2HEVT_CLEAR			0x01AF
+#define REG_C2HEVT_MSG_TEST		0x01B8
+#define REG_MCUTST_1				0x01c0
+#define REG_FMETHR					0x01C8
+#define REG_HMETFR					0x01CC
+#define REG_HMEBOX_0				0x01D0
+#define REG_HMEBOX_1				0x01D4
+#define REG_HMEBOX_2				0x01D8
+#define REG_HMEBOX_3				0x01DC
+
+#define REG_LLT_INIT				0x01E0
+#define REG_BB_ACCEESS_CTRL		0x01E8
+#define REG_BB_ACCESS_DATA		0x01EC
+
+
+/*  */
+/*  */
+/* 	0x0200h ~ 0x027Fh	TXDMA Configuration */
+/*  */
+/*  */
+#define REG_RQPN					0x0200
+#define REG_FIFOPAGE				0x0204
+#define REG_TDECTRL					0x0208
+#define REG_TXDMA_OFFSET_CHK		0x020C
+#define REG_TXDMA_STATUS			0x0210
+#define REG_RQPN_NPQ				0x0214
+
+/*  */
+/*  */
+/* 	0x0280h ~ 0x02FFh	RXDMA Configuration */
+/*  */
+/*  */
+#define REG_RXDMA_AGG_PG_TH		0x0280
+#define REG_RXPKT_NUM				0x0284
+#define REG_RXDMA_STATUS			0x0288
+
+
+/*  */
+/*  */
+/* 	0x0300h ~ 0x03FFh	PCIe */
+/*  */
+/*  */
+#define	REG_PCIE_CTRL_REG			0x0300
+#define	REG_INT_MIG				0x0304	/*  Interrupt Migration */
+#define	REG_BCNQ_DESA				0x0308	/*  TX Beacon Descriptor Address */
+#define	REG_HQ_DESA				0x0310	/*  TX High Queue Descriptor Address */
+#define	REG_MGQ_DESA				0x0318	/*  TX Manage Queue Descriptor Address */
+#define	REG_VOQ_DESA				0x0320	/*  TX VO Queue Descriptor Address */
+#define	REG_VIQ_DESA				0x0328	/*  TX VI Queue Descriptor Address */
+#define	REG_BEQ_DESA				0x0330	/*  TX BE Queue Descriptor Address */
+#define	REG_BKQ_DESA				0x0338	/*  TX BK Queue Descriptor Address */
+#define	REG_RX_DESA				0x0340	/*  RX Queue	Descriptor Address */
+#define	REG_DBI					0x0348	/*  Backdoor REG for Access Configuration */
+/* sherry added for DBI Read/Write  20091126 */
+#define	REG_DBI_WDATA				0x0348	/*  Backdoor REG for Access Configuration */
+#define		REG_DBI_RDATA				0x034C /* Backdoor REG for Access Configuration */
+#define	REG_DBI_CTRL				0x0350  /* Backdoor REG for Access Configuration */
+#define	REG_DBI_FLAG				0x0352 /* Backdoor REG for Access Configuration#define	REG_MDIO					0x0354	MDIO for Access PCIE PHY */
+#define	REG_MDIO					0x0354	/*  MDIO for Access PCIE PHY */
+#define	REG_DBG_SEL				0x0360	/*  Debug Selection Register */
+#define	REG_PCIE_HRPWM			0x0361	/* PCIe RPWM */
+#define	REG_PCIE_HCPWM			0x0363	/* PCIe CPWM */
+#define	REG_UART_CTRL				0x0364	/*  UART	Control */
+#define	REG_UART_TX_DESA			0x0370	/*  UART TX Descriptor Address */
+#define	REG_UART_RX_DESA			0x0378	/*  UART Rx Descriptor Address */
+
+
+/*  spec version 11 */
+/*  */
+/*  */
+/* 	0x0400h ~ 0x047Fh	Protocol Configuration */
+/*  */
+/*  */
+#define REG_VOQ_INFORMATION			0x0400
+#define REG_VIQ_INFORMATION			0x0404
+#define REG_BEQ_INFORMATION			0x0408
+#define REG_BKQ_INFORMATION			0x040C
+#define REG_MGQ_INFORMATION			0x0410
+#define REG_HGQ_INFORMATION			0x0414
+#define REG_BCNQ_INFORMATION			0x0418
+
+
+#define REG_CPU_MGQ_INFORMATION		0x041C
+#define REG_FWHW_TXQ_CTRL				0x0420
+#define REG_HWSEQ_CTRL					0x0423
+#define REG_TXPKTBUF_BCNQ_BDNY		0x0424
+#define REG_TXPKTBUF_MGQ_BDNY		0x0425
+#define REG_LIFETIME_EN				0x0426
+#define REG_MULTI_BCNQ_OFFSET			0x0427
+#define REG_SPEC_SIFS					0x0428
+#define REG_RL							0x042A
+#define REG_DARFRC						0x0430
+#define REG_RARFRC						0x0438
+#define REG_RRSR						0x0440
+#define REG_ARFR0						0x0444
+#define REG_ARFR1						0x0448
+#define REG_ARFR2						0x044C
+#define REG_ARFR3						0x0450
+#define REG_AGGLEN_LMT					0x0458
+#define REG_AMPDU_MIN_SPACE			0x045C
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD	0x045D
+#define REG_FAST_EDCA_CTRL				0x0460
+#define REG_RD_RESP_PKT_TH				0x0463
+#define REG_INIRTS_RATE_SEL			0x0480
+#define REG_INIDATA_RATE_SEL			0x0484
+
+/* define REG_FW_TSF_SYNC_CNT				0x04A0 */
+#define REG_FW_RESET_TSF_CNT_1				0x05FC
+#define REG_FW_RESET_TSF_CNT_0				0x05FD
+#define REG_FW_BCN_DIS_CNT				0x05FE
+
+#define REG_POWER_STATUS				0x04A4
+#define REG_POWER_STAGE1				0x04B4
+#define REG_POWER_STAGE2				0x04B8
+#define REG_PKT_VO_VI_LIFE_TIME			0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME			0x04C2
+#define REG_STBC_SETTING				0x04C4
+#define REG_PROT_MODE_CTRL			0x04C8
+#define REG_MAX_AGGR_NUM				0x04CA
+#define REG_RTS_MAX_AGGR_NUM			0x04CB
+#define REG_BAR_MODE_CTRL				0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
+#define REG_EARLY_MODE_CONTROL		0x04D0
+#define REG_NQOS_SEQ					0x04DC
+#define REG_QOS_SEQ					0x04DE
+#define REG_NEED_CPU_HANDLE			0x04E0
+#define REG_PKT_LOSE_RPT				0x04E1
+#define REG_PTCL_ERR_STATUS			0x04E2
+#define REG_DUMMY						0x04FC
+
+
+
+/*  */
+/*  */
+/* 	0x0500h ~ 0x05FFh	EDCA Configuration */
+/*  */
+/*  */
+#define REG_EDCA_VO_PARAM			0x0500
+#define REG_EDCA_VI_PARAM			0x0504
+#define REG_EDCA_BE_PARAM			0x0508
+#define REG_EDCA_BK_PARAM			0x050C
+#define REG_BCNTCFG					0x0510
+#define REG_PIFS						0x0512
+#define REG_RDG_PIFS				0x0513
+#define REG_SIFS_CTX				0x0514
+#define REG_SIFS_TRX				0x0516
+#define REG_TSFTR_SYN_OFFSET		0x0518
+#define REG_AGGR_BREAK_TIME		0x051A
+#define REG_SLOT					0x051B
+#define REG_TX_PTCL_CTRL			0x0520
+#define REG_TXPAUSE					0x0522
+#define REG_DIS_TXREQ_CLR			0x0523
+#define REG_RD_CTRL					0x0524
+#define REG_TBTT_PROHIBIT			0x0540
+#define REG_RD_NAV_NXT				0x0544
+#define REG_NAV_PROT_LEN			0x0546
+#define REG_BCN_CTRL				0x0550
+#define REG_BCN_CTRL_1				0x0551
+#define REG_MBID_NUM				0x0552
+#define REG_DUAL_TSF_RST			0x0553
+#define REG_BCN_INTERVAL			0x0554	/*  The same as REG_MBSSID_BCN_SPACE */
+#define REG_MBSSID_BCN_SPACE		0x0554
+#define REG_DRVERLYINT				0x0558
+#define REG_BCNDMATIM				0x0559
+#define REG_ATIMWND				0x055A
+#define REG_USTIME_TSF				0x055C
+#define REG_BCN_MAX_ERR			0x055D
+#define REG_RXTSF_OFFSET_CCK		0x055E
+#define REG_RXTSF_OFFSET_OFDM		0x055F
+#define REG_TSFTR					0x0560
+#define REG_TSFTR1					0x0568
+#define REG_INIT_TSFTR				0x0564
+#define REG_ATIMWND_1				0x0570
+#define REG_PSTIMER					0x0580
+#define REG_TIMER0					0x0584
+#define REG_TIMER1					0x0588
+#define REG_ACMHWCTRL				0x05C0
+#define REG_ACMRSTCTRL				0x05C1
+#define REG_ACMAVG					0x05C2
+#define REG_VO_ADMTIME				0x05C4
+#define REG_VI_ADMTIME				0x05C6
+#define REG_BE_ADMTIME				0x05C8
+#define REG_EDCA_RANDOM_GEN		0x05CC
+#define REG_SCH_TXCMD				0x05D0
+
+#define REG_DMC						0x05F0	/* Dual MAC Co-Existence Register */
+
+
+/*  */
+/*  */
+/* 	0x0600h ~ 0x07FFh	WMAC Configuration */
+/*  */
+/*  */
+#define REG_APSD_CTRL				0x0600
+#define REG_BWOPMODE				0x0603
+#define REG_TCR						0x0604
+#define REG_RCR						0x0608
+#define REG_RX_PKT_LIMIT			0x060C
+#define REG_RX_DLK_TIME			0x060D
+#define REG_RX_DRVINFO_SZ			0x060F
+
+#define REG_MACID					0x0610
+#define REG_BSSID					0x0618
+#define REG_MAR						0x0620
+#define REG_MBIDCAMCFG				0x0628
+
+#define REG_USTIME_EDCA			0x0638
+#define REG_MAC_SPEC_SIFS			0x063A
+#define REG_RESP_SIFS_CCK			0x063C
+#define REG_RESP_SIFS_OFDM			0x063E
+#define REG_ACKTO					0x0640
+#define REG_CTS2TO					0x0641
+#define REG_EIFS						0x0642
+
+
+/* WMA, BA, CCX */
+#define REG_NAV_CTRL				0x0650
+#define REG_BACAMCMD				0x0654
+#define REG_BACAMCONTENT			0x0658
+#define REG_LBDLY					0x0660
+#define REG_FWDLY					0x0661
+#define REG_RXERR_RPT				0x0664
+#define REG_WMAC_TRXPTCL_CTL		0x0668
+
+
+/*  Security */
+#define REG_CAMCMD					0x0670
+#define REG_CAMWRITE				0x0674
+#define REG_CAMREAD				0x0678
+#define REG_CAMDBG					0x067C
+#define REG_SECCFG					0x0680
+
+/*  Power */
+#define REG_WOW_CTRL				0x0690
+#define REG_PSSTATUS				0x0691
+#define REG_PS_RX_INFO				0x0692
+#define REG_LPNAV_CTRL				0x0694
+#define REG_WKFMCAM_CMD			0x0698
+#define REG_WKFMCAM_RWD			0x069C
+#define REG_RXFLTMAP0				0x06A0
+#define REG_RXFLTMAP1				0x06A2
+#define REG_RXFLTMAP2				0x06A4
+#define REG_BCN_PSR_RPT			0x06A8
+#define REG_CALB32K_CTRL			0x06AC
+#define REG_PKT_MON_CTRL			0x06B4
+#define REG_BT_COEX_TABLE			0x06C0
+#define REG_WMAC_RESP_TXINFO		0x06D8
+
+#define REG_MACID1					0x0700
+#define REG_BSSID1					0x0708
+
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
+#define REG_USB_INFO				0xFE17
+#define REG_USB_SPECIAL_OPTION	0xFE55
+#define REG_USB_DMA_AGG_TO		0xFE5B
+#define REG_USB_AGG_TO				0xFE5C
+#define REG_USB_AGG_TH				0xFE5D
+
+/*  for 92DU high_Queue low_Queue Normal_Queue select */
+#define REG_USB_High_NORMAL_Queue_Select_MAC0  0xFE44
+#define REG_USB_High_NORMAL_Queue_Select_MAC1  0xFE47
+
+/*  For test chip */
+#define REG_TEST_USB_TXQS			0xFE48
+#define REG_TEST_SIE_VID			0xFE60		/*  0xFE60~0xFE61 */
+#define REG_TEST_SIE_PID			0xFE62		/*  0xFE62~0xFE63 */
+#define REG_TEST_SIE_OPTIONAL		0xFE64
+#define REG_TEST_SIE_CHIRP_K		0xFE65
+#define REG_TEST_SIE_PHY			0xFE66		/*  0xFE66~0xFE6B */
+#define REG_TEST_SIE_MAC_ADDR		0xFE70		/*  0xFE70~0xFE75 */
+#define REG_TEST_SIE_STRING		0xFE80		/*  0xFE80~0xFEB9 */
+
+
+/*  For normal chip */
+#define REG_NORMAL_SIE_VID			0xFE60		/*  0xFE60~0xFE61 */
+#define REG_NORMAL_SIE_PID			0xFE62		/*  0xFE62~0xFE63 */
+#define REG_NORMAL_SIE_OPTIONAL	0xFE64
+#define REG_NORMAL_SIE_EP			0xFE65		/*  0xFE65~0xFE67 */
+#define REG_NORMAL_SIE_PHY		0xFE68		/*  0xFE68~0xFE6B */
+#define REG_NORMAL_SIE_MAC_ADDR	0xFE70		/*  0xFE70~0xFE75 */
+#define REG_NORMAL_SIE_STRING		0xFE80		/*  0xFE80~0xFEDF */
+
+
+/*  */
+/*  */
+/* 	Redifine 8192C register definition for compatibility */
+/*  */
+/*  */
+
+/*  TODO: use these definition when using REG_xxx naming rule. */
+/*  NOTE: DO NOT Remove these definition. Use later. */
+
+#define	SYS_ISO_CTRL				REG_SYS_ISO_CTRL	/*  System Isolation Interface Control. */
+#define	SYS_FUNC_EN				REG_SYS_FUNC_EN		/*  System Function Enable. */
+#define	SYS_CLK						REG_SYS_CLKR
+#define	CR9346						REG_9346CR			/*  93C46/93C56 Command Register. */
+#define	EFUSE_CTRL					REG_EFUSE_CTRL		/*  E-Fuse Control. */
+#define	EFUSE_TEST					REG_EFUSE_TEST		/*  E-Fuse Test. */
+#define	MSR							(REG_CR + 2)		/*  Media Status register */
+#define	ISR							REG_HISR
+#define	TSFR						REG_TSFTR			/*  Timing Sync Function Timer Register. */
+
+#define	MACIDR0					REG_MACID			/*  MAC ID Register, Offset 0x0050-0x0053 */
+#define	MACIDR4					(REG_MACID + 4)		/*  MAC ID Register, Offset 0x0054-0x0055 */
+
+#define		PBP							REG_PBP
+
+/*  Redifine MACID register, to compatible prior ICs. */
+#define	IDR0						MACIDR0
+#define	IDR4						MACIDR4
+
+
+/*  */
+/*  9. Security Control Registers	(Offset:) */
+/*  */
+#define	RWCAM						REG_CAMCMD		/* IN 8190 Data Sheet is called CAMcmd */
+#define	WCAMI						REG_CAMWRITE	/*  Software write CAM input content */
+#define	RCAMO						REG_CAMREAD		/*  Software read/write CAM config */
+#define	CAMDBG						REG_CAMDBG
+#define	SECR						REG_SECCFG		/* Security Configuration Register */
+
+/*  Unused register */
+#define	UnusedRegister				0x1BF
+#define	DCAM						UnusedRegister
+#define	PSR							UnusedRegister
+#define		BBAddr						UnusedRegister
+#define	PhyDataR					UnusedRegister
+
+#define	InvalidBBRFValue			0x12345678
+
+/*  Min Spacing related settings. */
+#define	MAX_MSS_DENSITY_2T			0x13
+#define	MAX_MSS_DENSITY_1T			0x0A
+
+/*  */
+/*        8192C Cmd9346CR bits					(Offset 0xA, 16bit) */
+/*  */
+#define	CmdEEPROM_En				BIT5	 /*  EEPROM enable when set 1 */
+#define	CmdEERPOMSEL				BIT4	/*  System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346 */
+#define	Cmd9346CR_9356SEL			BIT4
+#define	AutoLoadEEPROM			(CmdEEPROM_En|CmdEERPOMSEL)
+#define	AutoLoadEFUSE				CmdEEPROM_En
+
+/*        8192C GPIO MUX Configuration Register (offset 0x40, 4 byte) */
+/*  */
+#define	GPIOSEL_GPIO				0
+#define	GPIOSEL_ENBT				BIT5
+
+/*  */
+/*        8192C GPIO PIN Control Register (offset 0x44, 4 byte) */
+/*  */
+#define	GPIO_IN						REG_GPIO_PIN_CTRL		/*  GPIO pins input value */
+#define	GPIO_OUT					(REG_GPIO_PIN_CTRL+1)	/*  GPIO pins output value */
+#define	GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	/*  GPIO pins output enable when a bit is set to "1"; otherwise, input is configured. */
+#define	GPIO_MOD					(REG_GPIO_PIN_CTRL+3)
+
+
+/*  */
+/*        8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits) */
+/*  */
+/*
+Network Type
+00: No link
+01: Link in ad hoc network
+10: Link in infrastructure network
+11: AP mode
+Default: 00b.
+*/
+#define	MSR_NOLINK					0x00
+#define	MSR_ADHOC					0x01
+#define	MSR_INFRA					0x02
+#define	MSR_AP						0x03
+
+/*  */
+/*  6. Adaptive Control Registers  (Offset: 0x0160 - 0x01CF) */
+/*  */
+/*  */
+/*        8192C Response Rate Set Register	(offset 0x181, 24bits) */
+/*  */
+#define	RRSR_RSC_OFFSET			21
+#define	RRSR_SHORT_OFFSET			23
+#define	RRSR_RSC_BW_40M			0x600000
+#define	RRSR_RSC_UPSUBCHNL		0x400000
+#define	RRSR_RSC_LOWSUBCHNL		0x200000
+#define	RRSR_SHORT					0x800000
+#define	RRSR_1M					BIT0
+#define	RRSR_2M					BIT1
+#define	RRSR_5_5M					BIT2
+#define	RRSR_11M					BIT3
+#define	RRSR_6M					BIT4
+#define	RRSR_9M					BIT5
+#define	RRSR_12M					BIT6
+#define	RRSR_18M					BIT7
+#define	RRSR_24M					BIT8
+#define	RRSR_36M					BIT9
+#define	RRSR_48M					BIT10
+#define	RRSR_54M					BIT11
+#define	RRSR_MCS0					BIT12
+#define	RRSR_MCS1					BIT13
+#define	RRSR_MCS2					BIT14
+#define	RRSR_MCS3					BIT15
+#define	RRSR_MCS4					BIT16
+#define	RRSR_MCS5					BIT17
+#define	RRSR_MCS6					BIT18
+#define	RRSR_MCS7					BIT19
+#define	BRSR_AckShortPmb			BIT23
+/*  CCK ACK: use Short Preamble or not */
+
+
+/*  */
+/*        8192C Rate Definition */
+/*  */
+/* CCK */
+#define	RATR_1M					0x00000001
+#define	RATR_2M					0x00000002
+#define	RATR_55M					0x00000004
+#define	RATR_11M					0x00000008
+/* OFDM */
+#define	RATR_6M					0x00000010
+#define	RATR_9M					0x00000020
+#define	RATR_12M					0x00000040
+#define	RATR_18M					0x00000080
+#define	RATR_24M					0x00000100
+#define	RATR_36M					0x00000200
+#define	RATR_48M					0x00000400
+#define	RATR_54M					0x00000800
+/* MCS 1 Spatial Stream */
+#define	RATR_MCS0					0x00001000
+#define	RATR_MCS1					0x00002000
+#define	RATR_MCS2					0x00004000
+#define	RATR_MCS3					0x00008000
+#define	RATR_MCS4					0x00010000
+#define	RATR_MCS5					0x00020000
+#define	RATR_MCS6					0x00040000
+#define	RATR_MCS7					0x00080000
+/* MCS 2 Spatial Stream */
+#define	RATR_MCS8					0x00100000
+#define	RATR_MCS9					0x00200000
+#define	RATR_MCS10					0x00400000
+#define	RATR_MCS11					0x00800000
+#define	RATR_MCS12					0x01000000
+#define	RATR_MCS13					0x02000000
+#define	RATR_MCS14					0x04000000
+#define	RATR_MCS15					0x08000000
+
+/*  */
+/*        8192C BW_OPMODE bits					(Offset 0x203, 8bit) */
+/*  */
+#define	BW_OPMODE_20MHZ			BIT2
+#define	BW_OPMODE_5G				BIT1
+#define	BW_OPMODE_11J				BIT0
+
+
+/*  */
+/*        8192C CAM Config Setting (offset 0x250, 1 byte) */
+/*  */
+#define	CAM_VALID					BIT15
+#define	CAM_NOTVALID				0x0000
+#define	CAM_USEDK					BIT5
+
+#define	CAM_CONTENT_COUNT		8
+
+#define	CAM_NONE					0x0
+#define	CAM_WEP40					0x01
+#define	CAM_TKIP					0x02
+#define	CAM_AES					0x04
+#define	CAM_WEP104				0x05
+#define	CAM_SMS4					0x6
+
+
+#define	TOTAL_CAM_ENTRY			32
+#define	HALF_CAM_ENTRY			16
+
+#define	CAM_CONFIG_USEDK			true
+#define	CAM_CONFIG_NO_USEDK		false
+
+#define	CAM_WRITE					BIT16
+#define	CAM_READ					0x00000000
+#define	CAM_POLLINIG				BIT31
+
+#define	SCR_UseDK					0x01
+#define	SCR_TxSecEnable			0x02
+#define	SCR_RxSecEnable			0x04
+
+
+/*  */
+/*  12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F) */
+/*  */
+/*  */
+/*        8190 IMR/ISR bits						(offset 0xfd,  8bits) */
+/*  */
+#define	IMR8190_DISABLED			0x0
+/*  IMR DW0 Bit 0-31 */
+#define	IMR_BCNDMAINT6			BIT31		/*  Beacon DMA Interrupt 6 */
+#define	IMR_BCNDMAINT5			BIT30		/*  Beacon DMA Interrupt 5 */
+#define	IMR_BCNDMAINT4			BIT29		/*  Beacon DMA Interrupt 4 */
+#define	IMR_BCNDMAINT3			BIT28		/*  Beacon DMA Interrupt 3 */
+#define	IMR_BCNDMAINT2			BIT27		/*  Beacon DMA Interrupt 2 */
+#define	IMR_BCNDMAINT1			BIT26		/*  Beacon DMA Interrupt 1 */
+#define	IMR_BCNDOK8				BIT25		/*  Beacon Queue DMA OK Interrup 8 */
+#define	IMR_BCNDOK7				BIT24		/*  Beacon Queue DMA OK Interrup 7 */
+#define	IMR_BCNDOK6				BIT23		/*  Beacon Queue DMA OK Interrup 6 */
+#define	IMR_BCNDOK5				BIT22		/*  Beacon Queue DMA OK Interrup 5 */
+#define	IMR_BCNDOK4				BIT21		/*  Beacon Queue DMA OK Interrup 4 */
+#define	IMR_BCNDOK3				BIT20		/*  Beacon Queue DMA OK Interrup 3 */
+#define	IMR_BCNDOK2				BIT19		/*  Beacon Queue DMA OK Interrup 2 */
+#define	IMR_BCNDOK1				BIT18		/*  Beacon Queue DMA OK Interrup 1 */
+#define	IMR_TIMEOUT2				BIT17		/*  Timeout interrupt 2 */
+#define	IMR_TIMEOUT1				BIT16		/*  Timeout interrupt 1 */
+#define	IMR_TXFOVW				BIT15		/*  Transmit FIFO Overflow */
+#define	IMR_PSTIMEOUT				BIT14		/*  Power save time out interrupt */
+#define	IMR_BcnInt					BIT13		/*  Beacon DMA Interrupt 0 */
+#define	IMR_RXFOVW				BIT12		/*  Receive FIFO Overflow */
+#define	IMR_RDU					BIT11		/*  Receive Descriptor Unavailable */
+#define	IMR_ATIMEND				BIT10		/*  For 92C,ATIM Window End Interrupt */
+#define	IMR_BDOK					BIT9		/*  Beacon Queue DMA OK Interrup */
+#define	IMR_HIGHDOK				BIT8		/*  High Queue DMA OK Interrupt */
+#define	IMR_TBDOK					BIT7		/*  Transmit Beacon OK interrup */
+#define	IMR_MGNTDOK				BIT6		/*  Management Queue DMA OK Interrupt */
+#define	IMR_TBDER					BIT5		/*  For 92C,Transmit Beacon Error Interrupt */
+#define	IMR_BKDOK					BIT4		/*  AC_BK DMA OK Interrupt */
+#define	IMR_BEDOK					BIT3		/*  AC_BE DMA OK Interrupt */
+#define	IMR_VIDOK					BIT2		/*  AC_VI DMA OK Interrupt */
+#define	IMR_VODOK					BIT1		/*  AC_VO DMA Interrupt */
+#define	IMR_ROK					BIT0		/*  Receive DMA OK Interrupt */
+
+/*  13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh) */
+#define	IMR_TXERR					BIT11
+#define	IMR_RXERR					BIT10
+#define	IMR_C2HCMD				BIT9
+#define	IMR_CPWM					BIT8
+/* RSVD [2-7] */
+#define	IMR_OCPINT					BIT1
+#define	IMR_WLANOFF				BIT0
+
+
+
+/*  */
+/*  8192D EFUSE */
+/*  */
+#define	HWSET_MAX_SIZE				256
+
+/*  */
+/*        8192C EEPROM/EFUSE share register definition. */
+/*  */
+
+/*  */
+/*  Default Value for EEPROM or EFUSE!!! */
+/*  */
+#define	EEPROM_Default_TSSI					0x0
+#define		EEPROM_Default_TxPowerDiff				0x0
+#define		EEPROM_Default_CrystalCap				0x0		/* 92D default 0x0 */
+#define		EEPROM_Default_BoardType				0x02 /*  Default: 2X2, RTL8192CE(QFPN68) */
+#define		EEPROM_Default_TxPower				0x1010
+#define	EEPROM_Default_HT2T_TxPwr				0x10
+
+#define	EEPROM_Default_LegacyHTTxPowerDiff	0x4
+#define	EEPROM_Default_ThermalMeter			0x12
+
+#define	EEPROM_Default_AntTxPowerDiff			0x0
+/* define	EEPROM_Default_TxPwDiff_CrystalCap		0x5 */
+#define	EEPROM_Default_TxPowerLevel_2G		0x2C
+#define	EEPROM_Default_TxPowerLevel_5G		0x22
+
+#define	EEPROM_Default_HT40_2SDiff				0x0
+#define		EEPROM_Default_HT20_Diff				2	/*  HT20<->40 default Tx Power Index Difference */
+#define	EEPROM_Default_LegacyHTTxPowerDiff	0x4	/* OFDM Tx Power index diff */
+#define		EEPROM_Default_HT40_PwrMaxOffset		0
+#define		EEPROM_Default_HT20_PwrMaxOffset		0
+
+/*  For debug */
+#define		EEPROM_Default_PID						0x1234
+#define		EEPROM_Default_VID						0x5678
+#define		EEPROM_Default_CustomerID				0xAB
+#define		EEPROM_Default_SubCustomerID			0xCD
+#define		EEPROM_Default_Version					0
+
+#define	EEPROM_Default_externalPA_C9		0x00
+#define	EEPROM_Default_externalPA_CC		0xFF
+#define	EEPROM_Default_internalPA_SP3T_C9	0xAA
+#define	EEPROM_Default_internalPA_SP3T_CC	0xAF
+#define	EEPROM_Default_internalPA_SPDT_C9	0xAA
+#define	EEPROM_Default_internalPA_SPDT_CC	0xFA
+
+#define	EEPROM_CHANNEL_PLAN_FCC				0x0
+#define	EEPROM_CHANNEL_PLAN_IC				0x1
+#define	EEPROM_CHANNEL_PLAN_ETSI			0x2
+#define	EEPROM_CHANNEL_PLAN_SPAIN			0x3
+#define	EEPROM_CHANNEL_PLAN_FRANCE			0x4
+#define	EEPROM_CHANNEL_PLAN_MKK				0x5
+#define	EEPROM_CHANNEL_PLAN_MKK1			0x6
+#define	EEPROM_CHANNEL_PLAN_ISRAEL			0x7
+#define	EEPROM_CHANNEL_PLAN_TELEC			0x8
+#define	EEPROM_CHANNEL_PLAN_GLOBAL_DOMAIN	0x9
+#define	EEPROM_CHANNEL_PLAN_WORLD_WIDE_13	0xA
+#define	EEPROM_CHANNEL_PLAN_NCC				0xB
+#define	EEPROM_CHANNEL_PLAN_BY_HW_MASK	0x80
+
+
+#define		EEPROM_CID_DEFAULT					0x0
+#define		EEPROM_CID_TOSHIBA					0x4
+#define	EEPROM_CID_CCX						0x10 /*  CCX test. By Bruce, 2009-02-25. */
+#define	EEPROM_CID_QMI						0x0D
+#define		EEPROM_CID_WHQL							0xFE /*  added by chiyoko for dtm, 20090108 */
+
+
+#define	RTL8192_EEPROM_ID						0x8129
+#define	EEPROM_WAPI_SUPPORT					0x78
+
+#define RTL8190_EEPROM_ID						0x8129	/*  0-1 */
+#define EEPROM_HPON							0x02 /*  LDO settings.2-5 */
+#define EEPROM_CLK								0x06 /*  Clock settings.6-7 */
+#define EEPROM_MAC_FUNCTION					0x08 /*  SE Test mode.8 */
+
+#define EEPROM_VID								0xC /*  SE Vendor ID.A-B */
+#define EEPROM_PID								0xE /*  SE Device ID. C-D */
+#define EEPROM_ENDPOINT_SETTING				0x10
+#ifdef CONFIG_WOWLAN
+#define EEPROM_Option_Setting				0x11
+#endif /*  CONFIG_WOWLAN */
+#define EEPROM_CHIRP_K							0x12	/*  Changed */
+#define EEPROM_USB_PHY							0x13	/*  Changed */
+#define EEPROM_NORMAL_BoardType				EEPROM_RF_OPT1	/* 7:5] */
+#define EEPROM_MAC_ADDR						0x16 /*  SEMAC Address. 12-17 */
+#define EEPROM_STRING							0x1F
+#define EEPROM_SUBCUSTOMER_ID					0x59
+
+#define EEPROM_MAC_ADDR_MAC0_92D			0x19
+#define EEPROM_MAC_ADDR_MAC1_92D			0x5B
+/*  */
+/*  2.4G band Tx power index setting */
+#define EEPROM_CCK_TX_PWR_INX_2G				0x61
+#define EEPROM_HT40_1S_TX_PWR_INX_2G		0x67
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G	0x6D
+#define EEPROM_HT20_TX_PWR_INX_DIFF_2G		0x70
+#define EEPROM_OFDM_TX_PWR_INX_DIFF_2G		0x73
+#define EEPROM_HT40_MAX_PWR_OFFSET_2G		0x76
+#define EEPROM_HT20_MAX_PWR_OFFSET_2G		0x79
+
+/* 5GL channel 32-64 */
+#define EEPROM_HT40_1S_TX_PWR_INX_5GL		0x7C
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GL	0x82
+#define EEPROM_HT20_TX_PWR_INX_DIFF_5GL		0x85
+#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GL		0x88
+#define EEPROM_HT40_MAX_PWR_OFFSET_5GL		0x8B
+#define EEPROM_HT20_MAX_PWR_OFFSET_5GL		0x8E
+
+/* 5GM channel 100-140 */
+#define EEPROM_HT40_1S_TX_PWR_INX_5GM		0x91
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GM	0x97
+#define EEPROM_HT20_TX_PWR_INX_DIFF_5GM		0x9A
+#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GM	0x9D
+#define EEPROM_HT40_MAX_PWR_OFFSET_5GM		0xA0
+#define EEPROM_HT20_MAX_PWR_OFFSET_5GM		0xA3
+
+/* 5GH channel 149-165 */
+#define EEPROM_HT40_1S_TX_PWR_INX_5GH		0xA6
+#define EEPROM_HT40_2S_TX_PWR_INX_DIFF_5GH	0xAC
+#define EEPROM_HT20_TX_PWR_INX_DIFF_5GH		0xAF
+#define EEPROM_OFDM_TX_PWR_INX_DIFF_5GH		0xB2
+#define EEPROM_HT40_MAX_PWR_OFFSET_5GH		0xB5
+#define EEPROM_HT20_MAX_PWR_OFFSET_5GH		0xB8
+
+#define EEPROM_CHANNEL_PLAN					0xBB /*  Map of supported channels. */
+#define EEPROM_TEST_CHANNEL_PLAN				0xBB
+#define EEPROM_IQK_DELTA						0xBC
+#define EEPROM_LCK_DELTA						0xBC
+#define EEPROM_XTAL_K							0xBD	/* 7:5] */
+#define EEPROM_TSSI_A_5G						0xBE
+#define EEPROM_TSSI_B_5G						0xBF
+#define EEPROM_TSSI_AB_5G						0xC0
+#define EEPROM_THERMAL_METER					0xC3	/* 4:0] */
+#define EEPROM_RF_OPT1							0xC4
+#define EEPROM_RF_OPT2							0xC5
+#define EEPROM_RF_OPT3							0xC6
+#define EEPROM_RF_OPT4							0xC7
+#define EEPROM_RF_OPT5							0xC8
+#define EEPROM_RF_OPT6							0xC9
+#define EEPROM_VERSION							0xCA
+#define EEPROM_CUSTOMER_ID					0xCB
+#define EEPROM_RF_OPT7							0xCC
+
+#define EEPROM_DEF_PART_NO					0x3FD  /* Byte */
+#define EEPROME_CHIP_VERSION_L				0x3FF
+#define EEPROME_CHIP_VERSION_H				0x3FE
+
+/*  */
+/* 	EEPROM content definitions */
+/*  */
+#define OS_LINK_SPEED_NORMAL_MASK			BIT3 | BIT2
+#define OS_LINK_SPEED_TEST_MASK				BIT3 | BIT4
+
+#define BOARD_TYPE_NORMAL_MASK				0xE0
+#define BOARD_TYPE_TEST_MASK					0xF
+
+#define BT_COEXISTENCE_TEST					BIT4
+#define BT_COEXISTENCE_NORMAL					BIT5
+
+#define BT_CO_SHIFT_TEST						4
+#define BT_CO_SHIFT_NORMAL					5
+
+#define EP_NUMBER_MASK_TEST					0x30	/* bit 4:5 0Eh */
+#define EP_NUMBER_SHIFT_TEST					4
+
+#define USB_PHY_PARA_SIZE_TEST				6
+#define USB_PHY_PARA_SIZE_NORMAL				4
+
+/*  */
+/* 	EEPROM default value definitions */
+/*  */
+/*  Use 0xABCD instead of 0x8192 for debug */
+#define	EEPROM_DEF_ID_0						0xCD	/*  Byte 0x00 */
+#define	EEPROM_DEF_ID_1						0xAB	/*  Byte 0x01 */
+
+#define EEPROM_DEF_RTK_RSV_A3					0x74	/*  Byte 0x03 */
+#define EEPROM_DEF_RTK_RSV_A4					0x6D	/*  Byte 0x04 */
+#define EEPROM_DEF_RTK_RSV_A8					0xFF	/*  Byte 0x08 */
+
+#define EEPROM_DEF_VID_0						0x0A	/*  Byte 0x0A */
+#define EEPROM_DEF_VID_1						0x0B
+
+#define EEPROM_DEF_PID_0						0x92	/*  Byte 0x0C */
+#define EEPROM_DEF_PID_1						0x81
+
+
+#define EEPROM_TEST_DEF_USB_OPT				0x80	/*  Byte 0x0E */
+#define EEPROM_NORMAL_DEF_USB_OPT			0x00	/*  Byte 0x0E */
+
+#define EEPROM_DEF_CHIRPK						0x15	/*  Byte 0x0F */
+
+#define EEPROM_DEF_USB_PHY_0					0x85	/*  Byte 0x10 */
+#define EEPROM_DEF_USB_PHY_1					0x62	/*  Byte 0x11 */
+#define EEPROM_DEF_USB_PHY_2					0x9E	/*  Byte 0x12 */
+#define EEPROM_DEF_USB_PHY_3					0x06	/*  Byte 0x13 */
+
+#define EEPROM_DEF_TSSI_A						0x09	/*  Byte 0x78 */
+#define EEPROM_DEF_TSSI_B						0x09	/*  Byte 0x79 */
+
+
+#define EEPROM_DEF_THERMAL_METER				0x12	/*  Byte 0x7A */
+
+
+#define	EEPROM_USB_SN							BIT(0)
+#define	EEPROM_USB_REMOTE_WAKEUP			BIT(1)
+#define	EEPROM_USB_DEVICE_PWR				BIT(2)
+#define	EEPROM_EP_NUMBER						(BIT(3)|BIT(4))
+
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C,
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+/*
+Based on Datasheet V33---090401
+Register Summary
+Current IOREG MAP
+0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
+0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
+0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
+0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
+0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
+0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
+0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
+0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
+0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
+*/
+
+/*  */
+/*        8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits) */
+/*  */
+#define	RCR_APPFCS					BIT31		/* WMAC append FCS after pauload */
+#define	RCR_APP_MIC				BIT30		/*  */
+#define	RCR_APP_ICV				BIT29       /*  */
+#define	RCR_APP_PHYST_RXFF		BIT28       /*  */
+#define	RCR_APP_BA_SSN			BIT27		/* Accept BA SSN */
+#define	RCR_ENMBID					BIT24		/* Enable Multiple BssId. */
+#define	RCR_LSIGEN					BIT23
+#define	RCR_MFBEN					BIT22
+#define	RCR_HTC_LOC_CTRL			BIT14       /* MFC<--HTC=1 MFC-->HTC=0 */
+#define	RCR_AMF					BIT13		/* Accept management type frame */
+#define	RCR_ACF					BIT12		/* Accept control type frame */
+#define	RCR_ADF					BIT11		/* Accept data type frame */
+#define	RCR_AICV					BIT9		/* Accept ICV error packet */
+#define	RCR_ACRC32					BIT8		/* Accept CRC32 error packet */
+#define	RCR_CBSSID_BCN			BIT7		/* Accept BSSID match packet (Rx beacon, probe rsp) */
+#define	RCR_CBSSID_DATA			BIT6		/* Accept BSSID match packet (Data) */
+#define	RCR_CBSSID					RCR_CBSSID_DATA		/* Accept BSSID match packet */
+#define	RCR_APWRMGT				BIT5		/* Accept power management packet */
+#define	RCR_ADD3					BIT4		/* Accept address 3 match packet */
+#define	RCR_AB						BIT3		/* Accept broadcast packet */
+#define	RCR_AM						BIT2		/* Accept multicast packet */
+#define	RCR_APM					BIT1		/* Accept physical match packet */
+#define	RCR_AAP					BIT0		/* Accept all unicast packet */
+#define	RCR_MXDMA_OFFSET			8
+#define	RCR_FIFO_OFFSET			13
+
+
+
+/*  */
+/*        8192c USB specific Regsiter Offset and Content definition, */
+/*        2009.08.18, added by vivi. for merge 92c and 92C into one driver */
+/*  */
+#define RSV_CTRL					0x001C
+#define RD_CTRL					0x0524
+
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
+#define REG_USB_INFO				0xFE17
+#define REG_USB_SPECIAL_OPTION	0xFE55
+#define REG_USB_DMA_AGG_TO		0xFE5B
+#define REG_USB_AGG_TO				0xFE5C
+#define REG_USB_AGG_TH				0xFE5D
+
+#define REG_USB_VID					0xFE60
+#define REG_USB_PID					0xFE62
+#define REG_USB_OPTIONAL			0xFE64
+#define REG_USB_CHIRP_K			0xFE65
+#define REG_USB_PHY					0xFE66
+#define REG_USB_MAC_ADDR			0xFE70
+
+#define REG_USB_HRPWM				0xFE58
+#define REG_USB_HCPWM				0xFE57
+
+#define InvalidBBRFValue			0x12345678
+
+/*  */
+/*        8192C Regsiter Bit and Content definition */
+/*  */
+/*  */
+/*  */
+/* 	0x0000h ~ 0x00FFh	System Configuration */
+/*  */
+/*  */
+
+/* 2 SPS0_CTRL */
+#define SW18_FPWM					BIT(3)
+
+
+/* 2 SYS_ISO_CTRL */
+#define ISO_MD2PP					BIT(0)
+#define ISO_UA2USB					BIT(1)
+#define ISO_UD2CORE					BIT(2)
+#define ISO_PA2PCIE					BIT(3)
+#define ISO_PD2CORE					BIT(4)
+#define ISO_IP2MAC					BIT(5)
+#define ISO_DIOP						BIT(6)
+#define ISO_DIOE						BIT(7)
+#define ISO_EB2CORE					BIT(8)
+#define ISO_DIOR						BIT(9)
+
+#define PWC_EV25V					BIT(14)
+#define PWC_EV12V					BIT(15)
+
+
+/* 2 SYS_FUNC_EN */
+#define FEN_BBRSTB					BIT(0)
+#define FEN_BB_GLB_RSTn			BIT(1)
+#define FEN_USBA					BIT(2)
+#define FEN_UPLL					BIT(3)
+#define FEN_USBD					BIT(4)
+#define FEN_DIO_PCIE				BIT(5)
+#define FEN_PCIEA					BIT(6)
+#define FEN_PPLL						BIT(7)
+#define FEN_PCIED					BIT(8)
+#define FEN_DIOE					BIT(9)
+#define FEN_CPUEN					BIT(10)
+#define FEN_DCORE					BIT(11)
+#define FEN_ELDR					BIT(12)
+#define FEN_DIO_RF					BIT(13)
+#define FEN_HWPDN					BIT(14)
+#define FEN_MREGEN					BIT(15)
+
+/* 2 APS_FSMCO */
+#define PFM_LDALL					BIT(0)
+#define PFM_ALDN					BIT(1)
+#define PFM_LDKP					BIT(2)
+#define PFM_WOWL					BIT(3)
+#define EnPDN						BIT(4)
+#define PDN_PL						BIT(5)
+#define APFM_ONMAC					BIT(8)
+#define APFM_OFF					BIT(9)
+#define APFM_RSM					BIT(10)
+#define AFSM_HSUS					BIT(11)
+#define AFSM_PCIE					BIT(12)
+#define APDM_MAC					BIT(13)
+#define APDM_HOST					BIT(14)
+#define APDM_HPDN					BIT(15)
+#define RDY_MACON					BIT(16)
+#define SUS_HOST					BIT(17)
+#define ROP_ALD						BIT(20)
+#define ROP_PWR						BIT(21)
+#define ROP_SPS						BIT(22)
+#define SOP_MRST					BIT(25)
+#define SOP_FUSE					BIT(26)
+#define SOP_ABG						BIT(27)
+#define SOP_AMB						BIT(28)
+#define SOP_RCK						BIT(29)
+#define SOP_A8M						BIT(30)
+#define XOP_BTCK					BIT(31)
+
+/* 2 SYS_CLKR */
+#define ANAD16V_EN					BIT(0)
+#define ANA8M						BIT(1)
+#define MACSLP						BIT(4)
+#define LOADER_CLK_EN				BIT(5)
+#define _80M_SSC_DIS				BIT(7)
+#define _80M_SSC_EN_HO				BIT(8)
+#define PHY_SSC_RSTB				BIT(9)
+#define SEC_CLK_EN					BIT(10)
+#define MAC_CLK_EN					BIT(11)
+#define SYS_CLK_EN					BIT(12)
+#define RING_CLK_EN					BIT(13)
+
+
+/* 2 9346CR */
+
+#define BOOT_FROM_EEPROM			BIT(4)
+#define EEPROM_EN					BIT(5)
+
+
+/* 2 AFE_MISC */
+#define AFE_BGEN					BIT(0)
+#define AFE_MBEN					BIT(1)
+#define MAC_ID_EN					BIT(7)
+
+
+/* 2 SPS0_CTRL */
+
+
+/* 2 SPS_OCP_CFG */
+
+
+/* 2 RSV_CTRL */
+#define WLOCK_ALL					BIT(0)
+#define WLOCK_00					BIT(1)
+#define WLOCK_04					BIT(2)
+#define WLOCK_08					BIT(3)
+#define WLOCK_40					BIT(4)
+#define R_DIS_PRST_0				BIT(5)
+#define R_DIS_PRST_1				BIT(6)
+#define LOCK_ALL_EN					BIT(7)
+
+/* 2 RF_CTRL */
+#define RF_EN						BIT(0)
+#define RF_RSTB						BIT(1)
+#define RF_SDMRSTB					BIT(2)
+
+
+
+/* 2 LDOA15_CTRL */
+#define LDA15_EN					BIT(0)
+#define LDA15_STBY					BIT(1)
+#define LDA15_OBUF					BIT(2)
+#define LDA15_REG_VOS				BIT(3)
+#define _LDA15_VOADJ(x)				(((x) & 0x7) << 4)
+
+
+
+/* 2 LDOV12D_CTRL */
+#define LDV12_EN					BIT(0)
+#define LDV12_SDBY					BIT(1)
+#define LPLDO_HSM					BIT(2)
+#define LPLDO_LSM_DIS				BIT(3)
+#define _LDV12_VADJ(x)				(((x) & 0xF) << 4)
+
+
+/* 2 AFE_XTAL_CTRL */
+#define XTAL_EN						BIT(0)
+#define XTAL_BSEL					BIT(1)
+#define _XTAL_BOSC(x)				(((x) & 0x3) << 2)
+#define _XTAL_CADJ(x)				(((x) & 0xF) << 4)
+#define XTAL_GATE_USB				BIT(8)
+#define _XTAL_USB_DRV(x)			(((x) & 0x3) << 9)
+#define XTAL_GATE_AFE				BIT(11)
+#define _XTAL_AFE_DRV(x)			(((x) & 0x3) << 12)
+#define XTAL_RF_GATE				BIT(14)
+#define _XTAL_RF_DRV(x)				(((x) & 0x3) << 15)
+#define XTAL_GATE_DIG				BIT(17)
+#define _XTAL_DIG_DRV(x)			(((x) & 0x3) << 18)
+#define XTAL_BT_GATE				BIT(20)
+#define _XTAL_BT_DRV(x)				(((x) & 0x3) << 21)
+#define _XTAL_GPIO(x)				(((x) & 0x7) << 23)
+
+
+#define CKDLY_AFE					BIT(26)
+#define CKDLY_USB					BIT(27)
+#define CKDLY_DIG					BIT(28)
+#define CKDLY_BT					BIT(29)
+
+
+/* 2 AFE_PLL_CTRL */
+#define APLL_EN						BIT(0)
+#define APLL_320_EN					BIT(1)
+#define APLL_FREF_SEL				BIT(2)
+#define APLL_EDGE_SEL				BIT(3)
+#define APLL_WDOGB					BIT(4)
+#define APLL_LPFEN					BIT(5)
+
+#define APLL_REF_CLK_13MHZ			0x1
+#define APLL_REF_CLK_19_2MHZ		0x2
+#define APLL_REF_CLK_20MHZ			0x3
+#define APLL_REF_CLK_25MHZ			0x4
+#define APLL_REF_CLK_26MHZ			0x5
+#define APLL_REF_CLK_38_4MHZ		0x6
+#define APLL_REF_CLK_40MHZ			0x7
+
+#define APLL_320EN					BIT(14)
+#define APLL_80EN					BIT(15)
+#define APLL_1MEN					BIT(24)
+
+
+/* 2 EFUSE_CTRL */
+#define ALD_EN						BIT(18)
+#define EF_PD						BIT(19)
+#define EF_FLAG						BIT(31)
+
+/* 2 EFUSE_TEST */
+#define EF_TRPT						BIT(7)
+#define LDOE25_EN					BIT(31)
+
+/* 2 PWR_DATA */
+
+/* 2 CAL_TIMER */
+
+/* 2 ACLK_MON */
+#define RSM_EN						BIT(0)
+#define Timer_EN						BIT(4)
+
+
+/* 2 GPIO_MUXCFG */
+#define TRSW0EN						BIT(2)
+#define TRSW1EN						BIT(3)
+#define EROM_EN						BIT(4)
+#define EnBT							BIT(5)
+#define EnUart						BIT(8)
+#define Uart_910						BIT(9)
+#define EnPMAC						BIT(10)
+#define SIC_SWRST					BIT(11)
+#define EnSIC						BIT(12)
+#define SIC_23						BIT(13)
+#define EnHDP						BIT(14)
+#define SIC_LBK						BIT(15)
+
+/* 2 GPIO_PIN_CTRL */
+
+
+
+/* 2 GPIO_INTM */
+
+/* 2 LEDCFG */
+#define LED0PL					BIT(4)
+#define LED1PL					BIT(12)
+#define LED0DIS					BIT(7)
+
+#define  SECCAM_CLR				BIT(30)
+
+/* 2 FSIMR */
+
+/* 2 FSISR */
+
+
+/* 2 8051FWDL */
+/* 2 MCUFWDL */
+#define MCUFWDL_EN					BIT(0)
+#define MCUFWDL_RDY				BIT(1)
+#define FWDL_ChkSum_rpt			BIT(2)
+#define MACINI_RDY					BIT(3)
+#define BBINI_RDY					BIT(4)
+#define RFINI_RDY					BIT(5)
+#define WINTINI_RDY					BIT(6)
+#define MAC1_WINTINI_RDY			BIT(11)/*  0X81 BIT3 */
+#define CPRST						BIT(23)
+
+
+
+
+/* 2 REG_SYS_CFG */
+#define XCLK_VLD						BIT(0)
+#define ACLK_VLD					BIT(1)
+#define UCLK_VLD					BIT(2)
+#define PCLK_VLD						BIT(3)
+#define PCIRSTB						BIT(4)
+#define V15_VLD						BIT(5)
+#define TRP_B15V_EN					BIT(7)
+#define SIC_IDLE						BIT(8)
+#define BD_MAC2						BIT(9)
+#define BD_MAC1						BIT(10)
+#define IC_MACPHY_MODE				BIT(11)
+#define PAD_HWPD_IDN				BIT(22)
+#define TRP_VAUX_EN					BIT(23)
+#define TRP_BT_EN					BIT(24)
+#define BD_PKG_SEL					BIT(25)
+#define BD_HCI_SEL					BIT(26)
+#define TYPE_ID						BIT(27)
+
+#define CHIP_VER_RTL_MASK			0xF000	/* Bit 12 ~ 15 */
+#define CHIP_VER_RTL_SHIFT			12
+
+/*  */
+/*  */
+/* 	0x0100h ~ 0x01FFh	MACTOP General Configuration */
+/*  */
+/*  */
+
+
+/* 2 Function Enable Registers */
+/* 2 CR */
+
+#define REG_LBMODE					(REG_CR + 3)
+
+
+#define HCI_TXDMA_EN				BIT(0)
+#define HCI_RXDMA_EN				BIT(1)
+#define TXDMA_EN					BIT(2)
+#define RXDMA_EN					BIT(3)
+#define PROTOCOL_EN					BIT(4)
+#define SCHEDULE_EN					BIT(5)
+#define MACTXEN						BIT(6)
+#define MACRXEN						BIT(7)
+#define ENSWBCN						BIT(8)
+#define ENSEC						BIT(9)
+
+/*  Network type */
+#define _NETTYPE(x)					(((x) & 0x3) << 16)
+#define MASK_NETTYPE				0x30000
+#define NT_NO_LINK					0x0
+#define NT_LINK_AD_HOC				0x1
+#define NT_LINK_AP					0x2
+#define NT_AS_AP					0x3
+
+#define _LBMODE(x)					(((x) & 0xF) << 24)
+#define MASK_LBMODE				0xF000000
+#define LOOPBACK_NORMAL			0x0
+#define LOOPBACK_IMMEDIATELY		0xB
+#define LOOPBACK_MAC_DELAY		0x3
+#define LOOPBACK_PHY				0x1
+#define LOOPBACK_DMA				0x7
+
+
+/* 2 PBP - Page Size Register */
+#define GET_RX_PAGE_SIZE(value)		((value) & 0xF)
+#define GET_TX_PAGE_SIZE(value)		(((value) & 0xF0) >> 4)
+#define _PSRX_MASK					0xF
+#define _PSTX_MASK					0xF0
+#define _PSRX(x)						(x)
+#define _PSTX(x)						((x) << 4)
+
+#define PBP_64						0x0
+#define PBP_128						0x1
+#define PBP_256						0x2
+#define PBP_512						0x3
+#define PBP_1024					0x4
+
+
+/* 2 TX/RXDMA */
+#define RXDMA_ARBBW_EN			BIT(0)
+#define RXSHFT_EN					BIT(1)
+#define RXDMA_AGG_EN				BIT(2)
+#define QS_VO_QUEUE				BIT(8)
+#define QS_VI_QUEUE					BIT(9)
+#define QS_BE_QUEUE				BIT(10)
+#define QS_BK_QUEUE				BIT(11)
+#define QS_MANAGER_QUEUE			BIT(12)
+#define QS_HIGH_QUEUE				BIT(13)
+
+#define HQSEL_VOQ					BIT(0)
+#define HQSEL_VIQ					BIT(1)
+#define HQSEL_BEQ					BIT(2)
+#define HQSEL_BKQ					BIT(3)
+#define HQSEL_MGTQ					BIT(4)
+#define HQSEL_HIQ					BIT(5)
+
+/*  For normal driver, 0x10C */
+#define _TXDMA_HIQ_MAP(x)			(((x)&0x3) << 14)
+#define _TXDMA_MGQ_MAP(x)			(((x)&0x3) << 12)
+#define _TXDMA_BKQ_MAP(x)			(((x)&0x3) << 10)
+#define _TXDMA_BEQ_MAP(x)			(((x)&0x3) << 8)
+#define _TXDMA_VIQ_MAP(x)			(((x)&0x3) << 6)
+#define _TXDMA_VOQ_MAP(x)			(((x)&0x3) << 4)
+
+#define QUEUE_LOW					1
+#define QUEUE_NORMAL				2
+#define QUEUE_HIGH					3
+
+
+
+/* 2 TRXFF_BNDY */
+
+
+/* 2 LLT_INIT */
+#define _LLT_NO_ACTIVE				0x0
+#define _LLT_WRITE_ACCESS			0x1
+#define _LLT_READ_ACCESS			0x2
+
+#define _LLT_INIT_DATA(x)			((x) & 0xFF)
+#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
+#define _LLT_OP(x)					(((x) & 0x3) << 30)
+#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
+
+
+/* 2 BB_ACCESS_CTRL */
+#define BB_WRITE_READ_MASK		(BIT(31) | BIT(30))
+#define BB_WRITE_EN					BIT(30)
+#define BB_READ_EN					BIT(31)
+
+/*  */
+/*  */
+/* 	0x0200h ~ 0x027Fh	TXDMA Configuration */
+/*  */
+/*  */
+/* 2 RQPN */
+#define _HPQ(x)						((x) & 0xFF)
+#define _LPQ(x)						(((x) & 0xFF) << 8)
+#define _PUBQ(x)						(((x) & 0xFF) << 16)
+#define _NPQ(x)						((x) & 0xFF)			/*  NOTE: in RQPN_NPQ register */
+
+
+#define HPQ_PUBLIC_DIS				BIT(24)
+#define LPQ_PUBLIC_DIS				BIT(25)
+#define LD_RQPN						BIT(31)
+
+
+/* 2 TDECTRL */
+#define BCN_VALID					BIT(16)
+#define BCN_HEAD(x)					(((x) & 0xFF) << 8)
+#define	BCN_HEAD_MASK				0xFF00
+
+/* 2 TDECTL */
+#define BLK_DESC_NUM_SHIFT			4
+#define BLK_DESC_NUM_MASK			0xF
+
+
+/* 2 TXDMA_OFFSET_CHK */
+#define DROP_DATA_EN				BIT(9)
+
+/*  */
+/*  */
+/* 	0x0400h ~ 0x047Fh	Protocol Configuration */
+/*  */
+/*  */
+/* 2 FWHW_TXQ_CTRL */
+#define EN_AMPDU_RTY_NEW			BIT(7)
+
+/* 2 INIRTSMCS_SEL */
+#define _INIRTSMCS_SEL(x)			((x) & 0x3F)
+
+
+/* 2 SPEC SIFS */
+#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
+#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
+
+
+/* 2 RRSR */
+
+#define RATE_REG_BITMAP_ALL			0xFFFFF
+
+#define _RRSC_BITMAP(x)					((x) & 0xFFFFF)
+
+#define _RRSR_RSC(x)						(((x) & 0x3) << 21)
+#define RRSR_RSC_RESERVED				0x0
+#define RRSR_RSC_UPPER_SUBCHANNEL	0x1
+#define RRSR_RSC_LOWER_SUBCHANNEL	0x2
+#define RRSR_RSC_DUPLICATE_MODE		0x3
+
+
+/* 2 ARFR */
+#define USE_SHORT_G1				BIT(20)
+
+/* 2 AGGLEN_LMT_L */
+#define _AGGLMT_MCS0(x)				((x) & 0xF)
+#define _AGGLMT_MCS1(x)				(((x) & 0xF) << 4)
+#define _AGGLMT_MCS2(x)				(((x) & 0xF) << 8)
+#define _AGGLMT_MCS3(x)				(((x) & 0xF) << 12)
+#define _AGGLMT_MCS4(x)				(((x) & 0xF) << 16)
+#define _AGGLMT_MCS5(x)				(((x) & 0xF) << 20)
+#define _AGGLMT_MCS6(x)				(((x) & 0xF) << 24)
+#define _AGGLMT_MCS7(x)				(((x) & 0xF) << 28)
+
+
+/* 2 RL */
+#define	RETRY_LIMIT_SHORT_SHIFT		8
+#define	RETRY_LIMIT_LONG_SHIFT		0
+
+
+/* 2 DARFRC */
+#define _DARF_RC1(x)				((x) & 0x1F)
+#define _DARF_RC2(x)				(((x) & 0x1F) << 8)
+#define _DARF_RC3(x)				(((x) & 0x1F) << 16)
+#define _DARF_RC4(x)				(((x) & 0x1F) << 24)
+/*  NOTE: shift starting from address (DARFRC + 4) */
+#define _DARF_RC5(x)				((x) & 0x1F)
+#define _DARF_RC6(x)				(((x) & 0x1F) << 8)
+#define _DARF_RC7(x)				(((x) & 0x1F) << 16)
+#define _DARF_RC8(x)				(((x) & 0x1F) << 24)
+
+
+/* 2 RARFRC */
+#define _RARF_RC1(x)				((x) & 0x1F)
+#define _RARF_RC2(x)				(((x) & 0x1F) << 8)
+#define _RARF_RC3(x)				(((x) & 0x1F) << 16)
+#define _RARF_RC4(x)				(((x) & 0x1F) << 24)
+/*  NOTE: shift starting from address (RARFRC + 4) */
+#define _RARF_RC5(x)				((x) & 0x1F)
+#define _RARF_RC6(x)				(((x) & 0x1F) << 8)
+#define _RARF_RC7(x)				(((x) & 0x1F) << 16)
+#define _RARF_RC8(x)				(((x) & 0x1F) << 24)
+
+
+
+
+/*  */
+/*  */
+/* 	0x0500h ~ 0x05FFh	EDCA Configuration */
+/*  */
+/*  */
+
+
+
+/* 2 EDCA setting */
+#define AC_PARAM_TXOP_LIMIT_OFFSET	16
+#define AC_PARAM_ECW_MAX_OFFSET		12
+#define AC_PARAM_ECW_MIN_OFFSET		8
+#define AC_PARAM_AIFS_OFFSET			0
+
+
+/* 2 EDCA_VO_PARAM */
+#define _AIFS(x)						(x)
+#define _ECW_MAX_MIN(x)			((x) << 8)
+#define _TXOP_LIMIT(x)			((x) << 16)
+
+
+#define _BCNIFS(x)			((x) & 0xFF)
+#define _BCNECW(x)			((((x) & 0xF))<< 8)
+
+
+#define _LRL(x)				((x) & 0x3F)
+#define _SRL(x)				(((x) & 0x3F) << 8)
+
+
+/* 2 SIFS_CCK */
+#define _SIFS_CCK_CTX(x)		((x) & 0xFF)
+#define _SIFS_CCK_TRX(x)		(((x) & 0xFF) << 8);
+
+
+/* 2 SIFS_OFDM */
+#define _SIFS_OFDM_CTX(x)		((x) & 0xFF)
+#define _SIFS_OFDM_TRX(x)		(((x) & 0xFF) << 8);
+
+
+/* 2 TBTT PROHIBIT */
+#define _TBTT_PROHIBIT_HOLD(x)		(((x) & 0xFF) << 8)
+
+
+/* 2 REG_RD_CTRL */
+#define DIS_EDCA_CNT_DWN			BIT(11)
+
+
+/* 2 BCN_CTRL */
+#define EN_MBSSID						BIT(1)
+#define EN_TXBCN_RPT					BIT(2)
+#define EN_BCN_FUNCTION				BIT(3)
+/*  The same function but different bit field. */
+#define DIS_TSF_UDT0_NORMAL_CHIP		BIT(4)
+#define DIS_TSF_UDT0_TEST_CHIP		BIT(5)
+
+/* 2 ACMHWCTRL */
+#define	AcmHw_HwEn					BIT(0)
+#define	AcmHw_BeqEn					BIT(1)
+#define	AcmHw_ViqEn					BIT(2)
+#define	AcmHw_VoqEn					BIT(3)
+#define	AcmHw_BeqStatus				BIT(4)
+#define	AcmHw_ViqStatus				BIT(5)
+#define	AcmHw_VoqStatus				BIT(6)
+
+
+
+/*  */
+/*  */
+/* 	0x0600h ~ 0x07FFh	WMAC Configuration */
+/*  */
+/*  */
+
+/* 2 APSD_CTRL */
+#define APSDOFF						BIT(6)
+#define APSDOFF_STATUS				BIT(7)
+
+
+/* 2 BWOPMODE */
+#define BW_20MHZ					BIT(2)
+
+
+#define RATE_BITMAP_ALL			0xFFFFF
+
+/*  Only use CCK 1M rate for ACK */
+#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
+#define RATE_RRSR_WITHOUT_CCK		0xFFFF0
+
+/* 2 TCR */
+#define TSFRST						BIT(0)
+#define DIS_GCLK						BIT(1)
+#define PAD_SEL						BIT(2)
+#define PWR_ST						BIT(6)
+#define PWRBIT_OW_EN				BIT(7)
+#define ACRC							BIT(8)
+#define CFENDFORM					BIT(9)
+#define ICV							BIT(10)
+
+
+
+/* 2 RCR */
+#define AAP							BIT(0)
+#define APM							BIT(1)
+#define AM							BIT(2)
+#define AB							BIT(3)
+#define ADD3							BIT(4)
+#define APWRMGT					BIT(5)
+#define CBSSID						BIT(6)
+#define CBSSID_BCN					BIT(7)
+#define ACRC32						BIT(8)
+#define AICV							BIT(9)
+#define ADF							BIT(11)
+#define ACF							BIT(12)
+#define AMF							BIT(13)
+#define HTC_LOC_CTRL				BIT(14)
+#define UC_DATA_EN					BIT(16)
+#define BM_DATA_EN					BIT(17)
+#define MFBEN						BIT(22)
+#define LSIGEN						BIT(23)
+#define EnMBID						BIT(24)
+#define APP_BASSN					BIT(27)
+#define APP_PHYSTS					BIT(28)
+#define APP_ICV						BIT(29)
+#define APP_MIC						BIT(30)
+#define APP_FCS						BIT(31)
+
+/* 2 RX_PKT_LIMIT */
+
+/* 2 RX_DLK_TIME */
+
+/* 2 MBIDCAMCFG */
+
+
+
+/* 2 AMPDU_MIN_SPACE */
+#define _MIN_SPACE(x)				((x) & 0x7)
+#define _SHORT_GI_PADDING(x)		(((x) & 0x1F) << 3)
+
+
+/* 2 RXERR_RPT */
+#define RXERR_TYPE_OFDM_PPDU			0
+#define RXERR_TYPE_OFDMfalse_ALARM	1
+#define RXERR_TYPE_OFDM_MPDU_OK		2
+#define RXERR_TYPE_OFDM_MPDU_FAIL	3
+#define RXERR_TYPE_CCK_PPDU			4
+#define RXERR_TYPE_CCKfalse_ALARM	5
+#define RXERR_TYPE_CCK_MPDU_OK		6
+#define RXERR_TYPE_CCK_MPDU_FAIL		7
+#define RXERR_TYPE_HT_PPDU				8
+#define RXERR_TYPE_HTfalse_ALARM	9
+#define RXERR_TYPE_HT_MPDU_TOTAL		10
+#define RXERR_TYPE_HT_MPDU_OK			11
+#define RXERR_TYPE_HT_MPDU_FAIL		12
+#define RXERR_TYPE_RX_FULL_DROP		15
+
+#define RXERR_COUNTER_MASK			0xFFFFF
+#define RXERR_RPT_RST					BIT(27)
+#define _RXERR_RPT_SEL(type)			((type) << 28)
+
+
+/* 2 SECCFG */
+#define	SCR_TxUseDK					BIT(0)			/* Force Tx Use Default Key */
+#define	SCR_RxUseDK					BIT(1)			/* Force Rx Use Default Key */
+#define	SCR_TxEncEnable				BIT(2)			/* Enable Tx Encryption */
+#define	SCR_RxDecEnable				BIT(3)			/* Enable Rx Decryption */
+#define	SCR_SKByA2						BIT(4)			/* Search kEY BY A2 */
+#define	SCR_NoSKMC						BIT(5)			/* No Key Search Multicast */
+#define		SCR_TXBCUSEDK					BIT(6)			/*  Force Tx Broadcast packets Use Default Key */
+#define		SCR_RXBCUSEDK					BIT(7)			/*  Force Rx Broadcast packets Use Default Key */
+
+/* vivi added for new cam search flow, 20091028 */
+#ifdef HW_EN_DE_CRYPTION_FOR_NEW_CAM_SEARCH_FLOW
+#define	SCR_TxUseBroadcastDK			BIT6			/* Force Tx Use Broadcast Default Key */
+#define	SCR_RxUseBroadcastDK			BIT7			/* Force Rx Use Broadcast Default Key */
+#endif
+
+
+/*  */
+/*  */
+/* 	0xFE00h ~ 0xFE55h	USB Configuration */
+/*  */
+/*  */
+
+/* 2 USB Information (0xFE17) */
+#define USB_IS_HIGH_SPEED				0
+#define USB_IS_FULL_SPEED				1
+#define USB_SPEED_MASK					BIT(5)
+
+#define USB_NORMAL_SIE_EP_MASK		0xF
+#define USB_NORMAL_SIE_EP_SHIFT		4
+
+#define USB_TEST_EP_MASK				0x30
+#define USB_TEST_EP_SHIFT				4
+
+/* 2 Special Option */
+#define USB_AGG_EN						BIT(3)
+
+
+/* 2REG_C2HEVT_CLEAR */
+#define C2H_EVT_HOST_CLOSE				0x00	/*  Set by driver and notify FW that the driver has read the C2H command message */
+#define C2H_EVT_FW_CLOSE				0xFF	/*  Set by FW indicating that FW had set the C2H command message and it's not yet read by driver. */
+
+/* 2 8192D PartNo. */
+#define		PARTNO_92D_NIC			(BIT7|BIT6)
+#define		PARTNO_92D_NIC_REMARK (BIT5|BIT4)
+#define		PARTNO_SINGLE_BAND_VS  BIT3
+#define		PARTNO_SINGLE_BAND_VS_REMARK BIT1
+#define		PARTNO_CONCURRENT_BAND_VC (BIT3|BIT2)
+#define		PARTNO_CONCURRENT_BAND_VC_REMARK (BIT1|BIT0)
+/*  */
+/*  General definitions */
+/*  */
+
+#define MAC_ADDR_LEN						6
+#define LAST_ENTRY_OF_TX_PKT_BUFFER		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
+
+#define POLLING_LLT_THRESHOLD				20
+#define POLLING_READY_TIMEOUT_COUNT		1000
+
+/*  Min Spacing related settings. */
+#define	MAX_MSS_DENSITY_2T				0x13
+#define	MAX_MSS_DENSITY_1T				0x0A
+/*  GPIO BIT */
+#define	HAL_8192C_HW_GPIO_WPS_BIT		BIT2
+
+
+#include "basic_types.h"
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtl8192d_xmit.h b/drivers/net/wireless/rtl8192du/include/rtl8192d_xmit.h
new file mode 100644
index 0000000..a1a3ab3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtl8192d_xmit.h
@@ -0,0 +1,108 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTL8192D_XMIT_H_
+#define _RTL8192D_XMIT_H_
+
+/*  */
+/*  Queue Select Value in TxDesc */
+/*  */
+#define QSLT_BK							0x2/* 0x01 */
+#define QSLT_BE							0x0
+#define QSLT_VI							0x5/* 0x4 */
+#define QSLT_VO							0x7/* 0x6 */
+#define QSLT_BEACON						0x10
+#define QSLT_HIGH						0x11
+#define QSLT_MGNT						0x12
+#define QSLT_CMD						0x13
+
+/* Because we open EM for normal case, we just always insert 2*8 bytes.by wl */
+#define USB_92D_DUMMY_OFFSET		2
+#define USB_92D_DUMMY_LENGTH		(USB_92D_DUMMY_OFFSET * PACKET_OFFSET_SZ)
+#define USB_HWDESC_HEADER_LEN	(TXDESC_SIZE + USB_92D_DUMMY_LENGTH)
+
+/* For 92D early mode */
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 0, 3, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 4, 12, __Value)
+#define SET_EARLYMODE_LEN1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 16, 12, __Value)
+#define SET_EARLYMODE_LEN2_1(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr, 28, 4, __Value)
+#define SET_EARLYMODE_LEN2_2(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 8, __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 8, 12, __Value)
+#define SET_EARLYMODE_LEN4(__pAddr, __Value) SET_BITS_TO_LE_4BYTE(__pAddr+4, 20, 12, __Value)
+
+/* Copy from rtl8192c */
+struct txrpt_ccx_8192d {
+	/* offset 0 */
+	u8 retry_cnt:6;
+	u8 rsvd_0:2;
+
+	/* offset 1 */
+	u8 rts_retry_cnt:6;
+	u8 rsvd_1:2;
+
+	/* offset 2 */
+	u8 ccx_qtime0;
+	u8 ccx_qtime1;
+
+	/* offset 4 */
+	u8 missed_pkt_num:5;
+	u8 rsvd_4:3;
+
+	/* offset 5 */
+	u8 mac_id:5;
+	u8 des1_fragssn:3;
+
+	/* offset 6 */
+	u8 rpt_pkt_num:5;
+	u8 pkt_drop:1;
+	u8 lifetime_over:1;
+	u8 retry_over:1;
+
+	/* offset 7*/
+	u8 edca_tx_queue:4;
+	u8 rsvd_7:1;
+	u8 bmc:1;
+	u8 pkt_ok:1;
+	u8 int_ccx:1;
+};
+
+#define txrpt_ccx_qtime_8192d(txrpt_ccx) ((txrpt_ccx)->ccx_qtime0+((txrpt_ccx)->ccx_qtime1<<8))
+
+void dump_txrpt_ccx_8192d(void *buf);
+void handle_txrpt_ccx_8192d(struct rtw_adapter *adapter, void *buf);
+
+#define MAX_TX_AGG_PACKET_NUMBER 0xFF
+
+s32	rtl8192du_init_xmit_priv(struct rtw_adapter * padapter);
+
+void	rtl8192du_free_xmit_priv(struct rtw_adapter * padapter);
+
+void rtl8192du_cal_txdesc_chksum(struct tx_desc	*ptxdesc);
+
+s32 rtl8192du_xmitframe_complete(struct rtw_adapter *padapter,
+				 struct xmit_priv *pxmitpriv,
+				 struct xmit_buf *pxmitbuf);
+
+s32 rtl8192du_mgnt_xmit(struct rtw_adapter *padapter,
+			struct xmit_frame *pmgntframe);
+
+s32 rtl8192du_hal_xmit(struct rtw_adapter *padapter,
+		       struct xmit_frame *pxmitframe);
+
+#ifdef CONFIG_HOSTAPD_MLME
+s32	rtl8192du_hostap_mgnt_xmit_entry(struct rtw_adapter *padapter, struct sk_buff *pkt);
+#endif
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_android.h b/drivers/net/wireless/rtl8192du/include/rtw_android.h
new file mode 100644
index 0000000..a183197
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_android.h
@@ -0,0 +1,85 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __RTW_ANDROID_H__
+#define __RTW_ANDROID_H__
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+enum ANDROID_WIFI_CMD {
+	ANDROID_WIFI_CMD_START,
+	ANDROID_WIFI_CMD_STOP,
+	ANDROID_WIFI_CMD_SCAN_ACTIVE,
+	ANDROID_WIFI_CMD_SCAN_PASSIVE,
+	ANDROID_WIFI_CMD_RSSI,
+	ANDROID_WIFI_CMD_LINKSPEED,
+	ANDROID_WIFI_CMD_RXFILTER_START,
+	ANDROID_WIFI_CMD_RXFILTER_STOP,
+	ANDROID_WIFI_CMD_RXFILTER_ADD,
+	ANDROID_WIFI_CMD_RXFILTER_REMOVE,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_START,
+	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP,
+	ANDROID_WIFI_CMD_BTCOEXMODE,
+	ANDROID_WIFI_CMD_SETSUSPENDOPT,
+	ANDROID_WIFI_CMD_P2P_DEV_ADDR,
+	ANDROID_WIFI_CMD_SETFWPATH,
+	ANDROID_WIFI_CMD_SETBAND,
+	ANDROID_WIFI_CMD_GETBAND,
+	ANDROID_WIFI_CMD_COUNTRY,
+	ANDROID_WIFI_CMD_P2P_SET_NOA,
+	ANDROID_WIFI_CMD_P2P_GET_NOA,
+	ANDROID_WIFI_CMD_P2P_SET_PS,
+	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE,
+#ifdef PNO_SUPPORT
+	ANDROID_WIFI_CMD_PNOSSIDCLR_SET,
+	ANDROID_WIFI_CMD_PNOSETUP_SET,
+	ANDROID_WIFI_CMD_PNOENABLE_SET,
+	ANDROID_WIFI_CMD_PNODEBUG_SET,
+#endif
+
+	ANDROID_WIFI_CMD_MACADDR,
+
+	ANDROID_WIFI_CMD_BLOCK,
+
+	ANDROID_WIFI_CMD_WFD_ENABLE,
+	ANDROID_WIFI_CMD_WFD_DISABLE,
+
+	ANDROID_WIFI_CMD_WFD_SET_TCPPORT,
+	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT,
+	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE,
+
+	ANDROID_WIFI_CMD_MAX
+};
+
+int rtw_android_cmdstr_to_num(char *cmdstr);
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+int rtw_android_wifictrl_func_add(void);
+void rtw_android_wifictrl_func_del(void);
+void* wl_android_prealloc(int section, unsigned long size);
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr);
+int wifi_set_power(int on, unsigned long msec);
+int wifi_get_mac_addr(unsigned char *buf);
+void *wifi_get_country_code(char *ccode);
+#else
+static int rtw_android_wifictrl_func_add(void) { return 0; }
+static void rtw_android_wifictrl_func_del(void) {}
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+#endif /* __RTW_ANDROID_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_ap.h b/drivers/net/wireless/rtl8192du/include/rtw_ap.h
new file mode 100644
index 0000000..0a7cf82
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_ap.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_AP_H_
+#define __RTW_AP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#ifdef CONFIG_92D_AP_MODE
+
+/* external function */
+extern void rtw_indicate_sta_assoc_event(struct rtw_adapter *padapter, struct sta_info *psta);
+extern void rtw_indicate_sta_disassoc_event(struct rtw_adapter *padapter, struct sta_info *psta);
+
+
+void init_mlme_ap_info(struct rtw_adapter *padapter);
+void free_mlme_ap_info(struct rtw_adapter *padapter);
+void rtw_add_bcn_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork, u8 index, u8 *data, u8 len);
+void rtw_remove_bcn_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork, u8 index);
+void update_beacon(struct rtw_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
+void expire_timeout_chk(struct rtw_adapter *padapter);
+void update_sta_info_apmode(struct rtw_adapter *padapter, struct sta_info *psta);
+int rtw_check_beacon_data(struct rtw_adapter *padapter, u8 *pbuf,  int len);
+void rtw_set_macaddr_acl(struct rtw_adapter *padapter, int mode);
+int rtw_acl_add_sta(struct rtw_adapter *padapter, u8 *addr);
+int rtw_acl_remove_sta(struct rtw_adapter *padapter, u8 *addr);
+
+#ifdef CONFIG_NATIVEAP_MLME
+void associated_clients_update(struct rtw_adapter *padapter, u8 updated);
+void bss_cap_update_on_sta_join(struct rtw_adapter *padapter, struct sta_info *psta);
+u8 bss_cap_update_on_sta_leave(struct rtw_adapter *padapter, struct sta_info *psta);
+void sta_info_update(struct rtw_adapter *padapter, struct sta_info *psta);
+void ap_sta_info_defer_update(struct rtw_adapter *padapter, struct sta_info *psta);
+u8 ap_free_sta(struct rtw_adapter *padapter, struct sta_info *psta, bool active, u16 reason);
+int rtw_sta_flush(struct rtw_adapter *padapter);
+int rtw_ap_inform_ch_switch (struct rtw_adapter *padapter, u8 new_ch, u8 ch_offset);
+void start_ap_mode(struct rtw_adapter *padapter);
+void stop_ap_mode(struct rtw_adapter *padapter);
+#endif
+#endif /* end of CONFIG_92D_AP_MODE */
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_cmd.h b/drivers/net/wireless/rtl8192du/include/rtw_cmd.h
new file mode 100644
index 0000000..0572c48
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_cmd.h
@@ -0,0 +1,1114 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_CMD_H_
+#define __RTW_CMD_H_
+
+#include <drv_conf.h>
+#include <wlan_bssdef.h>
+#include <rtw_rf.h>
+#include <rtw_led.h>
+
+#define C2H_MEM_SZ (16*1024)
+
+	#include <osdep_service.h>
+	#include <ieee80211.h> /*  <ieee80211/ieee80211.h> */
+
+
+	#define FREE_CMDOBJ_SZ	128
+
+	#define MAX_CMDSZ	1024
+	#define MAX_RSPSZ	512
+	#define MAX_EVTSZ	1024
+
+	#define CMDBUFF_ALIGN_SZ 512
+
+	struct cmd_obj {
+		struct rtw_adapter *padapter;
+		u16	cmdcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	cmdsz;
+		u8	*rsp;
+		u32	rspsz;
+		struct list_head list;
+	};
+
+	struct cmd_priv {
+		struct  semaphore cmd_queue_sema;
+		struct  semaphore terminate_cmdthread_sema;
+		struct __queue cmd_queue;
+		u8	cmd_seq;
+		u8	*cmd_buf;	/* shall be non-paged, and 4 bytes aligned */
+		u8	*cmd_allocated_buf;
+		u8	*rsp_buf;	/* shall be non-paged, and 4 bytes aligned */
+		u8	*rsp_allocated_buf;
+		u32	cmd_issued_cnt;
+		u32	cmd_done_cnt;
+		u32	rsp_cnt;
+		u8 cmdthd_running;
+		struct rtw_adapter *padapter;
+	};
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	struct evt_obj {
+		u16	evtcode;
+		u8	res;
+		u8	*parmbuf;
+		u32	evtsz;
+		struct list_head list;
+	};
+#endif
+
+	struct	evt_priv {
+#ifdef CONFIG_EVENT_THREAD_MODE
+		struct  semaphore evt_notify;
+		struct  semaphore terminate_evtthread_sema;
+		struct __queue evt_queue;
+#endif
+
+/* define CONFIG_C2H_WK */
+#ifdef CONFIG_C2H_WK
+		struct work_struct c2h_wk;
+		bool c2h_wk_alive;
+		struct rtw_cbuf *c2h_queue;
+		#define C2H_QUEUE_MAX_LEN 10
+#endif
+
+#ifdef CONFIG_H2CLBK
+		struct  semaphore lbkevt_done;
+		u8	lbkevt_limit;
+		u8	lbkevt_num;
+		u8	*cmdevt_parm;
+#endif
+		ATOMIC_T event_seq;
+		u8	*evt_buf;	/* shall be non-paged, and 4 bytes aligned */
+		u8	*evt_allocated_buf;
+		u32	evt_done_cnt;
+	};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	INIT_LIST_HEAD(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (u8 *)(pparm);\
+	pcmd->cmdsz = sizeof (*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while (0)
+
+struct c2h_evt_hdr {
+	u8 id:4;
+	u8 plen:4;
+	u8 seq;
+	u8 payload[0];
+};
+
+#define c2h_evt_exist(c2h_evt) ((c2h_evt)->id || (c2h_evt)->plen)
+
+extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+extern u32 rtw_enqueue_evt(struct evt_priv *pevtpriv, struct evt_obj *obj);
+extern struct evt_obj *rtw_dequeue_evt(struct __queue *queue);
+extern void rtw_free_evt_obj(struct evt_obj *pcmd);
+#endif
+
+int rtw_cmd_thread(void *context);
+
+extern u32 rtw_init_cmd_priv (struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_priv (struct cmd_priv *pcmdpriv);
+
+extern u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_free_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
+
+enum rtw_drvextra_cmd_id
+{
+	NONE_WK_CID,
+	DYNAMIC_CHK_WK_CID,
+	DM_CTRL_WK_CID,
+	PBC_POLLING_WK_CID,
+	POWER_SAVING_CTRL_WK_CID,/* IPS,AUTOSuspend */
+	LPS_CTRL_WK_CID,
+	ANT_SELECT_WK_CID,
+	P2P_PS_WK_CID,
+	P2P_PROTO_WK_CID,
+	CHECK_HIQ_WK_CID,/* for softap mode, check hi queue if empty */
+	INTEl_WIDI_WK_CID,
+	C2H_WK_CID,
+	MAX_WK_CID
+};
+
+enum LPS_CTRL_TYPE
+{
+	LPS_CTRL_SCAN=0,
+	LPS_CTRL_JOINBSS=1,
+	LPS_CTRL_CONNECT=2,
+	LPS_CTRL_DISCONNECT=3,
+	LPS_CTRL_SPECIAL_PACKET=4,
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;/*  1: sleep, 0:resume */
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	struct wlan_bssid_ex network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 deauth_timeout_ms;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	struct wlan_bssid_ex network;
+};
+
+struct	setopmode_parm {
+	u8	mode;
+	u8	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode
+
+*/
+
+#define RTW_SSID_SCAN_AMOUNT 9 /*  for WEXT_CSCAN_AMOUNT 9 */
+#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
+struct sitesurvey_parm {
+	int scan_mode;	/* active: 1, passive: 0 */
+	u8 ssid_num;
+	u8 ch_num;
+	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	u8 mode;  /* 0: legacy open, 1: legacy shared 2: 802.1x */
+	u8 _1x;   /* 0: PSK, 1: TLS */
+	u8 rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	u8	algorithm;	/*  encryption algorithm, could be none, wep40, TKIP, CCMP, wep104 */
+	u8	keyid;
+	u8	grpkey;		/*  1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x */
+	u8	set_tx;		/*  1: main tx key for wep. 0: other key. */
+	u8	key[16];	/*  this could be 40 or 104 */
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid
+
+*/
+struct set_stakey_parm {
+	u8	addr[ETH_ALEN];
+	u8	algorithm;
+	u8	id;/*  currently for erasing cam entry if algorithm == _NO_PRIVACY_ */
+	u8	key[16];
+};
+
+struct set_stakey_rsp {
+	u8	addr[ETH_ALEN];
+	u8	keyid;
+	u8	rsvd;
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	u8	cam_id;
+	u8	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+
+	Command mode
+
+	This is to force fw to del an sta_data entry per driver's request
+
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	u8	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	u8	staid;
+	u8	status;
+	u8	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	u8	basicrates[NUMRATES];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	u8 basicrates[NUMRATES];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	u8	mac_id;
+	u8	datarates[NUMRATES];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	u8 datarates[NUMRATES];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_SETs[NUM_REGULATORYS];
+	u8	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_SETs[NUM_REGULATORYS];
+	u8	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	u8	rfchannel;
+	u8	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	u8	rfchannel;
+	u8	modem;
+};
+
+struct readBB_parm {
+	u8	offset;
+};
+struct readBB_rsp {
+	u8	value;
+};
+
+struct readTSSI_parm {
+	u8	offset;
+};
+struct readTSSI_rsp {
+	u8	value;
+};
+
+struct writeBB_parm {
+	u8	offset;
+	u8	value;
+};
+
+struct readRF_parm {
+	u8	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct getrfintfs_parm {
+	u8	rfintfs;
+};
+
+
+struct Tx_Beacon_param
+{
+	struct wlan_bssid_ex network;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=	swap32(w1);
+		b0		=	b1
+		s2		=	s0 + s1
+		b1		=	b0
+		w1		=	w0
+
+	mac[0] ==	2
+	==> CMD_EVENT mode, return	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=	swap32(w0);
+		b0		=	b1
+		s2		=	s0 + event.mac[2]
+		b1		=	b0
+		w1		=	swap32(w1) - event.mac[2];
+
+		parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+#ifdef CONFIG_H2CLBK
+
+struct seth2clbk_parm {
+	u8 mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16  s2;
+	u8	b1;
+	u32	w1;
+};
+
+struct geth2clbk_parm {
+	u32 rsv;
+};
+
+struct geth2clbk_rsp {
+	u8	mac[6];
+	u16	s0;
+	u16	s1;
+	u32	w0;
+	u8	b0;
+	u16	s2;
+	u8	b1;
+	u32	w1;
+};
+
+#endif	/* CONFIG_H2CLBK */
+
+/*  CMD param Formart for driver extra cmd handler */
+struct drvextra_cmd_parm {
+	int ec_id; /* extra cmd id */
+	int type_size; /*  Can use this field as the type id or command size */
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	u8	tx_antset;
+	u8	rx_antset;
+	u8	tx_antenna;
+	u8	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		/*  0: pure hw, 1: fw */
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	u8	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	u8	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	u8	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	u8	count_judge[MAX_RATES_LENGTH];
+};
+
+
+struct setratable_parm {
+	u8 ss_ForceUp[NUMRATES];
+	u8 ss_ULevel[NUMRATES];
+	u8 ss_DLevel[NUMRATES];
+	u8 count_judge[NUMRATES];
+};
+
+struct getratable_parm {
+                uint rsvd;
+};
+struct getratable_rsp {
+        u8 ss_ForceUp[NUMRATES];
+        u8 ss_ULevel[NUMRATES];
+        u8 ss_DLevel[NUMRATES];
+        u8 count_judge[NUMRATES];
+};
+
+
+/* to get TX,RX retry count */
+struct gettxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp{
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp{
+	unsigned long rx_retrycnt;
+};
+
+/* to get BCNOK,BCNERR count */
+struct getbcnokcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp{
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp{
+	unsigned long bcnerrcnt;
+};
+
+/*  to get current TX power level */
+struct getcurtxpwrlevel_parm{
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp{
+	unsigned short tx_power;
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm
+{
+	unsigned int tid;
+	u8	addr[ETH_ALEN];
+};
+
+/*H2C Handler index: 46 */
+struct set_ch_parm {
+	u8 ch;
+	u8 bw;
+	u8 ch_offset;
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTXPOWER_parm
+{
+	u8 TXPOWER;
+};
+
+/*H2C Handler index: 48 */
+struct SWITCHANTENNA_parm
+{
+	u16 antenna_tx;
+	u16 antenna_rx;
+/* 	R_ANTENNA_SELECT_CCK cck_txrx; */
+	u8 cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct setcrystalcap_parm
+{
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct setsinglecarriertx_parm
+{
+	u8 start;
+};
+
+/*H2C Handler index: 51 */
+struct setsingletonetx_parm
+{
+	u8 start;
+	u8 curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct setcarriersuppressiontx_parm
+{
+	u8 start;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct setcontinuoustx_parm
+{
+	u8 start;
+	u8 cck_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct switchbandwidth_parm
+{
+	u8 curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+/*H2C Handler index: 59 */
+struct setchannelplan_param
+{
+	u8 channel_plan;
+};
+
+/*H2C Handler index: 60 */
+struct ledblink_param
+{
+	struct LED_871X	*pLed;
+};
+
+/*H2C Handler index: 61 */
+struct setchannelswitch_param
+{
+	u8 new_ch_no;
+};
+
+/*H2C Handler index: 62 */
+struct tdlsoption_param
+{
+	u8 addr[ETH_ALEN];
+	u8 option;
+};
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result:
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+extern u8 rtw_setassocsta_cmd(struct rtw_adapter  *padapter, u8 *mac_addr);
+extern u8 rtw_setstandby_cmd(struct rtw_adapter *padapter, uint action);
+u8 rtw_sitesurvey_cmd(struct rtw_adapter  *padapter, struct ndis_802_11_ssid *ssid, int ssid_num, struct rtw_ieee80211_channel *ch, int ch_num);
+extern u8 rtw_createbss_cmd(struct rtw_adapter  *padapter);
+extern u8 rtw_createbss_cmd_ex(struct rtw_adapter  *padapter, unsigned char *pbss, unsigned int sz);
+extern u8 rtw_setphy_cmd(struct rtw_adapter  *padapter, u8 modem, u8 ch);
+extern u8 rtw_setstakey_cmd(struct rtw_adapter  *padapter, u8 *psta, u8 unicast_key);
+extern u8 rtw_clearstakey_cmd(struct rtw_adapter *padapter, u8 *psta, u8 entry, u8 enqueue);
+extern u8 rtw_joinbss_cmd(struct rtw_adapter  *padapter, struct wlan_network* pnetwork);
+u8 rtw_disassoc_cmd(struct rtw_adapter *padapter, u32 deauth_timeout_ms, bool enqueue);
+extern u8 rtw_setopmode_cmd(struct rtw_adapter  *padapter, enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+extern u8 rtw_setdatarate_cmd(struct rtw_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbasicrate_cmd(struct rtw_adapter  *padapter, u8 *rateset);
+extern u8 rtw_setbbreg_cmd(struct rtw_adapter * padapter, u8 offset, u8 val);
+extern u8 rtw_setrfreg_cmd(struct rtw_adapter * padapter, u8 offset, u32 val);
+extern u8 rtw_getbbreg_cmd(struct rtw_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_getrfreg_cmd(struct rtw_adapter * padapter, u8 offset, u8 * pval);
+extern u8 rtw_setrfintfs_cmd(struct rtw_adapter  *padapter, u8 mode);
+extern u8 rtw_setrttbl_cmd(struct rtw_adapter  *padapter, struct setratable_parm *prate_table);
+extern u8 rtw_getrttbl_cmd(struct rtw_adapter  *padapter, struct getratable_rsp *pval);
+
+extern u8 rtw_gettssi_cmd(struct rtw_adapter  *padapter, u8 offset,u8 *pval);
+extern u8 rtw_setfwdig_cmd(struct rtw_adapter*padapter, u8 type);
+extern u8 rtw_setfwra_cmd(struct rtw_adapter*padapter, u8 type);
+
+extern u8 rtw_addbareq_cmd(struct rtw_adapter*padapter, u8 tid, u8 *addr);
+
+extern u8 rtw_dynamic_chk_wk_cmd(struct rtw_adapter *adapter);
+
+u8 rtw_lps_ctrl_wk_cmd(struct rtw_adapter*padapter, u8 lps_ctrl_type, u8 enqueue);
+
+#ifdef CONFIG_ANTENNA_DIVERSITY
+extern  u8 rtw_antenna_select_cmd(struct rtw_adapter*padapter, u8 antenna,u8 enqueue);
+#endif
+
+extern u8 rtw_ps_cmd(struct rtw_adapter*padapter);
+
+
+#ifdef CONFIG_92D_AP_MODE
+u8 rtw_chk_hi_queue_cmd(struct rtw_adapter*padapter);
+#endif
+
+u8 rtw_set_ch_cmd(struct rtw_adapter*padapter, u8 ch, u8 bw, u8 ch_offset, u8 enqueue);
+extern u8 rtw_set_chplan_cmd(struct rtw_adapter*padapter, u8 chplan, u8 enqueue);
+extern u8 rtw_led_blink_cmd(struct rtw_adapter*padapter, struct LED_871X *pLed);
+extern u8 rtw_set_csa_cmd(struct rtw_adapter*padapter, u8 new_ch_no);
+extern u8 rtw_tdls_cmd(struct rtw_adapter*padapter, u8 *addr, u8 option);
+
+extern u8 rtw_c2h_wk_cmd(struct rtw_adapter * padapter, u8 *c2h_evt);
+
+u8 rtw_drvextra_cmd_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+
+extern void rtw_survey_cmd_callback(struct rtw_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_disassoc_cmd_callback(struct rtw_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(struct rtw_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_createbss_cmd_callback(struct rtw_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_getbbrfreg_cmdrsp_callback(struct rtw_adapter  *padapter, struct cmd_obj *pcmd);
+extern void rtw_readtssi_cmdrsp_callback(struct rtw_adapter*	padapter,  struct cmd_obj *pcmd);
+
+extern void rtw_setstakey_cmdrsp_callback(struct rtw_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_setassocsta_cmdrsp_callback(struct rtw_adapter  *padapter,  struct cmd_obj *pcmd);
+extern void rtw_getrttbl_cmdrsp_callback(struct rtw_adapter  *padapter,  struct cmd_obj *pcmd);
+
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(struct rtw_adapter  *padapter, struct cmd_obj *cmd);
+};
+
+enum rtw_h2c_cmd
+{
+	GEN_CMD_CODE(_READ_MACREG) ,	/*0*/
+	GEN_CMD_CODE(_WRITE_MACREG) ,
+	GEN_CMD_CODE(_READ_BBREG) ,
+	GEN_CMD_CODE(_WRITE_BBREG) ,
+	GEN_CMD_CODE(_READ_RFREG) ,
+	GEN_CMD_CODE(_WRITE_RFREG) , /*5*/
+	GEN_CMD_CODE(_READ_EEPROM) ,
+	GEN_CMD_CODE(_WRITE_EEPROM) ,
+	GEN_CMD_CODE(_READ_EFUSE) ,
+	GEN_CMD_CODE(_WRITE_EFUSE) ,
+
+	GEN_CMD_CODE(_READ_CAM) ,	/*10*/
+	GEN_CMD_CODE(_WRITE_CAM) ,
+	GEN_CMD_CODE(_SETBCNITV),
+	GEN_CMD_CODE(_SETMBIDCFG),
+	GEN_CMD_CODE(_JOINBSS),   /*14*/
+	GEN_CMD_CODE(_DISCONNECT) , /*15*/
+	GEN_CMD_CODE(_CREATEBSS) ,
+	GEN_CMD_CODE(_SETOPMODE) ,
+	GEN_CMD_CODE(_SITESURVEY),  /*18*/
+	GEN_CMD_CODE(_SETAUTH) ,
+
+	GEN_CMD_CODE(_SETKEY) ,	/*20*/
+	GEN_CMD_CODE(_SETSTAKEY) ,
+	GEN_CMD_CODE(_SETASSOCSTA) ,
+	GEN_CMD_CODE(_DELASSOCSTA) ,
+	GEN_CMD_CODE(_SETSTAPWRSTATE) ,
+	GEN_CMD_CODE(_SETBASICRATE) , /*25*/
+	GEN_CMD_CODE(_GETBASICRATE) ,
+	GEN_CMD_CODE(_SETDATARATE) ,
+	GEN_CMD_CODE(_GETDATARATE) ,
+	GEN_CMD_CODE(_SETPHYINFO) ,
+
+	GEN_CMD_CODE(_GETPHYINFO) ,	/*30*/
+	GEN_CMD_CODE(_SETPHY) ,
+	GEN_CMD_CODE(_GETPHY) ,
+	GEN_CMD_CODE(_READRSSI) ,
+	GEN_CMD_CODE(_READGAIN) ,
+	GEN_CMD_CODE(_SETATIM) , /*35*/
+	GEN_CMD_CODE(_SETPWRMODE) ,
+	GEN_CMD_CODE(_JOINBSSRPT),
+	GEN_CMD_CODE(_SETRATABLE) ,
+	GEN_CMD_CODE(_GETRATABLE) ,
+
+	GEN_CMD_CODE(_GETCCXREPORT), /*40*/
+	GEN_CMD_CODE(_GETDTMREPORT),
+	GEN_CMD_CODE(_GETTXRATESTATISTICS),
+	GEN_CMD_CODE(_SETUSBSUSPEND),
+	GEN_CMD_CODE(_SETH2CLBK),
+	GEN_CMD_CODE(_ADDBAREQ) , /*45*/
+	GEN_CMD_CODE(_SETCHANNEL), /*46*/
+	GEN_CMD_CODE(_SETTXPOWER),
+	GEN_CMD_CODE(_SWITCHANTENNA),
+	GEN_CMD_CODE(_SETCRYSTALCAP),
+	GEN_CMD_CODE(_SETSINGLECARRIERTX), /*50*/
+
+	GEN_CMD_CODE(_SETSINGLETONETX),/*51*/
+	GEN_CMD_CODE(_SETCARRIERSUPPRESSIONTX),
+	GEN_CMD_CODE(_SETCONTINUOUSTX),
+	GEN_CMD_CODE(_SWITCHBANDWIDTH), /*54*/
+	GEN_CMD_CODE(_TX_BEACON), /*55*/
+
+	GEN_CMD_CODE(_SET_MLME_EVT), /*56*/
+	GEN_CMD_CODE(_SET_DRV_EXTRA), /*57*/
+	GEN_CMD_CODE(_SET_H2C_MSG), /*58*/
+
+	GEN_CMD_CODE(_SETCHANNELPLAN), /*59*/
+	GEN_CMD_CODE(_LEDBLINK), /*60*/
+
+	GEN_CMD_CODE(_SETCHANNELSWITCH), /*61*/
+	GEN_CMD_CODE(_TDLS), /*62*/
+
+	MAX_H2CCMD
+};
+
+#define _GETBBREG_CMD_		_READ_BBREG_CMD_
+#define _SETBBREG_CMD_		_WRITE_BBREG_CMD_
+#define _GETRFREG_CMD_		_READ_RFREG_CMD_
+#define _SETRFREG_CMD_		_WRITE_RFREG_CMD_
+
+#ifdef _RTW_CMD_C_
+static struct _cmd_callback	rtw_cmd_callback[] =
+{
+	{GEN_CMD_CODE(_READ_MACREG), NULL}, /*0*/
+	{GEN_CMD_CODE(_WRITE_MACREG), NULL},
+	{GEN_CMD_CODE(_READ_BBREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_WRITE_BBREG), NULL},
+	{GEN_CMD_CODE(_READ_RFREG), &rtw_getbbrfreg_cmdrsp_callback},
+	{GEN_CMD_CODE(_WRITE_RFREG), NULL}, /*5*/
+	{GEN_CMD_CODE(_READ_EEPROM), NULL},
+	{GEN_CMD_CODE(_WRITE_EEPROM), NULL},
+	{GEN_CMD_CODE(_READ_EFUSE), NULL},
+	{GEN_CMD_CODE(_WRITE_EFUSE), NULL},
+
+	{GEN_CMD_CODE(_READ_CAM),	NULL},	/*10*/
+	{GEN_CMD_CODE(_WRITE_CAM),	 NULL},
+	{GEN_CMD_CODE(_SETBCNITV), NULL},
+	{GEN_CMD_CODE(_SETMBIDCFG), NULL},
+	{GEN_CMD_CODE(_JOINBSS), &rtw_joinbss_cmd_callback},  /*14*/
+	{GEN_CMD_CODE(_DISCONNECT), &rtw_disassoc_cmd_callback}, /*15*/
+	{GEN_CMD_CODE(_CREATEBSS), &rtw_createbss_cmd_callback},
+	{GEN_CMD_CODE(_SETOPMODE), NULL},
+	{GEN_CMD_CODE(_SITESURVEY), &rtw_survey_cmd_callback}, /*18*/
+	{GEN_CMD_CODE(_SETAUTH), NULL},
+
+	{GEN_CMD_CODE(_SETKEY), NULL},	/*20*/
+	{GEN_CMD_CODE(_SETSTAKEY), &rtw_setstakey_cmdrsp_callback},
+	{GEN_CMD_CODE(_SETASSOCSTA), &rtw_setassocsta_cmdrsp_callback},
+	{GEN_CMD_CODE(_DELASSOCSTA), NULL},
+	{GEN_CMD_CODE(_SETSTAPWRSTATE), NULL},
+	{GEN_CMD_CODE(_SETBASICRATE), NULL}, /*25*/
+	{GEN_CMD_CODE(_GETBASICRATE), NULL},
+	{GEN_CMD_CODE(_SETDATARATE), NULL},
+	{GEN_CMD_CODE(_GETDATARATE), NULL},
+	{GEN_CMD_CODE(_SETPHYINFO), NULL},
+
+	{GEN_CMD_CODE(_GETPHYINFO), NULL}, /*30*/
+	{GEN_CMD_CODE(_SETPHY), NULL},
+	{GEN_CMD_CODE(_GETPHY), NULL},
+	{GEN_CMD_CODE(_READRSSI), NULL},
+	{GEN_CMD_CODE(_READGAIN), NULL},
+	{GEN_CMD_CODE(_SETATIM), NULL}, /*35*/
+	{GEN_CMD_CODE(_SETPWRMODE), NULL},
+	{GEN_CMD_CODE(_JOINBSSRPT), NULL},
+	{GEN_CMD_CODE(_SETRATABLE), NULL},
+	{GEN_CMD_CODE(_GETRATABLE) , NULL},
+
+	{GEN_CMD_CODE(_GETCCXREPORT), NULL}, /*40*/
+	{GEN_CMD_CODE(_GETDTMREPORT),	NULL},
+	{GEN_CMD_CODE(_GETTXRATESTATISTICS), NULL},
+	{GEN_CMD_CODE(_SETUSBSUSPEND), NULL},
+	{GEN_CMD_CODE(_SETH2CLBK), NULL},
+	{GEN_CMD_CODE(_ADDBAREQ), NULL}, /*45*/
+	{GEN_CMD_CODE(_SETCHANNEL), NULL},		/*46*/
+	{GEN_CMD_CODE(_SETTXPOWER), NULL},
+	{GEN_CMD_CODE(_SWITCHANTENNA), NULL},
+	{GEN_CMD_CODE(_SETCRYSTALCAP), NULL},
+	{GEN_CMD_CODE(_SETSINGLECARRIERTX), NULL},	/*50*/
+
+	{GEN_CMD_CODE(_SETSINGLETONETX), NULL}, /*51*/
+	{GEN_CMD_CODE(_SETCARRIERSUPPRESSIONTX), NULL},
+	{GEN_CMD_CODE(_SETCONTINUOUSTX), NULL},
+	{GEN_CMD_CODE(_SWITCHBANDWIDTH), NULL},		/*54*/
+	{GEN_CMD_CODE(_TX_BEACON), NULL},/*55*/
+
+	{GEN_CMD_CODE(_SET_MLME_EVT), NULL},/*56*/
+	{GEN_CMD_CODE(_SET_DRV_EXTRA), NULL},/*57*/
+	{GEN_CMD_CODE(_SET_H2C_MSG), NULL},/*58*/
+	{GEN_CMD_CODE(_SETCHANNELPLAN), NULL},/*59*/
+	{GEN_CMD_CODE(_LEDBLINK), NULL},/*60*/
+
+	{GEN_CMD_CODE(_SETCHANNELSWITCH), NULL},/*61*/
+	{GEN_CMD_CODE(_TDLS), NULL},/*62*/
+};
+#endif
+
+#endif /*  _CMD_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_debug.h b/drivers/net/wireless/rtl8192du/include/rtw_debug.h
new file mode 100644
index 0000000..b307b55
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_debug.h
@@ -0,0 +1,388 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_DEBUG_H__
+#define __RTW_DEBUG_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define	_no_debug_			0
+#define _drv_emerg_			1
+#define _drv_alert_			2
+#define _drv_err_			3
+#define	_drv_warning_			4
+#define _drv_notice_			5
+#define _drv_info_			6
+#define	_drv_debug_			7
+
+#define RTL871X_MODULE_NAME "r8192du"
+
+#define _module_rtl871x_xmit_c_		BIT(0)
+#define _module_xmit_osdep_c_		BIT(1)
+#define _module_rtl871x_recv_c_		BIT(2)
+#define _module_recv_osdep_c_		BIT(3)
+#define _module_rtl871x_mlme_c_		BIT(4)
+#define _module_mlme_osdep_c_		BIT(5)
+#define _module_rtl871x_sta_mgt_c_		BIT(6)
+#define _module_rtl871x_cmd_c_			BIT(7)
+#define _module_cmd_osdep_c_		BIT(8)
+#define _module_rtl871x_io_c_				BIT(9)
+#define _module_io_osdep_c_		BIT(10)
+#define _module_os_intfs_c_			BIT(11)
+#define _module_rtl871x_security_c_		BIT(12)
+#define _module_rtl871x_eeprom_c_			BIT(13)
+#define _module_hal_init_c_		BIT(14)
+#define _module_hci_hal_init_c_		BIT(15)
+#define _module_rtl871x_ioctl_c_		BIT(16)
+#define _module_rtl871x_ioctl_set_c_		BIT(17)
+#define _module_rtl871x_ioctl_query_c_	BIT(18)
+#define _module_rtl871x_pwrctrl_c_			BIT(19)
+#define _module_hci_intfs_c_			BIT(20)
+#define _module_hci_ops_c_			BIT(21)
+#define _module_osdep_service_c_			BIT(22)
+#define _module_mp_			BIT(23)
+#define _module_hci_ops_os_c_			BIT(24)
+#define _module_rtl871x_ioctl_os_c		BIT(25)
+#define _module_rtl8712_cmd_c_		BIT(26)
+/* define _module_efuse_			BIT(27) */
+#define	_module_rtl8192c_xmit_c_ BIT(28)
+#define _module_hal_xmit_c_	BIT(28)
+#define _module_efuse_			BIT(29)
+#define _module_rtl8712_recv_c_		BIT(30)
+#define _module_rtl8712_led_c_		BIT(31)
+
+#undef _MODULE_DEFINE_
+
+#if defined _RTW_XMIT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_xmit_c_
+#elif defined _XMIT_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_xmit_osdep_c_
+#elif defined _RTW_RECV_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_recv_c_
+#elif defined _RECV_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_recv_osdep_c_
+#elif defined _RTW_MLME_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_mlme_c_
+#elif defined _MLME_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTW_MLME_EXT_C_
+	#define _MODULE_DEFINE_ 1
+#elif defined _RTW_STA_MGT_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_sta_mgt_c_
+#elif defined _RTW_CMD_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_cmd_c_
+#elif defined _CMD_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_cmd_osdep_c_
+#elif defined _RTW_IO_C_
+	#define _MODULE_DEFINE_	_module_rtl871x_io_c_
+#elif defined _IO_OSDEP_C_
+	#define _MODULE_DEFINE_	_module_io_osdep_c_
+#elif defined _OS_INTFS_C_
+	#define	_MODULE_DEFINE_	_module_os_intfs_c_
+#elif defined _RTW_SECURITY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_security_c_
+#elif defined _RTW_EEPROM_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_eeprom_c_
+#elif defined _HAL_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hal_init_c_
+#elif defined _HCI_HAL_INIT_C_
+	#define	_MODULE_DEFINE_	_module_hci_hal_init_c_
+#elif defined _RTL871X_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_c_
+#elif defined _RTL871X_IOCTL_SET_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_set_c_
+#elif defined _RTL871X_IOCTL_QUERY_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_query_c_
+#elif defined _RTL871X_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_pwrctrl_c_
+#elif defined _RTW_PWRCTRL_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _HCI_OPS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_c_
+#elif defined _SDIO_OPS_C_
+	#define	_MODULE_DEFINE_ 1
+#elif defined _OSDEP_HCI_INTF_C_
+	#define	_MODULE_DEFINE_	_module_hci_intfs_c_
+#elif defined _OSDEP_SERVICE_C_
+	#define	_MODULE_DEFINE_	_module_osdep_service_c_
+#elif defined _HCI_OPS_OS_C_
+	#define	_MODULE_DEFINE_	_module_hci_ops_os_c_
+#elif defined _RTL871X_IOCTL_LINUX_C_
+	#define	_MODULE_DEFINE_	_module_rtl871x_ioctl_os_c
+#elif defined _RTL8712_CMD_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_cmd_c_
+#elif defined _RTL8192C_XMIT_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _RTL8723AS_XMIT_C_
+	#define	_MODULE_DEFINE_	1
+#elif defined _RTL8712_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#elif defined _RTL8192CU_RECV_C_
+	#define	_MODULE_DEFINE_	_module_rtl8712_recv_c_
+#elif defined _RTL871X_MLME_EXT_C_
+	#define _MODULE_DEFINE_	_module_mlme_osdep_c_
+#elif defined _RTW_MP_C_
+	#define	_MODULE_DEFINE_	_module_mp_
+#elif defined _RTW_MP_IOCTL_C_
+	#define	_MODULE_DEFINE_	_module_mp_
+#elif defined _RTW_EFUSE_C_
+	#define	_MODULE_DEFINE_	_module_efuse_
+#endif
+
+#define RT_TRACE(_Comp, _Level, Fmt) do{}while (0)
+#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData, _HexDataLen) do{}while (0)
+
+#undef	_dbgdump
+
+#ifndef _RTL871X_DEBUG_C_
+	extern u32 GlobalDebugLevel;
+	extern u64 GlobalDebugComponents;
+#endif
+
+#define _dbgdump	pr_info
+
+#if defined (_dbgdump) && defined (_MODULE_DEFINE_)
+	#undef RT_TRACE
+	#define RT_TRACE(_Comp, _Level, Fmt)				\
+	do {								\
+		if (_Level <= GlobalDebugLevel) {			\
+			_dbgdump("%s [0x%08x,%d]", RTL871X_MODULE_NAME,	\
+				 (unsigned int)_Comp, _Level);		\
+			_dbgdump Fmt;					\
+		}							\
+	} while (0)
+#endif
+
+#if defined (_dbgdump)
+	#undef RT_PRINT_DATA
+	#define RT_PRINT_DATA(_Comp, _Level, _TitleString, _HexData,	\
+			      _HexDataLen)				\
+		if (((_Comp) & GlobalDebugComponents) &&		\
+		    (_Level <= GlobalDebugLevel)) {			\
+			int __i;					\
+			u8 *ptr = (u8 *)_HexData;			\
+			_dbgdump("Rtl871x: ");				\
+				_dbgdump(_TitleString);			\
+				for (__i = 0; __i < (int)_HexDataLen; __i++) {\
+					_dbgdump("%02X%s", ptr[__i],	\
+						 (((__i + 1) % 4) == 0) ?\
+						 " " : " ");	\
+					if (((__i + 1) % 16) == 0)	\
+						_dbgdump("\n");		\
+				}					\
+				_dbgdump("\n");				\
+			}
+#endif
+
+#undef	_dbgdump
+
+#define _dbgdump	pr_info
+
+extern u32 GlobalDebugLevel;
+#define LOG_LEVEL(level, ...)\
+	do {\
+		if (level <= GlobalDebugLevel) {			\
+			pr_debug(__VA_ARGS__);				\
+		}							\
+	} while (0)
+
+#define DBG_8192D(...) LOG_LEVEL(_drv_debug_ ,  __VA_ARGS__)
+
+#define MSG_8192D(...) pr_info(__VA_ARGS__)
+
+#define ERR_8192D(...) pr_err(__VA_ARGS__)
+
+#ifdef CONFIG_PROC_DEBUG
+
+	int proc_get_drv_version(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_log_level(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_log_level(struct file *file, const char __user *buffer,
+			unsigned long count, void *data);
+
+	int proc_get_write_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_write_reg(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_read_reg(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_read_reg(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+
+	int proc_get_fwstate(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_sec_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_mlmext_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_qos_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_ht_option(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rf_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_ap_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_adapter_state(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_trx_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_mac_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_mac_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_mac_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_bb_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_bb_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_bb_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rf_reg_dump1(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rf_reg_dump2(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rf_reg_dump3(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rf_reg_dump4(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+#ifdef CONFIG_92D_AP_MODE
+
+	int proc_get_all_sta_info(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	int proc_get_best_channel(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+#endif
+
+	int proc_get_rx_signal(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_rx_signal(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_ht_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_ht_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_cbw40_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_cbw40_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_ampdu_enable(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_ampdu_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+	int proc_get_two_path_rssi(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rx_stbc(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_rx_stbc(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+
+	int proc_get_vid(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_pid(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_get_rssi_disp(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data);
+
+	int proc_set_rssi_disp(struct file *file, const char __user *buffer,
+		unsigned long count, void *data);
+
+
+#endif /* CONFIG_PROC_DEBUG */
+
+#endif	/* __RTW_DEBUG_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_eeprom.h b/drivers/net/wireless/rtl8192du/include/rtw_eeprom.h
new file mode 100644
index 0000000..3be56c7
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_eeprom.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_EEPROM_H__
+#define __RTW_EEPROM_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define	RTL8712_EEPROM_ID			0x8712
+#define	EEPROM_MAX_SIZE			256
+#define	CLOCK_RATE					50			/* 100us */
+
+/*  EEPROM opcodes */
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      /*  Erase/write enable */
+#define EEPROM_EWDS_OPCODE		16      /*  Erase/write disable */
+
+/* Country codes */
+#define USA							0x555320
+#define EUROPE						0x1 /* temp, should be provided later */
+#define JAPAN						0x2 /* temp, should be provided later */
+
+#define	EEPROM_CID_DEFAULT			0x0
+#define	EEPROM_CID_ALPHA				0x1
+#define	EEPROM_CID_Senao				0x3
+#define	EEPROM_CID_NetCore				0x5
+#define	EEPROM_CID_CAMEO				0X8
+#define	EEPROM_CID_SITECOM				0x9
+#define	EEPROM_CID_COREGA				0xB
+#define	EEPROM_CID_EDIMAX_BELKIN		0xC
+#define	EEPROM_CID_SERCOMM_BELKIN		0xE
+#define	EEPROM_CID_CAMEO1				0xF
+#define	EEPROM_CID_WNC_COREGA		0x12
+#define	EEPROM_CID_CLEVO				0x13
+#define	EEPROM_CID_WHQL				0xFE /*  added by chiyoko for dtm, 20090108 */
+
+/*  */
+/*  Customer ID, note that: */
+/*  This variable is initiailzed through EEPROM or registry, */
+/*  however, its definition may be different with that in EEPROM for */
+/*  EEPROM size consideration. So, we have to perform proper translation between them. */
+/*  Besides, CustomerID of registry has precedence of that of EEPROM. */
+/*  defined below. 060703, by rcnjko. */
+/*  */
+enum RT_CUSTOMER_ID {
+	RT_CID_DEFAULT = 0,
+	RT_CID_8187_ALPHA0 = 1,
+	RT_CID_8187_SERCOMM_PS = 2,
+	RT_CID_8187_HW_LED = 3,
+	RT_CID_8187_NETGEAR = 4,
+	RT_CID_WHQL = 5,
+	RT_CID_819x_CAMEO  = 6,
+	RT_CID_819x_RUNTOP = 7,
+	RT_CID_819x_Senao = 8,
+	RT_CID_TOSHIBA = 9,	/*  Merge by Jacken, 2008/01/31. */
+	RT_CID_819x_Netcore = 10,
+	RT_CID_Nettronix = 11,
+	RT_CID_DLINK = 12,
+	RT_CID_PRONET = 13,
+	RT_CID_COREGA = 14,
+	RT_CID_CHINA_MOBILE = 15,
+	RT_CID_819x_ALPHA = 16,
+	RT_CID_819x_Sitecom = 17,
+	RT_CID_CCX = 18, /*  It's set under CCX logo test and isn't demanded for CCX functions, but for test behavior like retry limit and tx report. By Bruce, 2009-02-17. */
+	RT_CID_819x_Lenovo = 19,
+	RT_CID_819x_QMI = 20,
+	RT_CID_819x_Edimax_Belkin = 21,
+	RT_CID_819x_Sercomm_Belkin = 22,
+	RT_CID_819x_CAMEO1 = 23,
+	RT_CID_819x_MSI = 24,
+	RT_CID_819x_Acer = 25,
+	RT_CID_819x_AzWave_ASUS = 26,
+	RT_CID_819x_AzWave = 27, /*  For AzWave in PCIe, The ID is AzWave use and not only Asus */
+	RT_CID_819x_HP = 28,
+	RT_CID_819x_WNC_COREGA = 29,
+	RT_CID_819x_Arcadyan_Belkin = 30,
+	RT_CID_819x_SAMSUNG = 31,
+	RT_CID_819x_CLEVO = 32,
+	RT_CID_819x_DELL = 33,
+	RT_CID_819x_PRONETS = 34,
+	RT_CID_819x_Edimax_ASUS = 35,
+	RT_CID_819x_CAMEO_NETGEAR = 36,
+};
+
+struct eeprom_priv
+{
+	u8		bautoload_fail_flag;
+	u8		mac_addr[6];	/* PermanentAddress */
+	u16		channel_plan;
+	u8		EepromOrEfuse;
+	u8		efuse_eeprom_data[EEPROM_MAX_SIZE];
+};
+
+
+extern void eeprom_write16(struct rtw_adapter *padapter, u16 reg, u16 data);
+extern u16 eeprom_read16(struct rtw_adapter *padapter, u16 reg);
+extern void read_eeprom_content(struct rtw_adapter *padapter);
+extern void eeprom_read_sz(struct rtw_adapter * padapter, u16 reg,u8* data, u32 sz);
+
+extern void read_eeprom_content_by_attrib(struct rtw_adapter *	padapter	);
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+extern int storeAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv);
+extern int retriveAdaptorInfoFile(char *path, struct eeprom_priv * eeprom_priv);
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
+
+#endif  /* __RTL871X_EEPROM_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_efuse.h b/drivers/net/wireless/rtl8192du/include/rtw_efuse.h
new file mode 100644
index 0000000..b234acd
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_efuse.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_EFUSE_H__
+#define __RTW_EFUSE_H__
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#define	EFUSE_ERROE_HANDLE		1
+
+#define	PG_STATE_HEADER			0x01
+#define	PG_STATE_WORD_0		0x02
+#define	PG_STATE_WORD_1		0x04
+#define	PG_STATE_WORD_2		0x08
+#define	PG_STATE_WORD_3		0x10
+#define	PG_STATE_DATA			0x20
+
+#define	PG_SWBYTE_H			0x01
+#define	PG_SWBYTE_L			0x02
+
+#define	PGPKT_DATA_SIZE		8
+
+#define	EFUSE_WIFI				0
+#define	EFUSE_BT				1
+
+enum _EFUSE_DEF_TYPE {
+	TYPE_EFUSE_MAX_SECTION				= 0,
+	TYPE_EFUSE_REAL_CONTENT_LEN			= 1,
+	TYPE_AVAILABLE_EFUSE_BYTES_BANK		= 2,
+	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL	= 3,
+	TYPE_EFUSE_MAP_LEN					= 4,
+	TYPE_EFUSE_PROTECT_BYTES_BANK		= 5,
+};
+
+#define		EFUSE_MAX_MAP_LEN		256
+#define		EFUSE_MAX_HW_SIZE		512
+#define		EFUSE_MAX_SECTION_BASE	16
+
+#define EXT_HEADER(header) ((header & 0x1F) == 0x0F)
+#define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
+#define GET_HDR_OFFSET_2_0(header) ((header & 0xE0) >> 5)
+
+#define		EFUSE_REPEAT_THRESHOLD_			3
+
+/*  */
+/* 	The following is for BT Efuse definition */
+/*  */
+#define		EFUSE_BT_MAX_MAP_LEN		1024
+#define		EFUSE_MAX_BANK			4
+#define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
+/*  */
+/*--------------------------Define Parameters-------------------------------*/
+#define		EFUSE_MAX_WORD_UNIT			4
+
+/*------------------------------Define structure----------------------------*/
+struct pg_pkt_struct_a {
+	u8 offset;
+	u8 word_en;
+	u8 data[8];
+	u8 word_cnts;
+};
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+extern u8 fakeEfuseBank;
+extern u32 fakeEfuseUsedBytes;
+extern u8 fakeEfuseContent[];
+extern u8 fakeEfuseInitMap[];
+extern u8 fakeEfuseModifiedMap[];
+
+extern u32 BTEfuseUsedBytes;
+extern u8 BTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 BTEfuseInitMap[];
+extern u8 BTEfuseModifiedMap[];
+
+extern u32 fakeBTEfuseUsedBytes;
+extern u8 fakeBTEfuseContent[EFUSE_MAX_BT_BANK][EFUSE_MAX_HW_SIZE];
+extern u8 fakeBTEfuseInitMap[];
+extern u8 fakeBTEfuseModifiedMap[];
+/*------------------------Export global variable----------------------------*/
+
+u8	efuse_GetCurrentSize(struct rtw_adapter * padapter, u16 *size);
+u16	efuse_GetMaxSize(struct rtw_adapter * padapter);
+u8	rtw_efuse_access(struct rtw_adapter * padapter, u8 bRead, u16 start_addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_read(struct rtw_adapter * padapter, u16 addr, u16 cnts, u8 *data);
+u8	rtw_efuse_map_write(struct rtw_adapter * padapter, u16 addr, u16 cnts, u8 *data);
+
+u16	Efuse_GetCurrentSize(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
+u8	Efuse_CalculateWordCnts(u8 word_en);
+void	ReadEFuseByte(struct rtw_adapter * adapter, u16 _offset, u8 *pbuf, bool bPseudoTest) ;
+void	EFUSE_GetEfuseDefinition(struct rtw_adapter * adapter, u8 efuseType, u8 type, void *pOut, bool bPseudoTest);
+u8	efuse_OneByteRead(struct rtw_adapter * adapter, u16 addr, u8 *data, bool	 bPseudoTest);
+u8	efuse_OneByteWrite(struct rtw_adapter * adapter, u16 addr, u8 data, bool	 bPseudoTest);
+
+void	Efuse_PowerSwitch(struct rtw_adapter * adapter,u8	bWrite,u8	 PwrState);
+int	Efuse_PgPacketRead(struct rtw_adapter * adapter, u8 offset, u8 *data, bool bPseudoTest);
+int	Efuse_PgPacketWrite(struct rtw_adapter * adapter, u8 offset, u8 word_en, u8 *data, bool bPseudoTest);
+void	efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata);
+u8	Efuse_WordEnableDataWrite(struct rtw_adapter * adapter, u16 efuse_addr, u8 word_en, u8 *data, bool bPseudoTest);
+
+u8	EFUSE_Read1Byte(struct rtw_adapter * adapter, u16 Address);
+void	EFUSE_ShadowMapUpdate(struct rtw_adapter * adapter, u8 efuseType, bool bPseudoTest);
+void	EFUSE_ShadowRead(struct rtw_adapter * adapter, u8 Type, u16 Offset, u32 *Value);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_event.h b/drivers/net/wireless/rtl8192du/include/rtw_event.h
new file mode 100644
index 0000000..f601db6
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_event.h
@@ -0,0 +1,141 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_EVENT_H_
+#define _RTW_EVENT_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+#include <wlan_bssdef.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/sem.h>
+
+#ifdef CONFIG_H2CLBK
+#include <h2clbk.h>
+#endif
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	struct wlan_bssid_ex bss;
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+
+};
+
+struct stadel_event {
+ unsigned char macaddr[6];
+ unsigned char rsvd[2]; /* for reason */
+ int mac_id;
+};
+
+struct addba_event
+{
+	unsigned int tid;
+};
+
+
+#ifdef CONFIG_H2CLBK
+struct c2hlbk_event{
+	unsigned char mac[6];
+	unsigned short	s0;
+	unsigned short	s1;
+	unsigned int	w0;
+	unsigned char	b0;
+	unsigned short  s2;
+	unsigned char	b1;
+	unsigned int	w1;
+};
+#endif/* CONFIG_H2CLBK */
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(struct rtw_adapter *dev, u8 *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32
+
+struct event_node{
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct wlan_bssid_ex networks[NETWORK_QUEUE_SZ];
+};
+
+
+#endif /*  _WLANEVENT_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_ht.h b/drivers/net/wireless/rtl8192du/include/rtw_ht.h
new file mode 100644
index 0000000..ba19d00
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_ht.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_HT_H_
+#define _RTW_HT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include "wifi.h"
+
+struct ht_priv
+{
+	u32	ht_option;
+	u32	ampdu_enable;/* for enable Tx A-MPDU */
+	u32	tx_amsdu_enable;/* for enable Tx A-MSDU */
+	u32	tx_amdsu_maxlen; /*  1: 8k, 0:4k ; default:8k, for tx */
+	u32	rx_ampdu_maxlen; /* for rx reordering ctrl win_sz, updated when join_callback. */
+
+	u8	bwmode;/*  */
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi;/* short GI */
+
+	/* for processing Tx A-MPDU */
+	u8	agg_enable_bitmap;
+	u8	candidate_tid_bitmap;
+
+	struct rtw_ieee80211_ht_cap ht_cap;
+
+};
+
+#endif	/* _RTL871X_HT_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_io.h b/drivers/net/wireless/rtl8192du/include/rtw_io.h
new file mode 100644
index 0000000..54624da
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_io.h
@@ -0,0 +1,455 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _RTW_IO_H_
+#define _RTW_IO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <osdep_intf.h>
+
+#include <asm/byteorder.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+#include <asm/semaphore.h>
+#else
+#include <linux/semaphore.h>
+#endif
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/atomic.h>
+
+#include <linux/usb.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21))
+#include <linux/usb_ch9.h>
+#else
+#include <linux/usb/ch9.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+#define rtw_usb_buffer_alloc(dev, size, mem_flags, dma) usb_alloc_coherent((dev), (size), (mem_flags), (dma))
+#define rtw_usb_buffer_free(dev, size, addr, dma) usb_free_coherent((dev), (size), (addr), (dma))
+#else
+#define rtw_usb_buffer_alloc(dev, size, mem_flags, dma) usb_buffer_alloc((dev), (size), (mem_flags), (dma))
+#define rtw_usb_buffer_free(dev, size, addr, dma) usb_buffer_free((dev), (size), (addr), (dma))
+#endif
+
+#define NUM_IOREQ		8
+
+#define MAX_PROT_SZ	(64-16)
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+/*  IO COMMAND TYPE */
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+/*  IO STATUS TYPE */
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ((x) & _IOSZ_MASK_))
+
+
+
+/* below is for the intf_option bit defition... */
+
+#define _INTF_ASYNC_	BIT(0)	/* support async io */
+
+struct intf_priv;
+struct intf_hdl;
+struct io_queue;
+
+struct _io_ops
+{
+		u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
+		u16 (*_read16)(struct intf_hdl *pintfhdl, u32 addr);
+		u32 (*_read32)(struct intf_hdl *pintfhdl, u32 addr);
+
+		int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+		int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr, u32 length, u8 *pdata);
+
+		int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
+		int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
+		int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
+
+		void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		void (*_sync_irp_protocol_rw)(struct io_queue *pio_q);
+
+		u32 (*_read_interrupt)(struct intf_hdl *pintfhdl, u32 addr);
+
+		u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+		u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
+
+		u32 (*_write_scsi)(struct intf_hdl *pintfhdl,u32 cnt, u8 *pmem);
+
+		void (*_read_port_cancel)(struct intf_hdl *pintfhdl);
+		void (*_write_port_cancel)(struct intf_hdl *pintfhdl);
+
+};
+
+struct io_req {
+	struct list_head list;
+	u32	addr;
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	u8	*pbuf;
+	struct  semaphore sema;
+
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt);
+	u8 *cnxt;
+};
+
+struct	intf_hdl {
+	struct rtw_adapter *padapter;
+	struct dvobj_priv *pintf_dev;/* 	pointer to &(padapter->dvobjpriv); */
+	struct _io_ops	io_ops;
+};
+
+struct reg_protocol_rd {
+
+#ifdef __LITTLE_ENDIAN
+
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/* DW3 */
+	u32		BusAddress;
+	/* DW4 */
+#else
+
+
+/* DW1 */
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	/* DW2 */
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	/* DW3 */
+	u32		BusAddress;
+
+	/* DW4 */
+
+#endif
+
+};
+
+
+struct reg_protocol_wt {
+
+
+#ifdef __LITTLE_ENDIAN
+
+	/* DW1 */
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	/* DW2 */
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		/* 0:read, 1:write */
+	u32		FixOrContinuous:1;	/* 0:continuous, 1: Fix */
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	/* DW3 */
+	u32		BusAddress;
+	/* DW4 */
+	u32		Value;
+
+#else
+	/* DW1 */
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	/* DW2 */
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	/* DW3 */
+	u32		BusAddress;
+
+	/* DW4 */
+	u32		Value;
+
+#endif
+
+};
+
+
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+struct io_queue {
+	spinlock_t lock;
+	struct list_head free_ioreqs;
+	struct list_head pending;		/* The io_req list that will be served in the single protocol read/write. */
+	struct list_head processing;
+	u8	*free_ioreqs_buf; /*  4-byte aligned */
+	u8	*pallocated_free_ioreqs_buf;
+	struct	intf_hdl	intf;
+};
+
+struct io_priv{
+
+	struct rtw_adapter *padapter;
+
+	struct intf_hdl intf;
+
+};
+
+extern uint ioreq_flush(struct rtw_adapter *adapter, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq,struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(struct rtw_adapter *adapter, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(u8 *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void _rtw_attrib_read(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_attrib_write(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern u8 _rtw_read8(struct rtw_adapter *adapter, u32 addr);
+extern u16 _rtw_read16(struct rtw_adapter *adapter, u32 addr);
+extern u32 _rtw_read32(struct rtw_adapter *adapter, u32 addr);
+extern void _rtw_read_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void _rtw_read_port_cancel(struct rtw_adapter *adapter);
+
+
+extern int _rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16(struct rtw_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val);
+extern int _rtw_writeN(struct rtw_adapter *adapter, u32 addr, u32 length, u8 *pdata);
+
+extern int _rtw_write8_async(struct rtw_adapter *adapter, u32 addr, u8 val);
+extern int _rtw_write16_async(struct rtw_adapter *adapter, u32 addr, u16 val);
+extern int _rtw_write32_async(struct rtw_adapter *adapter, u32 addr, u32 val);
+
+extern void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern u32 _rtw_write_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+u32 _rtw_write_port_and_wait(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem, int timeout_ms);
+extern void _rtw_write_port_cancel(struct rtw_adapter *adapter);
+
+#ifdef DBG_IO
+bool match_read_sniff_ranges(u16 addr, u16 len);
+bool match_write_sniff_ranges(u16 addr, u16 len);
+
+extern u8 dbg_rtw_read8(struct rtw_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u16 dbg_rtw_read16(struct rtw_adapter *adapter, u32 addr, const char *caller, const int line);
+extern u32 dbg_rtw_read32(struct rtw_adapter *adapter, u32 addr, const char *caller, const int line);
+
+extern int dbg_rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val, const char *caller, const int line);
+extern int dbg_rtw_write16(struct rtw_adapter *adapter, u32 addr, u16 val, const char *caller, const int line);
+extern int dbg_rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val, const char *caller, const int line);
+extern int dbg_rtw_writeN(struct rtw_adapter *adapter, u32 addr ,u32 length , u8 *data, const char *caller, const int line);
+
+#define rtw_read8(adapter, addr) dbg_rtw_read8((adapter), (addr), __func__, __LINE__)
+#define rtw_read16(adapter, addr) dbg_rtw_read16((adapter), (addr), __func__, __LINE__)
+#define rtw_read32(adapter, addr) dbg_rtw_read32((adapter), (addr), __func__, __LINE__)
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) dbg_rtw_write8((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_write16(adapter, addr, val) dbg_rtw_write16((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_write32(adapter, addr, val) dbg_rtw_write32((adapter), (addr), (val), __func__, __LINE__)
+#define  rtw_writeN(adapter, addr, length, data) dbg_rtw_writeN((adapter), (addr), (length), (data), __func__, __LINE__)
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), addr, cnt, mem)
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port(adapter, addr, cnt, mem)
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel(adapter)
+#else /* DBG_IO */
+#define rtw_read8(adapter, addr) _rtw_read8((adapter), (addr))
+#define rtw_read16(adapter, addr) _rtw_read16((adapter), (addr))
+#define rtw_read32(adapter, addr) _rtw_read32((adapter), (addr))
+#define rtw_read_mem(adapter, addr, cnt, mem) _rtw_read_mem((adapter), (addr), (cnt), (mem))
+#define rtw_read_port(adapter, addr, cnt, mem) _rtw_read_port((adapter), (addr), (cnt), (mem))
+#define rtw_read_port_cancel(adapter) _rtw_read_port_cancel((adapter))
+
+#define  rtw_write8(adapter, addr, val) _rtw_write8((adapter), (addr), (val))
+#define  rtw_write16(adapter, addr, val) _rtw_write16((adapter), (addr), (val))
+#define  rtw_write32(adapter, addr, val) _rtw_write32((adapter), (addr), (val))
+#define  rtw_writeN(adapter, addr, length, data) _rtw_writeN((adapter), (addr), (length), (data))
+
+#define rtw_write8_async(adapter, addr, val) _rtw_write8_async((adapter), (addr), (val))
+#define rtw_write16_async(adapter, addr, val) _rtw_write16_async((adapter), (addr), (val))
+#define rtw_write32_async(adapter, addr, val) _rtw_write32_async((adapter), (addr), (val))
+
+#define rtw_write_mem(adapter, addr, cnt, mem) _rtw_write_mem((adapter), (addr), (cnt), (mem))
+#define rtw_write_port(adapter, addr, cnt, mem) _rtw_write_port((adapter), (addr), (cnt), (mem))
+#define rtw_write_port_and_wait(adapter, addr, cnt, mem, timeout_ms) _rtw_write_port_and_wait((adapter), (addr), (cnt), (mem), (timeout_ms))
+#define rtw_write_port_cancel(adapter) _rtw_write_port_cancel((adapter))
+#endif /* DBG_IO */
+
+extern void rtw_write_scsi(struct rtw_adapter *adapter, u32 cnt, u8 *pmem);
+
+/* ioreq */
+extern void ioreq_read8(struct rtw_adapter *adapter, u32 addr, u8 *pval);
+extern void ioreq_read16(struct rtw_adapter *adapter, u32 addr, u16 *pval);
+extern void ioreq_read32(struct rtw_adapter *adapter, u32 addr, u32 *pval);
+extern void ioreq_write8(struct rtw_adapter *adapter, u32 addr, u8 val);
+extern void ioreq_write16(struct rtw_adapter *adapter, u32 addr, u16 val);
+extern void ioreq_write32(struct rtw_adapter *adapter, u32 addr, u32 val);
+
+
+extern uint async_read8(struct rtw_adapter *adapter, u32 addr, u8 *pbuff,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read16(struct rtw_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern uint async_read32(struct rtw_adapter *adapter, u32 addr,  u8 *pbuff,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_read_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+extern void async_write8(struct rtw_adapter *adapter, u32 addr, u8 val,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write16(struct rtw_adapter *adapter, u32 addr, u16 val,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+extern void async_write32(struct rtw_adapter *adapter, u32 addr, u32 val,
+	void (*_async_io_callback)(struct rtw_adapter *padater, struct io_req *pio_req, u8 *cnxt), u8 *cnxt);
+
+extern void async_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+extern void async_write_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem);
+
+
+int rtw_init_io_priv(struct rtw_adapter *padapter, void (*set_intf_ops)(struct _io_ops *pops));
+
+
+extern uint alloc_io_queue(struct rtw_adapter *adapter);
+extern void free_io_queue(struct rtw_adapter *adapter);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(struct rtw_adapter * adapter, u8 bpwrup);
+
+/*
+#define RTL_R8(reg)		rtw_read8(padapter, reg)
+#define RTL_R16(reg)            rtw_read16(padapter, reg)
+#define RTL_R32(reg)            rtw_read32(padapter, reg)
+#define RTL_W8(reg, val8)       rtw_write8(padapter, reg, val8)
+#define RTL_W16(reg, val16)     rtw_write16(padapter, reg, val16)
+#define RTL_W32(reg, val32)     rtw_write32(padapter, reg, val32)
+*/
+
+/*
+#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(padapter, reg, val8)
+#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(padapter, reg, val16)
+#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(padapter, reg, val32)
+
+#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(padapter, reg, val32)
+#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(padapter, reg)
+*/
+
+#endif	/* _RTL8711_IO_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_ioctl.h b/drivers/net/wireless/rtl8192du/include/rtw_ioctl.h
new file mode 100644
index 0000000..888c488
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_ioctl.h
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_H_
+#define _RTW_IOCTL_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+/*  For DDK-defined OIDs */
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+/*  For Realtek-defined OIDs */
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+#define DEBUG_OID(dbg, str)			\
+       if ((!dbg))							\
+	{								\
+	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __func__, __LINE__, str));	\
+	}
+
+
+enum oid_type
+{
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; /* the starting number for OID */
+	unsigned int oid_end; /* the ending number for OID */
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; /* the size of node_array */
+	int query_counter; /* count the number of query hits for this segment */
+	int set_counter; /* count the number of set hits for this segment */
+};
+
+struct oid_par_priv
+{
+	void		*adapter_context;
+	uint	oid;
+	void		*information_buf;
+	u32		information_buf_len;
+	u32		*bytes_rw;
+	u32		*bytes_needed;
+	enum oid_type	type_of_oid;
+	u32		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; /*  0: without OID debug message  1: with OID debug message */
+	uint (*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+#if defined(CONFIG_WIRELESS_EXT)
+extern struct iw_handler_def  rtw_handlers_def;
+#endif
+
+extern	uint drv_query_info(
+		struct net_device *MiniportadapterContext,
+		uint		Oid,
+		void *InformationBuffer,
+		u32 InformationBufferLength,
+		u32 *BytesWritten,
+		u32 *BytesNeeded
+	);
+
+extern	uint	drv_set_info(
+		struct net_device *MiniportadapterContext,
+		uint		Oid,
+		void *InformationBuffer,
+		u32	InformationBufferLength,
+		u32 *BytesRead,
+		u32 *BytesNeeded
+	);
+
+#endif /*  #ifndef __INC_CEINFO_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_ioctl_rtl.h b/drivers/net/wireless/rtl8192du/include/rtw_ioctl_rtl.h
new file mode 100644
index 0000000..49e22d5
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_ioctl_rtl.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_RTL_H_
+#define _RTW_IOCTL_RTL_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+/*  oid_rtl_seg_01_01 ************** */
+uint oid_rt_get_signal_quality_hdl(struct oid_par_priv* poid_par_priv);/* 84 */
+uint oid_rt_get_small_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_middle_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_large_packet_crc_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_tx_retry_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_rx_retry_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_rx_total_packet_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_tx_beacon_ok_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_tx_beacon_err_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_set_fw_dig_state_hdl(struct oid_par_priv* poid_par_priv);	/* 8a */
+uint oid_rt_pro_set_fw_ra_state_hdl(struct oid_par_priv* poid_par_priv);	/* 8b */
+
+uint oid_rt_get_rx_icv_err_hdl(struct oid_par_priv* poid_par_priv);/* 93 */
+uint oid_rt_set_encryption_algorithm_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_ap_ip_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_channelplan_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_preamble_mode_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_bcn_intvl_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_dedicate_probe_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_total_tx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_total_rx_bytes_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_current_tx_power_level_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_enc_key_mismatch_count_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_enc_key_match_count_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_channel_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_hardware_radio_off_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_key_mismatch_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_supported_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_channel_list_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_scan_in_progress_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_forced_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_wireless_mode_for_scan_list_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_bss_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_scan_with_magic_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+/*   oid_rtl_seg_01_03 section start ************** */
+uint oid_rt_ap_get_associated_station_list_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_ap_switch_into_ap_mode_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_ap_supported_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_ap_set_passphrase_hdl(struct oid_par_priv* poid_par_priv);
+
+/*  oid_rtl_seg_01_11 */
+uint oid_rt_pro_rf_write_registry_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_rf_read_registry_hdl(struct oid_par_priv* poid_par_priv);
+
+/*   oid_rtl_seg_03_00 section start ************** */
+uint oid_rt_get_connect_state_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_default_key_id_hdl(struct oid_par_priv* poid_par_priv);
+
+
+
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_ioctl_set.h b/drivers/net/wireless/rtl8192du/include/rtw_ioctl_set.h
new file mode 100644
index 0000000..3ecc6c4
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_ioctl_set.h
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_IOCTL_SET_H_
+#define __RTW_IOCTL_SET_H_
+
+#include <drv_conf.h>
+#include <drv_types.h>
+
+u8 rtw_set_802_11_add_key(struct rtw_adapter * padapter, struct ndis_802_11_key *key);
+u8 rtw_set_802_11_authentication_mode(struct rtw_adapter *pdapter, enum NDIS_802_11_AUTHENTICATION_MODE authmode);
+u8 rtw_set_802_11_bssid(struct rtw_adapter* padapter, u8 *bssid);
+u8 rtw_set_802_11_add_wep(struct rtw_adapter * padapter, struct ndis_802_11_wep * wep);
+u8 rtw_set_802_11_disassociate(struct rtw_adapter * padapter);
+u8 rtw_set_802_11_bssid_list_scan(struct rtw_adapter* padapter, struct ndis_802_11_ssid *pssid, int ssid_max_num);
+u8 rtw_set_802_11_infrastructure_mode(struct rtw_adapter * padapter, enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+u8 rtw_set_802_11_remove_wep(struct rtw_adapter * padapter, u32 keyindex);
+u8 rtw_set_802_11_ssid(struct rtw_adapter * padapter, struct ndis_802_11_ssid * ssid);
+u8 rtw_set_802_11_remove_key(struct rtw_adapter * padapter, struct ndis_802_11_remove_key *key);
+
+u8 rtw_validate_ssid(struct ndis_802_11_ssid *ssid);
+
+u16 rtw_get_cur_max_rate(struct rtw_adapter *adapter);
+int rtw_set_scan_mode(struct rtw_adapter *adapter, enum RT_SCAN_TYPE scan_mode);
+int rtw_set_channel_plan(struct rtw_adapter *adapter, u8 channel_plan);
+int rtw_set_country(struct rtw_adapter *adapter, const char *country_code);
+int rtw_change_ifname(struct rtw_adapter *padapter, const char *ifname);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_led.h b/drivers/net/wireless/rtl8192du/include/rtw_led.h
new file mode 100644
index 0000000..d3740a5
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_led.h
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_LED_H_
+#define __RTW_LED_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define MSECS(t)	(HZ * ((t) / 1000) + (HZ * ((t) % 1000)) / 1000)
+
+enum LED_CTL_MODE {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+	LED_CTL_START_WPS_BOTTON = 11, /* added for runtop */
+	LED_CTL_STOP_WPS_FAIL = 12, /* added for ALPHA */
+	LED_CTL_STOP_WPS_FAIL_OVERLAP = 13, /* added for BELKIN */
+};
+
+
+/*  */
+/*  LED object. */
+/*  */
+
+enum LED_STATE_871X {
+	LED_UNKNOWN = 0,
+	RTW_LED_ON = 1,
+	RTW_LED_OFF = 2,
+	LED_BLINK_NORMAL = 3,
+	LED_BLINK_SLOWLY = 4,
+	LED_POWER_ON_BLINK = 5,
+	LED_SCAN_BLINK = 6, /*  LED is blinking during scanning period, the # of times to blink is depend on time for scanning. */
+	LED_NO_LINK_BLINK = 7, /*  LED is blinking during no link state. */
+	LED_BLINK_StartToBlink = 8,/*  Customzied for Sercomm Printer Server case */
+	LED_BLINK_WPS = 9,	/*  LED is blinkg during WPS communication */
+	LED_TXRX_BLINK = 10,
+	LED_BLINK_WPS_STOP = 11,	/* for ALPHA */
+	LED_BLINK_WPS_STOP_OVERLAP = 12,	/* for BELKIN */
+};
+
+#define IS_LED_WPS_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->CurrLedState==LED_BLINK_WPS \
+					|| ((struct LED_871X *)_LED_871X)->CurrLedState==LED_BLINK_WPS_STOP \
+					|| ((struct LED_871X *)_LED_871X)->bLedWPSBlinkInProgress)
+
+#define IS_LED_BLINKING(_LED_871X)	(((struct LED_871X *)_LED_871X)->bLedWPSBlinkInProgress \
+					||((struct LED_871X *)_LED_871X)->bLedScanBlinkInProgress)
+
+enum LED_PIN_871X {
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1
+};
+
+struct LED_871X {
+	struct rtw_adapter				*padapter;
+	enum LED_PIN_871X		LedPin;	/*  Identify how to implement this SW led. */
+	enum LED_STATE_871X		CurrLedState; /*  Current LED state. */
+	u8					bLedOn; /*  true if LED is ON, false if LED is OFF. */
+
+	u8					bSWLedCtrl;
+
+	u8					bLedBlinkInProgress; /*  true if it is blinking, false o.w.. */
+	/*  ALPHA, added by chiyoko, 20090106 */
+	u8					bLedNoLinkBlinkInProgress;
+	u8					bLedLinkBlinkInProgress;
+	u8					bLedStartToLinkBlinkInProgress;
+	u8					bLedScanBlinkInProgress;
+	u8					bLedWPSBlinkInProgress;
+
+	u32					BlinkTimes; /*  Number of times to toggle led state for blinking. */
+	enum LED_STATE_871X		BlinkingLedState; /*  Next state for blinking, either RTW_LED_ON or RTW_LED_OFF are. */
+
+	struct timer_list		BlinkTimer; /*  Timer object for led blinking. */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+	struct work_struct BlinkWorkItem; /*  Workitem used by BlinkTimer to manipulate H/W to blink LED. */
+#endif
+};
+
+
+/*  */
+/*  LED customization. */
+/*  */
+
+enum LED_STRATEGY_871X {
+	SW_LED_MODE0, /*  SW control 1 LED via GPIO0. It is default option. */
+	SW_LED_MODE1, /*  2 LEDs, through LED0 and LED1. For ALPHA. */
+	SW_LED_MODE2, /*  SW control 1 LED via GPIO0, customized for AzWave 8187 minicard. */
+	SW_LED_MODE3, /*  SW control 1 LED via GPIO0, customized for Sercomm Printer Server case. */
+	SW_LED_MODE4, /* for Edimax / Belkin */
+	SW_LED_MODE5, /* for Sercomm / Belkin */
+	SW_LED_MODE6, /* for 88CU minicard, porting from ce SW_LED_MODE7 */
+	HW_LED, /*  HW control 2 LEDs, LED0 and LED1 (there are 4 different control modes, see MAC.CONFIG1 for details.) */
+};
+
+struct led_priv{
+	/* add for led controll */
+	struct LED_871X			SwLed0;
+	struct LED_871X			SwLed1;
+	enum LED_STRATEGY_871X	LedStrategy;
+	u8	bRegUseLed;
+	void (*LedControlHandler)(struct rtw_adapter *padapter, enum LED_CTL_MODE _ledaction);
+	/* add for led controll */
+};
+
+#define rtw_led_control(adapter, _ledaction) \
+	do { \
+		if ((adapter)->ledpriv.LedControlHandler) \
+			(adapter)->ledpriv.LedControlHandler((adapter),	\
+							     (_ledaction)); \
+	} while (0)
+
+extern void BlinkHandler(struct LED_871X *pLed);
+
+#endif /* __RTW_LED_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_mlme.h b/drivers/net/wireless/rtl8192du/include/rtw_mlme.h
new file mode 100644
index 0000000..c57caf2
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_mlme.h
@@ -0,0 +1,649 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_H_
+#define __RTW_MLME_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <mlme_osdep.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+
+#define	MAX_BSS_CNT	128
+#define   MAX_JOIN_TIMEOUT	6500
+
+/* 	Commented by Albert 20101105 */
+/* 	Increase the scanning timeout because of increasing the SURVEY_TO value. */
+
+#define		SCANNING_TIMEOUT	8000
+
+#define	SCAN_INTERVAL	(30) /*  unit:2sec, 30*2=60sec */
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 /*  unit:us */
+#else
+#define	SCANQUEUE_LIFETIME 20 /*  unit:sec */
+#endif
+
+#define		WIFI_NULL_STATE			0x00000000
+
+#define	WIFI_ASOC_STATE			0x00000001		/*  Under Linked state... */
+#define		WIFI_REASOC_STATE		0x00000002
+#define	WIFI_SLEEP_STATE			0x00000004
+#define	WIFI_STATION_STATE		0x00000008
+
+#define	WIFI_AP_STATE				0x00000010
+#define	WIFI_ADHOC_STATE			0x00000020
+#define   WIFI_ADHOC_MASTER_STATE 0x00000040
+#define   WIFI_UNDER_LINKING		0x00000080
+
+#define	WIFI_UNDER_WPS			0x00000100
+#define	WIFI_STA_ALIVE_CHK_STATE	0x00000400
+#define	WIFI_SITE_MONITOR			0x00000800		/* to indicate the station is under site surveying */
+
+#ifdef WDS
+#define	WIFI_WDS					0x00001000
+#define	WIFI_WDS_RX_BEACON		0x00002000		/*  already rx WDS AP beacon */
+#endif
+#ifdef AUTO_CONFIG
+#define	WIFI_AUTOCONF				0x00004000
+#define	WIFI_AUTOCONF_IND		0x00008000
+#endif
+
+#define	WIFI_MP_STATE							0x00010000
+#define	WIFI_MP_CTX_BACKGROUND				0x00020000	/*  in continous tx background */
+#define	WIFI_MP_CTX_ST						0x00040000	/*  in continous tx with single-tone */
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	/*  pending in continous tx background due to out of skb */
+#define	WIFI_MP_CTX_CCK_HW					0x00100000	/*  in continous tx */
+#define	WIFI_MP_CTX_CCK_CS					0x00200000	/*  in continous tx with carrier suppression */
+#define   WIFI_MP_LPBK_STATE					0x00400000
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED			WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+
+enum dot11AuthAlgrthmNum {
+ dot11AuthAlgrthm_Open = 0,
+ dot11AuthAlgrthm_Shared,
+ dot11AuthAlgrthm_8021X,
+ dot11AuthAlgrthm_Auto,
+ dot11AuthAlgrthm_MaxNum
+};
+
+/*  Scan type including active and passive scan. */
+enum RT_SCAN_TYPE {
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+};
+
+enum  _BAND
+{
+	GHZ24_50 = 0,
+	GHZ_50,
+	GHZ_24,
+};
+
+enum SCAN_RESULT_TYPE
+{
+	SCAN_RESULT_P2P_ONLY = 0,		/* 	Will return all the P2P devices. */
+	SCAN_RESULT_ALL = 1,			/* 	Will return all the scanned device, include AP. */
+	SCAN_RESULT_WFD_TYPE = 2		/* 	Will just return the correct WFD device. */
+									/* 	If this device is Miracast sink device, it will just return all the Miracast source devices. */
+};
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each _queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	int	traffic_busy;
+	struct timer_list sitesurvey_ctrl_timer;
+};
+
+struct rt_link_detect {
+	u32				NumTxOkInPeriod;
+	u32				NumRxOkInPeriod;
+	u32				NumRxUnicastOkInPeriod;
+	bool			bBusyTraffic;
+	bool			bTxBusyTraffic;
+	bool			bRxBusyTraffic;
+	bool			bHigherBusyTraffic; /*  For interrupt migration purpose. */
+	bool			bHigherBusyRxTraffic; /*  We may disable Tx interrupt according as Rx traffic. */
+	bool			bHigherBusyTxTraffic; /*  We may disable Tx interrupt according as Tx traffic. */
+};
+
+struct profile_info {
+	u8	ssidlen;
+	u8	ssid[WLAN_SSID_MAXLEN];
+	u8	peermac[ETH_ALEN];
+};
+
+struct tx_invite_req_info{
+	u8					token;
+	u8					benable;
+	u8					go_ssid[WLAN_SSID_MAXLEN];
+	u8					ssidlen;
+	u8					go_bssid[ETH_ALEN];
+	u8					peer_macaddr[ETH_ALEN];
+	u8					operating_ch;	/* 	This information will be set by using the p2p_set op_ch=x */
+	u8					peer_ch;		/* 	The listen channel for peer P2P device */
+
+};
+
+struct tx_invite_resp_info{
+	u8					token;	/* 	Used to record the dialog token of p2p invitation request frame. */
+};
+
+struct tx_provdisc_req_info{
+	u16					wps_config_method_request;	/* 	Used when sending the provisioning request frame */
+	u16					peer_channel_num[2];		/* 	The channel number which the receiver stands. */
+	struct ndis_802_11_ssid	ssid;
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					peerIFAddr[ETH_ALEN];		/* 	Peer interface address */
+	u8					benable;					/* 	This provision discovery request frame is trigger to send or not */
+};
+
+struct rx_provdisc_req_info{	/* When peer device issue prov_disc_req first, we should store the following informations */
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					strconfig_method_desc_of_prov_disc_req[4];	/* 	description for the config method located in the provisioning discovery request frame. */
+																	/* 	The UI must know this information to know which config method the remote p2p device is requiring. */
+};
+
+struct tx_nego_req_info{
+	u16					peer_channel_num[2];		/* 	The channel number which the receiver stands. */
+	u8					peerDevAddr[ETH_ALEN];		/* 	Peer device address */
+	u8					benable;					/* 	This negoitation request frame is trigger to send or not */
+};
+
+struct group_id_info{
+	u8					go_device_addr[ETH_ALEN];	/* 	The GO's device address of this P2P group */
+	u8					ssid[WLAN_SSID_MAXLEN];	/* 	The SSID of this P2P group */
+};
+
+struct scan_limit_info{
+	u8					scan_op_ch_only;			/* 	When this flag is set, the driver should just scan the operation channel */
+	u8					operation_ch[2];				/* 	Store the operation channel of invitation request frame */
+};
+
+struct cfg80211_wifidirect_info{
+	struct timer_list		remain_on_ch_timer;
+	u8				restore_channel;
+	struct ieee80211_channel	remain_on_ch_channel;
+	enum nl80211_channel_type	remain_on_ch_type;
+	u64				remain_on_ch_cookie;
+	bool is_ro_ch;
+};
+
+struct wifidirect_info{
+	struct rtw_adapter *padapter;
+	struct timer_list			find_phase_timer;
+	struct timer_list			restore_p2p_state_timer;
+
+	/* 	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer. */
+	struct timer_list			pre_tx_scan_timer;
+	struct timer_list			reset_ch_sitesurvey;
+	struct timer_list			reset_ch_sitesurvey2;	/* 	Just for resetting the scan limit function by using p2p nego */
+#ifdef CONFIG_CONCURRENT_MODE
+	/* 	Used to switch the channel between legacy AP and listen state. */
+	struct timer_list			ap_p2p_switch_timer;
+#endif
+	struct tx_provdisc_req_info	tx_prov_disc_info;
+	struct rx_provdisc_req_info rx_prov_disc_info;
+	struct tx_invite_req_info	invitereq_info;
+	struct profile_info			profileinfo[P2P_MAX_PERSISTENT_GROUP_NUM];	/* 	Store the profile information of persistent group */
+	struct tx_invite_resp_info	inviteresp_info;
+	struct tx_nego_req_info	nego_req_info;
+	struct group_id_info		groupid_info;	/* 	Store the group id information when doing the group negotiation handshake. */
+	struct scan_limit_info		rx_invitereq_info;	/* 	Used for get the limit scan channel from the Invitation procedure */
+	struct scan_limit_info		p2p_info;		/* 	Used for get the limit scan channel from the P2P negotiation handshake */
+	enum P2P_ROLE			role;
+	enum P2P_STATE			pre_p2p_state;
+	enum P2P_STATE			p2p_state;
+	u8						device_addr[ETH_ALEN];	/* 	The device address should be the mac address of this device. */
+	u8						interface_addr[ETH_ALEN];
+	u8						social_chan[4];
+	u8						listen_channel;
+	u8						operating_channel;
+	u8						listen_dwell;		/* 	This value should be between 1 and 3 */
+	u8						support_rate[8];
+	u8						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
+	u8						intent;		/* 	should only include the intent value. */
+	u8						p2p_peer_interface_addr[ETH_ALEN];
+	u8						p2p_peer_device_addr[ETH_ALEN];
+	u8						peer_intent;	/* 	Included the intent value and tie breaker value. */
+	u8						device_name[WPS_MAX_DEVICE_NAME_LEN];	/* 	Device name for displaying on searching device screen */
+	u8						device_name_len;
+	u8						profileindex;	/* 	Used to point to the index of profileinfo array */
+	u8						peer_operating_ch;
+	u8						find_phase_state_exchange_cnt;
+	u16						device_password_id_for_nego;	/* 	The device password ID for group negotation */
+	u8						negotiation_dialog_token;
+	u8						nego_ssid[WLAN_SSID_MAXLEN];	/* 	SSID information for group negotitation */
+	u8						nego_ssidlen;
+	u8						p2p_group_ssid[WLAN_SSID_MAXLEN];
+	u8						p2p_group_ssid_len;
+	u8						persistent_supported;		/* 	Flag to know the persistent function should be supported or not. */
+														/* 	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI. */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						session_available;			/* 	Flag to set the WFD session available to enable or disable "by Sigma" */
+														/* 	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI. */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						wfd_tdls_enable;			/* 	Flag to enable or disable the TDLS by WFD Sigma */
+														/* 	0: disable */
+														/* 	1: enable */
+	u8						wfd_tdls_weaksec;			/* 	Flag to enable or disable the weak security function for TDLS by WFD Sigma */
+														/* 	0: disable */
+														/* 	In this case, the driver can't issue the tdsl setup request frame. */
+														/* 	1: enable */
+														/* 	In this case, the driver can issue the tdls setup request frame */
+														/* 	even the current security is weak security. */
+
+	enum	P2P_WPSINFO		ui_got_wps_info;			/* 	This field will store the WPS value (PIN value or PBC) that UI had got from the user. */
+	u16						supported_wps_cm;			/* 	This field describes the WPS config method which this driver supported. */
+														/* 	The value should be the combination of config method defined in page104 of WPS v2.0 spec. */
+	uint						channel_list_attr_len;		/* 	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame. */
+	u8						channel_list_attr[100];		/* 	This field will contain the body of P2P Channel List attribute of group negotitation response frame. */
+														/* 	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame. */
+#ifdef CONFIG_CONCURRENT_MODE
+	u16						ext_listen_interval;	/* 	The interval to be available with legacy AP (ms) */
+	u16						ext_listen_period;	/* 	The time period to be available for P2P listen state (ms) */
+#endif
+};
+
+struct tdls_ss_record{	/* signal strength record; recording the tdls sta with lowerest ss */
+	u8		macaddr[ETH_ALEN];
+	u8		rxpwdb_all;
+	u8		is_tdls_sta;	/*  true: direct link sta, false: else */
+};
+
+struct tdls_info{
+	u8					ap_prohibited;
+	uint					setup_state;
+	u8					sta_cnt;
+	u8					sta_maximum;	/*  1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else; */
+	struct tdls_ss_record	ss_record;
+	u8					macid_index;	/* macid entry that is ready to write */
+	u8					clear_cam;	/* cam entry that is trying to clear, using it in direct link teardown */
+	u8					ch_sensing;
+	u8					cur_channel;
+	u8					candidate_ch;
+	u8					collect_pkt_num[MAX_CHANNEL_NUM];
+	spinlock_t				cmd_lock;
+	spinlock_t				hdl_lock;
+	u8					watchdog_count;
+	u8					dev_discovered;		/* WFD_TDLS: for sigma test */
+	u8					enable;
+};
+
+struct mlme_priv {
+
+	spinlock_t	lock;
+	int	fw_state;	/* shall we protect this variable? maybe not necessarily... */
+
+	u8	to_join; /* flag */
+	#ifdef CONFIG_LAYER2_ROAMING
+	u8 to_roaming; /*  roaming trying times */
+	#endif
+
+	u8	*nic_hdl;
+
+	u8	not_indic_disco;
+	struct list_head *pscanned;
+	struct __queue free_bss_pool;
+	struct __queue scanned_queue;
+	u8		*free_bss_buf;
+	u32	num_of_scanned;
+
+	struct ndis_802_11_ssid	assoc_ssid;
+	u8	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+
+	/* uint wireless_mode; no used, remove it */
+
+	u32	scan_interval;
+
+	struct timer_list assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	struct timer_list scan_to_timer; /*  driver itself handles scan_timeout status. */
+	u32 scan_start_time; /*  used to evaluate the time spent in scanning */
+
+	#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	struct timer_list set_scan_deny_timer;
+	ATOMIC_T set_scan_deny; /* 0: allowed, 1: deny */
+	#endif
+
+	struct qos_priv qospriv;
+
+#ifdef CONFIG_80211N_HT
+
+	/* Number of non-HT AP/stations */
+	int num_sta_no_ht;
+
+	/* Number of HT AP/stations 20 MHz */
+	/* int num_sta_ht_20mhz; */
+
+
+	int num_FortyMHzIntolerant;
+
+	struct ht_priv	htpriv;
+
+#endif
+
+	struct rt_link_detect LinkDetectInfo;
+	struct timer_list dynamic_chk_timer; /* dynamic/periodic check timer */
+
+	u8	key_mask; /* use for ips to set wep key after ips_leave */
+	u8	acm_mask; /*  for wmm acm mask */
+	u8	ChannelPlan;
+	enum RT_SCAN_TYPE	scan_mode; /*  active: 1, passive: 0 */
+
+	u8 *wps_probe_req_ie;
+	u32 wps_probe_req_ie_len;
+
+	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
+	 * in 802.11g BSS) */
+	int num_sta_non_erp;
+
+	/* Number of associated stations that do not support Short Slot Time */
+	int num_sta_no_short_slot_time;
+
+	/* Number of associated stations that do not support Short Preamble */
+	int num_sta_no_short_preamble;
+
+	int olbc; /* Overlapping Legacy BSS Condition */
+
+	/* Number of HT associated stations that do not support greenfield */
+	int num_sta_ht_no_gf;
+
+	/* Number of associated non-HT stations */
+	/* int num_sta_no_ht; */
+
+	/* Number of HT associated stations 20 MHz */
+	int num_sta_ht_20mhz;
+
+	/* Overlapping BSS information */
+	int olbc_ht;
+
+#ifdef CONFIG_80211N_HT
+	u16 ht_op_mode;
+#endif /* CONFIG_80211N_HT */
+
+	u8 *assoc_req;
+	u32 assoc_req_len;
+	u8 *assoc_rsp;
+	u32 assoc_rsp_len;
+
+	u8 *wps_beacon_ie;
+	u8 *wps_probe_resp_ie;
+	u8 *wps_assoc_resp_ie; /*  this IE could include p2p ie / wfd ie */
+
+	u32 wps_beacon_ie_len;
+	u32 wps_probe_resp_ie_len;
+	u32 wps_assoc_resp_ie_len; /* this IE len could include p2p ie / wfd ie */
+
+	u8 *p2p_beacon_ie;
+	u8 *p2p_probe_req_ie;
+	u8 *p2p_probe_resp_ie;
+	u8 *p2p_go_probe_resp_ie; /* for GO */
+	u8 *p2p_assoc_req_ie;
+
+	u32 p2p_beacon_ie_len;
+	u32 p2p_probe_req_ie_len;
+	u32 p2p_probe_resp_ie_len;
+	u32 p2p_go_probe_resp_ie_len; /* for GO */
+	u32 p2p_assoc_req_ie_len;
+	spinlock_t	bcn_update_lock;
+	u8		update_bcn;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	u8	scanning_via_buddy_intf;
+#endif
+};
+
+#ifdef CONFIG_92D_AP_MODE
+
+struct hostapd_priv
+{
+	struct rtw_adapter *padapter;
+
+#ifdef CONFIG_HOSTAPD_MLME
+	struct net_device *pmgnt_netdev;
+	struct usb_anchor anchored;
+#endif
+
+};
+
+extern int hostapd_mode_init(struct rtw_adapter *padapter);
+extern void hostapd_mode_unload(struct rtw_adapter *padapter);
+#endif
+
+
+extern void rtw_joinbss_event_prehandle(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_survey_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_surveydone_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_joinbss_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_stassoc_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_stadel_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_atimdone_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+extern void rtw_cpwm_event_callback(struct rtw_adapter *adapter, u8 *pbuf);
+
+extern int event_thread(void *context);
+extern void rtw_join_timeout_handler(void* FunctionContext);
+extern void _rtw_scan_timeout_handler(void* FunctionContext);
+extern void rtw_free_network_queue(struct rtw_adapter *adapter,u8 isfreeall);
+extern int rtw_init_mlme_priv(struct rtw_adapter *adapter);/*  (struct mlme_priv *pmlmepriv); */
+extern void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv);
+extern int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern int rtw_set_key(struct rtw_adapter *adapter,struct security_priv *psecuritypriv,int keyid, u8 set_tx);
+extern int rtw_set_auth(struct rtw_adapter *adapter,struct security_priv *psecuritypriv);
+
+__inline static u8 *get_bssid(struct mlme_priv *pmlmepriv)
+{	/* if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid */
+	/*  if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address */
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+__inline static int check_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	if (pmlmepriv->fw_state & state)
+		return true;
+
+	return false;
+}
+
+__inline static int get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+__inline static void set_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	pmlmepriv->fw_state |= state;
+}
+
+__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv, int state)
+{
+	pmlmepriv->fw_state &= ~state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+__inline static void clr_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	if (check_fwstate(pmlmepriv, state) == true)
+		pmlmepriv->fw_state ^= state;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void clr_fwstate_ex(struct mlme_priv *pmlmepriv, int state)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	_clr_fwstate_(pmlmepriv, state);
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+#ifdef CONFIG_CONCURRENT_MODE
+int rtw_buddy_adapter_up(struct rtw_adapter *padapter);
+int check_buddy_fwstate(struct rtw_adapter *padapter, int state);
+#endif /* CONFIG_CONCURRENT_MODE */
+
+__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, int val)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned = val;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+extern u16 rtw_get_capability(struct wlan_bssid_ex *bss);
+extern void rtw_update_scanned_network(struct rtw_adapter *adapter, struct wlan_bssid_ex *target);
+extern void rtw_disconnect_hdl_under_linked(struct rtw_adapter* adapter, struct sta_info *psta, u8 free_assoc);
+extern void rtw_generate_random_ibss(u8 *pibss);
+extern struct wlan_network* rtw_find_network(struct __queue *scanned_queue, u8 *addr);
+extern struct wlan_network* rtw_get_oldest_wlan_network(struct __queue *scanned_queue);
+
+extern void rtw_free_assoc_resources(struct rtw_adapter* adapter, int lock_scanned_queue);
+extern void rtw_indicate_disconnect(struct rtw_adapter* adapter);
+extern void rtw_indicate_connect(struct rtw_adapter* adapter);
+void rtw_indicate_scan_done(struct rtw_adapter *padapter, bool aborted);
+void rtw_scan_abort(struct rtw_adapter *adapter);
+
+extern int rtw_restruct_sec_ie(struct rtw_adapter *adapter,u8 *in_ie,u8 *out_ie,uint in_len);
+extern int rtw_restruct_wmm_ie(struct rtw_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
+extern void rtw_init_registrypriv_dev_network(struct rtw_adapter *adapter);
+
+extern void rtw_update_registrypriv_dev_network(struct rtw_adapter *adapter);
+
+extern void rtw_get_encrypt_decrypt_from_registrypriv(struct rtw_adapter *adapter);
+
+extern void _rtw_join_timeout_handler(struct rtw_adapter *adapter);
+extern void rtw_scan_timeout_handler(struct rtw_adapter *adapter);
+
+extern void rtw_dynamic_check_timer_handlder(struct rtw_adapter *adapter);
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+bool rtw_is_scan_deny(struct rtw_adapter *adapter);
+void rtw_clear_scan_deny(struct rtw_adapter *adapter);
+void rtw_set_scan_deny_timer_hdl(struct rtw_adapter *adapter);
+void rtw_set_scan_deny(struct rtw_adapter *adapter, u32 ms);
+#else
+#define rtw_is_scan_deny(adapter) false
+#define rtw_clear_scan_deny(adapter) do {} while (0)
+#define rtw_set_scan_deny_timer_hdl(adapter) do {} while (0)
+#define rtw_set_scan_deny(adapter, ms) do {} while (0)
+#endif
+
+
+extern int _rtw_init_mlme_priv(struct rtw_adapter *padapter);
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);
+
+extern void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+extern int _rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork);
+
+extern struct wlan_network* _rtw_dequeue_network(struct __queue *queue);
+
+extern struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, u8 isfreeall);
+extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+extern void rtw_indicate_wx_assoc_event(struct rtw_adapter *padapter);
+extern void rtw_indicate_wx_disassoc_event(struct rtw_adapter *padapter);
+
+extern struct wlan_network* _rtw_find_network(struct __queue *scanned_queue, u8 *addr);
+
+extern void _rtw_free_network_queue(struct rtw_adapter* padapter, u8 isfreeall);
+
+extern int rtw_if_up(struct rtw_adapter *padapter);
+
+
+u8 *rtw_get_capability_from_ie(u8 *ie);
+u8 *rtw_get_timestampe_from_ie(u8 *ie);
+u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
+
+
+void rtw_joinbss_reset(struct rtw_adapter *padapter);
+
+#ifdef CONFIG_80211N_HT
+unsigned int rtw_restructure_ht_ie(struct rtw_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel);
+void rtw_update_ht_cap(struct rtw_adapter *padapter, u8 *pie, uint ie_len, u8 channel);
+void rtw_issue_addbareq_cmd(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+#endif
+
+int rtw_is_same_ibss(struct rtw_adapter *adapter, struct wlan_network *pnetwork);
+int is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst);
+
+#ifdef CONFIG_LAYER2_ROAMING
+void _rtw_roaming(struct rtw_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_roaming(struct rtw_adapter *adapter, struct wlan_network *tgt_network);
+void rtw_set_roaming(struct rtw_adapter *adapter, u8 to_roaming);
+u8 rtw_to_roaming(struct rtw_adapter *adapter);
+#else
+#define _rtw_roaming(adapter, tgt_network) do {} while (0)
+#define rtw_roaming(adapter, tgt_network) do {} while (0)
+#define rtw_set_roaming(adapter, to_roaming) do {} while (0)
+#define rtw_to_roaming(adapter) 0
+#endif
+
+#endif /* __RTL871X_MLME_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_mlme_ext.h b/drivers/net/wireless/rtl8192du/include/rtw_mlme_ext.h
new file mode 100644
index 0000000..a216564
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_mlme_ext.h
@@ -0,0 +1,847 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_EXT_H_
+#define __RTW_MLME_EXT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+
+
+/* 	Commented by Albert 20101105 */
+/* 	Increase the SURVEY_TO value from 100 to 150  (100ms to 150ms) */
+/* 	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request. */
+/* 	So, this driver tried to extend the dwell time for each scanning channel. */
+/* 	This will increase the chance to receive the probe response from SoftAP. */
+
+#define SURVEY_TO		(100)
+#define REAUTH_TO		(300) /* 50) */
+#define REASSOC_TO		(300) /* 50) */
+#define ADDBA_TO			(2000)
+
+#define LINKED_TO (1) /* unit:2 sec, 1x2=2 sec */
+
+#define REAUTH_LIMIT	(4)
+#define REASSOC_LIMIT	(4)
+#define READDBA_LIMIT	(2)
+
+#define	DYNAMIC_FUNC_DISABLE		(0x0)
+#define	DYNAMIC_FUNC_DIG			BIT(0)
+#define	DYNAMIC_FUNC_HP			BIT(1)
+#define	DYNAMIC_FUNC_SS			BIT(2) /* Tx Power Tracking */
+#define DYNAMIC_FUNC_BT			BIT(3)
+#define DYNAMIC_FUNC_ANT_DIV		BIT(4)
+
+#define _HW_STATE_NOLINK_		0x00
+#define _HW_STATE_ADHOC_		0x01
+#define _HW_STATE_STATION_	0x02
+#define _HW_STATE_AP_			0x03
+
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WMM_OUI[];
+extern unsigned char WPS_OUI[];
+extern unsigned char WFD_OUI[];
+extern unsigned char P2P_OUI[];
+
+extern unsigned char WMM_INFO_OUI[];
+extern unsigned char WMM_PARA_OUI[];
+
+
+/*  */
+/*  Channel Plan Type. */
+/*  Note: */
+/* 	We just add new channel plan when the new channel plan is different from any of the following */
+/* 	channel plan. */
+/* 	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan, */
+/* 	customize them in struct rt_channel_info in the RT_CHANNEL_LIST. */
+/*  */
+enum RT_CHANNEL_DOMAIN {
+	/*  old channel plan mapping ===== */
+	RT_CHANNEL_DOMAIN_FCC = 0x00,
+	RT_CHANNEL_DOMAIN_IC = 0x01,
+	RT_CHANNEL_DOMAIN_ETSI = 0x02,
+	RT_CHANNEL_DOMAIN_SPAIN = 0x03,
+	RT_CHANNEL_DOMAIN_FRANCE = 0x04,
+	RT_CHANNEL_DOMAIN_MKK = 0x05,
+	RT_CHANNEL_DOMAIN_MKK1 = 0x06,
+	RT_CHANNEL_DOMAIN_ISRAEL = 0x07,
+	RT_CHANNEL_DOMAIN_TELEC = 0x08,
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 0x09,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 0x0A,
+	RT_CHANNEL_DOMAIN_TAIWAN = 0x0B,
+	RT_CHANNEL_DOMAIN_CHINA = 0x0C,
+	RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO = 0x0D,
+	RT_CHANNEL_DOMAIN_KOREA = 0x0E,
+	RT_CHANNEL_DOMAIN_TURKEY = 0x0F,
+	RT_CHANNEL_DOMAIN_JAPAN = 0x10,
+	RT_CHANNEL_DOMAIN_FCC_NO_DFS = 0x11,
+	RT_CHANNEL_DOMAIN_JAPAN_NO_DFS = 0x12,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_5G = 0x13,
+	RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS = 0x14,
+
+	/*  new channel plan mapping, (2GDOMAIN_5GDOMAIN) ===== */
+	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
+	RT_CHANNEL_DOMAIN_ETSI1_NULL = 0x21,
+	RT_CHANNEL_DOMAIN_FCC1_NULL = 0x22,
+	RT_CHANNEL_DOMAIN_MKK1_NULL = 0x23,
+	RT_CHANNEL_DOMAIN_ETSI2_NULL = 0x24,
+	RT_CHANNEL_DOMAIN_FCC1_FCC1 = 0x25,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI1 = 0x26,
+	RT_CHANNEL_DOMAIN_MKK1_MKK1 = 0x27,
+	RT_CHANNEL_DOMAIN_WORLD_KCC1 = 0x28,
+	RT_CHANNEL_DOMAIN_WORLD_FCC2 = 0x29,
+	RT_CHANNEL_DOMAIN_WORLD_FCC3 = 0x30,
+	RT_CHANNEL_DOMAIN_WORLD_FCC4 = 0x31,
+	RT_CHANNEL_DOMAIN_WORLD_FCC5 = 0x32,
+	RT_CHANNEL_DOMAIN_WORLD_FCC6 = 0x33,
+	RT_CHANNEL_DOMAIN_FCC1_FCC7 = 0x34,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI2 = 0x35,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI3 = 0x36,
+	RT_CHANNEL_DOMAIN_MKK1_MKK2 = 0x37,
+	RT_CHANNEL_DOMAIN_MKK1_MKK3 = 0x38,
+	RT_CHANNEL_DOMAIN_FCC1_NCC1 = 0x39,
+	RT_CHANNEL_DOMAIN_FCC1_NCC2 = 0x40,
+
+	/*  Add new channel plan above this line=============== */
+	RT_CHANNEL_DOMAIN_MAX,
+	RT_CHANNEL_DOMAIN_REALTEK_DEFINE = 0x7F,
+};
+
+enum RT_CHANNEL_DOMAIN_2G {
+	RT_CHANNEL_DOMAIN_2G_WORLD = 0x00,		/* Worldwird 13 */
+	RT_CHANNEL_DOMAIN_2G_ETSI1 = 0x01,		/* Europe */
+	RT_CHANNEL_DOMAIN_2G_FCC1 = 0x02,		/* US */
+	RT_CHANNEL_DOMAIN_2G_MKK1 = 0x03,		/* Japan */
+	RT_CHANNEL_DOMAIN_2G_ETSI2 = 0x04,		/* France */
+	RT_CHANNEL_DOMAIN_2G_NULL = 0x05,
+	/*  Add new channel plan above this line=============== */
+	RT_CHANNEL_DOMAIN_2G_MAX,
+};
+
+enum RT_CHANNEL_DOMAIN_5G {
+	RT_CHANNEL_DOMAIN_5G_NULL = 0x00,
+	RT_CHANNEL_DOMAIN_5G_ETSI1 = 0x01,		/* Europe */
+	RT_CHANNEL_DOMAIN_5G_ETSI2 = 0x02,		/* Australia, New Zealand */
+	RT_CHANNEL_DOMAIN_5G_ETSI3 = 0x03,		/* Russia */
+	RT_CHANNEL_DOMAIN_5G_FCC1 = 0x04,		/* US */
+	RT_CHANNEL_DOMAIN_5G_FCC2 = 0x05,		/* FCC o/w DFS Channels */
+	RT_CHANNEL_DOMAIN_5G_FCC3 = 0x06,		/* India, Mexico */
+	RT_CHANNEL_DOMAIN_5G_FCC4 = 0x07,		/* Venezuela */
+	RT_CHANNEL_DOMAIN_5G_FCC5 = 0x08,		/* China */
+	RT_CHANNEL_DOMAIN_5G_FCC6 = 0x09,		/* Israel */
+	RT_CHANNEL_DOMAIN_5G_FCC7_IC1 = 0x0A,	/* US, Canada */
+	RT_CHANNEL_DOMAIN_5G_KCC1 = 0x0B,		/* Korea */
+	RT_CHANNEL_DOMAIN_5G_MKK1 = 0x0C,		/* Japan */
+	RT_CHANNEL_DOMAIN_5G_MKK2 = 0x0D,		/* Japan (W52, W53) */
+	RT_CHANNEL_DOMAIN_5G_MKK3 = 0x0E,		/* Japan (W56) */
+	RT_CHANNEL_DOMAIN_5G_NCC1 = 0x0F,		/* Taiwan */
+	RT_CHANNEL_DOMAIN_5G_NCC2 = 0x10,		/* Taiwan o/w DFS */
+	/*  Add new channel plan above this line=============== */
+	/*  Driver Self Defined ===== */
+	RT_CHANNEL_DOMAIN_5G_FCC = 0x11,
+	RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS = 0x12,
+	RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS = 0x13,
+	RT_CHANNEL_DOMAIN_5G_MAX,
+};
+
+#define rtw_is_channel_plan_valid(chplan) (chplan<RT_CHANNEL_DOMAIN_MAX || chplan == RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
+
+struct rt_channel_plan {
+	unsigned char	Channel[MAX_CHANNEL_NUM];
+	unsigned char	Len;
+};
+
+struct rt_channel_plan_2g {
+	unsigned char	Channel[MAX_CHANNEL_NUM_2G];
+	unsigned char	Len;
+};
+
+struct rt_channel_plan_5g {
+	unsigned char	Channel[MAX_CHANNEL_NUM_5G];
+	unsigned char	Len;
+};
+
+struct rt_channel_plan_map {
+	unsigned char	Index2G;
+	unsigned char	Index5G;
+};
+
+enum Associated_AP
+{
+	atherosAP	= 0,
+	broadcomAP	= 1,
+	ciscoAP		= 2,
+	marvellAP	= 3,
+	ralinkAP	= 4,
+	realtekAP	= 5,
+	airgocapAP	= 6,
+	unknownAP	= 7,
+	maxAP,
+};
+
+enum SCAN_STATE
+{
+	SCAN_DISABLE = 0,
+	SCAN_START = 1,
+	SCAN_TXNULL = 2,
+	SCAN_PROCESS = 3,
+	SCAN_COMPLETE = 4,
+	SCAN_STATE_MAX,
+};
+
+struct mlme_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+};
+
+struct action_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+};
+
+struct	ss_res
+{
+	int	state;
+	int	bss_cnt;
+	int	channel_idx;
+	int	scan_mode;
+	u8 ssid_num;
+	u8 ch_num;
+	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/* define AP_MODE				0x0C */
+/* define STATION_MODE	0x08 */
+/* define AD_HOC_MODE		0x04 */
+/* define NO_LINK_MODE	0x00 */
+
+#define		WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
+#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
+#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
+#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_
+
+#define	WIFI_FW_AUTH_NULL			0x00000100
+#define	WIFI_FW_AUTH_STATE			0x00000200
+#define	WIFI_FW_AUTH_SUCCESS			0x00000400
+
+#define	WIFI_FW_ASSOC_STATE			0x00002000
+#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
+
+#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
+
+struct FW_Sta_Info
+{
+	struct sta_info	*psta;
+	u32	status;
+	u32	rx_pkt;
+	u32	retry;
+	unsigned char  SupportedRates[NDIS_802_11_LENGTH_RATES_EX];
+};
+
+/*
+ * Usage:
+ * When one iface acted as AP mode and the other iface is STA mode and scanning,
+ * it should switch back to AP's operating channel periodically.
+ * Parameters info:
+ * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
+ * RTW_STAY_AP_CH_MILLISECOND * SURVEY_TO milliseconds.
+ * Example:
+ * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
+ * RTW_SCAN_NUM_OF_CH is 8, RTW_STAY_AP_CH_MILLISECOND is 3 and SURVEY_TO is 100.
+ * When it's STA mode gets set_scan command,
+ * it would
+ * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
+ * 2. Back to channel 1 for 300 milliseconds
+ * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
+ * 4. Back to channel 1 for 300 milliseconds
+ * 5. ... and so on, till survey done.
+ */
+#if defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
+#define RTW_SCAN_NUM_OF_CH			8
+#define RTW_STAY_AP_CH_MILLISECOND	3	/*  this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for */
+											/*  3 * SURVEY_TO millisecond. */
+#endif /* defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE */
+
+struct mlme_ext_info
+{
+	u32	state;
+	u32	reauth_count;
+	u32	reassoc_count;
+	u32	link_count;
+	u32	auth_seq;
+	u32	auth_algo;	/*  802.11 auth, could be open, shared, auto */
+	u32	authModeToggle;
+	u32	enc_algo;/* encrypt algorithm; */
+	u32	key_index;	/*  this is only valid for legendary wep, 0~3 for key id. */
+	u32	iv;
+	u8	chg_txt[128];
+	u16	aid;
+	u16	bcn_interval;
+	u16	capability;
+	u8	assoc_AP_vendor;
+	u8	slotTime;
+	u8	preamble_mode;
+	u8	WMM_enable;
+	u8	ERP_enable;
+	u8	ERP_IE;
+	u8	HT_enable;
+	u8	HT_caps_enable;
+	u8	HT_info_enable;
+	u8	HT_protection;
+	u8	turboMode_cts2self;
+	u8	turboMode_rtsen;
+	u8	SM_PS;
+	u8	agg_enable_bitmap;
+	u8	ADDBA_retry_count;
+	u8	candidate_tid_bitmap;
+	u8	dialogToken;
+	/*  Accept ADDBA Request */
+	bool bAcceptAddbaReq;
+	u8	bwmode_updated;
+	u8	hidden_ssid_mode;
+
+	struct ADDBA_request		ADDBA_req;
+	struct WMM_para_element	WMM_param;
+	struct HT_caps_element	HT_caps;
+	struct HT_info_element		HT_info;
+	struct wlan_bssid_ex network;/* join network or bss_network, if in ap mode, it is the same to cur_network.network */
+	struct FW_Sta_Info		FW_sta_info[NUM_STA];
+
+#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+	u8 scan_cnt;
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+};
+
+/*  The channel information about this channel including joining, scanning, and power constraints. */
+struct rt_channel_info {
+	u8				ChannelNum;		/*  The channel number. */
+	enum RT_SCAN_TYPE	ScanType;		/*  Scan type such as passive or active scan. */
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	u32				rx_count;
+#endif
+};
+
+int rtw_ch_set_search_ch(struct rt_channel_info *ch_set, const u32 ch);
+
+/*  P2P_MAX_REG_CLASSES - Maximum number of regulatory classes */
+#define P2P_MAX_REG_CLASSES 10
+
+/*  P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class */
+#define P2P_MAX_REG_CLASS_CHANNELS 20
+
+/*   struct p2p_channels - List of supported channels */
+struct p2p_channels {
+	/*  struct p2p_reg_class - Supported regulatory class */
+	struct p2p_reg_class {
+		/*  reg_class - Regulatory class (IEEE 802.11-2007, Annex J) */
+		u8 reg_class;
+
+		/*  channel - Supported channels */
+		u8 channel[P2P_MAX_REG_CLASS_CHANNELS];
+
+		/*  channels - Number of channel entries in use */
+		size_t channels;
+	} reg_class[P2P_MAX_REG_CLASSES];
+
+	/*  reg_classes - Number of reg_class entries in use */
+	size_t reg_classes;
+};
+
+struct p2p_oper_class_map {
+	enum hw_mode {IEEE80211G,IEEE80211A} mode;
+	u8 op_class;
+	u8 min_chan;
+	u8 max_chan;
+	u8 inc;
+	enum { BW20, BW40PLUS, BW40MINUS } bw;
+};
+
+struct mlme_ext_priv
+{
+	struct rtw_adapter *padapter;
+	u8	mlmeext_init;
+	ATOMIC_T		event_seq;
+	u16	mgnt_seq;
+
+	unsigned char	cur_channel;
+	unsigned char	cur_bwmode;
+	unsigned char	cur_ch_offset;/* PRIME_CHNL_OFFSET */
+	unsigned char	cur_wireless_mode;
+
+	unsigned char	max_chan_nums;
+	struct rt_channel_info channel_set[MAX_CHANNEL_NUM];
+	struct p2p_channels channel_list;
+	unsigned char	basicrate[NUMRATES];
+	unsigned char	datarate[NUMRATES];
+
+	struct ss_res		sitesurvey_res;
+	struct mlme_ext_info	mlmext_info;/* for sta/adhoc mode, including current scanning/connecting/connected related info. */
+                                                     /* for ap mode, network includes ap's cap_info */
+	struct timer_list survey_timer;
+	struct timer_list link_timer;
+	u16			chan_scan_time;
+
+	u8	scan_abort;
+	u8	tx_rate; /*  TXRATE when USERATE is set. */
+
+	u32	retry; /* retry for issue probereq */
+
+	u64 TSFValue;
+
+#ifdef CONFIG_92D_AP_MODE
+	unsigned char bstart_bss;
+#endif
+
+	/* recv_decache check for Action_public frame */
+        u8 action_public_dialog_token;
+	u16	 action_public_rxseq;
+
+#ifdef CONFIG_80211D
+	u8 update_channel_plan_by_ap_done;
+#endif
+
+	u8 active_keep_alive_check;
+};
+
+int init_mlme_ext_priv(struct rtw_adapter *padapter);
+int init_hw_mlme_ext(struct rtw_adapter *padapter);
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
+extern void init_mlme_ext_timer(struct rtw_adapter *padapter);
+extern void init_addba_retry_timer(struct rtw_adapter *padapter, struct sta_info *psta);
+extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
+
+unsigned char networktype_to_raid(unsigned char network_type);
+int judge_network_type(struct rtw_adapter *padapter, unsigned char *rate, int ratelen);
+void get_rate_set(struct rtw_adapter *padapter, unsigned char *pbssrate, int *bssrate_len);
+void UpdateBrateTbl(struct rtw_adapter *padapter,u8 *mBratesOS);
+void UpdateBrateTblForSoftAP(u8 *bssrateset, u32 bssratelen);
+void change_band_update_ie(struct rtw_adapter *padapter, struct wlan_bssid_ex *pnetwork);
+
+void Save_DM_Func_Flag(struct rtw_adapter *padapter);
+void Restore_DM_Func_Flag(struct rtw_adapter *padapter);
+void Switch_DM_Func(struct rtw_adapter *padapter, u8 mode, u8 enable);
+
+void Set_MSR(struct rtw_adapter *padapter, u8 type);
+
+u8 rtw_get_oper_ch(struct rtw_adapter *adapter);
+void rtw_set_oper_ch(struct rtw_adapter *adapter, u8 ch);
+u8 rtw_get_oper_bw(struct rtw_adapter *adapter);
+void rtw_set_oper_bw(struct rtw_adapter *adapter, u8 bw);
+u8 rtw_get_oper_choffset(struct rtw_adapter *adapter);
+void rtw_set_oper_choffset(struct rtw_adapter *adapter, u8 offset);
+
+void set_channel_bwmode(struct rtw_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
+void SelectChannel(struct rtw_adapter *padapter, unsigned char channel);
+void SetBWMode(struct rtw_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
+
+void write_cam(struct rtw_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key);
+void clear_cam_entry(struct rtw_adapter *padapter, u8 entry);
+
+void invalidate_cam_all(struct rtw_adapter *padapter);
+void CAM_empty_entry(struct rtw_adapter *adapter, u8 ucIndex);
+
+
+int allocate_fw_sta_entry(struct rtw_adapter *padapter);
+void flush_all_cam_entry(struct rtw_adapter *padapter);
+
+bool IsLegal5GChannel(struct rtw_adapter *adapter, u8 channel);
+
+void site_survey(struct rtw_adapter *padapter);
+u8 collect_bss_info(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame, struct wlan_bssid_ex *bssid);
+
+int get_bsstype(unsigned short capability);
+u8* get_my_bssid(struct wlan_bssid_ex *pnetwork);
+u16 get_beacon_interval(struct wlan_bssid_ex *bss);
+
+int is_client_associated_to_ap(struct rtw_adapter *padapter);
+int is_client_associated_to_ibss(struct rtw_adapter *padapter);
+int is_IBSS_empty(struct rtw_adapter *padapter);
+
+unsigned char check_assoc_AP(u8 *pframe, uint len);
+
+int WMM_param_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
+void WMMOnAssocRsp(struct rtw_adapter *padapter);
+
+void HT_caps_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
+void HT_info_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
+void HTOnAssocRsp(struct rtw_adapter *padapter);
+
+void ERP_IE_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE);
+void VCS_update(struct rtw_adapter *padapter, struct sta_info *psta);
+
+void update_beacon_info(struct rtw_adapter *padapter, u8 *pframe, uint len, struct sta_info *psta);
+#ifdef CONFIG_DFS
+void process_csa_ie(struct rtw_adapter *padapter, u8 *pframe, uint len);
+#endif /* CONFIG_DFS */
+void update_IOT_info(struct rtw_adapter *padapter);
+void update_capinfo(struct rtw_adapter *adapter, u16 updateCap);
+void update_wireless_mode(struct rtw_adapter *padapter);
+void update_tx_basic_rate(struct rtw_adapter *padapter, u8 modulation);
+void update_bmc_sta_support_rate(struct rtw_adapter *padapter, u32 mac_id);
+int update_sta_support_rate(struct rtw_adapter *padapter, u8* pvar_ie, uint var_ie_len, int cam_idx);
+
+/* for sta/adhoc mode */
+void update_sta_info(struct rtw_adapter *padapter, struct sta_info *psta);
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_MSC_rate(struct HT_caps_element *pHT_caps);
+void Update_RA_Entry(struct rtw_adapter *padapter, u32 mac_id);
+void set_sta_rate(struct rtw_adapter *padapter, struct sta_info *psta);
+
+unsigned int receive_disconnect(struct rtw_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
+
+unsigned char get_highest_rate_idx(u32 mask);
+int support_short_GI(struct rtw_adapter *padapter, struct HT_caps_element *pHT_caps);
+unsigned int is_ap_in_tkip(struct rtw_adapter *padapter);
+
+
+void report_join_res(struct rtw_adapter *padapter, int res);
+void report_survey_event(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+void report_surveydone_event(struct rtw_adapter *padapter);
+void report_del_sta_event(struct rtw_adapter *padapter, unsigned char* MacAddr, unsigned short reason);
+void report_add_sta_event(struct rtw_adapter *padapter, unsigned char* MacAddr, int cam_idx);
+
+void beacon_timing_control(struct rtw_adapter *padapter);
+extern u8 set_tx_beacon_cmd(struct rtw_adapter*padapter);
+unsigned int setup_beacon_frame(struct rtw_adapter *padapter, unsigned char *beacon_frame);
+void update_mgnt_tx_rate(struct rtw_adapter *padapter, u8 rate);
+void update_mgntframe_attrib(struct rtw_adapter *padapter, struct pkt_attrib *pattrib);
+void dump_mgntframe(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe);
+s32 dump_mgntframe_and_wait(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe, int timeout_ms);
+s32 dump_mgntframe_and_wait_ack(struct rtw_adapter *padapter, struct xmit_frame *pmgntframe);
+
+void issue_beacon(struct rtw_adapter *padapter);
+void issue_probersp(struct rtw_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
+void issue_assocreq(struct rtw_adapter *padapter);
+void issue_asocrsp(struct rtw_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
+void issue_auth(struct rtw_adapter *padapter, struct sta_info *psta, unsigned short status);
+void issue_probereq(struct rtw_adapter *padapter, struct ndis_802_11_ssid *pssid, u8 *da);
+s32 issue_probereq_ex(struct rtw_adapter *padapter, struct ndis_802_11_ssid *pssid, u8* da, int try_cnt, int wait_ms);
+int issue_nulldata(struct rtw_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+int issue_qos_nulldata(struct rtw_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
+int issue_deauth(struct rtw_adapter *padapter, unsigned char *da, unsigned short reason);
+int issue_deauth_ex(struct rtw_adapter *padapter, u8 *da, unsigned short reason, int try_cnt, int wait_ms);
+void issue_action_spct_ch_switch (struct rtw_adapter *padapter, u8 *ra, u8 new_ch, u8 ch_offset);
+void issue_action_BA(struct rtw_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status);
+unsigned int send_delba(struct rtw_adapter *padapter, u8 initiator, u8 *addr);
+unsigned int send_beacon(struct rtw_adapter *padapter);
+
+void start_clnt_assoc(struct rtw_adapter *padapter);
+void start_clnt_auth(struct rtw_adapter* padapter);
+void start_clnt_join(struct rtw_adapter* padapter);
+void start_create_ibss(struct rtw_adapter* padapter);
+
+unsigned int OnAssocReq(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAssocRsp(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnProbeReq(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnProbeRsp(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int DoReserved(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnBeacon(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAtim(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnDisassoc(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAuth(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAuthClient(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnDeAuth(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+
+unsigned int on_action_spct(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_qos(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_dls(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_back(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int on_action_public(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_ht(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_wmm(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+unsigned int OnAction_p2p(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+
+
+void mlmeext_joinbss_event_callback(struct rtw_adapter *padapter, int join_res);
+void mlmeext_sta_del_event_callback(struct rtw_adapter *padapter);
+void mlmeext_sta_add_event_callback(struct rtw_adapter *padapter, struct sta_info *psta);
+
+void linked_status_chk(struct rtw_adapter *padapter);
+
+void survey_timer_hdl (struct rtw_adapter *padapter);
+void link_timer_hdl (struct rtw_adapter *padapter);
+void addba_timer_hdl(struct sta_info *psta);
+
+#define set_survey_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_survey_timer(%p, %d)\n", __func__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->survey_timer, (ms)); \
+	} while (0)
+
+#define set_link_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_link_timer(%p, %d)\n", __func__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->link_timer, (ms)); \
+	} while (0)
+
+extern int cckrates_included(unsigned char *rate, int ratelen);
+extern int cckratesonly_included(unsigned char *rate, int ratelen);
+
+extern void process_addba_req(struct rtw_adapter *padapter, u8 *paddba_req, u8 *addr);
+
+extern void update_TSF(struct mlme_ext_priv *pmlmeext, u8 *pframe, uint len);
+extern void correct_TSF(struct rtw_adapter *padapter, struct mlme_ext_priv *pmlmeext);
+
+
+#ifdef CONFIG_CONCURRENT_MODE
+int check_buddy_mlmeinfo_state(struct rtw_adapter *padapter, u32 state);
+int concurrent_chk_start_clnt_join(struct rtw_adapter *padapter);
+void concurrent_chk_joinbss_done(struct rtw_adapter *padapter, int join_res);
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+void	dc_SelectChannel(struct rtw_adapter *padapter, unsigned char channel);
+void	dc_SetBWMode(struct rtw_adapter *padapter, unsigned short bwmode, unsigned char channel_offset);
+void	dc_set_channel_bwmode_disconnect(struct rtw_adapter *padapter);
+u8	dc_handle_join_request(struct rtw_adapter *padapter);
+void	dc_handle_join_done(struct rtw_adapter *padapter, u8 join_res);
+int	dc_check_fwstate(struct rtw_adapter *padapter, int fw_state);
+u8	dc_handle_site_survey(struct rtw_adapter *padapter);
+void	dc_report_survey_event(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame);
+void	dc_set_channel_bwmode_survey_done(struct rtw_adapter *padapter);
+void	dc_set_ap_channel_bandwidth(struct rtw_adapter *padapter, u8 channel, u8 channel_offset, u8 bwmode);
+void	dc_resume_xmit(struct rtw_adapter *padapter);
+u8	dc_check_xmit(struct rtw_adapter *padapter);
+#endif
+
+struct cmd_hdl {
+	uint	parmsize;
+	u8 (*h2cfuns)(struct rtw_adapter *padapter, u8 *pbuf);
+};
+
+
+u8 read_macreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 write_macreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 read_bbreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 write_bbreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 read_rfreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 write_rfreg_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+
+
+u8 NULL_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 join_cmd_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 disconnect_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 createbss_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 setopmode_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 sitesurvey_cmd_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 setauth_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 setkey_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 set_stakey_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 set_assocsta_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 del_assocsta_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 add_ba_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+
+u8 mlme_evt_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+u8 h2c_msg_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+u8 tx_beacon_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+u8 set_ch_hdl(struct rtw_adapter *padapter, u8 *pbuf);
+u8 set_chplan_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+u8 led_blink_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+u8 set_csa_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);	/* Kurt: Handling DFS channel switch announcement ie. */
+u8 tdls_hdl(struct rtw_adapter *padapter, unsigned char *pbuf);
+
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},
+
+#ifdef _RTW_CMD_C_
+
+static struct cmd_hdl wlancmds[] =
+{
+	GEN_DRV_CMD_HANDLER(0, NULL) /*0*/
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_DRV_CMD_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*10*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct joinbss_parm), join_cmd_hdl) /*14*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct disconnect_parm), disconnect_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct createbss_parm), createbss_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setopmode_parm), setopmode_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct sitesurvey_parm), sitesurvey_cmd_hdl) /*18*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setauth_parm), setauth_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setkey_parm), setkey_hdl) /*20*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_stakey_parm), set_stakey_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct del_assocsta_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setstapwrstate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getbasicrate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getdatarate_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphyinfo_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphyinfo_parm), NULL)  /*30*/
+	GEN_MLME_EXT_HANDLER(sizeof (struct setphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(sizeof (struct getphy_parm), NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)	/*40*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl) /* 46 */
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL) /*50*/
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(0, NULL)
+	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl) /*55*/
+
+	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl) /*56*/
+	GEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl) /*57*/
+
+	GEN_MLME_EXT_HANDLER(0, h2c_msg_hdl) /*58*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct setchannelplan_param), set_chplan_hdl) /*59*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct ledblink_param), led_blink_hdl) /*60*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct setchannelswitch_param), set_csa_hdl) /*61*/
+	GEN_MLME_EXT_HANDLER(sizeof(struct tdlsoption_param), tdls_hdl) /*62*/
+};
+
+#endif
+
+struct C2HEvent_Header
+{
+
+#ifdef __LITTLE_ENDIAN
+
+	unsigned int len:16;
+	unsigned int ID:8;
+	unsigned int seq:8;
+
+#elif defined(__BIG_ENDIAN)
+
+	unsigned int seq:8;
+	unsigned int ID:8;
+	unsigned int len:16;
+
+#else
+
+#  error "Must be LITTLE or BIG Endian"
+
+#endif
+
+	unsigned int rsvd;
+
+};
+
+enum rtw_c2h_event
+{
+	GEN_EVT_CODE(_READ_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_READ_BBREG),
+	GEN_EVT_CODE(_READ_RFREG),
+	GEN_EVT_CODE(_READ_EEPROM),
+	GEN_EVT_CODE(_READ_EFUSE),
+	GEN_EVT_CODE(_READ_CAM),			/*5*/
+	GEN_EVT_CODE(_GET_BASICRATE),
+	GEN_EVT_CODE(_GET_DATARATE),
+	GEN_EVT_CODE(_SURVEY),	 /*8*/
+	GEN_EVT_CODE(_SURVEYDONE),	 /*9*/
+
+	GEN_EVT_CODE(_JOINBSS) , /*10*/
+	GEN_EVT_CODE(_ADDSTA),
+	GEN_EVT_CODE(_DELSTA),
+	GEN_EVT_CODE(_ATIMDONE) ,
+	GEN_EVT_CODE(_TX_REPORT),
+	GEN_EVT_CODE(_CCX_REPORT),			/*15*/
+	GEN_EVT_CODE(_DTM_REPORT),
+	GEN_EVT_CODE(_TX_RATE_STATISTICS),
+	GEN_EVT_CODE(_C2HLBK),
+	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),            /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_REPORTPWRSTATE),		/* filen: only for PCIE, USB */
+	GEN_EVT_CODE(_CLOSERF),			/* filen: only for PCIE, work around ASPM */
+	MAX_C2HEVT
+};
+
+
+#ifdef _RTW_MLME_EXT_C_
+
+static struct fwevent wlanevents[] =
+{
+	{0, NULL}, /*rtw_dummy_event_callback},*/	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
+	{0, &rtw_atimdone_event_callback},
+	{0, NULL}, /*rtw_dummy_event_callback},*/
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL}, /*rtw_fwdbg_event_callback},*/
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_cpwm_event_callback},
+	{0, NULL},
+};
+
+#endif/* _RTL8192C_CMD_C_ */
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_mp.h b/drivers/net/wireless/rtl8192du/include/rtw_mp.h
new file mode 100644
index 0000000..0daa5c3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_mp.h
@@ -0,0 +1,466 @@
+/******************************************************************************
+ *
+ *Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ *This program is free software; you can redistribute it and/or modify it
+ *under the terms of version 2 of the GNU General Public License as
+ *published by the Free Software Foundation.
+ *
+ *This program is distributed in the hope that it will be useful, but WITHOUT
+ *ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ *more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_MP_H_
+#define _RTW_MP_H_
+
+/* 	00 - Success */
+/* 	11 - Error */
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define uint_SUCCESS			((uint)STATUS_SUCCESS)
+#define uint_PENDING			((uint)STATUS_PENDING)
+#define uint_NOT_RECOGNIZED		((uint)0x00010001L)
+#define uint_NOT_COPIED			((uint)0x00010002L)
+#define uint_NOT_ACCEPTED		((uint)0x00010003L)
+#define uint_CALL_ACTIVE			((uint)0x00010007L)
+
+#define uint_FAILURE			((uint)STATUS_UNSUCCESSFUL)
+#define uint_RESOURCES			((uint)STATUS_INSUFFICIENT_RESOURCES)
+#define uint_CLOSING			((uint)0xC0010002L)
+#define uint_BAD_VERSION			((uint)0xC0010004L)
+#define uint_BAD_CHARACTERISTICS		((uint)0xC0010005L)
+#define uint_ADAPTER_NOT_FOUND		((uint)0xC0010006L)
+#define uint_OPEN_FAILED			((uint)0xC0010007L)
+#define uint_DEVICE_FAILED		((uint)0xC0010008L)
+#define uint_MULTICAST_FULL		((uint)0xC0010009L)
+#define uint_MULTICAST_EXISTS		((uint)0xC001000AL)
+#define uint_MULTICAST_NOT_FOUND		((uint)0xC001000BL)
+#define uint_REQUEST_ABORTED		((uint)0xC001000CL)
+#define uint_RESET_IN_PROGRESS		((uint)0xC001000DL)
+#define uint_CLOSING_INDICATING		((uint)0xC001000EL)
+#define uint_NOT_SUPPORTED		((uint)STATUS_NOT_SUPPORTED)
+#define uint_INVALID_PACKET		((uint)0xC001000FL)
+#define uint_OPEN_LIST_FULL		((uint)0xC0010010L)
+#define uint_ADAPTER_NOT_READY		((uint)0xC0010011L)
+#define uint_ADAPTER_NOT_OPEN		((uint)0xC0010012L)
+#define uint_NOT_INDICATING		((uint)0xC0010013L)
+#define uint_INVALID_LENGTH		((uint)0xC0010014L)
+#define uint_INVALID_DATA		((uint)0xC0010015L)
+#define uint_BUFFER_TOO_SHORT		((uint)0xC0010016L)
+#define uint_INVALID_OID			((uint)0xC0010017L)
+#define uint_ADAPTER_REMOVED		((uint)0xC0010018L)
+#define uint_UNSUPPORTED_MEDIA		((uint)0xC0010019L)
+#define uint_GROUP_ADDRESS_IN_USE	((uint)0xC001001AL)
+#define uint_FILE_NOT_FOUND		((uint)0xC001001BL)
+#define uint_ERROR_READING_FILE		((uint)0xC001001CL)
+#define uint_ALREADY_MAPPED		((uint)0xC001001DL)
+#define uint_RESOURCE_CONFLICT		((uint)0xC001001EL)
+#define uint_NO_CABLE			((uint)0xC001001FL)
+
+#define uint_INVALID_SAP			((uint)0xC0010020L)
+#define uint_SAP_IN_USE			((uint)0xC0010021L)
+#define uint_INVALID_ADDRESS		((uint)0xC0010022L)
+#define uint_VC_NOT_ACTIVATED		((uint)0xC0010023L)
+#define uint_DEST_OUT_OF_ORDER		((uint)0xC0010024L)  /*  cause 27 */
+#define uint_VC_NOT_AVAILABLE		((uint)0xC0010025L)  /*  cause 35,45 */
+#define uint_CELLRATE_NOT_AVAILABLE	((uint)0xC0010026L)  /*  cause 37 */
+#define uint_INCOMPATABLE_QOS		((uint)0xC0010027L)  /*  cause 49 */
+#define uint_AAL_PARAMS_UNSUPPORTED	((uint)0xC0010028L)  /*  cause 93 */
+#define uint_NO_ROUTE_TO_DESTINATION	((uint)0xC0010029L)  /*  cause 3 */
+
+#define MAX_MP_XMITBUF_SZ	2048
+#define NR_MP_XMITFRAME		8
+
+struct mp_xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	struct sk_buff *pkt;
+	int frame_tag;
+	struct rtw_adapter *padapter;
+	/* insert urb, irp, and irpcnt info below... */
+	u8 *mem_addr;
+	u32 sz[8];
+	struct urb *pxmit_urb[8];
+	u8 bpending[8];
+	int ac_tag[8];
+	int last[8];
+	uint irpcnt;
+	uint fragcnt;
+	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
+};
+
+struct mp_wiparam {
+	u32 bcompleted;
+	u32 act_type;
+	u32 io_offset;
+	u32 io_value;
+};
+
+struct mp_tx {
+	u8 stop;
+	u32 count, sended;
+	u8 payload;
+	struct pkt_attrib attrib;
+	struct tx_desc desc;
+	u8 *pallocated_buf;
+	u8 *buf;
+	u32 buf_size, write_size;
+	void *PktTxThread;
+};
+
+#include <hal8192dphycfg.h>
+#define MP_MAX_LINES		1000
+#define MP_MAX_LINES_BYTES	256
+#define u1Byte u8
+#define s1Byte s8
+#define u4Byte u32
+#define s4Byte s32
+
+struct mpt_context {
+	/*  Indicate if we have started Mass Production Test. */
+	bool			bMassProdTest;
+
+	/*  Indicate if the driver is unloading or unloaded. */
+	bool			bMptDrvUnload;
+
+	/*  Indicate a MptWorkItem is scheduled and not yet finished. */
+	bool			bMptWorkItemInProgress;
+
+	/*  1=Start, 0=Stop from UI. */
+	u32			MptTestStart;
+	/*  _TEST_MODE, defined in MPT_Req2.h */
+	u32			MptTestItem;
+	/*  Variable needed in each implementation of CurrMptAct. */
+	u32			MptActType;	/*  Type of action performed in CurrMptAct. */
+	/*  The Offset of IO operation is depend of MptActType. */
+	u32			MptIoOffset;
+	/*  The Value of IO operation is depend of MptActType. */
+	u32			MptIoValue;
+	/*  The RfPath of IO operation is depend of MptActType. */
+	u32			MptRfPath;
+
+	enum WIRELESS_MODE	MptWirelessModeToSw;	/*  Wireless mode to switch. */
+	u8			MptChannelToSw;		/*  Channel to switch. */
+	u8			MptInitGainToSet;	/*  Initial gain to set. */
+	u32			MptBandWidth;		/*  bandwidth to switch. */
+	u32			MptRateIndex;		/*  rate index. */
+	/*  Register value kept for Single Carrier Tx test. */
+	u8			btMpCckTxPower;
+	/*  Register value kept for Single Carrier Tx test. */
+	u8			btMpOfdmTxPower;
+	/*  For MP Tx Power index */
+	u8			TxPwrLevel[2];	/*  rf-A, rf-B */
+
+	/*  Content of RCR Regsiter for Mass Production Test. */
+	u32			MptRCR;
+	/*  TRUE if we only receive packets with specific pattern. */
+	bool			bMptFilterPattern;
+	/*  Rx OK count, statistics used in Mass Production Test. */
+	u32			MptRxOkCnt;
+	/*  Rx CRC32 error count, statistics used in Mass Production Test. */
+	u32			MptRxCrcErrCnt;
+
+	bool			bCckContTx;	/*  TRUE if we are in CCK Continuous Tx test. */
+	bool			bOfdmContTx;	/*  TRUE if we are in OFDM Continuous Tx test. */
+	bool			bStartContTx;	/*  TRUE if we have start Continuous Tx test. */
+	/*  TRUE if we are in Single Carrier Tx test. */
+	bool			bSingleCarrier;
+	/*  TRUE if we are in Carrier Suppression Tx Test. */
+	bool			bCarrierSuppression;
+	/* TRUE if we are in Single Tone Tx test. */
+	bool			bSingleTone;
+
+	/*  ACK counter asked by K.Y.. */
+	bool			bMptEnableAckCounter;
+	u32			MptAckCounter;
+
+	/*  SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~! */
+
+	u8		APK_bound[2];	/* for APK	path A/path B */
+	bool		bMptIndexEven;
+
+	u8		backup0xc50;
+	u8		backup0xc58;
+	u8		backup0xc30;
+};
+
+/* E-Fuse */
+#define EFUSE_MAP_SIZE		255
+#define EFUSE_MAX_SIZE		512
+
+/* end of E-Fuse */
+
+enum {
+	WRITE_REG = 1,
+	READ_REG,
+	WRITE_RF,
+	READ_RF,
+	MP_START,
+	MP_STOP,
+	MP_RATE,
+	MP_CHANNEL,
+	MP_BANDWIDTH,
+	MP_TXPOWER,
+	MP_ANT_TX,
+	MP_ANT_RX,
+	MP_CTX,
+	MP_QUERY,
+	MP_ARX,
+	MP_PSD,
+	MP_PWRTRK,
+	MP_THER,
+	MP_IOCTL,
+	EFUSE_GET,
+	EFUSE_SET,
+	MP_RESET_STATS,
+	MP_DUMP,
+	MP_PHYPARA,
+	MP_NULL,
+};
+
+struct mp_priv
+{
+	struct rtw_adapter *papdater;
+
+	/* Testing Flag */
+	u32 mode;/* 0 for normal type packet, 1 for loopback packet (16bytes TXCMD) */
+
+	u32 prev_fw_state;
+
+	/* OID cmd handler */
+	struct mp_wiparam workparam;
+
+	/* Tx Section */
+	u8 TID;
+	u32 tx_pktcount;
+	struct mp_tx tx;
+
+	/* Rx Section */
+	u32 rx_pktcount;
+	u32 rx_crcerrpktcount;
+	u32 rx_pktloss;
+
+	struct recv_stat rxstat;
+
+	/* RF/BB relative */
+	u8 channel;
+	u8 bandwidth;
+	u8 prime_channel_offset;
+	u8 txpoweridx;
+	u8 txpoweridx_b;
+	u8 rateidx;
+	u32 preamble;
+	u32 CrystalCap;
+
+	u16 antenna_tx;
+	u16 antenna_rx;
+
+	u8 check_mp_pkt;
+
+
+	struct wlan_network mp_network;
+	unsigned char network_macaddr[6];
+
+	u8 *pallocated_mp_xmitframe_buf;
+	u8 *pmp_xmtframe_buf;
+	struct __queue free_mp_xmitqueue;
+	u32 free_mp_xmitframe_cnt;
+
+	struct mpt_context MptCtx;
+};
+
+struct rf_reg_param {
+	u32 path;
+	u32 offset;
+	u32 value;
+};
+
+struct bb_reg_param {
+	u32 offset;
+	u32 value;
+};
+/*  */
+
+#define LOWER	true
+#define RAISE	false
+
+/* Hardware Registers */
+#define BB_REG_BASE_ADDR		0x800
+
+/* MP variables */
+enum MP_MODE {
+	MP_OFF,
+	MP_ON,
+	MP_ERR,
+	MP_CONTINUOUS_TX,
+	MP_SINGLE_CARRIER_TX,
+	MP_CARRIER_SUPPRISSION_TX,
+	MP_SINGLE_TONE_TX,
+	MP_PACKET_TX,
+	MP_PACKET_RX
+};
+
+#define RF_PATH_A	0
+#define RF_PATH_B	1
+#define RF_PATH_C	2
+#define RF_PATH_D	3
+
+#define MAX_RF_PATH_NUMS	2
+
+extern u8 mpdatarate[NUMRATES];
+
+/* MP set force data rate base on the definition. */
+enum MPT_RATE_E {
+	/* CCK rate. */
+	MPT_RATE_1M,	/* 0 */
+	MPT_RATE_2M,
+	MPT_RATE_55M,
+	MPT_RATE_11M,	/* 3 */
+
+	/* OFDM rate. */
+	MPT_RATE_6M,	/* 4 */
+	MPT_RATE_9M,
+	MPT_RATE_12M,
+	MPT_RATE_18M,
+	MPT_RATE_24M,
+	MPT_RATE_36M,
+	MPT_RATE_48M,
+	MPT_RATE_54M,	/* 11 */
+
+	/* HT rate. */
+	MPT_RATE_MCS0,	/* 12 */
+	MPT_RATE_MCS1,
+	MPT_RATE_MCS2,
+	MPT_RATE_MCS3,
+	MPT_RATE_MCS4,
+	MPT_RATE_MCS5,
+	MPT_RATE_MCS6,
+	MPT_RATE_MCS7,	/* 19 */
+	MPT_RATE_MCS8,
+	MPT_RATE_MCS9,
+	MPT_RATE_MCS10,
+	MPT_RATE_MCS11,
+	MPT_RATE_MCS12,
+	MPT_RATE_MCS13,
+	MPT_RATE_MCS14,
+	MPT_RATE_MCS15,	/* 27 */
+	MPT_RATE_LAST
+};
+
+#define MAX_TX_PWR_INDEX_N_MODE 64	/*  0x3F */
+
+enum POWER_MODE {
+	POWER_LOW = 0,
+	POWER_NORMAL
+};
+
+
+#define RX_PKT_BROADCAST	1
+#define RX_PKT_DEST_ADDR	2
+#define RX_PKT_PHY_MATCH	3
+
+enum ENCRY_CTRL_STATE {
+	HW_CONTROL,		/* hw encryption& decryption */
+	SW_CONTROL,		/* sw encryption& decryption */
+	HW_ENCRY_SW_DECRY,	/* hw encryption & sw decryption */
+	SW_ENCRY_HW_DECRY	/* sw encryption & hw decryption */
+};
+
+enum OFDM_TX_MODE {
+	OFDM_ALL_OFF		= 0,
+	OFDM_ContinuousTx	= 1,
+	OFDM_SingleCarrier	= 2,
+	OFDM_SingleTone		= 4,
+};
+
+/*  */
+
+extern s32 init_mp_priv(struct rtw_adapter * padapter);
+extern void free_mp_priv(struct mp_priv *pmp_priv);
+extern s32 MPT_Initializeadapter(struct rtw_adapter * padapter, u8 Channel);
+extern void MPT_DeInitadapter(struct rtw_adapter * padapter);
+extern s32 mp_start_test(struct rtw_adapter * padapter);
+extern void mp_stop_test(struct rtw_adapter * padapter);
+
+/*  */
+
+
+
+extern u32 _read_rfreg(struct rtw_adapter * padapter, enum RF_RADIO_PATH_E rfpath, u32 addr, u32 bitmask);
+extern void _write_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+
+extern u32 read_macreg(struct rtw_adapter *padapter, u32 addr, u32 sz);
+extern void write_macreg(struct rtw_adapter *padapter, u32 addr, u32 val, u32 sz);
+extern u32 read_bbreg(struct rtw_adapter *padapter, u32 addr, u32 bitmask);
+extern void write_bbreg(struct rtw_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+extern u32 read_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr);
+extern void write_rfreg(struct rtw_adapter * padapter, u8 rfpath, u32 addr, u32 val);
+
+extern void	SetChannel(struct rtw_adapter * adapter);
+extern void	SetBandwidth(struct rtw_adapter * adapter);
+extern void	SetTxPower(struct rtw_adapter * adapter);
+extern void	SetAntennaPathPower(struct rtw_adapter * adapter);
+extern void	SetDataRate(struct rtw_adapter * adapter);
+
+extern void	SetAntenna(struct rtw_adapter * adapter);
+
+
+extern s32	SetThermalMeter(struct rtw_adapter * adapter, u8 target_ther);
+extern void	GetThermalMeter(struct rtw_adapter * adapter, u8 *value);
+
+extern void	SetContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetSingleCarrierTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetSingleToneTx(struct rtw_adapter * adapter, u8 bStart);
+extern void	SetCarrierSuppressionTx(struct rtw_adapter * adapter, u8 bStart);
+
+extern void	fill_txdesc_for_mp(struct rtw_adapter * padapter, struct tx_desc *ptxdesc);
+extern void	SetPacketTx(struct rtw_adapter * padapter);
+extern void	SetPacketRx(struct rtw_adapter * adapter, u8 bStartRx);
+
+extern void	ResetPhyRxPktCount(struct rtw_adapter * adapter);
+extern u32	GetPhyRxPktReceived(struct rtw_adapter * adapter);
+extern u32	GetPhyRxPktCRC32Error(struct rtw_adapter * adapter);
+
+extern s32	SetPowerTracking(struct rtw_adapter * padapter, u8 enable);
+extern void	GetPowerTracking(struct rtw_adapter * padapter, u8 *enable);
+
+extern u32	mp_query_psd(struct rtw_adapter * adapter, u8 *data);
+
+
+extern void Hal_SetAntenna(struct rtw_adapter * adapter);
+extern void Hal_SetBandwidth(struct rtw_adapter * adapter);
+
+extern void Hal_SetTxPower(struct rtw_adapter * adapter);
+extern void Hal_SetCarrierSuppressionTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetSingleToneTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetSingleCarrierTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetContinuousTx (struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetBandwidth(struct rtw_adapter * adapter);
+
+extern void Hal_SetDataRate(struct rtw_adapter * adapter);
+extern void Hal_SetChannel(struct rtw_adapter * adapter);
+extern void Hal_SetAntennaPathPower(struct rtw_adapter * adapter);
+extern s32 Hal_SetThermalMeter(struct rtw_adapter * adapter, u8 target_ther);
+extern s32 Hal_SetPowerTracking(struct rtw_adapter * padapter, u8 enable);
+extern void Hal_GetPowerTracking(struct rtw_adapter * padapter, u8 *enable);
+extern void Hal_GetThermalMeter(struct rtw_adapter * adapter, u8 *value);
+extern void Hal_mpt_SwitchRfSetting(struct rtw_adapter * adapter);
+extern void Hal_MPT_CCKTxPowerAdjust(struct rtw_adapter * adapter, bool bInCH14);
+extern void Hal_MPT_CCKTxPowerAdjustbyIndex(struct rtw_adapter * adapter, bool beven);
+extern void Hal_SetCCKTxPower(struct rtw_adapter * adapter, u8 *TxPower);
+extern void Hal_SetOFDMTxPower(struct rtw_adapter * adapter, u8 *TxPower);
+extern void Hal_TriggerRFThermalMeter(struct rtw_adapter * adapter);
+extern u8 Hal_ReadRFThermalMeter(struct rtw_adapter * adapter);
+extern void Hal_SetCCKContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_SetOFDMContinuousTx(struct rtw_adapter * adapter, u8 bStart);
+extern void Hal_ProSetCrystalCap (struct rtw_adapter * adapter, u32 CrystalCapVal);
+
+#endif /* _RTW_MP_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_mp_ioctl.h b/drivers/net/wireless/rtl8192du/include/rtw_mp_ioctl.h
new file mode 100644
index 0000000..910600f
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_mp_ioctl.h
@@ -0,0 +1,508 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_MP_IOCTL_H_
+#define _RTW_MP_IOCTL_H_
+
+#include <drv_types.h>
+#include <mp_custom_oid.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_rtl.h>
+#include <rtw_efuse.h>
+#include <rtw_mp.h>
+
+/*  */
+struct mp_rw_reg {
+	u32 offset;
+	u32 width;
+	u32 value;
+};
+
+#define _irqlevel_changed_(a,b)
+
+/* oid_rtl_seg_81_80_00 */
+uint oid_rt_pro_set_data_rate_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_start_test_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_stop_test_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_channel_direct_call_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_antenna_bb_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_tx_power_control_hdl(struct oid_par_priv* poid_par_priv);
+/* oid_rtl_seg_81_80_20 */
+uint oid_rt_pro_query_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_query_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_query_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_reset_tx_packet_sent_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_reset_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_modulation_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_set_continuous_tx_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_single_carrier_tx_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_carrier_suppression_tx_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_single_tone_tx_hdl(struct oid_par_priv* poid_par_priv);
+
+
+/* oid_rtl_seg_81_87 */
+uint oid_rt_pro_write_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_read_bb_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_write_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_read_rf_reg_hdl(struct oid_par_priv* poid_par_priv);
+
+
+/* oid_rtl_seg_81_85 */
+uint oid_rt_wireless_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+
+/*  oid_rtl_seg_87_11_00 */
+uint oid_rt_pro8711_join_bss_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_read_register_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_write_register_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_burst_read_register_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_burst_write_register_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_write_txcmd_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_read16_eeprom_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_write16_eeprom_hdl (struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro8711_wi_poll_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro8711_pkt_loss_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_rd_attrib_mem_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_wr_attrib_mem_hdl (struct oid_par_priv* poid_par_priv);
+uint  oid_rt_pro_set_rf_intfs_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_poll_rx_status_hdl(struct oid_par_priv* poid_par_priv);
+/*  oid_rtl_seg_87_11_20 */
+uint oid_rt_pro_cfg_debug_message_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_data_rate_ex_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_basic_rate_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_read_tssi_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_power_tracking_hdl(struct oid_par_priv* poid_par_priv);
+/* oid_rtl_seg_87_11_50 */
+uint oid_rt_pro_qry_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_pwrstate_hdl(struct oid_par_priv* poid_par_priv);
+/* oid_rtl_seg_87_11_F0 */
+uint oid_rt_pro_h2c_set_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_h2c_get_rate_table_hdl(struct oid_par_priv* poid_par_priv);
+
+
+/* oid_rtl_seg_87_12_00 */
+uint oid_rt_pro_encryption_ctrl_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_add_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_dele_sta_info_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_query_dr_variable_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_read_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_write_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_rw_efuse_pgpkt_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_get_efuse_current_size_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_hdl(struct oid_par_priv *poid_par_priv);
+uint oid_rt_pro_efuse_map_hdl(struct oid_par_priv *poid_par_priv);
+
+uint oid_rt_set_bandwidth_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_crystal_cap_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_set_rx_packet_type_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_efuse_max_size_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_pro_set_tx_agc_offset_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_set_pkt_test_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_get_thermal_meter_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_reset_phy_rx_packet_count_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_phy_rx_packet_received_hdl(struct oid_par_priv* poid_par_priv);
+uint oid_rt_get_phy_rx_packet_crc32_error_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_set_power_down_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_get_power_mode_hdl(struct oid_par_priv* poid_par_priv);
+
+uint oid_rt_pro_trigger_gpio_hdl(struct oid_par_priv *poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+const struct oid_obj_priv oid_rtl_seg_81_80_00[] =
+{
+	{1, &oid_null_function},			/* 0x00	OID_RT_PRO_RESET_DUT */
+	{1, &oid_rt_pro_set_data_rate_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_start_test_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_stop_test_hdl},			/* 0x03 */
+	{1, &oid_null_function},			/* 0x04	OID_RT_PRO_SET_PREAMBLE */
+	{1, &oid_null_function},			/* 0x05	OID_RT_PRO_SET_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x06	OID_RT_PRO_SET_FILTER_BB */
+	{1, &oid_null_function},			/* 0x07	OID_RT_PRO_SET_MANUAL_DIVERSITY_BB */
+	{1, &oid_rt_pro_set_channel_direct_call_hdl},	/* 0x08 */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_SET_SLEEP_MODE_DIRECT_CALL */
+	{1, &oid_null_function},			/* 0x0A	OID_RT_PRO_SET_WAKE_MODE_DIRECT_CALL */
+	{1, &oid_rt_pro_set_continuous_tx_hdl},		/* 0x0B	OID_RT_PRO_SET_TX_CONTINUOUS_DIRECT_CALL */
+	{1, &oid_rt_pro_set_single_carrier_tx_hdl},	/* 0x0C	OID_RT_PRO_SET_SINGLE_CARRIER_TX_CONTINUOUS */
+	{1, &oid_null_function},			/* 0x0D	OID_RT_PRO_SET_TX_ANTENNA_BB */
+	{1, &oid_rt_pro_set_antenna_bb_hdl},		/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F	OID_RT_PRO_SET_CR_SCRAMBLER */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_SET_CR_NEW_FILTER */
+	{1, &oid_rt_pro_set_tx_power_control_hdl},	/* 0x11	OID_RT_PRO_SET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x12	OID_RT_PRO_SET_CR_TX_CONFIG */
+	{1, &oid_null_function},			/* 0x13	OID_RT_PRO_GET_TX_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x14	OID_RT_PRO_GET_CR_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x15	OID_RT_PRO_SET_CR_SETPOINT */
+	{1, &oid_null_function},			/* 0x16	OID_RT_PRO_SET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x17	OID_RT_PRO_SET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x18	OID_RT_PRO_GET_INTEGRATOR */
+	{1, &oid_null_function},			/* 0x19	OID_RT_PRO_GET_SIGNAL_QUALITY */
+	{1, &oid_null_function},			/* 0x1A	OID_RT_PRO_QUERY_EEPROM_TYPE */
+	{1, &oid_null_function},			/* 0x1B	OID_RT_PRO_WRITE_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1C	OID_RT_PRO_READ_MAC_ADDRESS */
+	{1, &oid_null_function},			/* 0x1D	OID_RT_PRO_WRITE_CIS_DATA */
+	{1, &oid_null_function},			/* 0x1E	OID_RT_PRO_READ_CIS_DATA */
+	{1, &oid_null_function}				/* 0x1F	OID_RT_PRO_WRITE_POWER_CONTROL */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_20[] =
+{
+	{1, &oid_null_function},			/* 0x20	OID_RT_PRO_READ_POWER_CONTROL */
+	{1, &oid_null_function},			/* 0x21	OID_RT_PRO_WRITE_EEPROM */
+	{1, &oid_null_function},			/* 0x22	OID_RT_PRO_READ_EEPROM */
+	{1, &oid_rt_pro_reset_tx_packet_sent_hdl},	/* 0x23 */
+	{1, &oid_rt_pro_query_tx_packet_sent_hdl},	/* 0x24 */
+	{1, &oid_rt_pro_reset_rx_packet_received_hdl},	/* 0x25 */
+	{1, &oid_rt_pro_query_rx_packet_received_hdl},	/* 0x26 */
+	{1, &oid_rt_pro_query_rx_packet_crc32_error_hdl},	/* 0x27 */
+	{1, &oid_null_function},			/* 0x28	OID_RT_PRO_QUERY_CURRENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x29	OID_RT_PRO_QUERY_PERMANENT_ADDRESS */
+	{1, &oid_null_function},			/* 0x2A	OID_RT_PRO_SET_PHILIPS_RF_PARAMETERS */
+	{1, &oid_rt_pro_set_carrier_suppression_tx_hdl},/* 0x2B	OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX */
+	{1, &oid_null_function},			/* 0x2C	OID_RT_PRO_RECEIVE_PACKET */
+	{1, &oid_null_function},			/* 0x2D	OID_RT_PRO_WRITE_EEPROM_BYTE */
+	{1, &oid_null_function},			/* 0x2E	OID_RT_PRO_READ_EEPROM_BYTE */
+	{1, &oid_rt_pro_set_modulation_hdl}		/* 0x2F */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_40[] =
+{
+	{1, &oid_null_function},			/* 0x40 */
+	{1, &oid_null_function},			/* 0x41 */
+	{1, &oid_null_function},			/* 0x42 */
+	{1, &oid_rt_pro_set_single_tone_tx_hdl},	/* 0x43 */
+	{1, &oid_null_function},			/* 0x44 */
+	{1, &oid_null_function}				/* 0x45 */
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_80_80[] =
+{
+	{1, &oid_null_function},			/* 0x80	OID_RT_DRIVER_OPTION */
+	{1, &oid_null_function},			/* 0x81	OID_RT_RF_OFF */
+	{1, &oid_null_function}				/* 0x82	OID_RT_AUTH_STATUS */
+
+};
+
+const struct oid_obj_priv oid_rtl_seg_81_85[] =
+{
+	{1, &oid_rt_wireless_mode_hdl}			/* 0x00	OID_RT_WIRELESS_MODE */
+};
+
+struct oid_obj_priv oid_rtl_seg_81_87[] =
+{
+	{1, &oid_null_function},			/* 0x80	OID_RT_PRO8187_WI_POLL */
+	{1, &oid_rt_pro_write_bb_reg_hdl},		/* 0x81 */
+	{1, &oid_rt_pro_read_bb_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_write_rf_reg_hdl},		/* 0x82 */
+	{1, &oid_rt_pro_read_rf_reg_hdl}		/* 0x83 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_00[] =
+{
+	{1, &oid_rt_pro8711_join_bss_hdl},		/* 0x00 */
+	{1, &oid_rt_pro_read_register_hdl},		/* 0x01 */
+	{1, &oid_rt_pro_write_register_hdl},		/* 0x02 */
+	{1, &oid_rt_pro_burst_read_register_hdl},	/* 0x03 */
+	{1, &oid_rt_pro_burst_write_register_hdl},	/* 0x04 */
+	{1, &oid_rt_pro_write_txcmd_hdl},		/* 0x05 */
+	{1, &oid_rt_pro_read16_eeprom_hdl},		/* 0x06 */
+	{1, &oid_rt_pro_write16_eeprom_hdl},		/* 0x07 */
+	{1, &oid_null_function},			/* 0x08	OID_RT_PRO_H2C_SET_COMMAND */
+	{1, &oid_null_function},			/* 0x09	OID_RT_PRO_H2C_QUERY_RESULT */
+	{1, &oid_rt_pro8711_wi_poll_hdl},		/* 0x0A */
+	{1, &oid_rt_pro8711_pkt_loss_hdl},		/* 0x0B */
+	{1, &oid_rt_rd_attrib_mem_hdl},			/* 0x0C */
+	{1, &oid_rt_wr_attrib_mem_hdl},			/* 0x0D */
+	{1, &oid_null_function},			/* 0x0E */
+	{1, &oid_null_function},			/* 0x0F */
+	{1, &oid_null_function},			/* 0x10	OID_RT_PRO_H2C_CMD_MODE */
+	{1, &oid_null_function},			/* 0x11	OID_RT_PRO_H2C_CMD_RSP_MODE */
+	{1, &oid_null_function},			/* 0X12	OID_RT_PRO_WAIT_C2H_EVENT */
+	{1, &oid_null_function},			/* 0X13	OID_RT_PRO_RW_ACCESS_PROTOCOL_TEST */
+	{1, &oid_null_function},			/* 0X14	OID_RT_PRO_SCSI_ACCESS_TEST */
+	{1, &oid_null_function},			/* 0X15	OID_RT_PRO_SCSI_TCPIPOFFLOAD_OUT */
+	{1, &oid_null_function},			/* 0X16	OID_RT_PRO_SCSI_TCPIPOFFLOAD_IN */
+	{1, &oid_null_function},			/* 0X17	OID_RT_RRO_RX_PKT_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X18	OID_RT_RRO_RX_PKTARRAY_VIA_IOCTRL */
+	{1, &oid_null_function},			/* 0X19	OID_RT_RPO_SET_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1A */
+	{1, &oid_null_function},			/* 0X1B	OID_RT_PRO_QRY_PWRMGT_TEST */
+	{1, &oid_null_function},			/* 0X1C	OID_RT_RPO_ASYNC_RWIO_TEST */
+	{1, &oid_null_function},			/* 0X1D	OID_RT_RPO_ASYNC_RWIO_POLL */
+	{1, &oid_rt_pro_set_rf_intfs_hdl},		/* 0X1E */
+	{1, &oid_rt_poll_rx_status_hdl}			/* 0X1F */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_20[] =
+{
+	{1, &oid_rt_pro_cfg_debug_message_hdl},		/* 0x20 */
+	{1, &oid_rt_pro_set_data_rate_ex_hdl},		/* 0x21 */
+	{1, &oid_rt_pro_set_basic_rate_hdl},		/* 0x22 */
+	{1, &oid_rt_pro_read_tssi_hdl},			/* 0x23 */
+	{1, &oid_rt_pro_set_power_tracking_hdl}		/* 0x24 */
+};
+
+
+struct oid_obj_priv oid_rtl_seg_87_11_50[] =
+{
+	{1, &oid_rt_pro_qry_pwrstate_hdl},		/* 0x50 */
+	{1, &oid_rt_pro_set_pwrstate_hdl}		/* 0x51 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_80[] =
+{
+	{1, &oid_null_function}				/* 0x80 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_B0[] =
+{
+	{1, &oid_null_function}				/* 0xB0 */
+};
+
+struct oid_obj_priv oid_rtl_seg_87_11_F0[] =
+{
+	{1, &oid_null_function},			/* 0xF0 */
+	{1, &oid_null_function},			/* 0xF1 */
+	{1, &oid_null_function},			/* 0xF2 */
+	{1, &oid_null_function},			/* 0xF3 */
+	{1, &oid_null_function},			/* 0xF4 */
+	{1, &oid_null_function},			/* 0xF5 */
+	{1, &oid_null_function},			/* 0xF6 */
+	{1, &oid_null_function},			/* 0xF7 */
+	{1, &oid_null_function},			/* 0xF8 */
+	{1, &oid_null_function},			/* 0xF9 */
+	{1, &oid_null_function},			/* 0xFA */
+	{1, &oid_rt_pro_h2c_set_rate_table_hdl},	/* 0xFB */
+	{1, &oid_rt_pro_h2c_get_rate_table_hdl},	/* 0xFC */
+	{1, &oid_null_function},			/* 0xFD */
+	{1, &oid_null_function},			/* 0xFE	OID_RT_PRO_H2C_C2H_LBK_TEST */
+	{1, &oid_null_function}				/* 0xFF */
+
+};
+
+struct oid_obj_priv oid_rtl_seg_87_12_00[]=
+{
+	{1, &oid_rt_pro_encryption_ctrl_hdl},		/* 0x00	Q&S */
+	{1, &oid_rt_pro_add_sta_info_hdl},		/* 0x01	S */
+	{1, &oid_rt_pro_dele_sta_info_hdl},		/* 0x02	S */
+	{1, &oid_rt_pro_query_dr_variable_hdl},		/* 0x03	Q */
+	{1, &oid_rt_pro_rx_packet_type_hdl},		/* 0x04	Q,S */
+	{1, &oid_rt_pro_read_efuse_hdl},		/* 0x05	Q	OID_RT_PRO_READ_EFUSE */
+	{1, &oid_rt_pro_write_efuse_hdl},		/* 0x06	S	OID_RT_PRO_WRITE_EFUSE */
+	{1, &oid_rt_pro_rw_efuse_pgpkt_hdl},		/* 0x07	Q,S */
+	{1, &oid_rt_get_efuse_current_size_hdl},	/* 0x08	Q */
+	{1, &oid_rt_set_bandwidth_hdl},			/* 0x09 */
+	{1, &oid_rt_set_crystal_cap_hdl},		/* 0x0a */
+	{1, &oid_rt_set_rx_packet_type_hdl},		/* 0x0b	S */
+	{1, &oid_rt_get_efuse_max_size_hdl},		/* 0x0c */
+	{1, &oid_rt_pro_set_tx_agc_offset_hdl},		/* 0x0d */
+	{1, &oid_rt_pro_set_pkt_test_mode_hdl},		/* 0x0e */
+	{1, &oid_null_function},			/* 0x0f		OID_RT_PRO_FOR_EVM_TEST_SETTING */
+	{1, &oid_rt_get_thermal_meter_hdl},		/* 0x10	Q	OID_RT_PRO_GET_THERMAL_METER */
+	{1, &oid_rt_reset_phy_rx_packet_count_hdl},	/* 0x11	S	OID_RT_RESET_PHY_RX_PACKET_COUNT */
+	{1, &oid_rt_get_phy_rx_packet_received_hdl},	/* 0x12	Q	OID_RT_GET_PHY_RX_PACKET_RECEIVED */
+	{1, &oid_rt_get_phy_rx_packet_crc32_error_hdl},	/* 0x13	Q	OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR */
+	{1, &oid_rt_set_power_down_hdl},		/* 0x14	Q	OID_RT_SET_POWER_DOWN */
+	{1, &oid_rt_get_power_mode_hdl}			/* 0x15	Q	OID_RT_GET_POWER_MODE */
+};
+
+#else /* _RTL871X_MP_IOCTL_C_ */
+
+extern struct oid_obj_priv oid_rtl_seg_81_80_00[32];
+extern struct oid_obj_priv oid_rtl_seg_81_80_20[16];
+extern struct oid_obj_priv oid_rtl_seg_81_80_40[6];
+extern struct oid_obj_priv oid_rtl_seg_81_80_80[3];
+
+extern struct oid_obj_priv oid_rtl_seg_81_85[1];
+extern struct oid_obj_priv oid_rtl_seg_81_87[5];
+
+extern struct oid_obj_priv oid_rtl_seg_87_11_00[32];
+extern struct oid_obj_priv oid_rtl_seg_87_11_20[5];
+extern struct oid_obj_priv oid_rtl_seg_87_11_50[2];
+extern struct oid_obj_priv oid_rtl_seg_87_11_80[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_B0[1];
+extern struct oid_obj_priv oid_rtl_seg_87_11_F0[16];
+
+extern struct oid_obj_priv oid_rtl_seg_87_12_00[32];
+
+#endif /* _RTL871X_MP_IOCTL_C_ */
+
+struct rwreg_param{
+	u32 offset;
+	u32 width;
+	u32 value;
+};
+
+struct bbreg_param{
+	u32 offset;
+	u32 phymask;
+	u32 value;
+};
+/*
+struct rfchannel_param{
+	u32 ch;
+	u32 modem;
+};
+*/
+struct txpower_param{
+	u32 pwr_index;
+};
+
+
+struct datarate_param{
+	u32 rate_index;
+};
+
+
+struct rfintfs_parm {
+	u32 rfintfs;
+};
+
+struct mp_xmit_packet {
+	u32 len;
+	u32 mem[MAX_MP_XMITBUF_SZ >> 2];
+};
+
+struct psmode_param {
+	u32 ps_mode;
+	u32 smart_ps;
+};
+
+struct mp_ioctl_handler {
+	u32 paramsize;
+	u32 (*handler)(struct oid_par_priv* poid_par_priv);
+	u32 oid;
+};
+
+struct mp_ioctl_param{
+	u32 subcode;
+	u32 len;
+	u8 data[0];
+};
+
+#define GEN_MP_IOCTL_SUBCODE(code) _MP_IOCTL_ ## code ## _CMD_
+
+enum RTL871X_MP_IOCTL_SUBCODE {
+	GEN_MP_IOCTL_SUBCODE(MP_START),			/*0*/
+	GEN_MP_IOCTL_SUBCODE(MP_STOP),
+	GEN_MP_IOCTL_SUBCODE(READ_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_REG),
+	GEN_MP_IOCTL_SUBCODE(READ_BB_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_BB_REG),		/*5*/
+	GEN_MP_IOCTL_SUBCODE(READ_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG),
+	GEN_MP_IOCTL_SUBCODE(SET_CHANNEL),
+	GEN_MP_IOCTL_SUBCODE(SET_TXPOWER),
+	GEN_MP_IOCTL_SUBCODE(SET_DATARATE),		/*10*/
+	GEN_MP_IOCTL_SUBCODE(SET_BANDWIDTH),
+	GEN_MP_IOCTL_SUBCODE(SET_ANTENNA),
+	GEN_MP_IOCTL_SUBCODE(CNTU_TX),
+	GEN_MP_IOCTL_SUBCODE(SC_TX),
+	GEN_MP_IOCTL_SUBCODE(CS_TX),			/*15*/
+	GEN_MP_IOCTL_SUBCODE(ST_TX),
+	GEN_MP_IOCTL_SUBCODE(IOCTL_XMIT_PACKET),
+	GEN_MP_IOCTL_SUBCODE(SET_RX_PKT_TYPE),
+	GEN_MP_IOCTL_SUBCODE(RESET_PHY_RX_PKT_CNT),
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_RECV),	/*20*/
+	GEN_MP_IOCTL_SUBCODE(GET_PHY_RX_PKT_ERROR),
+	GEN_MP_IOCTL_SUBCODE(READ16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(WRITE16_EEPROM),
+	GEN_MP_IOCTL_SUBCODE(EFUSE),
+	GEN_MP_IOCTL_SUBCODE(EFUSE_MAP),		/*25*/
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_MAX_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_EFUSE_CURRENT_SIZE),
+	GEN_MP_IOCTL_SUBCODE(GET_THERMAL_METER),
+	GEN_MP_IOCTL_SUBCODE(SET_PTM),
+	GEN_MP_IOCTL_SUBCODE(SET_POWER_DOWN),		/*30*/
+	GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO),
+	GEN_MP_IOCTL_SUBCODE(SET_DM_BT),		/*35*/
+	GEN_MP_IOCTL_SUBCODE(DEL_BA),			/*36*/
+	GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS),	/*37*/
+	MAX_MP_IOCTL_SUBCODE,
+};
+
+u32 mp_ioctl_xmit_packet_hdl(struct oid_par_priv* poid_par_priv);
+
+#ifdef _RTW_MP_IOCTL_C_
+
+#define GEN_MP_IOCTL_HANDLER(sz, hdl, oid) {sz, hdl, oid},
+
+#define EXT_MP_IOCTL_HANDLER(sz, subcode, oid) {sz, mp_ioctl_ ## subcode ## _hdl, oid},
+
+
+struct mp_ioctl_handler mp_ioctl_hdl[] = {
+
+/*0*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_start_test_hdl, OID_RT_PRO_START_TEST)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_stop_test_hdl, OID_RT_PRO_STOP_TEST)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_read_register_hdl, OID_RT_PRO_READ_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rwreg_param), oid_rt_pro_write_register_hdl, OID_RT_PRO_WRITE_REGISTER)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_read_bb_reg_hdl, OID_RT_PRO_READ_BB_REG)
+/*5*/	GEN_MP_IOCTL_HANDLER(sizeof(struct bb_reg_param), oid_rt_pro_write_bb_reg_hdl, OID_RT_PRO_WRITE_BB_REG)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_read_rf_reg_hdl, OID_RT_PRO_RF_READ_REGISTRY)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct rf_reg_param), oid_rt_pro_write_rf_reg_hdl, OID_RT_PRO_RF_WRITE_REGISTRY)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_channel_direct_call_hdl, OID_RT_PRO_SET_CHANNEL_DIRECT_CALL)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct txpower_param), oid_rt_pro_set_tx_power_control_hdl, OID_RT_PRO_SET_TX_POWER_CONTROL)
+/*10*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_data_rate_hdl, OID_RT_PRO_SET_DATA_RATE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_bandwidth_hdl, OID_RT_SET_BANDWIDTH)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_antenna_bb_hdl, OID_RT_PRO_SET_ANTENNA_BB)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_continuous_tx_hdl, OID_RT_PRO_SET_CONTINUOUS_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_carrier_tx_hdl, OID_RT_PRO_SET_SINGLE_CARRIER_TX)
+/*15*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_carrier_suppression_tx_hdl, OID_RT_PRO_SET_CARRIER_SUPPRESSION_TX)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_pro_set_single_tone_tx_hdl, OID_RT_PRO_SET_SINGLE_TONE_TX)
+
+	EXT_MP_IOCTL_HANDLER(0, xmit_packet, 0)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_set_rx_packet_type_hdl, OID_RT_SET_RX_PACKET_TYPE)
+	GEN_MP_IOCTL_HANDLER(0, oid_rt_reset_phy_rx_packet_count_hdl, OID_RT_RESET_PHY_RX_PACKET_COUNT)
+/*20*/	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_received_hdl, OID_RT_GET_PHY_RX_PACKET_RECEIVED)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_phy_rx_packet_crc32_error_hdl, OID_RT_GET_PHY_RX_PACKET_CRC32_ERROR)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(struct eeprom_rw_param), NULL, 0)
+	GEN_MP_IOCTL_HANDLER(sizeof(EFUSE_ACCESS_STRUCT), oid_rt_pro_efuse_hdl, OID_RT_PRO_EFUSE)
+/*25*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_efuse_map_hdl, OID_RT_PRO_EFUSE_MAP)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_max_size_hdl, OID_RT_GET_EFUSE_MAX_SIZE)
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_efuse_current_size_hdl, OID_RT_GET_EFUSE_CURRENT_SIZE)
+
+	GEN_MP_IOCTL_HANDLER(sizeof(u32), oid_rt_get_thermal_meter_hdl, OID_RT_PRO_GET_THERMAL_METER)
+	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_pro_set_power_tracking_hdl, OID_RT_PRO_SET_POWER_TRACKING)
+/*30*/	GEN_MP_IOCTL_HANDLER(sizeof(u8), oid_rt_set_power_down_hdl, OID_RT_SET_POWER_DOWN)
+/*31*/	GEN_MP_IOCTL_HANDLER(0, oid_rt_pro_trigger_gpio_hdl, 0)
+
+
+};
+
+#else /* _RTW_MP_IOCTL_C_ */
+
+extern struct mp_ioctl_handler mp_ioctl_hdl[];
+
+#endif /* _RTW_MP_IOCTL_C_ */
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_mp_phy_regdef.h b/drivers/net/wireless/rtl8192du/include/rtw_mp_phy_regdef.h
new file mode 100644
index 0000000..35b361a
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_mp_phy_regdef.h
@@ -0,0 +1,1058 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *
+ * Module:	__RTW_MP_PHY_REGDEF_H_
+ *
+ *
+ * Note:	1. Define PMAC/BB register map
+ *			2. Define RF register map
+ *			3. PMAC/BB register bit mask.
+ *			4. RF reg bit mask.
+ *			5. Other BB/RF relative definition.
+ *
+ *
+ * Export:	Constants, macro, functions(API), global variables(None).
+ *
+ * Abbrev:
+ *
+ * History:
+ *	Data			Who		Remark
+ *	08/07/2007	MHC		1. Porting from 9x series PHYCFG.h.
+ *						2. Reorganize code architecture.
+ *	09/25/2008	MH		1. Add RL6052 register definition
+ *
+ *****************************************************************************/
+#ifndef __RTW_MP_PHY_REGDEF_H_
+#define __RTW_MP_PHY_REGDEF_H_
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*  */
+/*        8192S Regsiter offset definition */
+/*  */
+
+/*  */
+/*  BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00 */
+/*  3. RF register 0x00-2E */
+/*  4. Bit Mask for BB/RF register */
+/*  5. Other defintion for BB/RF R/W */
+/*  */
+
+
+/*  */
+/*  1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF */
+/*  1. Page1(0x100) */
+/*  */
+#define		rPMAC_Reset					0x100
+#define		rPMAC_TxStart					0x104
+#define		rPMAC_TxLegacySIG				0x108
+#define		rPMAC_TxHTSIG1				0x10c
+#define		rPMAC_TxHTSIG2				0x110
+#define		rPMAC_PHYDebug				0x114
+#define		rPMAC_TxPacketNum				0x118
+#define		rPMAC_TxIdle					0x11c
+#define		rPMAC_TxMACHeader0			0x120
+#define		rPMAC_TxMACHeader1			0x124
+#define		rPMAC_TxMACHeader2			0x128
+#define		rPMAC_TxMACHeader3			0x12c
+#define		rPMAC_TxMACHeader4			0x130
+#define		rPMAC_TxMACHeader5			0x134
+#define		rPMAC_TxDataType				0x138
+#define		rPMAC_TxRandomSeed			0x13c
+#define		rPMAC_CCKPLCPPreamble			0x140
+#define		rPMAC_CCKPLCPHeader			0x144
+#define		rPMAC_CCKCRC16				0x148
+#define		rPMAC_OFDMRxCRC32OK			0x170
+#define		rPMAC_OFDMRxCRC32Er			0x174
+#define		rPMAC_OFDMRxParityEr			0x178
+#define		rPMAC_OFDMRxCRC8Er			0x17c
+#define		rPMAC_CCKCRxRC16Er			0x180
+#define		rPMAC_CCKCRxRC32Er			0x184
+#define		rPMAC_CCKCRxRC32OK			0x188
+#define		rPMAC_TxStatus					0x18c
+
+/*  */
+/*  2. Page2(0x200) */
+/*  */
+
+/*  */
+/*  3. Page8(0x800) */
+/*  */
+#define		rFPGA0_RFMOD				0x800	/* RF mode & CCK TxSC  RF BW Setting?? */
+
+#define		rFPGA0_TxInfo				0x804	/*  Status report?? */
+#define		rFPGA0_PSDFunction			0x808
+
+#define		rFPGA0_TxGainStage			0x80c	/*  Set TX PWR init gain? */
+
+#define		rFPGA0_RFTiming1			0x810	/*  Useless now */
+#define		rFPGA0_RFTiming2			0x814
+
+#define		rFPGA0_XA_HSSIParameter1		0x820	/*  RF 3 wire register */
+#define		rFPGA0_XA_HSSIParameter2		0x824
+#define		rFPGA0_XB_HSSIParameter1		0x828
+#define		rFPGA0_XB_HSSIParameter2		0x82c
+#define		rFPGA0_XC_HSSIParameter1		0x830
+#define		rFPGA0_XC_HSSIParameter2		0x834
+#define		rFPGA0_XD_HSSIParameter1		0x838
+#define		rFPGA0_XD_HSSIParameter2		0x83c
+#define		rFPGA0_XA_LSSIParameter		0x840
+#define		rFPGA0_XB_LSSIParameter		0x844
+#define		rFPGA0_XC_LSSIParameter		0x848
+#define		rFPGA0_XD_LSSIParameter		0x84c
+
+#define		rFPGA0_RFWakeUpParameter		0x850	/*  Useless now */
+#define		rFPGA0_RFSleepUpParameter		0x854
+
+#define		rFPGA0_XAB_SwitchControl		0x858	/*  RF Channel switch */
+#define		rFPGA0_XCD_SwitchControl		0x85c
+
+#define		rFPGA0_XA_RFInterfaceOE		0x860	/*  RF Channel switch */
+#define		rFPGA0_XB_RFInterfaceOE		0x864
+#define		rFPGA0_XC_RFInterfaceOE		0x868
+#define		rFPGA0_XD_RFInterfaceOE		0x86c
+
+#define		rFPGA0_XAB_RFInterfaceSW		0x870	/*  RF Interface Software Control */
+#define		rFPGA0_XCD_RFInterfaceSW		0x874
+
+#define		rFPGA0_XAB_RFParameter		0x878	/*  RF Parameter */
+#define		rFPGA0_XCD_RFParameter		0x87c
+
+#define		rFPGA0_AnalogParameter1		0x880	/*  Crystal cap setting RF-R/W protection for parameter4?? */
+#define		rFPGA0_AnalogParameter2		0x884
+#define		rFPGA0_AnalogParameter3		0x888	/*  Useless now */
+#define		rFPGA0_AnalogParameter4		0x88c
+
+#define		rFPGA0_XA_LSSIReadBack		0x8a0	/*  Tranceiver LSSI Readback */
+#define		rFPGA0_XB_LSSIReadBack		0x8a4
+#define		rFPGA0_XC_LSSIReadBack		0x8a8
+#define		rFPGA0_XD_LSSIReadBack		0x8ac
+
+#define		rFPGA0_PSDReport				0x8b4	/*  Useless now */
+#define		rFPGA0_XAB_RFInterfaceRB		0x8e0	/*  Useless now  RF Interface Readback Value */
+#define		rFPGA0_XCD_RFInterfaceRB		0x8e4	/*  Useless now */
+
+/*  */
+/*  4. Page9(0x900) */
+/*  */
+#define		rFPGA1_RFMOD				0x900	/* RF mode & OFDM TxSC RF BW Setting?? */
+
+#define		rFPGA1_TxBlock				0x904	/*  Useless now */
+#define		rFPGA1_DebugSelect			0x908	/*  Useless now */
+#define		rFPGA1_TxInfo				0x90c	/*  Useless now Status report?? */
+
+/*  */
+/*  5. PageA(0xA00) */
+/*  */
+/*  Set Control channel to upper or lower. These settings are required only for 40MHz */
+#define		rCCK0_System				0xa00
+
+#define		rCCK0_AFESetting			0xa04	/*  Disable init gain now Select RX path by RSSI */
+#define		rCCK0_CCA					0xa08	/*  Disable init gain now Init gain */
+
+#define		rCCK0_RxAGC1				0xa0c	/* AGC default value, saturation level Antenna Diversity, RX AGC, LNA Threshold, RX LNA Threshold useless now. Not the same as 90 series */
+#define		rCCK0_RxAGC2				0xa10	/* AGC & DAGC */
+
+#define		rCCK0_RxHP					0xa14
+
+#define		rCCK0_DSPParameter1		0xa18	/* Timing recovery & Channel estimation threshold */
+#define		rCCK0_DSPParameter2		0xa1c	/* SQ threshold */
+
+#define		rCCK0_TxFilter1				0xa20
+#define		rCCK0_TxFilter2				0xa24
+#define		rCCK0_DebugPort			0xa28	/* debug port and Tx filter3 */
+#define		rCCK0_FalseAlarmReport		0xa2c	/* 0xa2d	useless now 0xa30-a4f channel report */
+#define		rCCK0_TRSSIReport			0xa50
+#define		rCCK0_RxReport				0xa54  /* 0xa57 */
+#define		rCCK0_FACounterLower		0xa5c  /* 0xa5b */
+#define		rCCK0_FACounterUpper		0xa58  /* 0xa5c */
+
+/*  */
+/*  6. PageC(0xC00) */
+/*  */
+#define		rOFDM0_LSTF				0xc00
+
+#define		rOFDM0_TRxPathEnable		0xc04
+#define		rOFDM0_TRMuxPar			0xc08
+#define		rOFDM0_TRSWIsolation		0xc0c
+
+#define		rOFDM0_XARxAFE			0xc10  /* RxIQ DC offset, Rx digital filter, DC notch filter */
+#define		rOFDM0_XARxIQImbalance		0xc14  /* RxIQ imblance matrix */
+#define		rOFDM0_XBRxAFE				0xc18
+#define		rOFDM0_XBRxIQImbalance		0xc1c
+#define		rOFDM0_XCRxAFE				0xc20
+#define		rOFDM0_XCRxIQImbalance		0xc24
+#define		rOFDM0_XDRxAFE				0xc28
+#define		rOFDM0_XDRxIQImbalance		0xc2c
+
+#define		rOFDM0_RxDetector1			0xc30  /* PD,BW & SBD	DM tune init gain */
+#define		rOFDM0_RxDetector2			0xc34  /* SBD & Fame Sync. */
+#define		rOFDM0_RxDetector3			0xc38  /* Frame Sync. */
+#define		rOFDM0_RxDetector4			0xc3c  /* PD, SBD, Frame Sync & Short-GI */
+
+#define		rOFDM0_RxDSP				0xc40  /* Rx Sync Path */
+#define		rOFDM0_CFOandDAGC		0xc44  /* CFO & DAGC */
+#define		rOFDM0_CCADropThreshold	0xc48 /* CCA Drop threshold */
+#define		rOFDM0_ECCAThreshold		0xc4c /*  energy CCA */
+
+#define		rOFDM0_XAAGCCore1			0xc50	/*  DIG */
+#define		rOFDM0_XAAGCCore2			0xc54
+#define		rOFDM0_XBAGCCore1			0xc58
+#define		rOFDM0_XBAGCCore2			0xc5c
+#define		rOFDM0_XCAGCCore1			0xc60
+#define		rOFDM0_XCAGCCore2			0xc64
+#define		rOFDM0_XDAGCCore1			0xc68
+#define		rOFDM0_XDAGCCore2			0xc6c
+
+#define		rOFDM0_AGCParameter1			0xc70
+#define		rOFDM0_AGCParameter2			0xc74
+#define		rOFDM0_AGCRSSITable			0xc78
+#define		rOFDM0_HTSTFAGC				0xc7c
+
+#define		rOFDM0_XATxIQImbalance		0xc80	/*  TX PWR TRACK and DIG */
+#define		rOFDM0_XATxAFE				0xc84
+#define		rOFDM0_XBTxIQImbalance		0xc88
+#define		rOFDM0_XBTxAFE				0xc8c
+#define		rOFDM0_XCTxIQImbalance		0xc90
+#define		rOFDM0_XCTxAFE					0xc94
+#define		rOFDM0_XDTxIQImbalance		0xc98
+#define		rOFDM0_XDTxAFE				0xc9c
+#define		rOFDM0_RxIQExtAnta			0xca0
+
+#define		rOFDM0_RxHPParameter			0xce0
+#define		rOFDM0_TxPseudoNoiseWgt		0xce4
+#define		rOFDM0_FrameSync				0xcf0
+#define		rOFDM0_DFSReport				0xcf4
+#define		rOFDM0_TxCoeff1				0xca4
+#define		rOFDM0_TxCoeff2				0xca8
+#define		rOFDM0_TxCoeff3				0xcac
+#define		rOFDM0_TxCoeff4				0xcb0
+#define		rOFDM0_TxCoeff5				0xcb4
+#define		rOFDM0_TxCoeff6				0xcb8
+
+
+/*  */
+/*  7. PageD(0xD00) */
+/*  */
+#define		rOFDM1_LSTF					0xd00
+#define		rOFDM1_TRxPathEnable			0xd04
+
+#define		rOFDM1_CFO						0xd08	/*  No setting now */
+#define		rOFDM1_CSI1					0xd10
+#define		rOFDM1_SBD						0xd14
+#define		rOFDM1_CSI2					0xd18
+#define		rOFDM1_CFOTracking			0xd2c
+#define		rOFDM1_TRxMesaure1			0xd34
+#define		rOFDM1_IntfDet					0xd3c
+#define		rOFDM1_PseudoNoiseStateAB		0xd50
+#define		rOFDM1_PseudoNoiseStateCD		0xd54
+#define		rOFDM1_RxPseudoNoiseWgt		0xd58
+
+#define		rOFDM_PHYCounter1				0xda0  /* cca, parity fail */
+#define		rOFDM_PHYCounter2				0xda4  /* rate illegal, crc8 fail */
+#define		rOFDM_PHYCounter3				0xda8  /* MCS not support */
+
+#define		rOFDM_ShortCFOAB				0xdac	/*  No setting now */
+#define		rOFDM_ShortCFOCD				0xdb0
+#define		rOFDM_LongCFOAB				0xdb4
+#define		rOFDM_LongCFOCD				0xdb8
+#define		rOFDM_TailCFOAB				0xdbc
+#define		rOFDM_TailCFOCD				0xdc0
+#define		rOFDM_PWMeasure1			0xdc4
+#define		rOFDM_PWMeasure2			0xdc8
+#define		rOFDM_BWReport				0xdcc
+#define		rOFDM_AGCReport				0xdd0
+#define		rOFDM_RxSNR					0xdd4
+#define		rOFDM_RxEVMCSI				0xdd8
+#define		rOFDM_SIGReport				0xddc
+
+
+/*  */
+/*  8. PageE(0xE00) */
+/*  */
+#define		rTxAGC_Rate18_06				0xe00
+#define		rTxAGC_Rate54_24				0xe04
+#define		rTxAGC_CCK_Mcs32				0xe08
+#define		rTxAGC_Mcs03_Mcs00			0xe10
+#define		rTxAGC_Mcs07_Mcs04			0xe14
+#define		rTxAGC_Mcs11_Mcs08			0xe18
+#define		rTxAGC_Mcs15_Mcs12			0xe1c
+
+/*  Analog- control in RX_WAIT_CCA : REG: EE0 [Analog- Power & Control Register] */
+#define			rRx_Wait_CCCA					0xe70
+#define		rAnapar_Ctrl_BB					0xee0
+
+/*  */
+/*  7. RF Register 0x00-0x2E (RF 8256) */
+/*     RF-0222D 0x00-3F */
+/*  */
+/* Zebra1 */
+#define RTL92SE_FPGA_VERIFY 0
+#define		rZebra1_HSSIEnable				0x0	/*  Useless now */
+#define		rZebra1_TRxEnable1				0x1
+#define		rZebra1_TRxEnable2				0x2
+#define		rZebra1_AGC					0x4
+#define		rZebra1_ChargePump			0x5
+#define		rZebra1_Channel				0x7	/*  RF channel switch */
+
+#define		rZebra1_TxGain					0x8	/*  Useless now */
+#define		rZebra1_TxLPF					0x9
+#define		rZebra1_RxLPF					0xb
+#define		rZebra1_RxHPFCorner			0xc
+
+/* Zebra4 */
+#define		rGlobalCtrl						0	/*  Useless now */
+#define		rRTL8256_TxLPF					19
+#define		rRTL8256_RxLPF					11
+
+/* RTL8258 */
+#define		rRTL8258_TxLPF					0x11	/*  Useless now */
+#define		rRTL8258_RxLPF					0x13
+#define		rRTL8258_RSSILPF				0xa
+
+/*  */
+/*  RL6052 Register definition */
+/*  */
+#define		RF_AC						0x00	/*  */
+
+#define		RF_IQADJ_G1				0x01	/*  */
+#define		RF_IQADJ_G2				0x02	/*  */
+#define		RF_POW_TRSW				0x05	/*  */
+
+#define		RF_GAIN_RX					0x06	/*  */
+#define		RF_GAIN_TX					0x07	/*  */
+
+#define		RF_TXM_IDAC				0x08	/*  */
+#define		RF_BS_IQGEN				0x0F	/*  */
+
+#define		RF_MODE1					0x10	/*  */
+#define		RF_MODE2					0x11	/*  */
+
+#define		RF_RX_AGC_HP				0x12	/*  */
+#define		RF_TX_AGC					0x13	/*  */
+#define		RF_BIAS						0x14	/*  */
+#define		RF_IPA						0x15	/*  */
+#define		RF_POW_ABILITY			0x17	/*  */
+#define		RF_MODE_AG				0x18	/*  */
+#define		rRfChannel					0x18	/*  RF channel and BW switch */
+#define		RF_CHNLBW					0x18	/*  RF channel and BW switch */
+#define		RF_TOP						0x19	/*  */
+
+#define		RF_RX_G1					0x1A	/*  */
+#define		RF_RX_G2					0x1B	/*  */
+
+#define		RF_RX_BB2					0x1C	/*  */
+#define		RF_RX_BB1					0x1D	/*  */
+
+#define		RF_RCK1					0x1E	/*  */
+#define		RF_RCK2					0x1F	/*  */
+
+#define		RF_TX_G1					0x20	/*  */
+#define		RF_TX_G2					0x21	/*  */
+#define		RF_TX_G3					0x22	/*  */
+
+#define		RF_TX_BB1					0x23	/*  */
+
+#define		RF_T_METER					0x24	/*  */
+
+#define		RF_SYN_G1					0x25	/*  RF TX Power control */
+#define		RF_SYN_G2					0x26	/*  RF TX Power control */
+#define		RF_SYN_G3					0x27	/*  RF TX Power control */
+#define		RF_SYN_G4					0x28	/*  RF TX Power control */
+#define		RF_SYN_G5					0x29	/*  RF TX Power control */
+#define		RF_SYN_G6					0x2A	/*  RF TX Power control */
+#define		RF_SYN_G7					0x2B	/*  RF TX Power control */
+#define		RF_SYN_G8					0x2C	/*  RF TX Power control */
+
+#define		RF_RCK_OS					0x30	/*  RF TX PA control */
+
+#define		RF_TXPA_G1					0x31	/*  RF TX PA control */
+#define		RF_TXPA_G2					0x32	/*  RF TX PA control */
+#define		RF_TXPA_G3					0x33	/*  RF TX PA control */
+
+/*  */
+/* Bit Mask */
+/*  */
+/*  1. Page1(0x100) */
+#define		bBBResetB						0x100	/*  Useless now? */
+#define		bGlobalResetB					0x200
+#define		bOFDMTxStart					0x4
+#define		bCCKTxStart						0x8
+#define		bCRC32Debug					0x100
+#define		bPMACLoopback					0x10
+#define		bTxLSIG							0xffffff
+#define		bOFDMTxRate					0xf
+#define		bOFDMTxReserved				0x10
+#define		bOFDMTxLength					0x1ffe0
+#define		bOFDMTxParity					0x20000
+#define		bTxHTSIG1						0xffffff
+#define		bTxHTMCSRate					0x7f
+#define		bTxHTBW						0x80
+#define		bTxHTLength					0xffff00
+#define		bTxHTSIG2						0xffffff
+#define		bTxHTSmoothing					0x1
+#define		bTxHTSounding					0x2
+#define		bTxHTReserved					0x4
+#define		bTxHTAggreation				0x8
+#define		bTxHTSTBC						0x30
+#define		bTxHTAdvanceCoding			0x40
+#define		bTxHTShortGI					0x80
+#define		bTxHTNumberHT_LTF			0x300
+#define		bTxHTCRC8						0x3fc00
+#define		bCounterReset					0x10000
+#define		bNumOfOFDMTx					0xffff
+#define		bNumOfCCKTx					0xffff0000
+#define		bTxIdleInterval					0xffff
+#define		bOFDMService					0xffff0000
+#define		bTxMACHeader					0xffffffff
+#define		bTxDataInit						0xff
+#define		bTxHTMode						0x100
+#define		bTxDataType					0x30000
+#define		bTxRandomSeed					0xffffffff
+#define		bCCKTxPreamble					0x1
+#define		bCCKTxSFD						0xffff0000
+#define		bCCKTxSIG						0xff
+#define		bCCKTxService					0xff00
+#define		bCCKLengthExt					0x8000
+#define		bCCKTxLength					0xffff0000
+#define		bCCKTxCRC16					0xffff
+#define		bCCKTxStatus					0x1
+#define		bOFDMTxStatus					0x2
+
+#define			IS_BB_REG_OFFSET_92S(_Offset)		((_Offset >= 0x800) && (_Offset <= 0xfff))
+
+/*  2. Page8(0x800) */
+#define		bRFMOD							0x1	/*  Reg 0x800 rFPGA0_RFMOD */
+#define		bJapanMode						0x2
+#define		bCCKTxSC						0x30
+#define		bCCKEn							0x1000000
+#define		bOFDMEn						0x2000000
+
+#define		bOFDMRxADCPhase				0x10000	/*  Useless now */
+#define		bOFDMTxDACPhase				0x40000
+#define		bXATxAGC					0x3f
+
+#define		bXBTxAGC					0xf00	/*  Reg 80c rFPGA0_TxGainStage */
+#define		bXCTxAGC					0xf000
+#define		bXDTxAGC					0xf0000
+
+#define		bPAStart					0xf0000000	/*  Useless now */
+#define		bTRStart					0x00f00000
+#define		bRFStart					0x0000f000
+#define		bBBStart					0x000000f0
+#define		bBBCCKStart				0x0000000f
+#define		bPAEnd						0xf          /* Reg0x814 */
+#define		bTREnd						0x0f000000
+#define		bRFEnd						0x000f0000
+#define		bCCAMask					0x000000f0   /* T2R */
+#define		bR2RCCAMask				0x00000f00
+#define		bHSSI_R2TDelay				0xf8000000
+#define		bHSSI_T2RDelay				0xf80000
+#define		bContTxHSSI				0x400     /* chane gain at continue Tx */
+#define		bIGFromCCK				0x200
+#define		bAGCAddress				0x3f
+#define		bRxHPTx						0x7000
+#define		bRxHPT2R					0x38000
+#define		bRxHPCCKIni				0xc0000
+#define		bAGCTxCode				0xc00000
+#define		bAGCRxCode				0x300000
+
+#define		b3WireDataLength			0x800	/*  Reg 0x820~84f rFPGA0_XA_HSSIParameter1 */
+#define		b3WireAddressLength			0x400
+
+#define		b3WireRFPowerDown			0x1	/*  Useless now */
+/* define bHWSISelect				0x8 */
+#define		b5GPAPEPolarity				0x40000000
+#define		b2GPAPEPolarity				0x80000000
+#define		bRFSW_TxDefaultAnt			0x3
+#define		bRFSW_TxOptionAnt			0x30
+#define		bRFSW_RxDefaultAnt			0x300
+#define		bRFSW_RxOptionAnt			0x3000
+#define		bRFSI_3WireData				0x1
+#define		bRFSI_3WireClock			0x2
+#define		bRFSI_3WireLoad				0x4
+#define		bRFSI_3WireRW				0x8
+#define		bRFSI_3Wire					0xf
+
+#define		bRFSI_RFENV				0x10	/*  Reg 0x870 rFPGA0_XAB_RFInterfaceSW */
+
+#define		bRFSI_TRSW				0x20	/*  Useless now */
+#define		bRFSI_TRSWB				0x40
+#define		bRFSI_ANTSW				0x100
+#define		bRFSI_ANTSWB				0x200
+#define		bRFSI_PAPE					0x400
+#define		bRFSI_PAPE5G				0x800
+#define		bBandSelect					0x1
+#define		bHTSIG2_GI					0x80
+#define		bHTSIG2_Smoothing			0x01
+#define		bHTSIG2_Sounding			0x02
+#define		bHTSIG2_Aggreaton			0x08
+#define		bHTSIG2_STBC				0x30
+#define		bHTSIG2_AdvCoding			0x40
+#define		bHTSIG2_NumOfHTLTF		0x300
+#define		bHTSIG2_CRC8				0x3fc
+#define		bHTSIG1_MCS				0x7f
+#define		bHTSIG1_BandWidth			0x80
+#define		bHTSIG1_HTLength			0xffff
+#define		bLSIG_Rate					0xf
+#define		bLSIG_Reserved				0x10
+#define		bLSIG_Length				0x1fffe
+#define		bLSIG_Parity					0x20
+#define		bCCKRxPhase				0x4
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadAddress			0x3f000000   /* LSSI "Read" Address  Reg 0x824 rFPGA0_XA_HSSIParameter2 */
+#else
+#define		bLSSIReadAddress			0x7f800000   /*  T65 RF */
+#endif
+#define		bLSSIReadEdge				0x80000000   /* LSSI "Read" edge signal */
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define		bLSSIReadBackData			0xfff		/*  Reg 0x8a0 rFPGA0_XA_LSSIReadBack */
+#else
+#define		bLSSIReadBackData			0xfffff		/*  T65 RF */
+#endif
+#define		bLSSIReadOKFlag				0x1000	/*  Useless now */
+#define		bCCKSampleRate				0x8       /* 0: 44MHz, 1:88MHz */
+#define		bRegulator0Standby			0x1
+#define		bRegulatorPLLStandby			0x2
+#define		bRegulator1Standby			0x4
+#define		bPLLPowerUp				0x8
+#define		bDPLLPowerUp				0x10
+#define		bDA10PowerUp				0x20
+#define		bAD7PowerUp				0x200
+#define		bDA6PowerUp				0x2000
+#define		bXtalPowerUp				0x4000
+#define		b40MDClkPowerUP				0x8000
+#define		bDA6DebugMode				0x20000
+#define		bDA6Swing					0x380000
+
+#define		bADClkPhase				0x4000000	/*  Reg 0x880 rFPGA0_AnalogParameter1 20/40 CCK support switch 40/80 BB MHZ */
+
+#define		b80MClkDelay				0x18000000	/*  Useless */
+#define		bAFEWatchDogEnable			0x20000000
+
+#define		bXtalCap01					0xc0000000	/*  Reg 0x884 rFPGA0_AnalogParameter2 Crystal cap */
+#define		bXtalCap23					0x3
+#define		bXtalCap92x					0x0f000000
+#define			bXtalCap					0x0f000000
+
+#define		bIntDifClkEnable			0x400	/*  Useless */
+#define		bExtSigClkEnable			0x800
+#define		bBandgapMbiasPowerUp		0x10000
+#define		bAD11SHGain				0xc0000
+#define		bAD11InputRange				0x700000
+#define		bAD11OPCurrent				0x3800000
+#define		bIPathLoopback				0x4000000
+#define		bQPathLoopback				0x8000000
+#define		bAFELoopback				0x10000000
+#define		bDA10Swing				0x7e0
+#define		bDA10Reverse				0x800
+#define		bDAClkSource				0x1000
+#define		bAD7InputRange				0x6000
+#define		bAD7Gain					0x38000
+#define		bAD7OutputCMMode			0x40000
+#define		bAD7InputCMMode				0x380000
+#define		bAD7Current					0xc00000
+#define		bRegulatorAdjust			0x7000000
+#define		bAD11PowerUpAtTx			0x1
+#define		bDA10PSAtTx				0x10
+#define		bAD11PowerUpAtRx			0x100
+#define		bDA10PSAtRx				0x1000
+#define		bCCKRxAGCFormat				0x200
+#define		bPSDFFTSamplepPoint			0xc000
+#define		bPSDAverageNum				0x3000
+#define		bIQPathControl				0xc00
+#define		bPSDFreq					0x3ff
+#define		bPSDAntennaPath				0x30
+#define		bPSDIQSwitch				0x40
+#define		bPSDRxTrigger				0x400000
+#define		bPSDTxTrigger				0x80000000
+#define		bPSDSineToneScale			0x7f000000
+#define		bPSDReport					0xffff
+
+/*  3. Page9(0x900) */
+#define		bOFDMTxSC				0x30000000	/*  Useless */
+#define		bCCKTxOn					0x1
+#define		bOFDMTxOn				0x2
+#define		bDebugPage				0xfff  /* reset debug page and also HWord, LWord */
+#define		bDebugItem				0xff   /* reset debug page and LWord */
+#define		bAntL					0x10
+#define		bAntNonHT					0x100
+#define		bAntHT1					0x1000
+#define		bAntHT2						0x10000
+#define		bAntHT1S1					0x100000
+#define		bAntNonHTS1				0x1000000
+
+/*  4. PageA(0xA00) */
+#define		bCCKBBMode				0x3	/*  Useless */
+#define		bCCKTxPowerSaving			0x80
+#define		bCCKRxPowerSaving			0x40
+
+#define		bCCKSideBand				0x10	/*  Reg 0xa00 rCCK0_System 20/40 switch */
+
+#define		bCCKScramble				0x8	/*  Useless */
+#define		bCCKAntDiversity			0x8000
+#define		bCCKCarrierRecovery		0x4000
+#define		bCCKTxRate				0x3000
+#define		bCCKDCCancel				0x0800
+#define		bCCKISICancel				0x0400
+#define		bCCKMatchFilter				0x0200
+#define		bCCKEqualizer				0x0100
+#define		bCCKPreambleDetect			0x800000
+#define		bCCKFastFalseCCA			0x400000
+#define		bCCKChEstStart				0x300000
+#define		bCCKCCACount				0x080000
+#define		bCCKcs_lim					0x070000
+#define		bCCKBistMode				0x80000000
+#define		bCCKCCAMask				0x40000000
+#define		bCCKTxDACPhase			0x4
+#define		bCCKRxADCPhase			0x20000000   /* r_rx_clk */
+#define		bCCKr_cp_mode0			0x0100
+#define		bCCKTxDCOffset				0xf0
+#define		bCCKRxDCOffset				0xf
+#define		bCCKCCAMode				0xc000
+#define		bCCKFalseCS_lim				0x3f00
+#define		bCCKCS_ratio				0xc00000
+#define		bCCKCorgBit_sel				0x300000
+#define		bCCKPD_lim					0x0f0000
+#define		bCCKNewCCA				0x80000000
+#define		bCCKRxHPofIG				0x8000
+#define		bCCKRxIG					0x7f00
+#define		bCCKLNAPolarity				0x800000
+#define		bCCKRx1stGain				0x7f0000
+#define		bCCKRFExtend				0x20000000 /* CCK Rx Iinital gain polarity */
+#define		bCCKRxAGCSatLevel			0x1f000000
+#define		bCCKRxAGCSatCount			0xe0
+#define		bCCKRxRFSettle				0x1f       /* AGCsamp_dly */
+#define		bCCKFixedRxAGC				0x8000
+#define		bCCKAntennaPolarity			0x2000
+#define		bCCKTxFilterType			0x0c00
+#define		bCCKRxAGCReportType		0x0300
+#define		bCCKRxDAGCEn				0x80000000
+#define		bCCKRxDAGCPeriod			0x20000000
+#define		bCCKRxDAGCSatLevel		0x1f000000
+#define		bCCKTimingRecovery			0x800000
+#define		bCCKTxC0					0x3f0000
+#define		bCCKTxC1					0x3f000000
+#define		bCCKTxC2					0x3f
+#define		bCCKTxC3					0x3f00
+#define		bCCKTxC4					0x3f0000
+#define		bCCKTxC5					0x3f000000
+#define		bCCKTxC6					0x3f
+#define		bCCKTxC7					0x3f00
+#define		bCCKDebugPort				0xff0000
+#define		bCCKDACDebug				0x0f000000
+#define		bCCKFalseAlarmEnable			0x8000
+#define		bCCKFalseAlarmRead			0x4000
+#define		bCCKTRSSI					0x7f
+#define		bCCKRxAGCReport				0xfe
+#define		bCCKRxReport_AntSel			0x80000000
+#define		bCCKRxReport_MFOff			0x40000000
+#define		bCCKRxRxReport_SQLoss		0x20000000
+#define		bCCKRxReport_Pktloss			0x10000000
+#define		bCCKRxReport_Lockedbit		0x08000000
+#define		bCCKRxReport_RateError		0x04000000
+#define		bCCKRxReport_RxRate			0x03000000
+#define		bCCKRxFACounterLower		0xff
+#define		bCCKRxFACounterUpper		0xff000000
+#define		bCCKRxHPAGCStart			0xe000
+#define		bCCKRxHPAGCFinal			0x1c00
+#define		bCCKRxFalseAlarmEnable		0x8000
+#define		bCCKFACounterFreeze			0x4000
+#define		bCCKTxPathSel				0x10000000
+#define		bCCKDefaultRxPath			0xc000000
+#define		bCCKOptionRxPath			0x3000000
+
+/*  5. PageC(0xC00) */
+#define		bNumOfSTF					0x3	/*  Useless */
+#define		bShift_L					0xc0
+#define		bGI_TH						0xc
+#define		bRxPathA					0x1
+#define		bRxPathB					0x2
+#define		bRxPathC					0x4
+#define		bRxPathD					0x8
+#define		bTxPathA					0x1
+#define		bTxPathB					0x2
+#define		bTxPathC					0x4
+#define		bTxPathD					0x8
+#define		bTRSSIFreq					0x200
+#define		bADCBackoff					0x3000
+#define		bDFIRBackoff					0xc000
+#define		bTRSSILatchPhase			0x10000
+#define		bRxIDCOffset					0xff
+#define		bRxQDCOffset					0xff00
+#define		bRxDFIRMode				0x1800000
+#define		bRxDCNFType				0xe000000
+#define		bRXIQImb_A					0x3ff
+#define		bRXIQImb_B					0xfc00
+#define		bRXIQImb_C					0x3f0000
+#define		bRXIQImb_D					0xffc00000
+#define		bDC_dc_Notch				0x60000
+#define		bRxNBINotch					0x1f000000
+#define		bPD_TH						0xf
+#define		bPD_TH_Opt2				0xc000
+#define		bPWED_TH					0x700
+#define		bIfMF_Win_L					0x800
+#define		bPD_Option					0x1000
+#define		bMF_Win_L					0xe000
+#define		bBW_Search_L				0x30000
+#define		bwin_enh_L					0xc0000
+#define		bBW_TH						0x700000
+#define		bED_TH2						0x3800000
+#define		bBW_option					0x4000000
+#define		bRatio_TH					0x18000000
+#define		bWindow_L					0xe0000000
+#define		bSBD_Option					0x1
+#define		bFrame_TH					0x1c
+#define		bFS_Option					0x60
+#define		bDC_Slope_check				0x80
+#define		bFGuard_Counter_DC_L			0xe00
+#define		bFrame_Weight_Short			0x7000
+#define		bSub_Tune					0xe00000
+#define		bFrame_DC_Length			0xe000000
+#define		bSBD_start_offset			0x30000000
+#define		bFrame_TH_2				0x7
+#define		bFrame_GI2_TH				0x38
+#define		bGI2_Sync_en				0x40
+#define		bSarch_Short_Early			0x300
+#define		bSarch_Short_Late			0xc00
+#define		bSarch_GI2_Late				0x70000
+#define		bCFOAntSum				0x1
+#define		bCFOAcc						0x2
+#define		bCFOStartOffset				0xc
+#define		bCFOLookBack				0x70
+#define		bCFOSumWeight				0x80
+#define		bDAGCEnable					0x10000
+#define		bTXIQImb_A					0x3ff
+#define		bTXIQImb_B					0xfc00
+#define		bTXIQImb_C					0x3f0000
+#define		bTXIQImb_D					0xffc00000
+#define		bTxIDCOffset					0xff
+#define		bTxQDCOffset					0xff00
+#define		bTxDFIRMode				0x10000
+#define		bTxPesudoNoiseOn			0x4000000
+#define		bTxPesudoNoise_A			0xff
+#define		bTxPesudoNoise_B			0xff00
+#define		bTxPesudoNoise_C			0xff0000
+#define		bTxPesudoNoise_D			0xff000000
+#define		bCCADropOption				0x20000
+#define		bCCADropThres				0xfff00000
+#define		bEDCCA_H					0xf
+#define		bEDCCA_L					0xf0
+#define		bLambda_ED               0x300
+#define		bRxInitialGain           0x7f
+#define		bRxAntDivEn              0x80
+#define		bRxAGCAddressForLNA      0x7f00
+#define		bRxHighPowerFlow         0x8000
+#define		bRxAGCFreezeThres        0xc0000
+#define		bRxFreezeStep_AGC1       0x300000
+#define		bRxFreezeStep_AGC2       0xc00000
+#define		bRxFreezeStep_AGC3       0x3000000
+#define		bRxFreezeStep_AGC0       0xc000000
+#define		bRxRssi_Cmp_En           0x10000000
+#define		bRxQuickAGCEn            0x20000000
+#define		bRxAGCFreezeThresMode    0x40000000
+#define		bRxOverFlowCheckType     0x80000000
+#define		bRxAGCShift              0x7f
+#define		bTRSW_Tri_Only           0x80
+#define		bPowerThres              0x300
+#define		bRxAGCEn                 0x1
+#define		bRxAGCTogetherEn         0x2
+#define		bRxAGCMin                0x4
+#define		bRxHP_Ini                0x7
+#define		bRxHP_TRLNA              0x70
+#define		bRxHP_RSSI               0x700
+#define		bRxHP_BBP1               0x7000
+#define		bRxHP_BBP2               0x70000
+#define		bRxHP_BBP3               0x700000
+#define		bRSSI_H                  0x7f0000     /* the threshold for high power */
+#define		bRSSI_Gen                0x7f000000   /* the threshold for ant diversity */
+#define		bRxSettle_TRSW           0x7
+#define		bRxSettle_LNA            0x38
+#define		bRxSettle_RSSI           0x1c0
+#define		bRxSettle_BBP            0xe00
+#define		bRxSettle_RxHP           0x7000
+#define		bRxSettle_AntSW_RSSI     0x38000
+#define		bRxSettle_AntSW          0xc0000
+#define		bRxProcessTime_DAGC      0x300000
+#define		bRxSettle_HSSI           0x400000
+#define		bRxProcessTime_BBPPW     0x800000
+#define		bRxAntennaPowerShift     0x3000000
+#define		bRSSITableSelect         0xc000000
+#define		bRxHP_Final              0x7000000
+#define		bRxHTSettle_BBP          0x7
+#define		bRxHTSettle_HSSI         0x8
+#define		bRxHTSettle_RxHP         0x70
+#define		bRxHTSettle_BBPPW        0x80
+#define		bRxHTSettle_Idle         0x300
+#define		bRxHTSettle_Reserved     0x1c00
+#define		bRxHTRxHPEn              0x8000
+#define		bRxHTAGCFreezeThres      0x30000
+#define		bRxHTAGCTogetherEn       0x40000
+#define		bRxHTAGCMin              0x80000
+#define		bRxHTAGCEn               0x100000
+#define		bRxHTDAGCEn              0x200000
+#define		bRxHTRxHP_BBP            0x1c00000
+#define		bRxHTRxHP_Final          0xe0000000
+#define		bRxPWRatioTH             0x3
+#define		bRxPWRatioEn             0x4
+#define		bRxMFHold                0x3800
+#define		bRxPD_Delay_TH1          0x38
+#define		bRxPD_Delay_TH2          0x1c0
+#define		bRxPD_DC_COUNT_MAX       0x600
+/* define bRxMF_Hold               0x3800 */
+#define		bRxPD_Delay_TH           0x8000
+#define		bRxProcess_Delay         0xf0000
+#define		bRxSearchrange_GI2_Early 0x700000
+#define		bRxFrame_Guard_Counter_L 0x3800000
+#define		bRxSGI_Guard_L           0xc000000
+#define		bRxSGI_Search_L          0x30000000
+#define		bRxSGI_TH                0xc0000000
+#define		bDFSCnt0                 0xff
+#define		bDFSCnt1                 0xff00
+#define		bDFSFlag                 0xf0000
+#define		bMFWeightSum             0x300000
+#define		bMinIdxTH                0x7f000000
+#define		bDAFormat                0x40000
+#define		bTxChEmuEnable           0x01000000
+#define		bTRSWIsolation_A         0x7f
+#define		bTRSWIsolation_B         0x7f00
+#define		bTRSWIsolation_C         0x7f0000
+#define		bTRSWIsolation_D         0x7f000000
+#define		bExtLNAGain              0x7c00
+
+/*  6. PageE(0xE00) */
+#define		bSTBCEn                  0x4	/*  Useless */
+#define		bAntennaMapping          0x10
+#define		bNss                     0x20
+#define		bCFOAntSumD              0x200
+#define		bPHYCounterReset         0x8000000
+#define		bCFOReportGet            0x4000000
+#define		bOFDMContinueTx          0x10000000
+#define		bOFDMSingleCarrier       0x20000000
+#define		bOFDMSingleTone          0x40000000
+#define		bHTDetect                0x100
+#define		bCFOEn                   0x10000
+#define		bCFOValue                0xfff00000
+#define		bSigTone_Re              0x3f
+#define		bSigTone_Im              0x7f00
+#define		bCounter_CCA             0xffff
+#define		bCounter_ParityFail      0xffff0000
+#define		bCounter_RateIllegal     0xffff
+#define		bCounter_CRC8Fail        0xffff0000
+#define		bCounter_MCSNoSupport    0xffff
+#define		bCounter_FastSync        0xffff
+#define		bShortCFO                0xfff
+#define		bShortCFOTLength         12   /* total */
+#define		bShortCFOFLength         11   /* fraction */
+#define		bLongCFO                 0x7ff
+#define		bLongCFOTLength          11
+#define		bLongCFOFLength          11
+#define		bTailCFO                 0x1fff
+#define		bTailCFOTLength          13
+#define		bTailCFOFLength          12
+#define		bmax_en_pwdB             0xffff
+#define		bCC_power_dB             0xffff0000
+#define		bnoise_pwdB              0xffff
+#define		bPowerMeasTLength        10
+#define		bPowerMeasFLength        3
+#define		bRx_HT_BW                0x1
+#define		bRxSC                    0x6
+#define		bRx_HT                   0x8
+#define		bNB_intf_det_on          0x1
+#define		bIntf_win_len_cfg        0x30
+#define		bNB_Intf_TH_cfg          0x1c0
+#define		bRFGain                  0x3f
+#define		bTableSel                0x40
+#define		bTRSW                    0x80
+#define		bRxSNR_A                 0xff
+#define		bRxSNR_B                 0xff00
+#define		bRxSNR_C                 0xff0000
+#define		bRxSNR_D                 0xff000000
+#define		bSNREVMTLength           8
+#define		bSNREVMFLength           1
+#define		bCSI1st                  0xff
+#define		bCSI2nd                  0xff00
+#define		bRxEVM1st                0xff0000
+#define		bRxEVM2nd                0xff000000
+#define		bSIGEVM                  0xff
+#define		bPWDB                    0xff00
+#define		bSGIEN                   0x10000
+
+#define		bSFactorQAM1             0xf	/*  Useless */
+#define		bSFactorQAM2             0xf0
+#define		bSFactorQAM3             0xf00
+#define		bSFactorQAM4             0xf000
+#define		bSFactorQAM5             0xf0000
+#define		bSFactorQAM6             0xf0000
+#define		bSFactorQAM7             0xf00000
+#define		bSFactorQAM8             0xf000000
+#define		bSFactorQAM9             0xf0000000
+#define		bCSIScheme               0x100000
+
+#define		bNoiseLvlTopSet          0x3	/*  Useless */
+#define		bChSmooth                0x4
+#define		bChSmoothCfg1            0x38
+#define		bChSmoothCfg2            0x1c0
+#define		bChSmoothCfg3            0xe00
+#define		bChSmoothCfg4            0x7000
+#define		bMRCMode                 0x800000
+#define		bTHEVMCfg                0x7000000
+
+#define		bLoopFitType             0x1	/*  Useless */
+#define		bUpdCFO                  0x40
+#define		bUpdCFOOffData           0x80
+#define		bAdvUpdCFO               0x100
+#define		bAdvTimeCtrl             0x800
+#define		bUpdClko                 0x1000
+#define		bFC                      0x6000
+#define		bTrackingMode            0x8000
+#define		bPhCmpEnable             0x10000
+#define		bUpdClkoLTF              0x20000
+#define		bComChCFO                0x40000
+#define		bCSIEstiMode             0x80000
+#define		bAdvUpdEqz               0x100000
+#define		bUChCfg                  0x7000000
+#define		bUpdEqz                  0x8000000
+
+#define		bTxAGCRate18_06			0x7f7f7f7f	/*  Useless */
+#define		bTxAGCRate54_24			0x7f7f7f7f
+#define		bTxAGCRateMCS32			0x7f
+#define		bTxAGCRateCCK			0x7f00
+#define		bTxAGCRateMCS3_MCS0		0x7f7f7f7f
+#define		bTxAGCRateMCS7_MCS4		0x7f7f7f7f
+#define		bTxAGCRateMCS11_MCS8	0x7f7f7f7f
+#define		bTxAGCRateMCS15_MCS12	0x7f7f7f7f
+
+/* Rx Pseduo noise */
+#define		bRxPesudoNoiseOn         0x20000000	/*  Useless */
+#define		bRxPesudoNoise_A         0xff
+#define		bRxPesudoNoise_B         0xff00
+#define		bRxPesudoNoise_C         0xff0000
+#define		bRxPesudoNoise_D         0xff000000
+#define		bPesudoNoiseState_A      0xffff
+#define		bPesudoNoiseState_B      0xffff0000
+#define		bPesudoNoiseState_C      0xffff
+#define		bPesudoNoiseState_D      0xffff0000
+
+/* 7. RF Register */
+/* Zebra1 */
+#define		bZebra1_HSSIEnable        0x8		/*  Useless */
+#define		bZebra1_TRxControl        0xc00
+#define		bZebra1_TRxGainSetting    0x07f
+#define		bZebra1_RxCorner          0xc00
+#define		bZebra1_TxChargePump      0x38
+#define		bZebra1_RxChargePump      0x7
+#define		bZebra1_ChannelNum        0xf80
+#define		bZebra1_TxLPFBW           0x400
+#define		bZebra1_RxLPFBW           0x600
+
+/* Zebra4 */
+#define		bRTL8256RegModeCtrl1      0x100	/*  Useless */
+#define		bRTL8256RegModeCtrl0      0x40
+#define		bRTL8256_TxLPFBW          0x18
+#define		bRTL8256_RxLPFBW          0x600
+
+/* RTL8258 */
+#define		bRTL8258_TxLPFBW          0xc	/*  Useless */
+#define		bRTL8258_RxLPFBW          0xc00
+#define		bRTL8258_RSSILPFBW        0xc0
+
+
+/*  */
+/*  Other Definition */
+/*  */
+
+/* byte endable for sb_write */
+#define		bByte0                    0x1	/*  Useless */
+#define		bByte1                    0x2
+#define		bByte2                    0x4
+#define		bByte3                    0x8
+#define		bWord0                    0x3
+#define		bWord1                    0xc
+#define		bDWord                    0xf
+
+/* for PutRegsetting & GetRegSetting BitMask */
+#define		bMaskByte0		0xff	/*  Reg 0xc50 rOFDM0_XAAGCCore~0xC6f */
+#define		bMaskByte1		0xff00
+#define		maskbyte2		0xff0000
+#define		bMaskByte3		0xff000000
+#define		bMaskHWord		0xffff0000
+#define		bMaskLWord		0x0000ffff
+#define		bMaskDWord		0xffffffff
+#define		bMaskH4Bits		0xf0000000
+#define		bMaskOFDM_D		0xffc00000
+#define		bMaskCCK		0x3f3f3f3f
+#define		bMask12Bits		0xfff
+
+/* for PutRFRegsetting & GetRFRegSetting BitMask */
+#if (RTL92SE_FPGA_VERIFY == 1)
+#define			bRFRegOffsetMask	0xfff
+#else
+#define			bRFRegOffsetMask	0xfffff
+#endif
+#define		bEnable                   0x1	/*  Useless */
+#define		bDisable                  0x0
+
+#define		LeftAntenna               0x0	/*  Useless */
+#define		RightAntenna              0x1
+
+#define		tCheckTxStatus            500   /* 500ms Useless */
+#define		tUpdateRxCounter          100   /* 100ms */
+
+#define		rateCCK     0	/*  Useless */
+#define		rateOFDM    1
+#define		rateHT      2
+
+/* define Register-End */
+#define		bPMAC_End                 0x1ff	/*  Useless */
+#define		bFPGAPHY0_End             0x8ff
+#define		bFPGAPHY1_End             0x9ff
+#define		bCCKPHY0_End              0xaff
+#define		bOFDMPHY0_End             0xcff
+#define		bOFDMPHY1_End             0xdff
+
+#define		bPMACControl	0x0		/*  Useless */
+#define		bWMACControl	0x1
+#define		bWNICControl	0x2
+
+#define RCR_AAP			BIT(0)				/*  accept all physical address */
+#define RCR_APM			BIT(1)				/*  accept physical match */
+#define RCR_AM			BIT(2)				/*  accept multicast */
+#define RCR_AB			BIT(3)				/*  accept broadcast */
+#define RCR_ACRC32		BIT(5)				/*  accept error packet */
+#define RCR_9356SEL		BIT(6)
+#define RCR_AICV		BIT(12)				/*  Accept ICV error packet */
+#define RCR_RXFTH0		(BIT(13)|BIT(14)|BIT(15))	/*  Rx FIFO threshold */
+#define RCR_ADF			BIT(18)				/*  Accept Data(frame type) frame */
+#define RCR_ACF			BIT(19)				/*  Accept control frame */
+#define RCR_AMF			BIT(20)				/*  Accept management frame */
+#define RCR_ADD3		BIT(21)
+#define RCR_APWRMGT		BIT(22)				/*  Accept power management packet */
+#define RCR_CBSSID		BIT(23)				/*  Accept BSSID match packet */
+#define RCR_ENMARP		BIT(28)				/*  enable mac auto reset phy */
+#define RCR_EnCS1		BIT(29)				/*  enable carrier sense method 1 */
+#define RCR_EnCS2		BIT(30)				/*  enable carrier sense method 2 */
+#define RCR_OnlyErlPkt		BIT(31)				/*  Rx Early mode is performed for packet size greater than 1536 */
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif	/* __INC_HAL8192SPHYREG_H */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_p2p.h b/drivers/net/wireless/rtl8192du/include/rtw_p2p.h
new file mode 100644
index 0000000..325bd02
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_p2p.h
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_P2P_H_
+#define __RTW_P2P_H_
+
+#include <drv_types.h>
+
+u32 build_beacon_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 build_prov_disc_request_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8* pssid, u8 ussidlen, u8* pdev_raddr);
+u32 build_assoc_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf, u8 status_code);
+u32 build_deauth_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf);
+u32 process_probe_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u32 process_assoc_req_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pframe, uint len, struct sta_info *psta);
+u32 process_p2p_devdisc_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_provdisc_req(struct wifidirect_info *pwdinfo,  u8 *pframe, uint len);
+u8 process_p2p_group_negotation_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_resp(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_group_negotation_confirm(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+u8 process_p2p_presence_req(struct wifidirect_info *pwdinfo, u8 *pframe, uint len);
+
+void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType);
+
+void rtw_init_cfg80211_wifidirect_info(struct rtw_adapter *padapter);
+int rtw_p2p_check_frames(struct rtw_adapter *padapter, const u8 *buf, u32 len, u8 tx);
+void rtw_append_wfd_ie(struct rtw_adapter *padapter, u8 *buf, u32 *len);
+
+void reset_global_wifidirect_info(struct rtw_adapter *padapter);
+int rtw_init_wifi_display_info(struct rtw_adapter *padapter);
+void rtw_init_wifidirect_timers(struct rtw_adapter *padapter);
+void rtw_init_wifidirect_addrs(struct rtw_adapter *padapter, u8 *dev_addr, u8 *iface_addr);
+void init_wifidirect_info(struct rtw_adapter *padapter, enum P2P_ROLE role);
+int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role);
+
+static inline void _rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if (wdinfo->p2p_state != state) {
+		wdinfo->p2p_state = state;
+	}
+}
+static inline void _rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	if (wdinfo->pre_p2p_state != state) {
+		wdinfo->pre_p2p_state = state;
+	}
+}
+
+static inline void _rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	if (wdinfo->role != role) {
+		wdinfo->role = role;
+	}
+}
+static inline int _rtw_p2p_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->p2p_state;
+}
+static inline int _rtw_p2p_pre_state(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->pre_p2p_state;
+}
+static inline int _rtw_p2p_role(struct wifidirect_info *wdinfo)
+{
+	return wdinfo->role;
+}
+static inline bool _rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
+{
+	return wdinfo->p2p_state == state;
+}
+static inline bool _rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
+{
+	return wdinfo->role == role;
+}
+
+#ifdef CONFIG_DBG_P2P
+void dbg_rtw_p2p_set_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+void dbg_rtw_p2p_set_pre_state(struct wifidirect_info *wdinfo, enum P2P_STATE state, const char *caller, int line);
+void dbg_rtw_p2p_set_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role, const char *caller, int line);
+#define rtw_p2p_set_state(wdinfo, state) dbg_rtw_p2p_set_state(wdinfo, state, __func__, __LINE__)
+#define rtw_p2p_set_pre_state(wdinfo, state) dbg_rtw_p2p_set_pre_state(wdinfo, state, __func__, __LINE__)
+#define rtw_p2p_set_role(wdinfo, role) dbg_rtw_p2p_set_role(wdinfo, role, __func__, __LINE__)
+#else /* CONFIG_DBG_P2P */
+#define rtw_p2p_set_state(wdinfo, state) _rtw_p2p_set_state(wdinfo, state)
+#define rtw_p2p_set_pre_state(wdinfo, state) _rtw_p2p_set_pre_state(wdinfo, state)
+#define rtw_p2p_set_role(wdinfo, role) _rtw_p2p_set_role(wdinfo, role)
+#endif /* CONFIG_DBG_P2P */
+
+#define rtw_p2p_state(wdinfo) _rtw_p2p_state(wdinfo)
+#define rtw_p2p_pre_state(wdinfo) _rtw_p2p_pre_state(wdinfo)
+#define rtw_p2p_role(wdinfo) _rtw_p2p_role(wdinfo)
+#define rtw_p2p_chk_state(wdinfo, state) _rtw_p2p_chk_state(wdinfo, state)
+#define rtw_p2p_chk_role(wdinfo, role) _rtw_p2p_chk_role(wdinfo, role)
+
+#define rtw_p2p_findphase_ex_set(wdinfo, value) \
+	(wdinfo)->find_phase_state_exchange_cnt = (value)
+
+/* is this find phase exchange for social channel scan? */
+#define rtw_p2p_findphase_ex_is_social(wdinfo)   \
+	(wdinfo)->find_phase_state_exchange_cnt >= P2P_FINDPHASE_EX_SOCIAL_FIRST
+
+/* should we need find phase exchange anymore? */
+#define rtw_p2p_findphase_ex_is_needed(wdinfo) \
+	((wdinfo)->find_phase_state_exchange_cnt < P2P_FINDPHASE_EX_MAX && \
+	(wdinfo)->find_phase_state_exchange_cnt != P2P_FINDPHASE_EX_NONE)
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_pwrctrl.h b/drivers/net/wireless/rtl8192du/include/rtw_pwrctrl.h
new file mode 100644
index 0000000..3e4cb14
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_pwrctrl.h
@@ -0,0 +1,334 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_PWRCTRL_H_
+#define __RTW_PWRCTRL_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+
+#define FW_PWR0	0
+#define FW_PWR1		1
+#define FW_PWR2		2
+#define FW_PWR3		3
+
+
+#define HW_PWR0	7
+#define HW_PWR1		6
+#define HW_PWR2		2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define PS_DPS				BIT(0)
+#define PS_LCLK				(PS_DPS)
+#define PS_RF_OFF			BIT(1)
+#define PS_ALL_ON			BIT(2)
+#define PS_ST_ACTIVE		BIT(3)
+
+#define PS_ISR_ENABLE		BIT(4)
+#define PS_IMR_ENABLE		BIT(5)
+#define PS_ACK				BIT(6)
+#define PS_TOGGLE			BIT(7)
+
+#define PS_STATE_MASK		(0x0F)
+#define PS_STATE_HW_MASK	(0x07)
+#define PS_SEQ_MASK			(0xc0)
+
+#define PS_STATE(x)		(PS_STATE_MASK & (x))
+#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define PS_SEQ(x)		(PS_SEQ_MASK & (x))
+
+#define PS_STATE_S0		(PS_DPS)
+#define PS_STATE_S1		(PS_LCLK)
+#define PS_STATE_S2		(PS_RF_OFF)
+#define PS_STATE_S3		(PS_ALL_ON)
+#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
+#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
+#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; /* the CPWM value */
+	unsigned short rsvd;
+};
+
+__inline static void _init_pwrlock(struct  semaphore *plock)
+{
+	_rtw_init_sema(plock, 1);
+}
+
+__inline static void _free_pwrlock(struct  semaphore *plock)
+{
+	_rtw_free_sema(plock);
+}
+
+
+__inline static void _enter_pwrlock(struct  semaphore *plock)
+{
+	_rtw_down_sema(plock);
+}
+
+
+__inline static void _exit_pwrlock(struct  semaphore *plock)
+{
+	_rtw_up_sema(plock);
+}
+
+#define LPS_DELAY_TIME	1*HZ /*  1 sec */
+
+#define EXE_PWR_NONE	0x01
+#define EXE_PWR_IPS		0x02
+#define EXE_PWR_LPS		0x04
+
+/*  RF state. */
+enum rt_rf_power_state {
+	rf_on,		/*  RF is on after RFSleep or RFOff */
+	rf_sleep,	/*  802.11 Power Save mode */
+	rf_off,		/*  HW/SW Radio OFF or Inactive Power Save */
+	/* Add the new RF state above this line===== */
+	rf_max
+};
+
+/*  RF Off Level for IPS or HW/SW radio off */
+#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	/*  PCI ASPM */
+#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	/*  PCI clock request */
+#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	/*  PCI D3 mode */
+#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	/*  NIC halt, re-initialize hw parameters */
+#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	/*  FW free, re-download the FW */
+#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	/*  FW in 32k */
+#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	/*  Always enable ASPM and Clock Req in initialization. */
+#define	RT_RF_LPS_DISALBE_2R			BIT(30)	/*  When LPS is on, disable 2R if no packet is received or transmittd. */
+#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	/*  LPS with ASPM */
+
+#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? true : false)
+#define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
+#define	RT_SET_PS_LEVEL(ppsc, _PS_FLAG)		(ppsc->cur_ps_level |= _PS_FLAG)
+
+
+enum _PS_BBRegBackup_ {
+	PSBBREG_RF0 = 0,
+	PSBBREG_RF1,
+	PSBBREG_RF2,
+	PSBBREG_AFE0,
+	PSBBREG_TOTALCNT
+};
+
+enum { /*  for ips_mode */
+	IPS_NONE=0,
+	IPS_NORMAL,
+	IPS_LEVEL_2,
+};
+
+struct pwrctrl_priv
+{
+	struct  semaphore lock;
+	volatile u8 rpwm; /*  requested power state for fw */
+	volatile u8 cpwm; /*  fw current power state. updated when 1. read from HCPWM 2. driver lowers power level */
+	volatile u8 tog; /*  toggling */
+	volatile u8 cpwm_tog; /*  toggling */
+	u8	pwr_mode;
+	u8	smart_ps;
+	u32 alives;
+
+	u8	b_hw_radio_off;
+	u8	reg_rfoff;
+	u8	reg_pdnmode; /* powerdown mode */
+	u32	rfoff_reason;
+
+	/* RF OFF Level */
+	u32	cur_ps_level;
+	u32	reg_rfps_level;
+	uint	ips_enter_cnts;
+	uint	ips_leave_cnts;
+
+	u8	ips_mode;
+	u8	ips_mode_req; /*  used to accept the mode setting request, will update to ipsmode later */
+	uint bips_processing;
+	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
+	u8 ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
+
+	u8	bLeisurePs;
+	u8	LpsIdleCount;
+	u8	power_mgnt;
+	u8	bFwCurrentInPSMode;
+	u32	DelayLPSLastTimeStamp;
+
+	s32		pnp_current_pwr_state;
+	u8		pnp_bstop_trx;
+
+
+	u8		bInternalAutoSuspend;
+	u8		bInSuspend;
+	u8		bSupportRemoteWakeup;
+#ifdef CONFIG_WOWLAN
+	u8		wowlan_mode;
+	u8		wowlan_pattern;
+	u8		wowlan_magic;
+	u8		wowlan_unicast;
+	u8		wowlan_pattern_idx;
+	u32		wowlan_pattern_context[8][5];
+#endif /*  CONFIG_WOWLAN */
+	struct timer_list pwr_state_check_timer;
+	int		pwr_state_check_interval;
+	u8		pwr_state_check_cnts;
+
+	int		ps_flag;
+
+	enum rt_rf_power_state	rf_pwrstate;/* cur power state */
+	enum rt_rf_power_state	change_rfpwrstate;
+
+	u8		wepkeymask;
+	u8		bHWPowerdown;/* if support hw power down */
+	u8		bHWPwrPindetect;
+	u8		bkeepfwalive;
+	u8		brfoffbyhw;
+	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
+
+	#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	struct workqueue_struct *rtw_workqueue;
+	struct work_struct resume_work;
+	#endif
+
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+	u8 do_late_resume;
+	#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+	#ifdef CONFIG_ANDROID_POWER
+	android_early_suspend_t early_suspend;
+	u8 do_late_resume;
+	#endif
+
+};
+
+#define rtw_get_ips_mode_req(pwrctrlpriv) \
+	(pwrctrlpriv)->ips_mode_req
+
+#define rtw_ips_mode_req(pwrctrlpriv, ips_mode) \
+	(pwrctrlpriv)->ips_mode_req = (ips_mode)
+
+#define RTW_PWR_STATE_CHK_INTERVAL 2000
+
+#define _rtw_set_pwr_state_check_timer(pwrctrlpriv, ms) \
+	do { \
+		/*DBG_871X("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __func__, (pwrctrlpriv), (ms));*/ \
+		_set_timer(&(pwrctrlpriv)->pwr_state_check_timer, (ms)); \
+	} while (0)
+
+#define rtw_set_pwr_state_check_timer(pwrctrlpriv) \
+	_rtw_set_pwr_state_check_timer((pwrctrlpriv), (pwrctrlpriv)->pwr_state_check_interval)
+
+extern void rtw_init_pwrctrl_priv(struct rtw_adapter *adapter);
+extern void rtw_free_pwrctrl_priv(struct rtw_adapter * adapter);
+
+#ifdef CONFIG_LPS_LCLK
+extern s32 rtw_register_tx_alive(struct rtw_adapter * padapter);
+extern void rtw_unregister_tx_alive(struct rtw_adapter * padapter);
+extern s32 rtw_register_rx_alive(struct rtw_adapter * padapter);
+extern void rtw_unregister_rx_alive(struct rtw_adapter * padapter);
+extern s32 rtw_register_cmd_alive(struct rtw_adapter * padapter);
+extern void rtw_unregister_cmd_alive(struct rtw_adapter * padapter);
+extern s32 rtw_register_evt_alive(struct rtw_adapter * padapter);
+extern void rtw_unregister_evt_alive(struct rtw_adapter * padapter);
+extern void cpwm_int_hdl(struct rtw_adapter * padapter, struct reportpwrstate_parm *preportpwrstate);
+#endif
+
+extern void rtw_set_ps_mode(struct rtw_adapter * padapter, u8 ps_mode, u8 smart_ps);
+extern void rtw_set_rpwm(struct rtw_adapter * padapter, u8 val8);
+extern void LeaveAllPowerSaveMode(struct rtw_adapter * adapter);
+#ifdef CONFIG_IPS
+void ips_enter(struct rtw_adapter * padapter);
+int ips_leave(struct rtw_adapter * padapter);
+#endif
+
+void rtw_ps_processor(struct rtw_adapter*padapter);
+
+#ifdef CONFIG_AUTOSUSPEND
+int autoresume_enter(struct rtw_adapter* padapter);
+#endif
+#ifdef CONFIG_LPS
+void rtw_lps_enter(struct rtw_adapter * padapter);
+void rtw_lps_leave(struct rtw_adapter * padapter);
+#endif
+
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv);
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv);
+bool rtw_is_do_late_resume(struct pwrctrl_priv *pwrpriv);
+void rtw_set_do_late_resume(struct pwrctrl_priv *pwrpriv, bool enable);
+void rtw_register_early_suspend(struct pwrctrl_priv *pwrpriv);
+void rtw_unregister_early_suspend(struct pwrctrl_priv *pwrpriv);
+#else
+#define rtw_is_earlysuspend_registered(pwrpriv) false
+#define rtw_is_do_late_resume(pwrpriv) false
+#define rtw_set_do_late_resume(pwrpriv, enable) do {} while (0)
+#define rtw_register_early_suspend(pwrpriv) do {} while (0)
+#define rtw_unregister_early_suspend(pwrpriv) do {} while (0)
+#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
+
+u8 rtw_interface_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id,u8* val);
+void rtw_set_ips_deny(struct rtw_adapter *padapter, u32 ms);
+int _rtw_pwr_wakeup(struct rtw_adapter *padapter, u32 ips_deffer_ms, const char *caller);
+#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __func__)
+#define rtw_pwr_wakeup_ex(adapter, ips_deffer_ms) _rtw_pwr_wakeup(adapter, ips_deffer_ms, __func__)
+int rtw_pm_set_ips(struct rtw_adapter *padapter, u8 mode);
+int rtw_pm_set_lps(struct rtw_adapter *padapter, u8 mode);
+
+#endif  /* __RTL871X_PWRCTRL_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_qos.h b/drivers/net/wireless/rtl8192du/include/rtw_qos.h
new file mode 100644
index 0000000..7070036
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_qos.h
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef _RTW_QOS_H_
+#define _RTW_QOS_H_
+#include <drv_conf.h>
+#include <osdep_service.h>
+
+
+
+
+
+
+struct	qos_priv	{
+
+	unsigned int	  qos_option;	/* bit mask option: u-apsd, s-apsd, ts, block ack... */
+
+};
+
+
+#endif	/* _RTL871X_QOS_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_recv.h b/drivers/net/wireless/rtl8192du/include/rtw_recv.h
new file mode 100644
index 0000000..1a00e2d
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_recv.h
@@ -0,0 +1,448 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_RECV_H_
+#define _RTW_RECV_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define NR_RECVFRAME			256
+
+#define RXFRAME_ALIGN			8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define MAX_RXFRAME_CNT			512
+#define MAX_RX_NUMBLKS			32
+#define RECVFRAME_HDR_ALIGN		128
+
+static u8 SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static u8 SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static u8 SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
+static u8 SNAP_HDR_APPLETALK_DDP[3] = {
+	0x08, 0x00, 0x07
+}; /*  Datagram Delivery Protocol */
+
+static u8 oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8 oui_rfc1042[] = {0x00, 0x00, 0x00};
+
+#define MAX_SUBFRAME_COUNT		64
+static u8 rtw_rfc1042_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00
+};
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static u8 rtw_bridge_tunnel_header[] = {
+	0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8
+};
+
+/* for Rx reordering buffer control */
+struct recv_reorder_ctrl {
+	struct rtw_adapter	*padapter;
+	u8 enable;
+	u16 indicate_seq;/* wstart_b, init_value=0xffff */
+	u16 wend_b;
+	u8 wsize_b;
+	struct __queue pending_recvframe_queue;
+	struct timer_list reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16	tid_rxseq[16];
+};
+
+struct smooth_rssi_data {
+	u32	elements[100];	/* array to store values */
+	u32	index;			/* index to current array to store */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements */
+};
+
+struct signal_stat {
+	u8	update_req;		/* used to indicate */
+	u8	avg_val;		/* avg of valid elements */
+	u32	total_num;		/* num of valid elements */
+	u32	total_val;		/* sum of valid elements */
+};
+
+struct rx_pkt_attrib {
+	u16	pkt_len;
+	u8	physt;
+	u8	drvinfo_sz;
+	u8	shift_sz;
+	u8	hdrlen; /* the WLAN Header Len */
+	u8	to_fr_ds;
+	u8	amsdu;
+	u8	qos;
+	u8	priority;
+	u8	pw_save;
+	u8	mdata;
+	u16	seq_num;
+	u8	frag_num;
+	u8	mfrag;
+	u8	order;
+	u8	privacy; /* in frame_ctrl field */
+	u8	bdecrypted;
+	u8	encrypt; /* when non-zero, indicate the encrypt algorith */
+	u8	iv_len;
+	u8	icv_len;
+	u8	crc_err;
+	u8	icv_err;
+	u16	eth_type;
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	bssid[ETH_ALEN];
+	u8	ack_policy;
+	u8	tcpchk_valid; /*  0: invalid, 1: valid */
+	u8	ip_chkrpt; /* 0: incorrect, 1: correct */
+	u8	tcp_chkrpt; /* 0: incorrect, 1: correct */
+	u8	key_index;
+	u8	mcs_rate;
+	u8	rxht;
+	u8	sgi;
+	u8	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	u8	signal_strength;
+	u8	rx_rssi[2];  /* This value is percentage */
+	u8	rx_snr[2];
+	u32	rxpwdb_all;
+	s32	recvsignalpower;
+};
+
+/* These definition is used for Rx packet reordering. */
+#define SN_LESS(a, b)		(((a - b) & 0x800) != 0)
+#define SN_EQUAL(a, b)		(a == b)
+#define REORDER_WAIT_TIME	(50) /*  (ms) */
+
+#define RECVBUFF_ALIGN_SZ	8
+
+#define RXDESC_SIZE		24
+#define RXDESC_OFFSET		RXDESC_SIZE
+
+struct recv_stat {
+	__le32 rxdw0;
+	__le32 rxdw1;
+	__le32 rxdw2;
+	__le32 rxdw3;
+	__le32 rxdw4;
+	__le32 rxdw5;
+};
+
+#define EOR			BIT(30)
+
+/* accesser of recv_priv: rtw_recv_entry(dispatch / passive level);
+ * recv_thread(passive); returnpkt(dispatch); halt(passive);
+ *
+ * use enter_critical section to protect
+ */
+struct recv_priv {
+	struct __queue free_recv_queue;
+	struct __queue recv_pending_queue;
+	struct __queue uc_swdec_pending_queue;
+	struct rtw_adapter	*adapter;
+	struct  semaphore allrxreturnevt;
+	struct tasklet_struct irq_prepare_beacon_tasklet;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+	struct __queue free_recv_buf_queue;
+	struct timer_list signal_stat_timer;
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+
+	spinlock_t lock;
+
+	u8 *pallocated_frame_buf;
+	u8 *precv_frame_buf;
+
+	uint free_recvframe_cnt;
+
+	u32	bIsAnyNonBEPkts;
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+	u64	last_rx_bytes;
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+	uint	ff_hwaddr;
+	u8	rx_pending_cnt;
+
+	u8 *pallocated_recv_buf;
+	u8 *precv_buf;    /*  4 alignment */
+	u32	free_recv_buf_queue_cnt;
+
+	/* For display the phy informatiom */
+	u8 is_signal_dbg;	/*  for debug */
+	u8 signal_strength_dbg;	/*  for debug */
+	s8 rssi;
+	s8 rxpwdb;
+	u8 signal_strength;
+	u8 signal_qual;
+	u8 noise;
+	int RxSNRdB[2];
+	s8 RxRssi[2];
+	int falsealmcnt_all;
+
+	u32 signal_stat_sampling_interval;
+
+	u32 recvbuf_skb_alloc_fail_cnt;
+	u32 recvbuf_null_cnt;
+	u32 read_port_complete_EINPROGRESS_cnt;
+	u32 read_port_complete_other_urb_err_cnt;
+};
+
+#define rtw_set_signal_stat_timer(recvpriv)				\
+	_set_timer(&(recvpriv)->signal_stat_timer,			\
+		   (recvpriv)->signal_stat_sampling_interval)
+
+struct sta_recv_priv {
+	struct __queue defrag_q; /* keeping the fragment frame until defrag */
+	struct	stainfo_rxcache rxcache;
+	spinlock_t lock;
+	int	option;
+};
+
+struct recv_buf {
+	struct list_head list;
+	struct rtw_adapter *adapter;
+	struct urb *purb;
+	struct sk_buff *pskb;
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+
+	spinlock_t recvbuf_lock;
+
+	u32	ref_cnt;
+	u32	len;
+	u8	*pbuf;
+	u8	*pallocated_buf;
+
+	u8	*phead;
+	u8	*pdata;
+	u8	*ptail;
+	u8	*pend;
+	u32	alloc_sz;
+	u8	irp_pending;
+	int	transfer_len;
+	u8	reuse;
+};
+
+/*	head  ----->
+ *		data  ----->
+ *			payload
+ *		tail  ----->
+ *	end   ----->
+ *
+ *	len = (unsigned int)(tail - data);
+ */
+struct recv_frame_hdr {
+	struct list_head list;
+	struct sk_buff	 *pkt;
+	struct sk_buff	 *pkt_newalloc;
+	struct rtw_adapter  *adapter;
+	struct rx_pkt_attrib attrib;
+	struct sta_info *psta;
+	/* for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl *preorder_ctrl;
+	void *precvbuf;
+
+	u8 fragcnt;
+
+	int frame_tag;
+
+	uint  len;
+	u8 *rx_head;
+	u8 *rx_data;
+	u8 *rx_tail;
+	u8 *rx_end;
+};
+
+/* get a free recv_frame from pfree_recv_queue */
+struct recv_frame_hdr *_rtw_alloc_recvframe(struct __queue *pfree_recv_queue);
+/* get a free recv_frame from pfree_recv_queue */
+struct recv_frame_hdr *rtw_alloc_recvframe(struct __queue *pfree_recv_queue);
+void rtw_init_recvframe(struct recv_frame_hdr *precvframe,
+			struct recv_priv *precvpriv);
+int rtw_free_recvframe(struct recv_frame_hdr *precvframe,
+		       struct __queue *pfree_recv_queue);
+
+#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
+int _rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe,
+			   struct __queue *queue);
+int rtw_enqueue_recvframe(struct recv_frame_hdr *precvframe,
+			  struct __queue *queue);
+
+void rtw_free_recvframe_queue(struct __queue *pframequeue,
+			      struct __queue *pfree_recv_queue);
+u32 rtw_free_uc_swdec_pending_queue(struct rtw_adapter *adapter);
+
+int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf,
+				struct __queue *queue);
+int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue);
+struct recv_buf *rtw_dequeue_recvbuf(struct __queue *queue);
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext);
+
+static inline u8 *get_rxmem(struct recv_frame_hdr *precvframe)
+{
+	/* always return rx_head... */
+	if (precvframe == NULL)
+		return NULL;
+
+	return precvframe->rx_head;
+}
+
+static inline u8 *get_rx_status(struct recv_frame_hdr *precvframe)
+{
+	return get_rxmem(precvframe);
+}
+
+static inline u8 *get_recvframe_data(struct recv_frame_hdr *precvframe)
+{
+	/* alwasy return rx_data */
+	if (precvframe == NULL)
+		return NULL;
+
+	return precvframe->rx_data;
+}
+
+static inline u8 *recvframe_push(struct recv_frame_hdr *precvframe, int sz)
+{
+/*  append data before rx_data
+ * add data to the start of recv_frame
+ *
+ *      This function extends the used data area of the recv_frame at the buffer
+ *      start. rx_data must be still larger than rx_head, after pushing.
+ */
+	if (precvframe == NULL)
+		return NULL;
+	precvframe->rx_data -= sz;
+	if (precvframe->rx_data < precvframe->rx_head) {
+		precvframe->rx_data += sz;
+		return NULL;
+	}
+	precvframe->len += sz;
+	return precvframe->rx_data;
+}
+
+static inline u8 *recvframe_pull(struct recv_frame_hdr *precvframe, int sz)
+{
+/*  rx_data += sz; move rx_data sz bytes  hereafter
+ * used for extract sz bytes from rx_data, update rx_data and return the
+ * updated rx_data to the caller
+ */
+	if (precvframe == NULL)
+		return NULL;
+
+
+	precvframe->rx_data += sz;
+
+	if (precvframe->rx_data > precvframe->rx_tail) {
+		precvframe->rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->len -= sz;
+
+	return precvframe->rx_data;
+}
+
+static inline u8 *recvframe_put(struct recv_frame_hdr *precvframe, int sz)
+{
+/*  rx_tai += sz; move rx_tail sz bytes  hereafter
+ * used for append sz bytes from ptr to rx_tail, update rx_tail and return
+ * the updated rx_tail to the caller
+ * after putting, rx_tail must be still larger than rx_end.
+ */
+	if (precvframe == NULL)
+		return NULL;
+
+	precvframe->rx_tail += sz;
+
+	if (precvframe->rx_tail > precvframe->rx_end) {
+		precvframe->rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->len += sz;
+
+	return precvframe->rx_tail;
+}
+
+static inline u8 *recvframe_pull_tail(struct recv_frame_hdr *precvframe, int sz)
+{
+/*  rmv data from rx_tail
+ * used for extract sz bytes from rx_end, update rx_end and return the
+ * updated rx_end to the caller
+ * after pulling, rx_end must be still larger than rx_data.
+ */
+	if (precvframe == NULL)
+		return NULL;
+
+	precvframe->rx_tail -= sz;
+
+	if (precvframe->rx_tail < precvframe->rx_data) {
+		precvframe->rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->len -= sz;
+
+	return precvframe->rx_tail;
+}
+
+static inline unsigned char *get_rxbuf_desc(struct recv_frame_hdr *precvframe)
+{
+	unsigned char *buf_desc;
+
+	if (precvframe == NULL)
+		return NULL;
+	return buf_desc;
+}
+
+static inline u8 query_rx_pwr_percentage(s8 antpower)
+{
+	if ((antpower <= -100) || (antpower >= 20))
+		return	0;
+	else if (antpower >= 0)
+		return	100;
+	else
+		return	100+antpower;
+}
+
+static inline s32 translate_percentage_to_dbm(u32 index)
+{
+	s32	power; /*  in dBm. */
+
+	/*  Translate to dBm (x=0.5y-95). */
+	power = (s32)((index + 1) >> 1);
+	power -= 95;
+
+	return power;
+}
+
+struct sta_info;
+
+void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+void  mgt_dispatcher(struct rtw_adapter *padapter,
+		     struct recv_frame_hdr *precv_frame);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_rf.h b/drivers/net/wireless/rtl8192du/include/rtw_rf.h
new file mode 100644
index 0000000..c983886
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_rf.h
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_RF_H_
+#define __RTW_RF_H_
+
+#include <drv_conf.h>
+#include <rtw_cmd.h>
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#define NUMRATES	(13)
+
+/*  slot time for 11g */
+#define SHORT_SLOT_TIME					9
+#define NON_SHORT_SLOT_TIME				20
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+/*  */
+/*  We now define the following channels as the max channels in each channel plan. */
+/*  2G, total 14 chnls */
+/*  {1,2,3,4,5,6,7,8,9,10,11,12,13,14} */
+/*  5G, total 24 chnls */
+/*  {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165} */
+#define	MAX_CHANNEL_NUM_2G				14
+#define	MAX_CHANNEL_NUM_5G				24
+#define	MAX_CHANNEL_NUM					38/* 14+24 */
+
+#define NUM_REGULATORYS	1
+
+/* Country codes */
+#define USA							0x555320
+#define EUROPE						0x1 /* temp, should be provided later */
+#define JAPAN						0x2 /* temp, should be provided later */
+
+struct	regulatory_class {
+	u32	starting_freq;					/* MHz, */
+	u8	channel_set[MAX_CHANNEL_NUM];
+	u8	channel_cck_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	channel_ofdm_power[MAX_CHANNEL_NUM];/* dbm */
+	u8	txpower_limit;					/* dbm */
+	u8	channel_spacing;				/* MHz */
+	u8	modem;
+};
+
+enum CAPABILITY {
+	cESS			= 0x0001,
+	cIBSS			= 0x0002,
+	cPollable		= 0x0004,
+	cPollReq			= 0x0008,
+	cPrivacy		= 0x0010,
+	cShortPreamble	= 0x0020,
+	cPBCC			= 0x0040,
+	cChannelAgility	= 0x0080,
+	cSpectrumMgnt	= 0x0100,
+	cQos			= 0x0200,	/*  For HCCA, use with CF-Pollable and CF-PollReq */
+	cShortSlotTime	= 0x0400,
+	cAPSD			= 0x0800,
+	cRM				= 0x1000,	/*  RRM (Radio Request Measurement) */
+	cDSSS_OFDM	= 0x2000,
+	cDelayedBA		= 0x4000,
+	cImmediateBA	= 0x8000,
+};
+
+enum	_REG_PREAMBLE_MODE {
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_ {
+	RTL8712_RFCONFIG_1T = 0x10,
+	RTL8712_RFCONFIG_2T = 0x20,
+	RTL8712_RFCONFIG_1R = 0x01,
+	RTL8712_RFCONFIG_2R = 0x02,
+	RTL8712_RFCONFIG_1T1R = 0x11,
+	RTL8712_RFCONFIG_1T2R = 0x12,
+	RTL8712_RFCONFIG_TURBO = 0x92,
+	RTL8712_RFCONFIG_2T2R = 0x22
+};
+
+
+/*  Bandwidth Offset */
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+
+/*  Represent Channel Width in HT Capabilities */
+/*  */
+enum HT_CHANNEL_WIDTH {
+	HT_CHANNEL_WIDTH_20 = 0,
+	HT_CHANNEL_WIDTH_40 = 1,
+};
+
+/*  */
+/*  Represent Extention Channel Offset in HT Capabilities */
+/*  This is available only in 40Mhz mode. */
+/*  */
+enum HT_EXTCHNL_OFFSET {
+	HT_EXTCHNL_OFFSET_NO_EXT = 0,
+	HT_EXTCHNL_OFFSET_UPPER = 1,
+	HT_EXTCHNL_OFFSET_NO_DEF = 2,
+	HT_EXTCHNL_OFFSET_LOWER = 3,
+};
+
+/* 2007/11/15 MH Define different RF type. */
+enum RT_RF_TYPE_DEF_E {
+	RF_1T2R = 0,
+	RF_2T4R = 1,
+	RF_2T2R = 2,
+	RF_1T1R = 3,
+	RF_2T2R_GREEN = 4,
+	RF_819X_MAX_TYPE = 5,
+};
+
+enum RF_RADIO_PATH_E {
+	RF_PATH_A = 0,			/* Radio Path A */
+	RF_PATH_B = 1,			/* Radio Path B */
+	RF_PATH_C = 2,			/* Radio Path C */
+	RF_PATH_D = 3,			/* Radio Path D */
+};
+
+u32 rtw_ch2freq(u32 ch);
+u32 rtw_freq2ch(u32 freq);
+
+
+#endif /* _RTL8711_RF_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_security.h b/drivers/net/wireless/rtl8192du/include/rtw_security.h
new file mode 100644
index 0000000..f7d62b3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_security.h
@@ -0,0 +1,385 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_SECURITY_H_
+#define __RTW_SECURITY_H_
+
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+
+#define _NO_PRIVACY_	0x0
+#define _WEP40_			0x1
+#define _TKIP_			0x2
+#define _TKIP_WTMIC_	0x3
+#define _AES_			0x4
+#define _WEP104_		0x5
+
+#define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#define SHA256_MAC_LEN 32
+#define AES_BLOCK_SIZE 16
+#define AES_PRIV_SIZE (4 * 44)
+
+#define NDIS802_11AUTHMODEWPA2 (NDIS802_11AUTHMODEWPANONE + 1)
+
+#define NDIS802_11AUTHMODEWPA2PSK (NDIS802_11AUTHMODEWPANONE + 2)
+
+union pn48	{
+	u64	val;
+
+#ifdef __LITTLE_ENDIAN
+
+struct {
+  u8 TSC0;
+  u8 TSC1;
+  u8 TSC2;
+  u8 TSC3;
+  u8 TSC4;
+  u8 TSC5;
+  u8 TSC6;
+  u8 TSC7;
+} _byte_;
+
+#elif defined(__BIG_ENDIAN)
+
+struct {
+  u8 TSC7;
+  u8 TSC6;
+  u8 TSC5;
+  u8 TSC4;
+  u8 TSC3;
+  u8 TSC2;
+  u8 TSC1;
+  u8 TSC0;
+} _byte_;
+
+#endif
+
+};
+
+union Keytype {
+        u8   skey[16];
+        u32    lkey[4];
+};
+
+
+struct RT_PMKID_LIST {
+	u8						bUsed;
+	u8						Bssid[6];
+	u8						PMKID[16];
+	u8						SsidBuf[33];
+	u8*						ssid_octet;
+	u16						ssid_length;
+};
+
+
+struct security_priv
+{
+	u32	  dot11AuthAlgrthm;		/*  802.11 auth, could be open, shared, 8021x and authswitch */
+	u32	  dot11PrivacyAlgrthm;	/*  This specify the privacy for shared auth. algorithm. */
+
+	/* WEP */
+	u32	  dot11PrivacyKeyIndex;	/*  this is only valid for legendary wep, 0~3 for key id. (tx key index) */
+	union Keytype dot11DefKey[4];			/*  this is only valid for def. key */
+	u32	dot11DefKeylen[4];
+
+	u32 dot118021XGrpPrivacy;	/*  This specify the privacy algthm. used for Grp key */
+	u32	dot118021XGrpKeyid;		/*  key id used for Grp Key (tx key index) */
+	union Keytype	dot118021XGrpKey[4];	/*  802.1x Group Key, for inx0 and inx1 */
+	union Keytype	dot118021XGrptxmickey[4];
+	union Keytype	dot118021XGrprxmickey[4];
+	union pn48		dot11Grptxpn;			/*  PN48 used for Grp Key xmit. */
+	union pn48		dot11Grprxpn;			/*  PN48 used for Grp Key recv. */
+
+#ifdef CONFIG_92D_AP_MODE
+	/* extend security capabilities for AP_MODE */
+	unsigned int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	unsigned int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;
+#endif
+
+	u8 wps_ie[MAX_WPS_IE_LEN];/* added in assoc req */
+	int wps_ie_len;
+
+
+	u8	binstallGrpkey;
+	u8	busetkipkey;
+	u8	bcheck_grpkey;
+	u8	bgrpkey_handshake;
+
+
+	s32	sw_encrypt;/* from registry_priv */
+	s32	sw_decrypt;/* from registry_priv */
+
+	s32	hw_decrypted;/* if the rx packets is hw_decrypted==false, it means the hw has not been ready. */
+
+
+	/* keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc) */
+	u32 ndisauthtype;	/*  NDIS_802_11_AUTHENTICATION_MODE */
+	u32 ndisencryptstatus;	/*  NDIS_802_11_ENCRYPTION_STATUS */
+
+	struct wlan_bssid_ex sec_bss;  /* for joinbss (h2c buffer) usage */
+
+	struct ndis_802_11_wep ndiswep;
+	u8 assoc_info[600];
+	u8 szofcapability[256]; /* for wpa2 usage */
+	u8 oidassociation[512]; /* for wpa/wpa2 usage */
+	u8 authenticator_ie[256];  /* store ap security information element */
+	u8 supplicant_ie[256];  /* store sta security information element */
+
+
+	/* for tkip countermeasure */
+	u32 last_mic_err_time;
+	u8	btkip_countermeasure;
+	u8	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	/*  */
+	/*  For WPA2 Pre-Authentication. */
+	/*  */
+	struct RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	/*  Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13. */
+	u8				PMKIDIndex;
+
+	u8 bWepDefaultKeyIdxSet;
+};
+
+struct sha256_state {
+	u64 length;
+	u32 state[8], curlen;
+	u8 buf[64];
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+do{\
+	switch (psecuritypriv->dot11AuthAlgrthm)\
+	{\
+		case dot11AuthAlgrthm_Open:\
+		case dot11AuthAlgrthm_Shared:\
+		case dot11AuthAlgrthm_Auto:\
+			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case dot11AuthAlgrthm_8021X:\
+			if (bmcst)\
+				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo =(u8) psta->dot118021XPrivacy;\
+			break;\
+	}\
+}while (0)
+
+
+#define SET_ICE_IV_LEN(iv_len, icv_len, encrypt)\
+do{\
+	switch (encrypt)\
+	{\
+		case _WEP40_:\
+		case _WEP104_:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case _TKIP_:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case _AES_:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+	}\
+}while (0)
+
+
+#define GET_TKIP_PN(iv,dot11txpn)\
+do{\
+	dot11txpn._byte_.TSC0=iv[2];\
+	dot11txpn._byte_.TSC1=iv[0];\
+	dot11txpn._byte_.TSC2=iv[4];\
+	dot11txpn._byte_.TSC3=iv[5];\
+	dot11txpn._byte_.TSC4=iv[6];\
+	dot11txpn._byte_.TSC5=iv[7];\
+}while (0)
+
+
+#define ROL32(A, n)	(((A) << (n)) | (((A)>>(32-(n)))  & ((1UL << (n)) - 1)))
+#define ROR32(A, n)	ROL32((A), 32-(n))
+
+struct mic_data
+{
+	u32  K0, K1;         /*  Key */
+	u32  L, R;           /*  Current state */
+	u32  M;              /*  Message accumulator (single word) */
+	u32     nBytesInM;      /*  # bytes in M */
+};
+
+extern const u32 Te0[256];
+extern const u32 Te1[256];
+extern const u32 Te2[256];
+extern const u32 Te3[256];
+extern const u32 Te4[256];
+extern const u32 Td0[256];
+extern const u32 Td1[256];
+extern const u32 Td2[256];
+extern const u32 Td3[256];
+extern const u32 Td4[256];
+extern const u32 rcon[10];
+extern const u8 Td4s[256];
+extern const u8 rcons[10];
+
+#define RCON(i) (rcons[(i)] << 24)
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+#define TE0(i) Te0[((i) >> 24) & 0xff]
+#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
+#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
+#define TE3(i) rotr(Te0[(i) & 0xff], 24)
+#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
+#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
+#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
+#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
+#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
+#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
+#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
+#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
+#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)
+
+#define TD0(i) Td0[((i) >> 24) & 0xff]
+#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
+#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
+#define TD3(i) rotr(Td0[(i) & 0xff], 24)
+#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
+#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
+#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
+#define TD44(i) (Td4s[(i) & 0xff])
+#define TD0_(i) Td0[(i) & 0xff]
+#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
+#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
+#define TD3_(i) rotr(Td0[(i) & 0xff], 24)
+
+#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
+			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+
+#define PUTU32(ct, st) { \
+(ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); \
+(ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
+
+#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (u8) (((u64) (val)) >> 56);	\
+		(a)[1] = (u8) (((u64) (val)) >> 48);	\
+		(a)[2] = (u8) (((u64) (val)) >> 40);	\
+		(a)[3] = (u8) (((u64) (val)) >> 32);	\
+		(a)[4] = (u8) (((u64) (val)) >> 24);	\
+		(a)[5] = (u8) (((u64) (val)) >> 16);	\
+		(a)[6] = (u8) (((u64) (val)) >> 8);	\
+		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+/* ===== start - public domain SHA256 implementation ===== */
+
+/* This is based on SHA256 implementation in LibTomCrypt that was released into
+ * public domain by Tom St Denis. */
+
+/* the K array */
+static const unsigned long K[64] = {
+	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
+	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
+	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
+	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
+	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
+	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
+	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
+	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
+	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
+	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
+	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
+	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
+	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
+};
+
+
+/* Various logical functions */
+#define RORc(x, y) \
+(((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
+   ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
+#define Ch(x,y,z)       (z ^ (x & (y ^ z)))
+#define Maj(x,y,z)      (((x | y) & z) | (x & y))
+#define S(x, n)         RORc((x), (n))
+#define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
+#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
+#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
+#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
+#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key);
+void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b);
+void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nBytes);
+void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst);
+
+void rtw_seccalctkipmic(
+	u8 * key,
+	u8 *header,
+	u8 *data,
+	u32 data_len,
+	u8 *Miccode,
+	u8   priority);
+
+u32 rtw_aes_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe);
+u32 rtw_tkip_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe);
+void rtw_wep_encrypt(struct rtw_adapter *padapter, u8  *pxmitframe);
+
+u32 rtw_aes_decrypt(struct rtw_adapter *padapter, u8  *precvframe);
+u32 rtw_tkip_decrypt(struct rtw_adapter *padapter, u8  *precvframe);
+void rtw_wep_decrypt(struct rtw_adapter *padapter, u8  *precvframe);
+
+void rtw_use_tkipkey_handler(void* FunctionContext);
+
+#endif	/* __RTL871X_SECURITY_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_sreset.h b/drivers/net/wireless/rtl8192du/include/rtw_sreset.h
new file mode 100644
index 0000000..40f6dbc
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_sreset.h
@@ -0,0 +1,54 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_SRESET_C_
+#define _RTW_SRESET_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+struct sreset_priv {
+	_mutex	silentreset_mutex;
+	u8	silent_reset_inprogress;
+	u8	Wifi_Error_Status;
+	unsigned long last_tx_time;
+	unsigned long last_tx_complete_time;
+};
+
+#include <rtl8192d_hal.h>
+
+#define	WIFI_STATUS_SUCCESS		0
+#define	USB_VEN_REQ_CMD_FAIL	BIT0
+#define	USB_READ_PORT_FAIL		BIT1
+#define	USB_WRITE_PORT_FAIL		BIT2
+#define	WIFI_MAC_TXDMA_ERROR	BIT3
+#define   WIFI_TX_HANG				BIT4
+#define	WIFI_RX_HANG				BIT5
+#define		WIFI_IF_NOT_EXIST			BIT6
+
+#if defined(DBG_CONFIG_ERROR_DETECT)
+void sreset_init_value(struct rtw_adapter *padapter);
+void sreset_reset_value(struct rtw_adapter *padapter);
+u8 sreset_get_wifi_status(struct rtw_adapter *padapter);
+void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status);
+#else
+static void sreset_init_value(struct rtw_adapter *padapter) {}
+static void sreset_reset_value(struct rtw_adapter *padapter) {}
+static u8 sreset_get_wifi_status(struct rtw_adapter *padapter) {return WIFI_STATUS_SUCCESS;}
+static void sreset_set_wifi_error_status(struct rtw_adapter *padapter, u32 status) {}
+#endif
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_tdls.h b/drivers/net/wireless/rtl8192du/include/rtw_tdls.h
new file mode 100644
index 0000000..2673103
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_tdls.h
@@ -0,0 +1,23 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_TDLS_H_
+#define __RTW_TDLS_H_
+
+#include <drv_types.h>
+
+s32 rtw_dump_xframe(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/rtw_xmit.h b/drivers/net/wireless/rtl8192du/include/rtw_xmit.h
new file mode 100644
index 0000000..21e32dc
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/rtw_xmit.h
@@ -0,0 +1,447 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_XMIT_H_
+#define _RTW_XMIT_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#define MAX_XMITBUF_SZ		(20480)	/*  20k */
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMITBUFF		(1)
+#else
+#define NR_XMITBUFF		(4)
+#endif /* CONFIG_SINGLE_XMIT_BUF */
+
+#define XMITBUF_ALIGN_SZ	512
+
+/*  xmit extension buff defination */
+#define MAX_XMIT_EXTBUF_SZ	(1536)
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMIT_EXTBUFF		(1)
+#else
+#define NR_XMIT_EXTBUFF		(32)
+#endif /* CONFIG_SINGLE_XMIT_BUF */
+
+#define MAX_NUMBLKS		(1)
+
+#define XMIT_VO_QUEUE (0)
+#define XMIT_VI_QUEUE (1)
+#define XMIT_BE_QUEUE (2)
+#define XMIT_BK_QUEUE (3)
+
+#define VO_QUEUE_INX		0
+#define VI_QUEUE_INX		1
+#define BE_QUEUE_INX		2
+#define BK_QUEUE_INX		3
+#define BCN_QUEUE_INX		4
+#define MGT_QUEUE_INX		5
+#define HIGH_QUEUE_INX		6
+#define TXCMD_QUEUE_INX	7
+
+#define HW_QUEUE_ENTRY	8
+
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
+}while (0)
+
+
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while (0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while (0)
+
+
+#define HWXMIT_ENTRY	4
+
+#define TXDESC_SIZE 32
+
+#define PACKET_OFFSET_SZ (8)
+#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
+
+/*  */
+/* defined for TX DESC Operation */
+/*  */
+
+#define MAX_TID (15)
+
+/* OFFSET 0 */
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC		BIT(24)
+#define LSG		BIT(26)
+#define FSG		BIT(27)
+#define OWN		BIT(31)
+
+/* OFFSET 4 */
+#define PKT_OFFSET_SZ	0
+#define BK		BIT(6)
+#define QSEL_SHT	8
+#define Rate_ID_SHT	16
+#define NAVUSEHDR	BIT(20)
+#define PKT_OFFSET_SHT	26
+#define HWPC		BIT(31)
+
+/* OFFSET 8 */
+#define AGG_EN		BIT(29)
+
+/* OFFSET 12 */
+#define SEQ_SHT		16
+
+/* OFFSET 16 */
+#define QoS		BIT(6)
+#define HW_SEQ_EN	BIT(7)
+#define USERATE		BIT(8)
+#define DISDATAFB	BIT(10)
+#define DATA_SHORT	BIT(24)
+#define DATA_BW		BIT(25)
+
+/* OFFSET 20 */
+#define SGI		BIT(6)
+
+struct tx_desc{
+	/* DWORD 0 */
+	__le32 txdw0;
+	__le32 txdw1;
+	__le32 txdw2;
+	__le32 txdw3;
+	__le32 txdw4;
+	__le32 txdw5;
+	__le32 txdw6;
+	__le32 txdw7;
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];
+};
+
+struct	hw_xmit	{
+	struct __queue *sta_queue;
+	int	accnt;
+};
+
+/* reduce size */
+struct pkt_attrib
+{
+	u8	type;
+	u8	subtype;
+	u8	bswenc;
+	u8	dhcp_pkt;
+	u16	ether_type;
+	u16	seqnum;
+	u16	pkt_hdrlen;	/* the original 802.3 pkt header len */
+	u16	hdrlen;		/* the WLAN Header Len */
+	u32	pktlen;		/* the original 802.3 pkt raw_data len (not include ether_hdr data) */
+	u32	last_txcmdsz;
+	u8	nr_frags;
+	u8	encrypt;	/* when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith */
+	u8	iv_len;
+	u8	icv_len;
+	u8	iv[8];
+	u8	icv[8];
+	u8	priority;
+	u8	ack_policy;
+	u8	mac_id;
+	u8	vcs_mode;	/* virtual carrier sense method */
+	u8	dst[ETH_ALEN];
+	u8	src[ETH_ALEN];
+	u8	ta[ETH_ALEN];
+	u8	ra[ETH_ALEN];
+	u8	key_idx;
+	u8	qos_en;
+	u8	ht_en;
+	u8	raid;/* rate adpative id */
+	u8	bwmode;
+	u8	ch_offset;/* PRIME_CHNL_OFFSET */
+	u8	sgi;/* short GI */
+	u8	ampdu_en;/* tx ampdu enable */
+	u8	mdata;/* more data bit */
+	u8	pctrl;/* per packet txdesc control enable */
+	u8	triggered;/* for ap mode handling Power Saving sta */
+	u8	qsel;
+	u8	eosp;
+	u8	rate;
+	u8	intel_proxim;
+	u8	retry_ctrl;
+	struct sta_info * psta;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	u8	hw_tcp_csum;
+#endif
+};
+
+#define WLANHDR_OFFSET	64
+
+#define NULL_FRAMETAG		(0x0)
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+#define TXAGG_FRAMETAG	0x08
+
+struct  submit_ctx{
+	u32 submit_time; /* */
+	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
+	int status; /* status for operation */
+	struct completion done;
+};
+
+enum {
+	RTW_SCTX_SUBMITTED = -1,
+	RTW_SCTX_DONE_SUCCESS = 0,
+	RTW_SCTX_DONE_UNKNOWN,
+	RTW_SCTX_DONE_TIMEOUT,
+	RTW_SCTX_DONE_BUF_ALLOC,
+	RTW_SCTX_DONE_BUF_FREE,
+	RTW_SCTX_DONE_WRITE_PORT_ERR,
+	RTW_SCTX_DONE_TX_DESC_NA,
+	RTW_SCTX_DONE_TX_DENY,
+	RTW_SCTX_DONE_CCX_PKT_FAIL,
+	RTW_SCTX_DONE_DRV_STOP,
+	RTW_SCTX_DONE_DEV_REMOVE,
+};
+
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
+int rtw_sctx_wait(struct submit_ctx *sctx);
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
+void rtw_sctx_done(struct submit_ctx **sctx);
+
+struct xmit_buf
+{
+	struct list_head list;
+
+	struct rtw_adapter *padapter;
+
+	u8 *pallocated_buf;
+
+	u8 *pbuf;
+
+	void *priv_data;
+
+	u16 ext_tag; /*  0: Normal xmitbuf, 1: extension xmitbuf. */
+	u16 flags;
+	u32 alloc_sz;
+
+	struct submit_ctx *sctx;
+	u32 sz[8];
+	struct urb *pxmit_urb[8];
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+	u8 bpending[8];
+	int last[8];
+#ifdef DBG_XMIT_BUF
+	u8 no;
+#endif
+};
+
+struct xmit_frame {
+	struct list_head list;
+	struct pkt_attrib attrib;
+	struct sk_buff *pkt;
+	int	frame_tag;
+	struct rtw_adapter *padapter;
+	u8	*buf_addr;
+	struct xmit_buf *pxmitbuf;
+	u8	agg_num;
+	u8	pkt_offset;
+	u8	EMPktNum;
+	u16	EMPktLen[5];/* The max value by HW */
+	u8 ack_report;
+};
+
+struct tx_servq {
+	struct list_head tx_pending;
+	struct __queue sta_pending;
+	int qcnt;
+};
+
+
+
+struct sta_xmit_priv {
+	spinlock_t lock;
+	int	option;
+	int	apsd_setting;	/* When bit mask is on, the associated edca queue supports APSD. */
+	struct tx_servq	be_q;			/* priority == 0,3 */
+	struct tx_servq	bk_q;			/* priority == 1,2 */
+	struct tx_servq	vi_q;			/* priority == 4,5 */
+	struct tx_servq	vo_q;			/* priority == 6,7 */
+	struct list_head legacy_dz;
+	struct list_head apsd;
+	u16 txseq_tid[16];
+};
+
+
+struct	hw_txqueue	{
+	volatile int	head;
+	volatile int	tail;
+	volatile int	free_sz;	/* in units of 64 bytes */
+	volatile int      free_cmdsz;
+	volatile int	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	int	ac_tag;
+};
+
+
+struct	xmit_priv	{
+
+	spinlock_t lock;
+
+	struct  semaphore xmit_sema;
+	struct  semaphore terminate_xmitthread_sema;
+
+	struct __queue be_pending;
+	struct __queue bk_pending;
+	struct __queue vi_pending;
+	struct __queue vo_pending;
+	struct __queue bm_pending;
+
+	u8 *pallocated_frame_buf;
+	u8 *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+
+	struct __queue free_xmit_queue;
+
+	uint	frag_len;
+
+	struct rtw_adapter	*adapter;
+
+	u8   vcs_setting;
+	u8	vcs;
+	u8	vcs_type;
+	/* u16  rts_thresh; */
+
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	last_tx_bytes;
+	u64	last_tx_pkts;
+
+	struct hw_xmit *hwxmits;
+	u8	hwxmit_entry;
+	struct  semaphore tx_retevt;/* all tx return event; */
+	u8		txirp_cnt;/*  */
+	struct tasklet_struct xmit_tasklet;
+	/* per AC pending irp */
+	int beq_cnt;
+	int bkq_cnt;
+	int viq_cnt;
+	int voq_cnt;
+	struct __queue free_xmitbuf_queue;
+	struct __queue pending_xmitbuf_queue;
+	u8 *pallocated_xmitbuf;
+	u8 *pxmitbuf;
+	uint free_xmitbuf_cnt;
+
+	struct __queue free_xmit_extbuf_queue;
+	u8 *pallocated_xmit_extbuf;
+	u8 *pxmit_extbuf;
+	uint free_xmit_extbuf_cnt;
+
+	u16	nqos_ssn;
+
+	int	ack_tx;
+	_mutex ack_tx_mutex;
+	struct submit_ctx ack_tx_ops;
+};
+
+struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
+s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtw_count_tx_stats(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe, int sz);
+void rtw_update_protection(struct rtw_adapter *padapter, u8 *ie, uint ie_len);
+s32 rtw_make_wlanhdr(struct rtw_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
+s32 rtw_put_snap(u8 *data, u16 h_proto);
+
+struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue);
+struct tx_servq *rtw_get_sta_pending(struct rtw_adapter *padapter, struct sta_info *psta, int up, u8 *ac);
+s32 rtw_xmitframe_enqueue(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i, int entry);
+
+s32 rtw_xmit_classifier(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+int rtw_xmit_thread(void *context);
+u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
+#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
+s32 rtw_xmitframe_coalesce(struct rtw_adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe);
+s32 _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, u8 ac_tag);
+void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+
+s32 rtw_txframes_pending(struct rtw_adapter *padapter);
+s32 rtw_txframes_sta_ac_pending(struct rtw_adapter *padapter, struct pkt_attrib *pattrib);
+void rtw_init_hwxmits(struct hw_xmit *phwxmit, int entry);
+
+s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtw_adapter *padapter);
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+void rtw_alloc_hwxmits(struct rtw_adapter *padapter);
+void rtw_free_hwxmits(struct rtw_adapter *padapter);
+
+s32 rtw_xmit(struct rtw_adapter *padapter, struct sk_buff **pkt);
+
+#if defined(CONFIG_92D_AP_MODE)
+int xmitframe_enqueue_for_sleeping_sta(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe);
+void stop_sta_xmit(struct rtw_adapter *padapter, struct sta_info *psta);
+void wakeup_sta_to_xmit(struct rtw_adapter *padapter, struct sta_info *psta);
+void xmit_delivery_enabled_frames(struct rtw_adapter *padapter, struct sta_info *psta);
+#endif
+
+u8	qos_acm(u8 acm_mask, u8 priority);
+
+int rtw_ack_tx_wait(struct xmit_priv *pxmitpriv, u32 timeout_ms);
+void rtw_ack_tx_done(struct xmit_priv *pxmitpriv, int status);
+
+/* include after declaring struct xmit_buf, in order to avoid warning */
+#include <xmit_osdep.h>
+
+#endif	/* _RTL871X_XMIT_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/sta_info.h b/drivers/net/wireless/rtl8192du/include/sta_info.h
new file mode 100644
index 0000000..ad6d3a3
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/sta_info.h
@@ -0,0 +1,360 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wifi.h>
+
+#define IBSS_START_MAC_ID	2
+#define NUM_STA 32
+#define NUM_ACL 16
+
+
+/* if mode ==0, then the sta is allowed once the addr is hit. */
+/* if mode ==1, then the sta is rejected once the addr is non-hit. */
+struct rtw_wlan_acl_node {
+        struct list_head list;
+        u8       addr[ETH_ALEN];
+        u8       valid;
+};
+
+/* mode=0, disable */
+/* mode=1, accept unless in deny list */
+/* mode=2, deny unless in accept list */
+struct wlan_acl_pool {
+	int mode;
+	int num;
+	struct rtw_wlan_acl_node aclnode[NUM_ACL];
+	struct __queue acl_node_q;
+};
+
+struct rssi_sta {
+	s32	UndecoratedSmoothedPWDB;
+	s32	UndecoratedSmoothedCCK;
+	s32	UndecoratedSmoothedOFDM;
+	u64	PacketMap;
+	u8	ValidBit;
+};
+
+struct	stainfo_stats	{
+
+	u64 rx_mgnt_pkts;
+		u64 rx_beacon_pkts;
+		u64 rx_probereq_pkts;
+		u64 rx_probersp_pkts;
+		u64 rx_probersp_bm_pkts;
+		u64 rx_probersp_uo_pkts;
+	u64 rx_ctrl_pkts;
+	u64 rx_data_pkts;
+
+	u64	last_rx_mgnt_pkts;
+		u64 last_rx_beacon_pkts;
+		u64 last_rx_probereq_pkts;
+		u64 last_rx_probersp_pkts;
+		u64 last_rx_probersp_bm_pkts;
+		u64 last_rx_probersp_uo_pkts;
+	u64	last_rx_ctrl_pkts;
+	u64	last_rx_data_pkts;
+
+	u64	rx_bytes;
+	u64	rx_drops;
+
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64  tx_drops;
+
+};
+
+struct sta_info {
+	spinlock_t lock;
+	struct list_head list; /* free_sta_queue */
+	struct list_head hash_list; /* sta_hash */
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+
+	struct __queue sleep_q;
+	unsigned int sleepq_len;
+
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	u8	hwaddr[ETH_ALEN];
+
+	uint	ieee8021x_blocked;	/* 0: allowed, 1:blocked */
+	uint	dot118021XPrivacy; /* aes, tkip... */
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+	union pn48		dot11txpn;			/*  PN48 used for Unicast xmit. */
+	union pn48		dot11rxpn;			/*  PN48 used for Unicast recv. */
+
+
+	u8	bssrateset[16];
+	u32	bssratelen;
+	s32  rssi;
+	s32	signal_quality;
+
+	u8	cts2self;
+	u8	rtsen;
+
+	u8	raid;
+	u8	init_rate;
+	u32	ra_mask;
+	struct stainfo_stats sta_stats;
+
+	/* for A-MPDU TX, ADDBA timeout check */
+	struct timer_list addba_retry_timer;
+
+	/* for A-MPDU Rx reordering buffer control */
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+
+	/* for A-MPDU Tx */
+	u16	BA_starting_seqctrl[16];
+
+
+#ifdef CONFIG_80211N_HT
+	struct ht_priv	htpriv;
+#endif
+
+	/* Notes: */
+	/* STA_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO */
+	/* scan_q: AP CAP/INFO */
+
+	/* AP_Mode: */
+	/* curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO */
+	/* sta_info: (AP & STA) CAP/INFO */
+
+	struct list_head asoc_list;
+	struct list_head auth_list;
+
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	u16 capability;
+	int flags;
+
+	int dot8021xalg;/* 0:disable, 1:psk, 2:802.1x */
+	int wpa_psk;/* 0:disable, bit(0): WPA, bit(1):WPA2 */
+	int wpa_group_cipher;
+	int wpa2_group_cipher;
+	int wpa_pairwise_cipher;
+	int wpa2_pairwise_cipher;
+
+	u8 bpairwise_key_installed;
+
+#ifdef CONFIG_NATIVEAP_MLME
+	u8 wpa_ie[32];
+
+	u8 nonerp_set;
+	u8 no_short_slot_time_set;
+	u8 no_short_preamble_set;
+	u8 no_ht_gf_set;
+	u8 no_ht_set;
+	u8 ht_20mhz_set;
+#endif	/*  CONFIG_NATIVEAP_MLME */
+
+	unsigned int tx_ra_bitmap;
+	u8 qos_info;
+
+	u8 max_sp_len;
+	u8 uapsd_bk;/* BIT(0): Delivery enabled, BIT(1): Trigger enabled */
+	u8 uapsd_be;
+	u8 uapsd_vi;
+	u8 uapsd_vo;
+
+	u8 has_legacy_ac;
+	unsigned int sleepq_ac_len;
+
+	u8 under_exist_checking;
+
+	u8 keep_alive_trycnt;
+
+	u8 *passoc_req;
+	u32 assoc_req_len;
+
+	/* for DM */
+	struct rssi_sta	 rssi_stat;
+
+        /* To store the sequence number of received management frame */
+	u16 RxMgmtFrameSeqNum;
+};
+
+#define sta_rx_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts \
+	+ sta->sta_stats.rx_ctrl_pkts \
+	+ sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts \
+	+ sta->sta_stats.last_rx_ctrl_pkts \
+	+ sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_data_pkts(sta) \
+	(sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_data_pkts(sta) \
+	(sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts)
+
+#define sta_last_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts)
+
+#define sta_rx_beacon_pkts(sta) \
+	(sta->sta_stats.rx_beacon_pkts)
+
+#define sta_last_rx_beacon_pkts(sta) \
+	(sta->sta_stats.last_rx_beacon_pkts)
+
+#define sta_rx_probereq_pkts(sta) \
+	(sta->sta_stats.rx_probereq_pkts)
+
+#define sta_last_rx_probereq_pkts(sta) \
+	(sta->sta_stats.last_rx_probereq_pkts)
+
+#define sta_rx_probersp_pkts(sta) \
+	(sta->sta_stats.rx_probersp_pkts)
+
+#define sta_last_rx_probersp_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_pkts)
+
+#define sta_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.rx_probersp_bm_pkts)
+
+#define sta_last_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_bm_pkts)
+
+#define sta_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.rx_probersp_uo_pkts)
+
+#define sta_last_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_uo_pkts)
+
+#define sta_update_last_rx_pkts(sta) \
+	do { \
+		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
+		sta->sta_stats.last_rx_beacon_pkts = sta->sta_stats.rx_beacon_pkts; \
+		sta->sta_stats.last_rx_probereq_pkts = sta->sta_stats.rx_probereq_pkts; \
+		sta->sta_stats.last_rx_probersp_pkts = sta->sta_stats.rx_probersp_pkts; \
+		sta->sta_stats.last_rx_probersp_bm_pkts = sta->sta_stats.rx_probersp_bm_pkts; \
+		sta->sta_stats.last_rx_probersp_uo_pkts = sta->sta_stats.rx_probersp_uo_pkts; \
+		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
+		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
+	} while (0)
+
+#define STA_RX_PKTS_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts
+
+#define STA_LAST_RX_PKTS_ARG(sta) \
+	sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.last_rx_data_pkts
+
+#define STA_RX_PKTS_DIFF_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts - sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts - sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts -sta->sta_stats.last_rx_data_pkts
+
+#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
+
+struct	sta_priv {
+
+	u8 *pallocated_stainfo_buf;
+	u8 *pstainfo_buf;
+	struct __queue free_sta_queue;
+
+	spinlock_t sta_hash_lock;
+	struct list_head sta_hash[NUM_STA];
+	int asoc_sta_count;
+	struct __queue sleep_q;
+	struct __queue wakeup_q;
+
+	struct rtw_adapter *padapter;
+
+
+#ifdef CONFIG_92D_AP_MODE
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	spinlock_t asoc_list_lock;
+	spinlock_t auth_list_lock;
+	u8 asoc_list_cnt;
+	u8 auth_list_cnt;
+
+	unsigned int auth_to;  /* sec, time to expire in authenticating. */
+	unsigned int assoc_to; /* sec, time to expire before associating. */
+	unsigned int expire_to; /* sec , time to expire after associated. */
+
+	/* pointers to STA info; based on allocated AID or NULL if AID free
+	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
+	 * and so on
+	 */
+	struct sta_info *sta_aid[NUM_STA + 1];
+
+	u16 sta_dz_bitmap;/* only support 15 stations, staion aid bitmap for sleeping sta. */
+	u16 tim_bitmap;/* only support 15 stations, aid=0~15 mapping bit0~bit15 */
+
+	u16 max_num_sta;
+
+	struct wlan_acl_pool acl_list;
+#endif
+
+};
+
+
+__inline static u32 wifi_mac_hash(u8 *mac)
+{
+        u32 x;
+
+        x = mac[0];
+        x = (x << 2) ^ mac[1];
+        x = (x << 2) ^ mac[2];
+        x = (x << 2) ^ mac[3];
+        x = (x << 2) ^ mac[4];
+        x = (x << 2) ^ mac[5];
+
+        x ^= x >> 8;
+        x  = x & (NUM_STA - 1);
+
+        return x;
+}
+
+
+extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);
+
+#define stainfo_offset_valid(offset) (offset < NUM_STA && offset >= 0)
+int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta);
+struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset);
+
+extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
+extern u32	rtw_free_stainfo(struct rtw_adapter *padapter , struct sta_info *psta);
+extern void rtw_free_all_stainfo(struct rtw_adapter *padapter);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+extern u32 rtw_init_bcmc_stainfo(struct rtw_adapter* padapter);
+extern struct sta_info* rtw_get_bcmc_stainfo(struct rtw_adapter* padapter);
+extern u8 rtw_access_ctrl(struct rtw_adapter *padapter, u8 *mac_addr);
+
+#endif /* _STA_INFO_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/usb_hal.h b/drivers/net/wireless/rtl8192du/include/usb_hal.h
new file mode 100644
index 0000000..b1d227f
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/usb_hal.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_HAL_H__
+#define __USB_HAL_H__
+
+
+void rtl8192cu_set_hal_ops(struct rtw_adapter * padapter);
+
+void rtl8192du_set_hal_ops(struct rtw_adapter * padapter);
+#ifdef CONFIG_WOWLAN
+#ifdef CONFIG_WOWLAN_MANUAL
+extern int rtw_suspend_toshiba(struct rtw_adapter * adapter);
+extern int rtw_resume_toshiba(struct rtw_adapter * adapter);
+#endif /*  CONFIG_WOWLAN_MANUAL */
+#endif /* CONFIG_WOWLAN */
+
+#endif /* __USB_HAL_H__ */
diff --git a/drivers/net/wireless/rtl8192du/include/usb_ops.h b/drivers/net/wireless/rtl8192du/include/usb_ops.h
new file mode 100644
index 0000000..d19ad1a
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/usb_ops.h
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <osdep_intf.h>
+
+#define REALTEK_USB_VENQT_READ		0xC0
+#define REALTEK_USB_VENQT_WRITE		0x40
+#define REALTEK_USB_VENQT_CMD_REQ	0x05
+#define REALTEK_USB_VENQT_CMD_IDX	0x00
+
+enum{
+	VENDOR_WRITE = 0x00,
+	VENDOR_READ = 0x01,
+};
+#define ALIGNMENT_UNIT				16
+#define MAX_VENDOR_REQ_CMD_SIZE	254		/* 8188cu SIE Support */
+#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size, timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), (timeout_ms))
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), (timeout_ms))
+#else
+#define rtw_usb_control_msg(dev, pipe, request, requesttype, value, index, data, size,timeout_ms) \
+	usb_control_msg((dev), (pipe), (request), (requesttype), (value), (index), (data), (size), \
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+#define rtw_usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout_ms) \
+	usb_bulk_msg((usb_dev), (pipe), (data), (len), (actual_length), \
+		((timeout_ms) == 0) ||((timeout_ms)*HZ/1000>0)?((timeout_ms)*HZ/1000):1)
+#endif
+#include <usb_ops_linux.h>
+
+void rtl8192du_set_intf_ops(struct _io_ops *pops);
+#define usb_set_intf_ops	rtl8192du_set_intf_ops
+
+void rtl8192du_recv_tasklet(void *priv);
+
+void rtl8192du_xmit_tasklet(void *priv);
+
+/*
+* Increase and check if the continual_urb_error of this @param dvobjprive is larger than MAX_CONTINUAL_URB_ERR
+* @return true:
+* @return false:
+*/
+static inline int rtw_inc_and_chk_continual_urb_error(struct dvobj_priv *dvobj)
+{
+	int ret = false;
+	int value;
+	if ((value=ATOMIC_INC_RETURN(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
+		DBG_8192D("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
+		ret = true;
+	}
+	return ret;
+}
+
+/*
+* Set the continual_urb_error of this @param dvobjprive to 0
+*/
+static inline void rtw_reset_continual_urb_error(struct dvobj_priv *dvobj)
+{
+	ATOMIC_SET(&dvobj->continual_urb_error, 0);
+}
+
+#endif /* __USB_OPS_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/usb_ops_linux.h b/drivers/net/wireless/rtl8192du/include/usb_ops_linux.h
new file mode 100644
index 0000000..31db98a
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/usb_ops_linux.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_LINUX_H__
+#define __USB_OPS_LINUX_H__
+
+#define VENDOR_CMD_MAX_DATA_LEN	254
+
+#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10/* ms */
+#define RTW_USB_CONTROL_MSG_TIMEOUT	500/* ms */
+
+#define MAX_USBCTRL_VENDORREQ_TIMES	1
+
+#define RTW_USB_BULKOUT_TIMEOUT	5000/* ms */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)) || (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+#define _usbctrl_vendorreq_async_callback(urb, regs)	_usbctrl_vendorreq_async_callback(urb)
+#define usb_bulkout_zero_complete(purb, regs)	usb_bulkout_zero_complete(purb)
+#define usb_write_mem_complete(purb, regs)	usb_write_mem_complete(purb)
+#define usb_write_port_complete(purb, regs)	usb_write_port_complete(purb)
+#define usb_read_port_complete(purb, regs)	usb_read_port_complete(purb)
+#define usb_read_interrupt_complete(purb, regs)	usb_read_interrupt_complete(purb)
+#endif
+
+unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr);
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem);
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+
+void usb_read_port_cancel(struct intf_hdl *pintfhdl);
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem);
+void usb_write_port_cancel(struct intf_hdl *pintfhdl);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/usb_osintf.h b/drivers/net/wireless/rtl8192du/include/usb_osintf.h
new file mode 100644
index 0000000..e2f201b
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/usb_osintf.h
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OSINTF_H
+#define __USB_OSINTF_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <usb_vendor_req.h>
+
+#define USBD_HALTED(Status) ((u32)(Status) >> 30 == 3)
+
+#ifdef CONFIG_80211N_HT
+extern int rtw_ht_enable;
+extern int rtw_cbw40_enable;
+extern int rtw_ampdu_enable;/* for enable tx_ampdu */
+#endif
+
+extern int rtw_mc2u_disable;
+extern char *rtw_initmac;
+
+u8 usbvendorrequest(struct dvobj_priv *pdvobjpriv,
+		    enum RT_USB_BREQUEST brequest,
+		    enum RT_USB_WVALUE wvalue, u8 windex, void *data,
+		    u8 datalen, u8 isdirectionin);
+
+void netdev_br_init(struct net_device *netdev);
+int pm_netdev_open(struct net_device *pnetdev,u8 bnormal);
+int nat25_db_handle(struct rtw_adapter *priv, struct sk_buff *skb, int method);
+int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
+void dhcp_flag_bcast(struct rtw_adapter *priv, struct sk_buff *skb);
+void *scdb_findentry(struct rtw_adapter *priv, unsigned char *macaddr,
+		     unsigned char *ipaddr);
+void nat25_db_expire(struct rtw_adapter *priv);
+u8 str_2char2num(u8 hch, u8 lch);
+u8 str_2char2num(u8 hch, u8 lch);
+u8 key_2char2num(u8 hch, u8 lch);
+u8 convert_ip_addr(u8 hch, u8 mch, u8 lch);
+void process_wmmps_data(struct rtw_adapter *padapter,
+			struct recv_frame_hdr *precv_frame);
+s32 c2h_evt_hdl(struct rtw_adapter *adapter, struct c2h_evt_hdr *c2h_evt,
+		c2h_id_filter filter);
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/usb_vendor_req.h b/drivers/net/wireless/rtl8192du/include/usb_vendor_req.h
new file mode 100644
index 0000000..a92f821
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/usb_vendor_req.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+/* 4	Set/Get Register related wIndex/Data */
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+/* 4	Set/Get SYSCLK related	wValue or Data */
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+enum RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+};
+
+
+enum RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+};
+
+#endif
diff --git a/drivers/net/wireless/rtl8192du/include/wifi.h b/drivers/net/wireless/rtl8192du/include/wifi.h
new file mode 100644
index 0000000..8982140
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/wifi.h
@@ -0,0 +1,1127 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+
+#ifdef BIT
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	/*  QoS Data */
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+    /*  below is for mgt frame */
+    WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+    WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+    WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+    WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+    WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+    WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+    WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+    WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+
+    /*  below is for control frame */
+    WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+    WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+    /*  below is for data frame */
+    WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+    WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+    WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	/*  WPA reason */
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	/* belowing are Realtek definition */
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+	_RSON_TDLS_TEAR_TOOFAR_			= 25,
+	_RSON_TDLS_TEAR_UN_RSN_			= 26,
+};
+
+/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+/* IEEE 802.11h */
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+/* IEEE 802.11i */
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+};
+
+/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* entended */
+/* IEEE 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+/* IEEE 802.11h */
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+/* IEEE 802.11g */
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
+#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
+/* IEEE 802.11w */
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+/* IEEE 802.11i */
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+/* IEEE 802.11r */
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while (0)
+
+#define GetToDs(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while (0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while (0)
+
+#define GetFrDs(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while (0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while (0)
+
+#define GetMFrag(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while (0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while (0)
+
+#define GetRetry(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while (0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while (0)
+
+#define GetPwrMgt(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while (0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while (0)
+
+#define GetMData(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while (0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while (0)
+
+#define GetPrivacy(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(__le16 *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while (0)
+
+
+#define GetOrder(pbuf)	(((*(__le16 *)(pbuf)) & cpu_to_le16(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf,type)	\
+	do {	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while (0)
+
+#define GetFrameSubType(pbuf)	(le16_to_cpu(*(__le16 *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(__le16 *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(__le16 *)(pbuf) |= cpu_to_le16(type); \
+	} while (0)
+
+#define GetSequence(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((SIZE_PTR)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while (0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 22) = \
+			((*(__le16 *)((SIZE_PTR)(pbuf) + 22)) & cpu_to_le16((unsigned short)0x000f)) | \
+			cpu_to_le16((unsigned short)(0xfff0 & (num << 4))); \
+	} while (0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(__le16 *)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while (0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while (0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(__le16 *)(pbuf))) & 0xf)
+
+#define SetEOSP(pbuf, eosp)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((eosp & 1) << 4); \
+	} while (0)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((ack & 3) << 5); \
+	} while (0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(__le16 *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(__le16 *)(pbuf) |= cpu_to_le16((amsdu & 1) << 7); \
+	} while (0)
+
+#define GetAid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(le16_to_cpu(*(__le16 *)((SIZE_PTR)(pbuf) +	\
+			(((GetToDs(pbuf)<<1) | GetFrDs(pbuf)) == 3 ?	\
+			30 : 24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
+
+#define MacAddr_isBcst(addr) \
+(\
+	((addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff))  ? true : false \
+)
+
+__inline static int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01)
+		return true;
+	else
+		return false;
+}
+
+
+__inline static unsigned char * get_da(unsigned char *pframe)
+{
+	unsigned char	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	/*  ToDs=0, FromDs=0 */
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x01:	/*  ToDs=0, FromDs=1 */
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x02:	/*  ToDs=1, FromDs=0 */
+			da = GetAddr3Ptr(pframe);
+			break;
+		default:	/*  ToDs=1, FromDs=1 */
+			da = GetAddr3Ptr(pframe);
+			break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char * get_sa(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	/*  ToDs=0, FromDs=0 */
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x01:	/*  ToDs=0, FromDs=1 */
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x02:	/*  ToDs=1, FromDs=0 */
+			sa = GetAddr2Ptr(pframe);
+			break;
+		default:	/*  ToDs=1, FromDs=1 */
+			sa = GetAddr4Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char * get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	/*  ToDs=0, FromDs=0 */
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x01:	/*  ToDs=0, FromDs=1 */
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x02:	/*  ToDs=1, FromDs=0 */
+			sa = GetAddr1Ptr(pframe);
+			break;
+		case 0x03:	/*  ToDs=1, FromDs=1 */
+			sa = GetAddr1Ptr(pframe);
+			break;
+		default:
+			sa =NULL; /*  */
+			break;
+	}
+
+	return sa;
+}
+
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if (WIFI_CTRL_TYPE == GetFrameType(pframe))
+		return true;
+	else
+		return false;
+}
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
+#define _ACKCTSLNG_				14	/* 14 bytes long, including crclng */
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	/*  excluding wlan_hdr */
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+#define _PUBLIC_ACTION_IE_OFFSET_	8
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _COUNTRY_IE_			7
+#define _CHLGETXT_IE_			16
+#define _POW_CAP_IE_			33
+#define _SUPPORTED_CH_IE_		36
+#define _CH_SWTICH_ANNOUNCE_	37	/* Secondary Channel Offset */
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _FTIE_						55
+#define _TIMEOUT_ITVL_IE_			56
+#define _SRC_IE_				59
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 /* _HT_EXTRA_INFO_IE_ */
+
+#define	EID_BSSCoexistence			72 /*  20/40 BSS Coexistence */
+#define	EID_BSSIntolerantChlReport	73
+#define _RIC_Descriptor_IE_			75
+
+#define _LINK_ID_IE_					101
+#define _CH_SWITCH_TIMING_		104
+#define _PTI_BUFFER_STATUS_		106
+#define _EXT_CAP_IE_				127
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+#define cap_PBCC	BIT(6)
+#define cap_ChAgility	BIT(7)
+#define cap_SpecMgmt	BIT(8)
+#define cap_QoS	BIT(9)
+#define cap_ShortSlot	BIT(10)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		/*  WPA */
+#define _IEEE8021X_PSK_			2		/*  WPA with pre-shared key */
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  /*  for WMM STA */
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/* ifdef CONFIG_80211N_HT */
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while (0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct rtw_ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct rtw_ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __attribute__((packed));
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+ /**
+ * struct rtw_ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+
+struct rtw_ieee80211_ht_cap {
+	unsigned short	cap_info;
+	unsigned char	ampdu_params_info;
+	unsigned char	supp_mcs_set[16];
+	unsigned short	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__ ((packed));
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char	control_chan;
+	unsigned char	ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char	basic_set[16];
+} __attribute__ ((packed));
+
+
+struct HT_caps_element {
+	union {
+		struct {
+			__le16	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			__le16	HT_ext_caps;
+			__le32	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	}u;
+} __attribute__ ((packed));
+
+struct HT_info_element {
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+}  __attribute__ ((packed));
+
+struct AC_param {
+	unsigned char	ACI_AIFSN;
+	unsigned char	CW;
+	__le16	TXOP_limit;
+}  __attribute__ ((packed));
+
+struct WMM_para_element {
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+}  __attribute__ ((packed));
+
+struct ADDBA_request {
+	unsigned char		dialog_token;
+	__le16	BA_para_set;
+	__le16	BA_timeout_value;
+	__le16	BA_starting_seqctrl;
+}  __attribute__ ((packed));
+
+ /**
+ * struct cfg80211_mgmt_tx_params - mgmt tx parameters
+ *
+ * This structure provides information needed to transmit a mgmt frame
+ *
+ * @chan: channel to use
+ * @offchan: indicates wether off channel operation is required
+ * @wait: duration for ROC
+ * @buf: buffer to transmit
+ * @len: buffer length
+ * @no_cck: don't use cck rates for this frame
+ * @dont_wait_for_ack: tells the low level not to wait for an ack
+ */
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE		0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFA0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+#define OP_MODE_PURE                    0
+#define OP_MODE_MAY_BE_LEGACY_STAS      1
+#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
+#define OP_MODE_MIXED                   3
+
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
+#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
+#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))
+
+#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
+		((u16) (0x0001 | 0x0002))
+#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
+#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
+#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
+#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))
+
+#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
+#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
+#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
+#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
+
+
+
+/* endif */
+
+/* 	===============WPS Section=============== */
+/* 	For WPSv1.0 */
+#define WPSOUI							0x0050f204
+/* 	WPS attribute ID */
+#define WPS_ATTR_VER1					0x104A
+#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
+#define WPS_ATTR_RESP_TYPE			0x103B
+#define WPS_ATTR_UUID_E				0x1047
+#define WPS_ATTR_MANUFACTURER		0x1021
+#define WPS_ATTR_MODEL_NAME			0x1023
+#define WPS_ATTR_MODEL_NUMBER		0x1024
+#define WPS_ATTR_SERIAL_NUMBER		0x1042
+#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
+#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
+#define WPS_ATTR_DEVICE_NAME			0x1011
+#define WPS_ATTR_CONF_METHOD			0x1008
+#define WPS_ATTR_RF_BANDS				0x103C
+#define WPS_ATTR_DEVICE_PWID			0x1012
+#define WPS_ATTR_REQUEST_TYPE			0x103A
+#define WPS_ATTR_ASSOCIATION_STATE	0x1002
+#define WPS_ATTR_CONFIG_ERROR			0x1009
+#define WPS_ATTR_VENDOR_EXT			0x1049
+#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
+
+/* 	Value of WPS attribute "WPS_ATTR_DEVICE_NAME */
+#define WPS_MAX_DEVICE_NAME_LEN		32
+
+/* 	Value of WPS Request Type Attribute */
+#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
+#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
+#define WPS_REQ_TYPE_REGISTRAR					0x02
+#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
+
+/* 	Value of WPS Response Type Attribute */
+#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
+#define WPS_RESPONSE_TYPE_8021X		0x01
+#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
+#define WPS_RESPONSE_TYPE_AP			0x03
+
+/* 	Value of WPS WiFi Simple Configuration State Attribute */
+#define WPS_WSC_STATE_NOT_CONFIG	0x01
+#define WPS_WSC_STATE_CONFIG			0x02
+
+/* 	Value of WPS Version Attribute */
+#define WPS_VERSION_1					0x10
+
+/* 	Value of WPS Configuration Method Attribute */
+#define WPS_CONFIG_METHOD_FLASH		0x0001
+#define WPS_CONFIG_METHOD_ETHERNET	0x0002
+#define WPS_CONFIG_METHOD_LABEL		0x0004
+#define WPS_CONFIG_METHOD_DISPLAY	0x0008
+#define WPS_CONFIG_METHOD_E_NFC		0x0010
+#define WPS_CONFIG_METHOD_I_NFC		0x0020
+#define WPS_CONFIG_METHOD_NFC		0x0040
+#define WPS_CONFIG_METHOD_PBC		0x0080
+#define WPS_CONFIG_METHOD_KEYPAD	0x0100
+#define WPS_CONFIG_METHOD_VPBC		0x0280
+#define WPS_CONFIG_METHOD_PPBC		0x0480
+#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
+#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
+
+/* 	Value of Category ID of WPS Primary Device Type Attribute */
+#define WPS_PDT_CID_DISPLAYS			0x0007
+#define WPS_PDT_CID_MULIT_MEDIA		0x0008
+#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
+
+/* 	Value of Sub Category ID of WPS Primary Device Type Attribute */
+#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
+#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
+
+/* 	Value of Device Password ID */
+#define WPS_DPID_PIN					0x0000
+#define WPS_DPID_USER_SPEC			0x0001
+#define WPS_DPID_MACHINE_SPEC			0x0002
+#define WPS_DPID_REKEY					0x0003
+#define WPS_DPID_PBC					0x0004
+#define WPS_DPID_REGISTRAR_SPEC		0x0005
+
+/* 	Value of WPS RF Bands Attribute */
+#define WPS_RF_BANDS_2_4_GHZ		0x01
+#define WPS_RF_BANDS_5_GHZ		0x02
+
+/* 	Value of WPS Association State Attribute */
+#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
+#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
+#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
+#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
+#define WPS_ASSOC_STATE_IP_FAILURE				0x04
+
+/* 	=====================P2P Section===================== */
+/* 	For P2P */
+#define	P2POUI							0x506F9A09
+
+/* 	P2P Attribute ID */
+#define	P2P_ATTR_STATUS					0x00
+#define	P2P_ATTR_MINOR_REASON_CODE		0x01
+#define	P2P_ATTR_CAPABILITY				0x02
+#define	P2P_ATTR_DEVICE_ID				0x03
+#define	P2P_ATTR_GO_INTENT				0x04
+#define	P2P_ATTR_CONF_TIMEOUT			0x05
+#define	P2P_ATTR_LISTEN_CH				0x06
+#define	P2P_ATTR_GROUP_BSSID				0x07
+#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
+#define	P2P_ATTR_INTENTED_IF_ADDR		0x09
+#define	P2P_ATTR_MANAGEABILITY			0x0A
+#define	P2P_ATTR_CH_LIST					0x0B
+#define	P2P_ATTR_NOA						0x0C
+#define	P2P_ATTR_DEVICE_INFO				0x0D
+#define	P2P_ATTR_GROUP_INFO				0x0E
+#define	P2P_ATTR_GROUP_ID					0x0F
+#define	P2P_ATTR_INTERFACE				0x10
+#define	P2P_ATTR_OPERATING_CH			0x11
+#define	P2P_ATTR_INVITATION_FLAGS		0x12
+
+/* 	Value of Status Attribute */
+#define	P2P_STATUS_SUCCESS						0x00
+#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
+#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
+#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
+#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
+#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
+#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
+#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
+#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
+#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
+
+/* 	Value of Inviation Flags Attribute */
+#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
+
+#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
+									P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
+									P2P_DEVCAP_CONCURRENT_OPERATION | \
+									P2P_DEVCAP_INVITATION_PROC)
+
+#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
+
+/* 	Value of Device Capability Bitmap */
+#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
+#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
+#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
+#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
+#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
+#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
+
+/* 	Value of Group Capability Bitmap */
+#define	P2P_GRPCAP_GO							BIT(0)
+#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
+#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
+#define	P2P_GRPCAP_INTRABSS					BIT(3)
+#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
+#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
+#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
+
+/* 	P2P Public Action Frame (Management Frame) */
+#define	P2P_PUB_ACTION_ACTION				0x09
+
+/* 	P2P Public Action Frame Type */
+#define	P2P_GO_NEGO_REQ						0
+#define	P2P_GO_NEGO_RESP						1
+#define	P2P_GO_NEGO_CONF						2
+#define	P2P_INVIT_REQ							3
+#define	P2P_INVIT_RESP							4
+#define	P2P_DEVDISC_REQ						5
+#define	P2P_DEVDISC_RESP						6
+#define	P2P_PROVISION_DISC_REQ				7
+#define	P2P_PROVISION_DISC_RESP				8
+
+/* 	P2P Action Frame Type */
+#define	P2P_NOTICE_OF_ABSENCE	0
+#define	P2P_PRESENCE_REQUEST		1
+#define	P2P_PRESENCE_RESPONSE	2
+#define	P2P_GO_DISC_REQUEST		3
+
+
+#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
+
+#define	P2P_PROVISIONING_SCAN_CNT			3
+
+#define	P2P_WILDCARD_SSID_LEN				7
+
+#define	P2P_FINDPHASE_EX_NONE				0	/*  default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase */
+#define	P2P_FINDPHASE_EX_FULL				1	/*  used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase */
+#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
+#define	P2P_FINDPHASE_EX_MAX					4
+#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
+
+#define	P2P_PROVISION_TIMEOUT				5000	/* 	5 seconds timeout for sending the provision discovery request */
+#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	/* 	3 seconds timeout for sending the provision discovery request under concurrent mode */
+#define	P2P_GO_NEGO_TIMEOUT					5000	/* 	5 seconds timeout for receiving the group negotation response */
+#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	/* 	3 seconds timeout for sending the negotiation request under concurrent mode */
+#define	P2P_TX_PRESCAN_TIMEOUT				100		/* 	100ms */
+#define	P2P_INVITE_TIMEOUT					5000	/* 	5 seconds timeout for sending the invitation request */
+#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	/* 	3 seconds timeout for sending the invitation request under concurrent mode */
+#define	P2P_RESET_SCAN_CH						15000	/* 	15 seconds timeout to reset the scan channel (based on channel plan) */
+#define	P2P_MAX_INTENT						15
+
+#define	P2P_MAX_NOA_NUM						2
+
+/* 	WPS Configuration Method */
+#define	WPS_CM_NONE							0x0000
+#define	WPS_CM_LABEL							0x0004
+#define	WPS_CM_DISPLYA						0x0008
+#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
+#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
+#define	WPS_CM_NFC_INTERFACE					0x0040
+#define	WPS_CM_PUSH_BUTTON					0x0080
+#define	WPS_CM_KEYPAD						0x0100
+#define	WPS_CM_SW_PUHS_BUTTON				0x0280
+#define	WPS_CM_HW_PUHS_BUTTON				0x0480
+#define	WPS_CM_SW_DISPLAY_PIN				0x2008
+#define	WPS_CM_LCD_DISPLAY_PIN				0x4008
+
+enum P2P_ROLE {
+	P2P_ROLE_DISABLE = 0,
+	P2P_ROLE_DEVICE = 1,
+	P2P_ROLE_CLIENT = 2,
+	P2P_ROLE_GO = 3
+};
+
+enum P2P_STATE {
+	P2P_STATE_NONE = 0,							/* 	P2P disable */
+	P2P_STATE_IDLE = 1,								/* 	P2P had enabled and do nothing */
+	P2P_STATE_LISTEN = 2,							/* 	In pure listen state */
+	P2P_STATE_SCAN = 3,							/* 	In scan phase */
+	P2P_STATE_FIND_PHASE_LISTEN = 4,				/* 	In the listen state of find phase */
+	P2P_STATE_FIND_PHASE_SEARCH = 5,				/* 	In the search state of find phase */
+	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			/* 	In P2P provisioning discovery */
+	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
+	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
+	P2P_STATE_GONEGO_ING = 9,						/* 	Doing the group owner negoitation handshake */
+	P2P_STATE_GONEGO_OK = 10,						/* 	finish the group negoitation handshake with success */
+	P2P_STATE_GONEGO_FAIL = 11,					/* 	finish the group negoitation handshake with failure */
+	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		/* 	receiving the P2P Inviation request and match with the profile. */
+	P2P_STATE_PROVISIONING_ING = 13,				/* 	Doing the P2P WPS */
+	P2P_STATE_PROVISIONING_DONE = 14,			/* 	Finish the P2P WPS */
+	P2P_STATE_TX_INVITE_REQ = 15,					/* 	Transmit the P2P Invitation request */
+	P2P_STATE_RX_INVITE_RESP_OK = 16,				/* 	Receiving the P2P Invitation response with sucess */
+	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	/* 	receiving the P2P Inviation request and dismatch with the profile. */
+	P2P_STATE_RECV_INVITE_REQ_GO = 18,			/* 	receiving the P2P Inviation request and this wifi is GO. */
+	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			/* 	receiving the P2P Inviation request to join an existing P2P Group. */
+	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			/* 	recveing the P2P Inviation response with failure */
+	P2P_STATE_RX_INFOR_NOREADY = 21,			/*  receiving p2p negoitation response with information is not available */
+	P2P_STATE_TX_INFOR_NOREADY = 22,			/*  sending p2p negoitation response with information is not available */
+};
+
+enum P2P_WPSINFO {
+	P2P_NO_WPSINFO						= 0,
+	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
+	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
+	P2P_GOT_WPSINFO_PBC					= 3,
+};
+
+#define	P2P_PRIVATE_IOCTL_SET_LEN		64
+
+enum P2P_PROTO_WK_ID
+{
+	P2P_FIND_PHASE_WK = 0,
+	P2P_RESTORE_STATE_WK = 1,
+	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
+	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
+	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
+	P2P_AP_P2P_CH_SWITCH_PROCESS_WK =5,
+	P2P_RO_CH_WK = 6,
+};
+
+/* 	=====================WFD Section===================== */
+/* 	For Wi-Fi Display */
+#define	WFD_ATTR_DEVICE_INFO			0x00
+#define	WFD_ATTR_ASSOC_BSSID			0x01
+#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
+#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
+#define	WFD_ATTR_SESSION_INFO		0x09
+#define	WFD_ATTR_ALTER_MAC			0x0a
+
+/* 	For WFD Device Information Attribute */
+#define	WFD_DEVINFO_SOURCE					0x0000
+#define	WFD_DEVINFO_PSINK					0x0001
+#define	WFD_DEVINFO_SSINK					0x0002
+#define	WFD_DEVINFO_DUAL					0x0003
+
+#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
+#define	WFD_DEVINFO_WSD						0x0040
+#define	WFD_DEVINFO_PC_TDLS					0x0080
+#define	WFD_DEVINFO_HDCP_SUPPORT			0x0100
+
+#define IP_MCAST_MAC(mac)	((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
+extern unsigned char REALTEK_96B_IE[6];
+extern unsigned char MCS_rate_2R[16];
+extern unsigned char MCS_rate_1R[16];
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WPA_TKIP_CIPHER[4];
+extern unsigned char RSN_TKIP_CIPHER[4];
+extern unsigned char WMM_OUI[];
+extern unsigned char WPS_OUI[];
+extern unsigned char P2P_OUI[];
+extern unsigned char WFD_OUI[];
+
+
+#endif /*  _WIFI_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/wlan_bssdef.h b/drivers/net/wireless/rtl8192du/include/wlan_bssdef.h
new file mode 100644
index 0000000..889f1a8
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/wlan_bssdef.h
@@ -0,0 +1,319 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+#define MAX_IE_SZ	768
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+struct ndis_802_11_ssid {
+	u32  SsidLength;
+	u8  Ssid[32];
+};
+
+enum NDIS_802_11_NETWORK_TYPE {
+	NDIS802_11FH,
+	NDIS802_11DS,
+	NDIS802_11OFDM5,
+	NDIS802_11OFDM24,
+	NDIS802_11NetworkTypeMax    /*  not a real type - upper bound */
+};
+
+struct ndis_802_11_config_fh {
+    u32           Length;             /*  Length of structure */
+    u32           HopPattern;         /*  As defined by 802.11, MSB set */
+    u32           HopSet;             /*  to one if non-802.11 */
+    u32           DwellTime;          /*  units are Kusec */
+};
+
+
+/*	FW will only save the channel number in DSConfig.
+ *	ODI Handler will convert the channel number to freq. number.
+ */
+struct ndis_802_11_config {
+	u32           Length;             /*  Length of structure */
+	u32           BeaconPeriod;       /*  units are Kusec */
+	u32           ATIMWindow;         /*  units are Kusec */
+	u32           DSConfig;           /*  Frequency, units are kHz */
+	struct ndis_802_11_config_fh    FHConfig;
+};
+
+enum NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	NDIS802_11IBSS,
+	NDIS802_11INFRA,
+	NDIS802_11AUTOUNK,
+	NDIS802_11INFRA_MAX,     /*  Not a real value, defined as upper bound */
+	NDIS802_11APMODE
+};
+
+struct ndis_802_11_fixed_ies {
+	u8  Timestamp[8];
+	u16  BeaconInterval;
+	u16  Capabilities;
+};
+
+struct ndis_802_11_variable_ies {
+	u8  ElementID;
+	u8  Length;
+	u8  data[1];
+};
+
+/*
+Length is the 4 bytes multiples of the sume of
+	6 * sizeof(unsigned char) + 2 + sizeof (struct ndis_802_11_ssid) + sizeof (u32)
++   sizeof (long) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (struct ndis_802_11_config)
++   NDIS_802_11_LENGTH_RATES_EX * sizeof(unsigned char) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+*/
+
+enum NDIS_802_11_AUTHENTICATION_MODE {
+	NDIS802_11AUTHMODEOPEN,
+	NDIS802_11AUTHMODESHARED,
+	NDIS802_11AUTHMODESWITCH,
+	NDIS802_11AUTHMODEWPA,
+	NDIS802_11AUTHMODEWPAPSK,
+	NDIS802_11AUTHMODEWPANONE,
+	NDIS802_11AUTHMODEMAX               /*  Not a real mode, defined as upper bound */
+};
+
+enum NDIS_802_11_ENCRYPTION_STATUS {
+	NDIS802_11WEP_ENABLED,
+	NDIS802_11ENCRYPTION1ENABLED = NDIS802_11WEP_ENABLED,
+	NDIS802_11WEPDISABLED,
+	NDIS802_11ENCRYPTION_DISABLED = NDIS802_11WEPDISABLED,
+	NDIS802_11WEPKEYABSENT,
+	NDIS802_11ENCRYPTION1KEYABSENT = NDIS802_11WEPKEYABSENT,
+	NDIS802_11WEPNOTSUPPORTED,
+	NDIS802_11ENCRYPTIONNOTSUPPORTED = NDIS802_11WEPNOTSUPPORTED,
+	NDIS802_11ENCRYPTION2ENABLED,
+	NDIS802_11ENCRYPTION2KEYABSENT,
+	NDIS802_11ENCRYPTION3ENABLED,
+	NDIS802_11ENCRYPTION3KEYABSENT
+};
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+struct ndis_802_11_ai_reqfi {
+    u16 Capabilities;
+    u16 ListenInterval;
+    unsigned char  CurrentAPAddress[6];
+};
+
+struct ndis_802_11_ai_resfi {
+    u16 Capabilities;
+    u16 StatusCode;
+    u16 AssociationId;
+};
+
+struct ndis_802_11_assoc_info {
+    u32                   Length;
+    u16                  AvailableRequestFixedIEs;
+    struct ndis_802_11_ai_reqfi    RequestFixedIEs;
+    u32                   RequestIELength;
+    u32                   OffsetRequestIEs;
+    u16                  AvailableResponseFixedIEs;
+    struct ndis_802_11_ai_resfi ResponseFixedIEs;
+    u32                   ResponseIELength;
+    u32                   OffsetResponseIEs;
+};
+
+/*  Key mapping keys require a BSSID */
+struct ndis_802_11_key {
+    u32           Length;             /*  Length of this structure */
+    u32           KeyIndex;
+    u32           KeyLength;          /*  length of key in bytes */
+    unsigned char BSSID[6];
+    unsigned long long KeyRSC;
+    u8           KeyMaterial[32];     /*  variable length depending on above field */
+};
+
+struct ndis_802_11_remove_key {
+    u32                   Length;        /*  Length of this structure */
+    u32                   KeyIndex;
+    unsigned char BSSID[6];
+};
+
+struct ndis_802_11_wep {
+    u32     Length;        /*  Length of this structure */
+    u32     KeyIndex;      /*  0 is the per-client key, 1-N are the global keys */
+    u32     KeyLength;     /*  length of key in bytes */
+    u8     KeyMaterial[16];/*  variable length depending on above field */
+};
+
+struct ndis_802_11_auth_req {
+    u32 Length;            /*  Length of structure */
+    unsigned char Bssid[6];
+    u32 Flags;
+};
+
+enum NDIS_802_11_STATUS_TYPE {
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    /*  not a real type, defined as an upper bound */
+};
+
+struct ndis_802_11_status_ind {
+	enum NDIS_802_11_STATUS_TYPE StatusType;
+};
+
+/*  mask for authentication/integrity fields */
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+/*  MIC check time, 60 seconds. */
+#define MIC_CHECK_TIME	60000000
+
+struct ndis_802_11_auth_event {
+    struct ndis_802_11_status_ind Status;
+    struct ndis_802_11_auth_req Request[1];
+};
+
+struct ndis_802_11_test {
+    u32 Length;
+    u32 Type;
+    union {
+        struct ndis_802_11_auth_event AuthenticationEvent;
+        long RssiTrigger;
+    } tt;
+};
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (NDIS802_11INFRA_MAX+1)
+#endif
+
+struct wlan_phy_info {
+	u8	SignalStrength;/* in percentage) */
+	u8	SignalQuality;/* in percentage) */
+	u8	Optimum_antenna;  /* for Antenna diversity */
+	u8	Reserved_0;
+};
+
+struct wlan_bssid_ex {
+	u32  Length;
+	unsigned char  MacAddress[6];
+	u8  Reserved[2];/* 0]: IS beacon frame */
+	struct ndis_802_11_ssid  Ssid;
+	u32  Privacy;
+	long  Rssi;/* in dBM,raw data ,get from PHY) */
+	enum NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+	struct ndis_802_11_config  Configuration;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+	unsigned char SupportedRates[NDIS_802_11_LENGTH_RATES_EX];
+	struct wlan_phy_info PhyInfo;
+	u32  IELength;
+	u8  IEs[MAX_IE_SZ];	/* timestamp, beacon interval, and capability information) */
+} __packed;
+
+__inline  static uint get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss)
+{
+	return (sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + bss->IELength);
+}
+
+struct	wlan_network {
+	struct list_head list;
+	int	network_type;	/* refer to ieee80211.h for WIRELESS_11A/B/G */
+	int	fixed;			/*  set to fixed when not to be removed as site-surveying */
+	unsigned long	last_scanned; /* timestamp for the network */
+	int	aid;			/* will only be valid when a BSS is joinned. */
+	int	join_res;
+	struct wlan_bssid_ex network; /* must be the last item */
+};
+
+enum VRTL_CARRIER_SENSE
+{
+    DISABLE_VCS,
+    ENABLE_VCS,
+    AUTO_VCS
+};
+
+enum VCS_TYPE
+{
+    NONE_VCS,
+    RTS_CTS,
+    CTS_TO_SELF
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP
+{
+	NO_LIMIT,
+       TWO_MSDU,
+       FOUR_MSDU,
+       SIX_MSDU
+};
+
+
+/* john */
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+*	WPA2
+*/
+
+struct pmkid_candidate {
+	unsigned char BSSID[6];
+	u32 Flags;
+};
+
+struct ndis_802_11_pmkid_list {
+	u32 Version;       /*  Version of the structure */
+	u32 NumCandidates; /*  No. of pmkid candidates */
+	struct pmkid_candidate CandidateList[1];
+};
+
+struct ndis_802_11_auth_encr {
+	enum NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
+	enum NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
+
+};
+
+struct ndis_802_11_capa {
+	u32  Length;
+	u32  Version;
+	u32  NoOfPMKIDs;
+	u32  NoOfAuthEncryptPairsSupported;
+	struct ndis_802_11_auth_encr AuthenticationEncryptionSupported[1];
+
+};
+
+
+#endif /* ifndef WLAN_BSSDEF_H_ */
diff --git a/drivers/net/wireless/rtl8192du/include/xmit_osdep.h b/drivers/net/wireless/rtl8192du/include/xmit_osdep.h
new file mode 100644
index 0000000..2e230bf
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/include/xmit_osdep.h
@@ -0,0 +1,43 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+int rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev);
+
+void rtw_os_xmit_schedule(struct rtw_adapter *padapter);
+
+int rtw_os_xmit_resource_alloc(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 alloc_sz);
+void rtw_os_xmit_resource_free(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz);
+
+void rtw_set_tx_chksum_offload(struct sk_buff *pkt, struct pkt_attrib *pattrib);
+
+void rtw_os_pkt_complete(struct rtw_adapter *padapter, struct sk_buff *pkt);
+void rtw_os_xmit_complete(struct rtw_adapter *padapter, struct xmit_frame *pxframe);
+
+#endif /* __XMIT_OSDEP_H_ */
diff --git a/drivers/net/wireless/rtl8192du/os_dep/ioctl_cfg80211.c b/drivers/net/wireless/rtl8192du/os_dep/ioctl_cfg80211.c
new file mode 100644
index 0000000..1223def
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/ioctl_cfg80211.c
@@ -0,0 +1,3882 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define  _IOCTL_CFG80211_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <xmit_osdep.h>
+
+#include "ioctl_cfg80211.h"
+
+#define RTW_MAX_MGMT_TX_CNT (8)
+
+#define RTW_SCAN_IE_LEN_MAX      2304
+#define RTW_MAX_REMAIN_ON_CHANNEL_DURATION 65535 /* ms */
+#define RTW_MAX_NUM_PMKIDS 4
+
+#define RTW_CH_MAX_2G_CHANNEL               14      /* Max channel in 2G band */
+
+#define FALSE 0
+
+static const u32 rtw_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+};
+
+#define RATETAB_ENT(_rate, _rateid, _flags) \
+	{								\
+		.bitrate	= (_rate),				\
+		.hw_value	= (_rateid),				\
+		.flags		= (_flags),				\
+	}
+
+#define CHAN2G(_channel, _freq, _flags) {			\
+	.band			= IEEE80211_BAND_2GHZ,		\
+	.center_freq		= (_freq),			\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define CHAN5G(_channel, _flags) {				\
+	.band			= IEEE80211_BAND_5GHZ,		\
+	.center_freq		= 5000 + (5 * (_channel)),	\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+static struct ieee80211_rate rtw_rates[] = {
+	RATETAB_ENT(10,  0x1,   0),
+	RATETAB_ENT(20,  0x2,   0),
+	RATETAB_ENT(55,  0x4,   0),
+	RATETAB_ENT(110, 0x8,   0),
+	RATETAB_ENT(60,  0x10,  0),
+	RATETAB_ENT(90,  0x20,  0),
+	RATETAB_ENT(120, 0x40,  0),
+	RATETAB_ENT(180, 0x80,  0),
+	RATETAB_ENT(240, 0x100, 0),
+	RATETAB_ENT(360, 0x200, 0),
+	RATETAB_ENT(480, 0x400, 0),
+	RATETAB_ENT(540, 0x800, 0),
+};
+
+#define rtw_a_rates		(rtw_rates + 4)
+#define RTW_A_RATES_NUM	8
+#define rtw_g_rates		(rtw_rates + 0)
+#define RTW_G_RATES_NUM	12
+
+#define RTW_2G_CHANNELS_NUM 14
+#define RTW_5G_CHANNELS_NUM 37
+
+static struct ieee80211_channel rtw_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+static struct ieee80211_channel rtw_5ghz_a_channels[] = {
+	CHAN5G(34, 0),		CHAN5G(36, 0),
+	CHAN5G(38, 0),		CHAN5G(40, 0),
+	CHAN5G(42, 0),		CHAN5G(44, 0),
+	CHAN5G(46, 0),		CHAN5G(48, 0),
+	CHAN5G(52, 0),		CHAN5G(56, 0),
+	CHAN5G(60, 0),		CHAN5G(64, 0),
+	CHAN5G(100, 0),		CHAN5G(104, 0),
+	CHAN5G(108, 0),		CHAN5G(112, 0),
+	CHAN5G(116, 0),		CHAN5G(120, 0),
+	CHAN5G(124, 0),		CHAN5G(128, 0),
+	CHAN5G(132, 0),		CHAN5G(136, 0),
+	CHAN5G(140, 0),		CHAN5G(149, 0),
+	CHAN5G(153, 0),		CHAN5G(157, 0),
+	CHAN5G(161, 0),		CHAN5G(165, 0),
+	CHAN5G(184, 0),		CHAN5G(188, 0),
+	CHAN5G(192, 0),		CHAN5G(196, 0),
+	CHAN5G(200, 0),		CHAN5G(204, 0),
+	CHAN5G(208, 0),		CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+
+static void rtw_2g_channels_init(struct ieee80211_channel *channels)
+{
+	memcpy((void*)channels, (void*)rtw_2ghz_channels,
+		sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
+	);
+}
+
+static void rtw_5g_channels_init(struct ieee80211_channel *channels)
+{
+	memcpy((void*)channels, (void*)rtw_5ghz_a_channels,
+		sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
+	);
+}
+
+static void rtw_2g_rates_init(struct ieee80211_rate *rates)
+{
+	memcpy(rates, rtw_g_rates,
+		sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM
+	);
+}
+
+static void rtw_5g_rates_init(struct ieee80211_rate *rates)
+{
+	memcpy(rates, rtw_a_rates,
+		sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM
+	);
+}
+
+static struct ieee80211_supported_band *rtw_spt_band_alloc(
+	enum ieee80211_band band
+	)
+{
+	struct ieee80211_supported_band *spt_band = NULL;
+	int n_channels, n_bitrates;
+	int len;
+
+	if (band == IEEE80211_BAND_2GHZ)
+	{
+		n_channels = RTW_2G_CHANNELS_NUM;
+		n_bitrates = RTW_G_RATES_NUM;
+	}
+	else if (band == IEEE80211_BAND_5GHZ)
+	{
+		n_channels = RTW_5G_CHANNELS_NUM;
+		n_bitrates = RTW_A_RATES_NUM;
+	}
+	else
+	{
+		goto exit;
+	}
+
+	len = sizeof(struct ieee80211_supported_band) +
+	      sizeof(struct ieee80211_channel) * n_channels +
+	      sizeof(struct ieee80211_rate) * n_bitrates;
+	spt_band = (struct ieee80211_supported_band *)kzalloc(len, GFP_KERNEL);
+	if (!spt_band)
+		goto exit;
+
+	spt_band->channels = (struct ieee80211_channel*)(((u8*)spt_band)+sizeof(struct ieee80211_supported_band));
+	spt_band->bitrates= (struct ieee80211_rate*)(((u8*)spt_band->channels)+sizeof(struct ieee80211_channel)*n_channels);
+	spt_band->band = band;
+	spt_band->n_channels = n_channels;
+	spt_band->n_bitrates = n_bitrates;
+
+	if (band == IEEE80211_BAND_2GHZ)
+	{
+		rtw_2g_channels_init(spt_band->channels);
+		rtw_2g_rates_init(spt_band->bitrates);
+	}
+	else if (band == IEEE80211_BAND_5GHZ)
+	{
+		rtw_5g_channels_init(spt_band->channels);
+		rtw_5g_rates_init(spt_band->bitrates);
+	}
+
+	/* spt_band.ht_cap */
+
+exit:
+
+	return spt_band;
+}
+
+static void rtw_spt_band_free(struct ieee80211_supported_band *spt_band)
+{
+	u32 size;
+
+	if (!spt_band)
+		return;
+
+	if (spt_band->band == IEEE80211_BAND_2GHZ)
+	{
+		size = sizeof(struct ieee80211_supported_band)
+			+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM
+			+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;
+	}
+	else if (spt_band->band == IEEE80211_BAND_5GHZ)
+	{
+		size = sizeof(struct ieee80211_supported_band)
+			+ sizeof(struct ieee80211_channel)*RTW_5G_CHANNELS_NUM
+			+ sizeof(struct ieee80211_rate)*RTW_A_RATES_NUM;
+	}
+	else
+	{
+
+	}
+	kfree(spt_band);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+static const struct ieee80211_txrx_stypes
+rtw_cfg80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_ADHOC] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_AP_VLAN] = {
+		/* copy AP */
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		BIT(IEEE80211_STYPE_AUTH >> 4) |
+		BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+};
+#endif
+
+static int rtw_ieee80211_channel_to_frequency(int chan, int band)
+{
+	/* see 802.11 17.3.8.3.2 and Annex J
+	* there are overlapping channel numbers in 5GHz and 2GHz bands */
+
+	if (band == IEEE80211_BAND_5GHZ) {
+	if (chan >= 182 && chan <= 196)
+			return 4000 + chan * 5;
+             else
+                    return 5000 + chan * 5;
+       } else { /* IEEE80211_BAND_2GHZ */
+		if (chan == 14)
+			return 2484;
+             else if (chan < 14)
+			return 2407 + chan * 5;
+             else
+			return 0; /* not supported */
+	}
+}
+
+#define MAX_BSSINFO_LEN 1000
+static int rtw_cfg80211_inform_bss(struct rtw_adapter *padapter, struct wlan_network *pnetwork)
+{
+	int ret=0;
+	struct ieee80211_channel *notify_channel;
+	struct cfg80211_bss *bss;
+	u16 channel;
+	u32 freq;
+	u64 notify_timestamp;
+	u8 *notify_ie;
+	size_t notify_ielen;
+	s32 notify_signal;
+	u8 buf[MAX_BSSINFO_LEN], *pbuf;
+	size_t len,bssinf_len=0;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	struct wireless_dev *wdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = wdev->wiphy;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	bssinf_len = pnetwork->network.IELength+sizeof (struct rtw_ieee80211_hdr_3addr);
+	if (bssinf_len > MAX_BSSINFO_LEN) {
+		DBG_8192D("%s IE Length too long > %d byte\n",__func__,MAX_BSSINFO_LEN);
+		goto exit;
+	}
+
+	channel = pnetwork->network.Configuration.DSConfig;
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	notify_channel = ieee80211_get_channel(wiphy, freq);
+
+	notify_timestamp = jiffies_to_msecs(jiffies)*1000; /* uSec */
+
+	notify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;
+	notify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;
+
+	/* We've set wiphy's signal_type as CFG80211_SIGNAL_TYPE_MBM: signal strength in mBm (100*dBm) */
+	if (check_fwstate(pmlmepriv, _FW_LINKED)== true &&
+		is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+		notify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);/* dbm */
+	} else {
+		notify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);/* dbm */
+	}
+	pbuf = buf;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pbuf;
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+
+	if (pnetwork->network.Reserved[0] == 1) { /*  WIFI_BEACON */
+		memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+		SetFrameSubType(pbuf, WIFI_BEACON);
+	} else {
+		memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);
+		SetFrameSubType(pbuf, WIFI_PROBERSP);
+	}
+
+	memcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);
+
+	pbuf += sizeof(struct rtw_ieee80211_hdr_3addr);
+	len = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	memcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);
+	len += pnetwork->network.IELength;
+
+	bss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,
+		len, notify_signal, GFP_ATOMIC);
+	if (unlikely(!bss)) {
+		DBG_8192D("rtw_cfg80211_inform_bss error\n");
+		return -EINVAL;
+	}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
+	/* patch for cfg80211, update beacon ies to information_elements */
+	if (pnetwork->network.Reserved[0] == 1) { /*  WIFI_BEACON */
+
+		 if (bss->len_information_elements != bss->len_beacon_ies)
+		 {
+			bss->information_elements = bss->beacon_ies;
+			bss->len_information_elements =  bss->len_beacon_ies;
+		 }
+	}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
+	cfg80211_put_bss(bss);
+#else
+	cfg80211_put_bss(wiphy, bss);
+#endif
+
+exit:
+	return ret;
+}
+
+void rtw_cfg80211_indicate_connect(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+
+	DBG_8192D("%s(padapter=%p)\n", __func__, padapter);
+
+	if (pwdev->iftype != NL80211_IFTYPE_STATION
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		return;
+
+	#ifdef CONFIG_LAYER2_ROAMING
+	if (rtw_to_roaming(padapter) > 0) {
+		#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+		struct wiphy *wiphy = pwdev->wiphy;
+		struct ieee80211_channel *notify_channel;
+		u32 freq;
+		u16 channel = cur_network->network.Configuration.DSConfig;
+
+		if (channel <= RTW_CH_MAX_2G_CHANNEL)
+			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+		else
+			freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+		notify_channel = ieee80211_get_channel(wiphy, freq);
+		#endif
+
+		DBG_8192D("%s call cfg80211_roamed\n", __func__);
+		cfg80211_roamed(padapter->pnetdev
+			#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+			, notify_channel
+			#endif
+			, cur_network->network.MacAddress
+			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
+			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
+			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
+			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
+			, GFP_ATOMIC);
+	}
+	else
+	#endif
+	{
+		cfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress
+			, pmlmepriv->assoc_req+sizeof(struct rtw_ieee80211_hdr_3addr)+2
+			, pmlmepriv->assoc_req_len-sizeof(struct rtw_ieee80211_hdr_3addr)-2
+			, pmlmepriv->assoc_rsp+sizeof(struct rtw_ieee80211_hdr_3addr)+6
+			, pmlmepriv->assoc_rsp_len-sizeof(struct rtw_ieee80211_hdr_3addr)-6
+			, WLAN_STATUS_SUCCESS, GFP_ATOMIC);
+	}
+}
+
+void rtw_cfg80211_indicate_disconnect(struct rtw_adapter *padapter)
+{
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+
+	DBG_8192D("%s(padapter=%p)\n", __func__, padapter);
+
+	if (pwdev->iftype != NL80211_IFTYPE_STATION
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+		&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT
+		#endif
+	) {
+		return;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		return;
+
+	if (!padapter->mlmepriv.not_indic_disco) {
+		if (check_fwstate(&padapter->mlmepriv, WIFI_UNDER_LINKING)) {
+			cfg80211_connect_result(padapter->pnetdev, NULL, NULL,
+						0, NULL, 0,
+						WLAN_STATUS_UNSPECIFIED_FAILURE,
+						GFP_ATOMIC/*GFP_KERNEL*/);
+		} else {
+			cfg80211_disconnected(padapter->pnetdev, 0, NULL,
+					      0, FALSE, GFP_ATOMIC);
+		}
+	}
+}
+
+#ifdef CONFIG_92D_AP_MODE
+static u8 set_pairwise_key(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv				*pcmdpriv=&padapter->cmdpriv;
+	u8	res=_SUCCESS;
+
+	ph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (ph2c == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);
+	if (psetstakey_para==NULL) {
+		kfree(ph2c);
+		res=_FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
+
+	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
+
+	memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
+
+	memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+static int set_group_key(struct rtw_adapter *padapter, u8 *key, u8 alg, int keyid)
+{
+	u8 keylen;
+	struct cmd_obj* pcmd;
+	struct setkey_parm *psetkeyparm;
+	struct cmd_priv	*pcmdpriv=&(padapter->cmdpriv);
+	int res=_SUCCESS;
+
+	DBG_8192D("%s\n", __func__);
+
+	pcmd = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (pcmd==NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+	psetkeyparm=(struct setkey_parm*)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
+	if (psetkeyparm==NULL) {
+		kfree(pcmd);
+		res= _FAIL;
+		goto exit;
+	}
+
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	psetkeyparm->keyid=(u8)keyid;
+
+	psetkeyparm->algorithm = alg;
+
+	psetkeyparm->set_tx = 1;
+
+	switch (alg)
+	{
+		case _WEP40_:
+			keylen = 5;
+			break;
+		case _WEP104_:
+			keylen = 13;
+			break;
+		case _TKIP_:
+		case _TKIP_WTMIC_:
+		case _AES_:
+			keylen = 16;
+		default:
+			keylen = 16;
+	}
+
+	memcpy(&(psetkeyparm->key[0]), key, keylen);
+
+	pcmd->cmdcode = _SETKEY_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+
+}
+
+static int set_wep_key(struct rtw_adapter *padapter, u8 *key, u8 keylen, int keyid)
+{
+	u8 alg;
+
+	switch (keylen)
+	{
+		case 5:
+			alg =_WEP40_;
+			break;
+		case 13:
+			alg =_WEP104_;
+			break;
+		default:
+			alg =_NO_PRIVACY_;
+	}
+
+	return set_group_key(padapter, key, alg, keyid);
+}
+
+static int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192D("%s\n", __func__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	/* sizeof(struct ieee_param) = 64 bytes; */
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+	else
+	{
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if (!psta)
+		{
+			DBG_8192D("rtw_set_encryption(), sta has already been removed or never been added\n");
+			goto exit;
+		}
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta==NULL))
+	{
+		/* todo:clear default encryption keys */
+
+		DBG_8192D("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
+
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta==NULL))
+	{
+		DBG_8192D("r871x_set_encryption, crypt.alg = WEP\n");
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		DBG_8192D("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
+
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len<=0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (wep_key_len > 0)
+		{
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+		}
+
+		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
+		{
+			/* wep default key has not been set, so use this key index as default key. */
+
+			psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			psecuritypriv->dot11PrivacyAlgrthm=_WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy=_WEP40_;
+
+			if (wep_key_len == 13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm=_WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy=_WEP104_;
+			}
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+		}
+
+		memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
+
+		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
+
+		set_wep_key(padapter, param->u.crypt.key, wep_key_len, wep_key_idx);
+
+		goto exit;
+
+	}
+
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
+	{
+		if (param->u.crypt.set_tx == 0) /* group key */
+		{
+			if (strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				DBG_8192D("%s, set group_key, WEP\n", __func__);
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+				if (param->u.crypt.key_len==13)
+				{
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+				}
+
+			}
+			else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+			{
+				DBG_8192D("%s, set group_key, TKIP\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				/* set mic key */
+				memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+				memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = true;
+
+			}
+			else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+			{
+				DBG_8192D("%s, set group_key, CCMP\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+			}
+			else
+			{
+				DBG_8192D("%s, set group_key, none\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = true;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
+
+			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta)
+			{
+				pbcmc_sta->ieee8021x_blocked = false;
+				pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
+			}
+
+		}
+
+		goto exit;
+
+	}
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) /*  psk/802_1x */
+	{
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		{
+			if (param->u.crypt.set_tx ==1) /* pairwise key */
+			{
+				memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					DBG_8192D("%s, set pairwise key, WEP\n", __func__);
+
+					psta->dot118021XPrivacy = _WEP40_;
+					if (param->u.crypt.key_len==13)
+					{
+						psta->dot118021XPrivacy = _WEP104_;
+					}
+				}
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{
+					DBG_8192D("%s, set pairwise key, TKIP\n", __func__);
+
+					psta->dot118021XPrivacy = _TKIP_;
+
+					/* set mic key */
+					memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				}
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+
+					DBG_8192D("%s, set pairwise key, CCMP\n", __func__);
+
+					psta->dot118021XPrivacy = _AES_;
+				}
+				else
+				{
+					DBG_8192D("%s, set pairwise key, none\n", __func__);
+
+					psta->dot118021XPrivacy = _NO_PRIVACY_;
+				}
+
+				set_pairwise_key(padapter, psta);
+
+				psta->ieee8021x_blocked = false;
+
+				psta->bpairwise_key_installed = true;
+
+			}
+			else/* group key??? */
+			{
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+					if (param->u.crypt.key_len==13)
+					{
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+					}
+				}
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					/* set mic key */
+					memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				}
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				}
+				else
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = true;
+
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
+
+				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+				pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+				if (pbcmc_sta)
+				{
+					pbcmc_sta->ieee8021x_blocked = false;
+					pbcmc_sta->dot118021XPrivacy= psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
+				}
+
+			}
+
+		}
+
+	}
+
+exit:
+
+	return ret;
+}
+#endif
+
+static int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len,wep_total_len;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	DBG_8192D("%s\n", __func__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("wpa_set_encryption, crypt.alg = WEP\n"));
+		DBG_8192D("wpa_set_encryption, crypt.alg = WEP\n");
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		if ((wep_key_idx > WEP_KEYS) || (wep_key_len <= 0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (psecuritypriv->bWepDefaultKeyIdxSet == 0)
+		{
+			/* wep default key has not been set, so use this key index as default key. */
+
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+
+		psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+
+			if (wep_key_len==13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+			}
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+		}
+
+		memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);
+
+		psecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;
+
+		rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);
+
+		goto exit;
+	}
+
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) /*  802_1x */
+	{
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) /* sta mode */
+		{
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			if (psta == NULL) {
+				DBG_8192D("%s, : Obtain Sta_info fail\n", __func__);
+			}
+			else
+			{
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					psta->ieee8021x_blocked = false;
+
+				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
+						(padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
+				{
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}
+
+				if (param->u.crypt.set_tx ==1)/* pairwise key */
+				{
+
+					DBG_8192D("%s, : param->u.crypt.set_tx ==1\n", __func__);
+
+					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0)/* set mic key */
+					{
+						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey=false;
+					}
+
+					DBG_8192D(" ~~~~set sta key:unicastkey\n");
+
+					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
+				}
+				else/* group key */
+				{
+					memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key,(param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]),8);
+					memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]),8);
+                                        padapter->securitypriv.binstallGrpkey = true;
+					DBG_8192D(" ~~~~set sta key:groupkey\n");
+
+					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+
+					rtw_set_key(padapter,&padapter->securitypriv,param->u.crypt.idx, 1);
+				}
+			}
+
+			pbcmc_sta=rtw_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta==NULL)
+			{
+			}
+			else
+			{
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					pbcmc_sta->ieee8021x_blocked = false;
+
+				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
+						(padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
+				{
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+				}
+			}
+		}
+		else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) /* adhoc mode */
+		{
+		}
+	}
+
+exit:
+
+	DBG_8192D("%s, ret=%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+				u8 key_index, const u8 *mac_addr,
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+				struct key_params *params)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;
+	int ret=0;
+	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	DBG_8192D(FUNC_NDEV_FMT" adding key for %pM\n", FUNC_NDEV_ARG(ndev), mac_addr);
+	DBG_8192D("cipher=0x%x\n", params->cipher);
+	DBG_8192D("key_len=0x%x\n", params->key_len);
+	DBG_8192D("seq_len=0x%x\n", params->seq_len);
+	DBG_8192D("key_index=%d\n", key_index);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	DBG_8192D("pairwise=%d\n", pairwise);
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+
+	param_len = sizeof(struct ieee_param) + params->key_len;
+	param = (struct ieee_param *)kmalloc(param_len, GFP_KERNEL);
+	if (param == NULL)
+		return -1;
+
+	memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+
+	switch (params->cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		/* todo: remove key */
+		/* remove = 1; */
+		alg_name = "none";
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		alg_name = "WEP";
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		alg_name = "TKIP";
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	if (!mac_addr || is_broadcast_ether_addr(mac_addr))
+	{
+		param->u.crypt.set_tx = 0; /* for wpa/wpa2 group key */
+	} else {
+		param->u.crypt.set_tx = 1; /* for wpa/wpa2 pairwise key */
+	}
+
+	param->u.crypt.idx = key_index;
+
+	if (params->seq_len && params->seq)
+	{
+		memcpy(param->u.crypt.seq, params->seq, params->seq_len);
+	}
+
+	if (params->key_len && params->key)
+	{
+		param->u.crypt.key_len = params->key_len;
+		memcpy(param->u.crypt.key, params->key, params->key_len);
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	{
+		ret =  rtw_cfg80211_set_encryption(ndev, param, param_len);
+	}
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+#ifdef CONFIG_92D_AP_MODE
+		if (mac_addr)
+			memcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);
+
+		ret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);
+#endif
+	} else {
+		DBG_8192D("error! fw_state=0x%x, iftype=%d\n", pmlmepriv->fw_state, rtw_wdev->iftype);
+	}
+
+	if (param)
+		kfree(param);
+
+	return ret;
+}
+
+static int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr,
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+				u8 key_index, const u8 *mac_addr,
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+				void *cookie,
+				void (*callback)(void *cookie,
+						 struct key_params*))
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+				u8 key_index, bool pairwise, const u8 *mac_addr)
+#else	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+				u8 key_index, const u8 *mac_addr)
+#endif	/*  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) */
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	DBG_8192D(FUNC_NDEV_FMT" key_index=%d\n", FUNC_NDEV_ARG(ndev), key_index);
+
+	if (key_index == psecuritypriv->dot11PrivacyKeyIndex)
+	{
+		/* clear the flag of wep default key set. */
+		psecuritypriv->bWepDefaultKeyIdxSet = 0;
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_default_key(struct wiphy *wiphy,
+	struct net_device *ndev, u8 key_index
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	, bool unicast, bool multicast
+	#endif
+	)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	DBG_8192D(FUNC_NDEV_FMT" key_index=%d, unicast=%d, multicast=%d\n",
+		  FUNC_NDEV_ARG(ndev), key_index, unicast, multicast);
+#else
+	DBG_8192D(FUNC_NDEV_FMT" key_index=%d\n", FUNC_NDEV_ARG(ndev),
+		  key_index);
+#endif
+	if ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_))) /* set wep default key */
+	{
+		psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+
+		psecuritypriv->dot11PrivacyKeyIndex = key_index;
+
+		psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+		psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+		if (psecuritypriv->dot11DefKeylen[key_index] == 13)
+		{
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+			psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+		}
+
+		psecuritypriv->bWepDefaultKeyIdxSet = 1; /* set the flag to represent that wep default key has been set */
+	}
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14,0))
+static int cfg80211_rtw_get_station(struct wiphy *wiphy,
+				    struct net_device *ndev,
+				    const u8 *mac, struct station_info *sinfo)
+#else
+static int cfg80211_rtw_get_station(struct wiphy *wiphy,
+				    struct net_device *ndev,
+				    u8 *mac, struct station_info *sinfo)
+#endif
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	sinfo->filled = 0;
+
+	if (!mac) {
+		DBG_8192D(FUNC_NDEV_FMT" mac==%p\n", FUNC_NDEV_ARG(ndev), mac);
+		ret = -ENOENT;
+		goto exit;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, (u8 *)mac);
+	if (psta == NULL) {
+		DBG_8192D("%s, sta_info is null\n", __func__);
+		ret = -ENOENT;
+		goto exit;
+	}
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D(FUNC_NDEV_FMT" mac=%pM\n", FUNC_NDEV_ARG(ndev), mac);
+#endif
+
+	/* for infra./P2PClient mode */
+	if (	check_fwstate(pmlmepriv, WIFI_STATION_STATE)
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+
+		if (memcmp(mac, cur_network->network.MacAddress, ETH_ALEN)) {
+			DBG_8192D("%s, mismatch bssid=%pM\n", __func__, cur_network->network.MacAddress);
+			ret = -ENOENT;
+			goto exit;
+		}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0))
+		sinfo->filled |= STATION_INFO_SIGNAL;
+		sinfo->filled |= STATION_INFO_TX_BITRATE;
+		sinfo->filled |= STATION_INFO_RX_PACKETS;
+		sinfo->filled |= STATION_INFO_TX_PACKETS;
+#else
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);
+		sinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);
+		sinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);
+#endif
+		sinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
+
+		sinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);
+
+		sinfo->rx_packets = sta_rx_data_pkts(psta);
+
+		sinfo->tx_packets = psta->sta_stats.tx_pkts;
+
+	}
+
+	/* for Ad-Hoc/AP mode */
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)
+			||check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)
+			||check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		&& check_fwstate(pmlmepriv, _FW_LINKED)
+	)
+	{
+		/* TODO: should acquire station info... */
+	}
+
+exit:
+	return ret;
+}
+
+extern int netdev_open(struct net_device *pnetdev);
+#ifdef CONFIG_CONCURRENT_MODE
+extern int netdev_if2_open(struct net_device *pnetdev);
+#endif
+
+static int cfg80211_rtw_change_iface(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     enum nl80211_iftype type, u32 *flags,
+				     struct vif_params *params)
+{
+	enum nl80211_iftype old_type;
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct wireless_dev *rtw_wdev = wiphy_to_wdev(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct __queue *queue = &pmlmepriv->scanned_queue;
+	int ret = 0;
+	u8 change = false;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->adapter_type == SECONDARY_ADAPTER)
+	{
+		DBG_8192D(FUNC_NDEV_FMT" call netdev_if2_open\n", FUNC_NDEV_ARG(ndev));
+		if (netdev_if2_open(ndev) != 0) {
+			ret= -EPERM;
+			goto exit;
+		}
+	}
+	else if (padapter->adapter_type == PRIMARY_ADAPTER)
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		DBG_8192D(FUNC_NDEV_FMT" call netdev_open\n", FUNC_NDEV_ARG(ndev));
+		if (netdev_open(ndev) != 0) {
+			ret= -EPERM;
+			goto exit;
+		}
+	}
+
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	old_type = rtw_wdev->iftype;
+	DBG_8192D(FUNC_NDEV_FMT" old_iftype=%d, new_iftype=%d\n",
+		FUNC_NDEV_ARG(ndev), old_type, type);
+
+	if (old_type != type)
+	{
+		change = true;
+		pmlmeext->action_public_rxseq = 0xffff;
+		pmlmeext->action_public_dialog_token = 0xff;
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+		networkType = NDIS802_11IBSS;
+		break;
+	case NL80211_IFTYPE_STATION:
+		networkType = NDIS802_11INFRA;
+		break;
+	case NL80211_IFTYPE_AP:
+		networkType = Ndis802_11APMode;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	rtw_wdev->iftype = type;
+
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
+
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false)
+	{
+		rtw_wdev->iftype = old_type;
+		ret = -EPERM;
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
+		goto exit;
+	}
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_setopmode_cmd(padapter, networkType);
+
+exit:
+
+	return ret;
+}
+
+void rtw_cfg80211_indicate_scan_done(struct rtw_wdev_priv *pwdev_priv, bool aborted)
+{
+
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
+	if (pwdev_priv->scan_request != NULL)
+	{
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("%s with scan req\n", __func__);
+		#endif
+
+		/* avoid WARN_ON(request != wiphy_to_dev(request->wiphy)->scan_req); */
+		if (pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)
+		{
+			DBG_8192D("error wiphy compare\n");
+		}
+		else
+		{
+			cfg80211_scan_done(pwdev_priv->scan_request, aborted);
+		}
+
+		pwdev_priv->scan_request = NULL;
+
+	} else {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("%s without scan req\n", __func__);
+		#endif
+	}
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
+}
+
+void rtw_cfg80211_surveydone_event_callback(struct rtw_adapter *padapter)
+{
+	struct list_head *plist, *phead;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct __queue		*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	u32 cnt=0;
+	u32 wait_for_surveydone;
+	int wait_status;
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D("%s\n", __func__);
+#endif
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead,plist)== true)
+			break;
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		/* report network only if the current channel set contains the channel to which this network belongs */
+		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+			#ifdef CONFIG_VALIDATE_SSID
+			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
+			#endif
+		)
+		{
+			/* ev=translate_scan(padapter, a, pnetwork, ev, stop); */
+			rtw_cfg80211_inform_bss(padapter, pnetwork);
+		}
+
+		plist = plist->next;
+
+	}
+
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	/* call this after other things have been done */
+	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), false);
+}
+
+static int rtw_cfg80211_set_probe_req_wpsp2pie(struct rtw_adapter *padapter, char *buf, int len)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;
+	u8 *wfd_ie;
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D("%s, ielen=%d\n", __func__, len);
+#endif
+
+	if (len>0)
+	{
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192D("probe_req_wps_ielen=%d\n", wps_ielen);
+			#endif
+
+			if (pmlmepriv->wps_probe_req_ie)
+			{
+				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
+				pmlmepriv->wps_probe_req_ie_len = 0;
+				kfree(pmlmepriv->wps_probe_req_ie);
+				pmlmepriv->wps_probe_req_ie = NULL;
+			}
+
+			pmlmepriv->wps_probe_req_ie = kmalloc(wps_ielen, GFP_KERNEL);
+			if (pmlmepriv->wps_probe_req_ie == NULL) {
+				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+				return -EINVAL;
+
+			}
+			memcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_probe_req_ie_len = wps_ielen;
+		}
+	}
+	return ret;
+}
+
+static int cfg80211_rtw_scan(struct wiphy *wiphy
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+	, struct net_device *ndev
+	#endif
+	, struct cfg80211_scan_request *request)
+{
+	int i;
+	u8 _status = false;
+	int ret = 0;
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv= &padapter->mlmepriv;
+	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+	u8 *wps_ie=NULL;
+	uint wps_ielen=0;
+	u8 *p2p_ie=NULL;
+	uint p2p_ielen=0;
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct cfg80211_ssid *ssids = request->ssids;
+	int social_channel = 0, j = 0;
+	bool need_indicate_scan_done = false;
+#ifdef CONFIG_CONCURRENT_MODE
+	PADAPTER pbuddy_adapter = NULL;
+	struct mlme_priv *pbuddy_mlmepriv = NULL;
+#endif /* CONFIG_CONCURRENT_MODE */
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter))
+	{
+		pbuddy_adapter = padapter->pbuddy_adapter;
+		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	spin_lock_bh(&pwdev_priv->scan_req_lock);
+	pwdev_priv->scan_request = request;
+	spin_unlock_bh(&pwdev_priv->scan_req_lock);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+
+#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("%s under WIFI_AP_STATE\n", __func__);
+#endif
+	}
+
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+
+	if (request->ie && request->ie_len>0)
+		rtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len);
+
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic) {
+		DBG_8192D("%s, bBusyTraffic == true\n", __func__);
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+	if (rtw_is_scan_deny(padapter)) {
+		DBG_8192D(FUNC_ADPT_FMT  ": scan deny\n", FUNC_ADPT_ARG(padapter));
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (pbuddy_mlmepriv && (pbuddy_mlmepriv->LinkDetectInfo.bBusyTraffic == true))
+	{
+		DBG_8192D("%s, bBusyTraffic == true at buddy_intf\n", __func__);
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		DBG_8192D("%s, fwstate=0x%x\n", __func__, pmlmepriv->fw_state);
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter,
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == true)
+	{
+		if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
+		{
+			DBG_8192D("scanning_via_buddy_intf\n");
+			pmlmepriv->scanning_via_buddy_intf = true;
+		}
+
+		DBG_8192D("buddy_intf's mlme state:0x%x\n", pbuddy_mlmepriv->fw_state);
+
+		need_indicate_scan_done = true;
+		goto check_need_indicate_scan_done;
+	}
+#endif
+
+	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
+	/* parsing request ssids, n_ssids */
+	for (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("ssid=%s, len=%d\n", ssids[i].ssid, ssids[i].ssid_len);
+		#endif
+		memcpy(ssid[i].Ssid, ssids[i].ssid, ssids[i].ssid_len);
+		ssid[i].SsidLength = ssids[i].ssid_len;
+	}
+
+	/* parsing channels, n_channels */
+	memset(ch, 0, sizeof(struct rtw_ieee80211_channel)*RTW_CHANNEL_SCAN_AMOUNT);
+	if (request->n_channels == 1)
+	for (i=0;i<request->n_channels && i<RTW_CHANNEL_SCAN_AMOUNT;i++) {
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D(FUNC_ADPT_FMT CHAN_FMT"\n", FUNC_ADPT_ARG(padapter), CHAN_ARG(request->channels[i]));
+		#endif
+		ch[i].hw_value = request->channels[i]->hw_value;
+		ch[i].flags = request->channels[i]->flags;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+	if (request->n_channels == 1) {
+		memcpy(&ch[1], &ch[0], sizeof(struct rtw_ieee80211_channel));
+		memcpy(&ch[2], &ch[0], sizeof(struct rtw_ieee80211_channel));
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, 3);
+	} else {
+		_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);
+	}
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	if (_status == false)
+	{
+		ret = -1;
+	}
+
+check_need_indicate_scan_done:
+	if (need_indicate_scan_done)
+		rtw_cfg80211_surveydone_event_callback(padapter);
+
+exit:
+
+	return ret;
+}
+
+static int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	DBG_8192D("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,
+				  struct cfg80211_ibss_params *params)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)
+{
+	DBG_8192D("%s, wpa_version=%d\n", __func__, wpa_version);
+
+	if (!wpa_version) {
+		psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
+		return 0;
+	}
+
+	if (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))
+		psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,
+			     enum nl80211_auth_type sme_auth_type)
+{
+	DBG_8192D("%s, nl80211_auth_type=%d\n", __func__, sme_auth_type);
+
+	switch (sme_auth_type) {
+	case NL80211_AUTHTYPE_AUTOMATIC:
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+		break;
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		if (psecuritypriv->ndisauthtype > NDIS802_11AUTHMODEWPA)
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+		break;
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+		psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+		break;
+	default:
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		/* return -ENOTSUPP; */
+	}
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)
+{
+	u32 ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+
+	u32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :
+		&psecuritypriv->dot118021XGrpPrivacy;
+
+	DBG_8192D("%s, ucast=%d, cipher=0x%x\n", __func__, ucast, cipher);
+
+	if (!cipher) {
+		*profile_cipher = _NO_PRIVACY_;
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+		return 0;
+	}
+
+	switch (cipher) {
+	case IW_AUTH_CIPHER_NONE:
+		*profile_cipher = _NO_PRIVACY_;
+		ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+		break;
+	case WLAN_CIPHER_SUITE_WEP40:
+		*profile_cipher = _WEP40_;
+		ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		*profile_cipher = _WEP104_;
+		ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		*profile_cipher = _TKIP_;
+		ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		*profile_cipher = _AES_;
+		ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+		break;
+	default:
+		DBG_8192D("Unsupported cipher: 0x%x\n", cipher);
+		return -ENOTSUPP;
+	}
+
+	if (ucast)
+		psecuritypriv->ndisencryptstatus = ndisencryptstatus;
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key_mgt)
+{
+	DBG_8192D("%s, key_mgt=0x%x\n", __func__, key_mgt);
+
+	if (key_mgt == WLAN_AKM_SUITE_8021X)
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	else if (key_mgt == WLAN_AKM_SUITE_PSK) {
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+	} else {
+		DBG_8192D("Invalid key mgt: 0x%x\n", key_mgt);
+	}
+
+	return 0;
+}
+
+static int rtw_cfg80211_set_wpa_ie(struct rtw_adapter *padapter, u8 *pie, size_t ielen)
+{
+	u8 *buf=NULL, *pos=NULL;
+	u32 left;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	int wpa_ielen=0;
+	int wpa2_ielen=0;
+	u8 *pwpa, *pwpa2;
+	u8 null_addr[]= {0,0,0,0,0,0};
+
+	if (pie == NULL || !ielen) {
+		/* Treat this as normal case, but need to clear WIFI_UNDER_WPS */
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		goto exit;
+	}
+
+	if (ielen > MAX_WPA_IE_LEN+MAX_WPS_IE_LEN+MAX_P2P_IE_LEN) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf = kzalloc(ielen, GFP_KERNEL);
+	if (buf == NULL) {
+		ret =  -ENOMEM;
+		goto exit;
+	}
+
+	memcpy(buf, pie , ielen);
+
+	/* dump */
+	{
+		int i;
+		DBG_8192D("set wpa_ie(length:%zu):\n", ielen);
+		for (i=0;i<ielen;i=i+8)
+			DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",buf[i],buf[i+1],buf[i+2],buf[i+3],buf[i+4],buf[i+5],buf[i+6],buf[i+7]);
+	}
+
+	pos = buf;
+	if (ielen < RSN_HEADER_LEN) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c,_drv_err_,("Ie len too short %d\n", ielen));
+		ret  = -1;
+		goto exit;
+	}
+
+	pwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);
+	if (pwpa && wpa_ielen>0)
+	{
+		if (rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
+			memcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);
+
+			DBG_8192D("got wpa_ie, wpa_ielen:%u\n", wpa_ielen);
+		}
+	}
+
+	pwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);
+	if (pwpa2 && wpa2_ielen>0)
+	{
+		if (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
+		{
+			padapter->securitypriv.dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK;
+			memcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);
+
+			DBG_8192D("got wpa2_ie, wpa2_ielen:%u\n", wpa2_ielen);
+		}
+	}
+
+	if (group_cipher == 0)
+	{
+		group_cipher = WPA_CIPHER_NONE;
+	}
+	if (pairwise_cipher == 0)
+	{
+		pairwise_cipher = WPA_CIPHER_NONE;
+	}
+
+	switch (group_cipher)
+	{
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot118021XGrpPrivacy=_NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot118021XGrpPrivacy=_WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot118021XGrpPrivacy=_TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot118021XGrpPrivacy=_AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+	}
+
+	switch (pairwise_cipher)
+	{
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+	}
+
+	{/* handle wps_ie */
+		uint wps_ielen;
+		u8 *wps_ie;
+
+		wps_ie = rtw_get_wps_ie(buf, ielen, NULL, &wps_ielen);
+		if (wps_ie && wps_ielen > 0) {
+			DBG_8192D("got wps_ie, wps_ielen:%u\n", wps_ielen);
+			padapter->securitypriv.wps_ie_len = wps_ielen<MAX_WPS_IE_LEN?wps_ielen:MAX_WPS_IE_LEN;
+			memcpy(padapter->securitypriv.wps_ie, wps_ie, padapter->securitypriv.wps_ie_len);
+			set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		} else {
+			_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		}
+	}
+
+	/* TKIP and AES disallow multicast packets until installing group key */
+	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_
+		|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_
+		|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+		/* WPS open need to enable multicast */
+		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		("rtw_set_wpa_ie: pairwise_cipher=0x%08x padapter->securitypriv.ndisencryptstatus=%d padapter->securitypriv.ndisauthtype=%d\n",
+		pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+
+exit:
+	if (buf)
+		kfree(buf);
+	if (ret)
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+	return ret;
+}
+
+static int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,
+				 struct cfg80211_connect_params *sme)
+{
+	int ret=0;
+	struct list_head  *phead;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
+	struct ndis_802_11_ssid ndis_ssid;
+	u8 *dst_ssid, *src_ssid;
+	u8 *dst_bssid;
+	const u8 *src_bssid;
+	u8 matched=false;
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct __queue *queue = &pmlmepriv->scanned_queue;
+
+	DBG_8192D("=>"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	DBG_8192D("privacy=%d, key=%p, key_len=%d, key_idx=%d\n",
+		sme->privacy, sme->key, sme->key_len, sme->key_idx);
+
+	if (wdev_to_priv(padapter->rtw_wdev)->block == true)
+	{
+		ret = -EBUSY;
+		DBG_8192D("%s wdev_priv.block is set\n", __func__);
+		goto exit;
+	}
+
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret= -EPERM;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_LINKING) == true) {
+		DBG_8192D("%s, but buddy_intf is under linking\n", __func__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY) == true) {
+		rtw_scan_abort(padapter->pbuddy_adapter);
+	}
+#endif
+
+	if (!sme->ssid || !sme->ssid_len)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (sme->ssid_len > IW_ESSID_MAX_SIZE) {
+
+		ret= -E2BIG;
+		goto exit;
+	}
+
+	memset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));
+	ndis_ssid.SsidLength = sme->ssid_len;
+	memcpy(ndis_ssid.Ssid, sme->ssid, sme->ssid_len);
+
+	DBG_8192D("ssid=%s, len=%zu\n", ndis_ssid.Ssid, sme->ssid_len);
+
+	if (sme->bssid)
+		DBG_8192D("bssid=%pM\n", sme->bssid);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+		ret = -EBUSY;
+		DBG_8192D("%s, fw_state=0x%x, goto exit\n", __func__, pmlmepriv->fw_state);
+		goto exit;
+	}
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		rtw_scan_abort(padapter);
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
+
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = phead->next;
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true)
+		{
+			break;
+		}
+
+		pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+		pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+		dst_ssid = pnetwork->network.Ssid.Ssid;
+		dst_bssid = pnetwork->network.MacAddress;
+
+		if (sme->bssid)  {
+			if (memcmp(pnetwork->network.MacAddress, (void *)sme->bssid, ETH_ALEN))
+				continue;
+		}
+
+		if (sme->ssid && sme->ssid_len) {
+			if (pnetwork->network.Ssid.SsidLength != sme->ssid_len ||
+			    memcmp(pnetwork->network.Ssid.Ssid, (void *)sme->ssid, sme->ssid_len))
+				continue;
+		}
+
+		if (sme->bssid) {
+			src_bssid = sme->bssid;
+
+			if (!memcmp(dst_bssid, (void *)src_bssid, ETH_ALEN)) {
+				DBG_8192D("matched by bssid\n");
+
+				ndis_ssid.SsidLength = pnetwork->network.Ssid.SsidLength;
+				memcpy(ndis_ssid.Ssid, pnetwork->network.Ssid.Ssid, pnetwork->network.Ssid.SsidLength);
+
+				matched=true;
+				break;
+			}
+
+		}
+		else if (sme->ssid && sme->ssid_len)
+		{
+			src_ssid = ndis_ssid.Ssid;
+
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == true) &&
+				(pnetwork->network.Ssid.SsidLength==ndis_ssid.SsidLength))
+			{
+				DBG_8192D("matched by ssid\n");
+				matched=true;
+				break;
+			}
+		}
+
+	}
+
+	if ((matched == false) || (pnetwork== NULL))
+	{
+		ret = -ENOENT;
+		DBG_8192D("connect, matched == false, goto exit\n");
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
+		goto exit;
+	}
+
+	if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
+	{
+		ret = -EPERM;
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
+		goto exit;
+	}
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+	psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
+
+	ret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);
+	if (ret < 0)
+		goto exit;
+
+	ret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);
+	if (ret < 0)
+		goto exit;
+
+	DBG_8192D("%s, ie_len=%zu\n", __func__, sme->ie_len);
+
+	ret = rtw_cfg80211_set_wpa_ie(padapter, (u8 *)sme->ie, sme->ie_len);
+	if (ret < 0)
+		goto exit;
+
+	if (sme->crypto.n_ciphers_pairwise) {
+		ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], true);
+		if (ret < 0)
+			goto exit;
+	}
+
+	/* For WEP Shared auth */
+	if ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared
+		|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key
+	)
+	{
+		u32 wep_key_idx, wep_key_len,wep_total_len;
+		struct ndis_802_11_wep	 *pwep = NULL;
+		DBG_8192D("%s(): Shared/Auto WEP\n",__func__);
+
+		wep_key_idx = sme->key_idx;
+		wep_key_len = sme->key_len;
+
+		if (sme->key_idx > WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
+			pwep =(struct ndis_802_11_wep *)kmalloc(wep_total_len, GFP_KERNEL);
+			if (pwep == NULL) {
+				DBG_8192D(" wpa_set_encryption: pwep allocate fail !!!\n");
+				ret = -ENOMEM;
+				goto exit;
+			}
+
+			memset(pwep, 0, wep_total_len);
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if (wep_key_len==13) {
+				padapter->securitypriv.dot11PrivacyAlgrthm=_WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy=_WEP104_;
+			}
+		} else {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		memcpy(pwep->KeyMaterial,  (void *)sme->key, pwep->KeyLength);
+
+		if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+			ret = -EOPNOTSUPP ;
+
+		if (pwep)
+			kfree(pwep);
+
+		if (ret < 0)
+			goto exit;
+	}
+
+	ret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, false);
+	if (ret < 0)
+		return ret;
+
+	if (sme->crypto.n_akm_suites) {
+		ret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);
+		if (ret < 0)
+			goto exit;
+	}
+
+	authmode = psecuritypriv->ndisauthtype;
+	rtw_set_802_11_authentication_mode(padapter, authmode);
+
+	if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
+		ret = -1;
+		goto exit;
+	}
+
+	DBG_8192D("set ssid:dot11AuthAlgrthm=%d, dot11PrivacyAlgrthm=%d, dot118021XGrpPrivacy=%d\n",
+		  psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+		  psecuritypriv->dot118021XGrpPrivacy);
+
+exit:
+
+	DBG_8192D("<=%s, ret %d\n",__func__, ret);
+
+	return ret;
+}
+
+static int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,
+				   u16 reason_code)
+{
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	rtw_set_roaming(padapter, 0);
+
+	if (check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+	{
+		rtw_scan_abort(padapter);
+		LeaveAllPowerSaveMode(padapter);
+		rtw_disassoc_cmd(padapter, 500, false);
+
+		DBG_8192D("%s...call rtw_indicate_disconnect\n", __func__);
+
+		padapter->mlmepriv.not_indic_disco = true;
+		rtw_indicate_disconnect(padapter);
+		padapter->mlmepriv.not_indic_disco = false;
+
+		rtw_free_assoc_resources(padapter, 1);
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_txpower(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	struct wireless_dev *wdev,
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	enum nl80211_tx_power_setting type, int mbm)
+#else
+	enum tx_power_setting type, int dbm)
+#endif
+{
+	DBG_8192D("%s\n", __func__);
+	return 0;
+}
+
+static int cfg80211_rtw_get_txpower(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	struct wireless_dev *wdev,
+#endif
+	int *dbm)
+{
+	DBG_8192D("%s\n", __func__);
+	*dbm = (12);
+	return 0;
+}
+
+inline bool rtw_cfg80211_pwr_mgmt(struct rtw_adapter *adapter)
+{
+	struct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	return rtw_wdev_priv->power_mgmt;
+}
+
+static int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,
+				       struct net_device *ndev,
+				       bool enabled, int timeout)
+{
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct rtw_wdev_priv *rtw_wdev_priv = wdev_to_priv(padapter->rtw_wdev);
+
+	DBG_8192D(FUNC_NDEV_FMT" enabled:%u, timeout:%d\n", FUNC_NDEV_ARG(ndev),
+		enabled, timeout);
+
+	rtw_wdev_priv->power_mgmt = enabled;
+
+	#ifdef CONFIG_LPS
+	if (!enabled)
+		LPS_Leave(padapter);
+	#endif
+
+	return 0;
+}
+
+static int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,
+				  struct net_device *netdev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	u8	index,blInserted = false;
+	struct rtw_adapter	*padapter = wiphy_to_adapter(wiphy);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	u8	strZeroMacAddress[ETH_ALEN] = { 0x00 };
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+
+	if (!memcmp(pmksa->bssid, strZeroMacAddress, ETH_ALEN))
+		return -EINVAL;
+
+	blInserted = false;
+
+	/* overwrite PMKID */
+	for (index=0 ; index<NUM_PMKID_CACHE; index++) {
+		if (!memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN))
+		{ /*  BSSID is matched, the same AP => rewrite with new PMKID. */
+			DBG_8192D(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(netdev));
+
+			memcpy(psecuritypriv->PMKIDList[index].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+			psecuritypriv->PMKIDList[index].bUsed = true;
+			psecuritypriv->PMKIDIndex = index+1;
+			blInserted = true;
+			break;
+		}
+	}
+
+	if (!blInserted)
+	{
+		/*  Find a new entry */
+		DBG_8192D(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",
+			FUNC_NDEV_ARG(netdev), psecuritypriv->PMKIDIndex);
+
+		memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, pmksa->bssid, ETH_ALEN);
+		memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);
+
+		psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
+		psecuritypriv->PMKIDIndex++ ;
+		if (psecuritypriv->PMKIDIndex==16)
+		{
+			psecuritypriv->PMKIDIndex =0;
+		}
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,
+				  struct net_device *netdev,
+				  struct cfg80211_pmksa *pmksa)
+{
+	u8	index, bMatched = false;
+	struct rtw_adapter	*padapter = wiphy_to_adapter(wiphy);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+
+	for (index=0 ; index<NUM_PMKID_CACHE; index++)
+	{
+		if (!memcmp(psecuritypriv->PMKIDList[index].Bssid, pmksa->bssid, ETH_ALEN))
+		{ /*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
+			memset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN);
+			memset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN);
+			psecuritypriv->PMKIDList[index].bUsed = false;
+			bMatched = true;
+			break;
+		}
+	}
+
+	if (false == bMatched)
+	{
+		DBG_8192D(FUNC_NDEV_FMT" do not have matched BSSID\n"
+			, FUNC_NDEV_ARG(netdev));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,
+				    struct net_device *netdev)
+{
+	struct rtw_adapter	*padapter = wiphy_to_adapter(wiphy);
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(netdev));
+
+	memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+	psecuritypriv->PMKIDIndex = 0;
+
+	return 0;
+}
+
+#ifdef CONFIG_92D_AP_MODE
+void rtw_cfg80211_indicate_sta_assoc(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
+{
+	s32 freq;
+	int channel;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	struct net_device *ndev = padapter->pnetdev;
+	u32 flags = 0;
+
+	DBG_8192D("%s(padapter=%p,%s)\n", __func__, padapter, ndev->name);
+
+#if defined(RTW_USE_CFG80211_STA_EVENT)
+	{
+		struct station_info sinfo;
+		u8 ie_offset;
+		if (GetFrameSubType(pmgmt_frame) == WIFI_ASSOCREQ)
+			ie_offset = _ASOCREQ_IE_OFFSET_;
+		else /*  WIFI_REASSOCREQ */
+			ie_offset = _REASOCREQ_IE_OFFSET_;
+
+		sinfo.filled = 0;
+		sinfo.filled = STATION_INFO_ASSOC_REQ_IES;
+		sinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;
+		sinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;
+		cfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);
+	}
+#else /* defined(RTW_USE_CFG80211_STA_EVENT) */
+	channel = pmlmeext->cur_channel;
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, flags);
+#endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
+}
+
+void rtw_cfg80211_indicate_sta_disassoc(struct rtw_adapter *padapter, unsigned char *da, unsigned short reason)
+{
+	s32 freq;
+	int channel;
+	u8 *pmgmt_frame;
+	uint frame_len;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	__le16 *fctrl;
+	u8 mgmt_buf[128] = {0};
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct net_device *ndev = padapter->pnetdev;
+	u32 flags = 0;
+
+	DBG_8192D("%s(padapter=%p,%s)\n", __func__, padapter, ndev->name);
+
+#if defined(RTW_USE_CFG80211_STA_EVENT)
+	cfg80211_del_sta(ndev, da, GFP_ATOMIC);
+#else /* defined(RTW_USE_CFG80211_STA_EVENT) */
+	channel = pmlmeext->cur_channel;
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	pmgmt_frame = mgmt_buf;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pmgmt_frame;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);
+	memcpy(pwlanhdr->addr2, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pmgmt_frame, WIFI_DEAUTH);
+
+	pmgmt_frame += sizeof(struct rtw_ieee80211_hdr_3addr);
+	frame_len = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+//	reason = cpu_to_le16(reason);
+	pmgmt_frame = rtw_set_fixed_ie(pmgmt_frame, _RSON_CODE_ , (unsigned char *)&reason, &frame_len);
+
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, mgmt_buf, frame_len, flags);
+#endif /* defined(RTW_USE_CFG80211_STA_EVENT) */
+}
+
+static int rtw_cfg80211_monitor_if_open(struct net_device *ndev)
+{
+	int ret = 0;
+
+	DBG_8192D("%s\n", __func__);
+
+	return ret;
+}
+
+static int rtw_cfg80211_monitor_if_close(struct net_device *ndev)
+{
+	int ret = 0;
+
+	DBG_8192D("%s\n", __func__);
+
+	return ret;
+}
+
+static int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)
+{
+	int ret = 0;
+	int rtap_len;
+	int qos_len = 0;
+	int dot11_hdr_len = 24;
+	int snap_len = 6;
+	unsigned char *pdata;
+	u16 frame_ctl;
+	unsigned char src_mac_addr[6];
+	unsigned char dst_mac_addr[6];
+	struct ieee80211_hdr *dot11_hdr;
+	struct ieee80211_radiotap_header *rtap_hdr;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
+		goto fail;
+
+	rtap_hdr = (struct ieee80211_radiotap_header *)skb->data;
+	if (unlikely(rtap_hdr->it_version))
+		goto fail;
+
+	rtap_len = ieee80211_get_radiotap_len(skb->data);
+	if (unlikely(skb->len < rtap_len))
+		goto fail;
+
+	if (rtap_len != 14)
+	{
+		DBG_8192D("radiotap len (should be 14): %d\n", rtap_len);
+		goto fail;
+	}
+
+	/* Skip the ratio tap header */
+	skb_pull(skb, rtap_len);
+
+	dot11_hdr = (struct ieee80211_hdr *)skb->data;
+	frame_ctl = le16_to_cpu(dot11_hdr->frame_control);
+	/* Check if the QoS bit is set */
+	if ((frame_ctl & RTW_IEEE80211_FCTL_FTYPE) == RTW_IEEE80211_FTYPE_DATA) {
+		/* Check if this ia a Wireless Distribution System (WDS) frame
+		 * which has 4 MAC addresses
+		 */
+		if (frame_ctl & 0x0080)
+			qos_len = 2;
+		if ((frame_ctl & 0x0300) == 0x0300)
+			dot11_hdr_len += 6;
+
+		memcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));
+		memcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));
+
+		/* Skip the 802.11 header, QoS (if any) and SNAP, but leave spaces for
+		 * for two MAC addresses
+		 */
+		skb_pull(skb, dot11_hdr_len + qos_len + snap_len - sizeof(src_mac_addr) * 2);
+		pdata = (unsigned char*)skb->data;
+		memcpy(pdata, dst_mac_addr, sizeof(dst_mac_addr));
+		memcpy(pdata + sizeof(dst_mac_addr), src_mac_addr, sizeof(src_mac_addr));
+
+		DBG_8192D("should be eapol packet\n");
+
+		/* Use the real net device to transmit the packet */
+		ret =  rtw_xmit_entry(skb, padapter->pnetdev);
+
+		return ret;
+
+	}
+	else if ((frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE))
+		== (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
+	)
+	{
+		/* only for action frames */
+		struct xmit_frame		*pmgntframe;
+		struct pkt_attrib	*pattrib;
+		unsigned char	*pframe;
+		struct rtw_ieee80211_hdr *pwlanhdr;
+		struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+		struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+		u8 *buf = skb->data;
+		u32 len = skb->len;
+		u8 category, action;
+		int type = -1;
+
+		if (rtw_action_frame_parse(buf, len, &category, &action) == false) {
+			DBG_8192D(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),
+				  ((struct rtw_ieee80211_hdr_3addr *)buf)->frame_ctl);
+			goto fail;
+		}
+
+		DBG_8192D("RTW_Tx:da=%pM via "FUNC_NDEV_FMT"\n",
+			GetAddr1Ptr(buf), FUNC_NDEV_ARG(ndev));
+		if (category == RTW_WLAN_CATEGORY_PUBLIC)
+			DBG_8192D("RTW_Tx:%s\n", action_public_str(action));
+		else
+			DBG_8192D("RTW_Tx:category(%u), action(%u)\n", category, action);
+
+dump:
+		/* starting alloc mgmt frame to dump it */
+		if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+		{
+			goto fail;
+		}
+
+		/* update attribute */
+		pattrib = &pmgntframe->attrib;
+		update_mgntframe_attrib(padapter, pattrib);
+		pattrib->retry_ctrl = false;
+
+		memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+		pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+		memcpy(pframe, (void*)buf, len);
+		pattrib->pktlen = len;
+
+		pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+		/* update seq number */
+		pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
+		pattrib->seqnum = pmlmeext->mgnt_seq;
+		pmlmeext->mgnt_seq++;
+
+		pattrib->last_txcmdsz = pattrib->pktlen;
+
+		dump_mgntframe(padapter, pmgntframe);
+
+	}
+	else
+	{
+		DBG_8192D("frame_ctl=0x%x\n", frame_ctl & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE));
+	}
+
+fail:
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void rtw_cfg80211_monitor_if_set_multicast_list(struct net_device *ndev)
+{
+	DBG_8192D("%s\n", __func__);
+}
+
+static int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)
+{
+	int ret = 0;
+
+	DBG_8192D("%s\n", __func__);
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtw_cfg80211_monitor_if_ops = {
+	.ndo_open = rtw_cfg80211_monitor_if_open,
+       .ndo_stop = rtw_cfg80211_monitor_if_close,
+       .ndo_start_xmit = rtw_cfg80211_monitor_if_xmit_entry,
+       #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0))
+       .ndo_set_multicast_list = rtw_cfg80211_monitor_if_set_multicast_list,
+       #endif
+       .ndo_set_mac_address = rtw_cfg80211_monitor_if_set_mac_address,
+};
+#endif
+
+static int rtw_cfg80211_add_monitor_if (struct rtw_adapter *padapter, char *name, struct net_device **ndev)
+{
+	int ret = 0;
+	struct net_device* mon_ndev = NULL;
+	struct wireless_dev* mon_wdev = NULL;
+	struct rtw_netdev_priv_indicator *pnpi;
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+
+	if (!name) {
+		DBG_8192D(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (pwdev_priv->pmon_ndev) {
+		DBG_8192D(FUNC_ADPT_FMT" monitor interface exist: "NDEV_FMT"\n",
+			FUNC_ADPT_ARG(padapter), NDEV_ARG(pwdev_priv->pmon_ndev));
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mon_ndev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+	if (!mon_ndev) {
+		DBG_8192D(FUNC_ADPT_FMT" allocate ndev fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+	strncpy(mon_ndev->name, name, IFNAMSIZ);
+	mon_ndev->name[IFNAMSIZ - 1] = 0;
+	mon_ndev->destructor = rtw_ndev_destructor;
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+	mon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;
+#else
+	mon_ndev->open = rtw_cfg80211_monitor_if_open;
+	mon_ndev->stop = rtw_cfg80211_monitor_if_close;
+	mon_ndev->hard_start_xmit = rtw_cfg80211_monitor_if_xmit_entry;
+	mon_ndev->set_mac_address = rtw_cfg80211_monitor_if_set_mac_address;
+#endif
+
+	pnpi = netdev_priv(mon_ndev);
+	pnpi->priv = padapter;
+	pnpi->sizeof_priv = sizeof(struct rtw_adapter);
+
+	/*  wdev */
+	mon_wdev = (struct wireless_dev *)kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);
+	if (!mon_wdev) {
+		DBG_8192D(FUNC_ADPT_FMT" allocate mon_wdev fail\n", FUNC_ADPT_ARG(padapter));
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mon_wdev->wiphy = padapter->rtw_wdev->wiphy;
+	mon_wdev->netdev = mon_ndev;
+	mon_wdev->iftype = NL80211_IFTYPE_MONITOR;
+	mon_ndev->ieee80211_ptr = mon_wdev;
+
+	ret = register_netdevice(mon_ndev);
+	if (ret) {
+		goto out;
+	}
+
+	*ndev = pwdev_priv->pmon_ndev = mon_ndev;
+	memcpy(pwdev_priv->ifname_mon, name, IFNAMSIZ+1);
+
+out:
+	if (ret && mon_wdev) {
+		kfree(mon_wdev);
+		mon_wdev = NULL;
+	}
+
+	if (ret && mon_ndev) {
+		free_netdev(mon_ndev);
+		*ndev = mon_ndev = NULL;
+	}
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+static struct wireless_dev *
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+static struct net_device *
+#else
+static int
+#endif
+	cfg80211_rtw_add_virtual_intf(
+		struct wiphy *wiphy,
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0))
+		const char *name,
+	#else
+		char *name,
+	#endif
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0))
+		unsigned char name_assign_type,
+	#endif
+		enum nl80211_iftype type, u32 *flags, struct vif_params *params)
+{
+	int ret = 0;
+	struct net_device* ndev = NULL;
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+
+	DBG_8192D(FUNC_ADPT_FMT " wiphy:%s, name:%s, type:%d\n",
+		FUNC_ADPT_ARG(padapter), wiphy_name(wiphy), name, type);
+
+	switch (type) {
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_WDS:
+	case NL80211_IFTYPE_MESH_POINT:
+		ret = -ENODEV;
+		break;
+	case NL80211_IFTYPE_MONITOR:
+		ret = rtw_cfg80211_add_monitor_if (padapter, (char *)name, &ndev);
+		break;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	case NL80211_IFTYPE_P2P_CLIENT:
+#endif
+	case NL80211_IFTYPE_STATION:
+		ret = -ENODEV;
+		break;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	case NL80211_IFTYPE_P2P_GO:
+#endif
+	case NL80211_IFTYPE_AP:
+		ret = -ENODEV;
+		break;
+	default:
+		ret = -ENODEV;
+		DBG_8192D("Unsupported interface type\n");
+		break;
+	}
+
+	DBG_8192D(FUNC_ADPT_FMT" ndev:%p, ret:%d\n", FUNC_ADPT_ARG(padapter), ndev, ret);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	return ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	return ndev ? ndev : ERR_PTR(ret);
+#else
+	return ret;
+#endif
+}
+
+static int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct wireless_dev *wdev
+#else
+	struct net_device *ndev
+#endif
+)
+{
+	struct rtw_wdev_priv *pwdev_priv = (struct rtw_wdev_priv *)wiphy_priv(wiphy);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
+	struct net_device *ndev;
+	ndev = wdev ? wdev->netdev : NULL;
+#endif
+
+	if (!ndev)
+		goto exit;
+
+	unregister_netdevice(ndev);
+
+	if (ndev == pwdev_priv->pmon_ndev) {
+		pwdev_priv->pmon_ndev = NULL;
+		pwdev_priv->ifname_mon[0] = '\0';
+		DBG_8192D(FUNC_NDEV_FMT" remove monitor interface\n", FUNC_NDEV_ARG(ndev));
+	}
+
+exit:
+	return 0;
+}
+
+static int rtw_add_beacon(struct rtw_adapter *adapter, const u8 *head, size_t head_len, const u8 *tail, size_t tail_len)
+{
+	int ret=0;
+	u8 *pbuf = NULL;
+	uint len, wps_ielen=0;
+	uint p2p_ielen=0;
+	u8 *p2p_ie;
+	u8 got_p2p_ie = false;
+	struct mlme_priv *pmlmepriv = &(adapter->mlmepriv);
+
+	DBG_8192D("%s beacon_head_len=%zu, beacon_tail_len=%zu\n", __func__, head_len, tail_len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	if (head_len<24)
+		return -EINVAL;
+
+	pbuf = kzalloc(head_len+tail_len, GFP_KERNEL);
+	if (!pbuf)
+		return -ENOMEM;
+
+	memcpy(pbuf, (void *)head+24, head_len-24);/*  24=beacon header len. */
+	memcpy(pbuf+head_len-24, (void *)tail, tail_len);
+
+	len = head_len+tail_len-24;
+
+	/* check wps ie if inclued */
+	if (rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))
+		DBG_8192D("add bcn, wps_ielen=%d\n", wps_ielen);
+
+	rtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);
+
+	/*  pbss_network->IEs will not include p2p_ie */
+	if (rtw_check_beacon_data(adapter, pbuf,  len) == _SUCCESS)
+		ret = 0;
+	else
+		ret = -EINVAL;
+
+	kfree(pbuf);
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0))
+static int	cfg80211_rtw_add_beacon(struct wiphy *wiphy, struct net_device *ndev,
+			      struct beacon_parameters *info)
+{
+	int ret=0;
+	struct rtw_adapter *adapter = wiphy_to_adapter(wiphy);
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
+
+	return ret;
+}
+
+static int	cfg80211_rtw_set_beacon(struct wiphy *wiphy, struct net_device *ndev,
+			      struct beacon_parameters *info)
+{
+	struct rtw_adapter *padapter = wiphy_to_adapter(wiphy);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	pmlmeext->bstart_bss = true;
+
+	cfg80211_rtw_add_beacon(wiphy, ndev, info);
+
+	return 0;
+}
+
+static int	cfg80211_rtw_del_beacon(struct wiphy *wiphy, struct net_device *ndev)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	return 0;
+}
+#else
+static int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,
+								struct cfg80211_ap_settings *settings)
+{
+	int ret = 0;
+	struct rtw_adapter *adapter = wiphy_to_adapter(wiphy);
+
+	DBG_8192D(FUNC_NDEV_FMT" hidden_ssid:%d, auth_type:%d\n", FUNC_NDEV_ARG(ndev),
+		settings->hidden_ssid, settings->auth_type);
+
+	ret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,
+		settings->beacon.tail, settings->beacon.tail_len);
+
+	adapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = settings->hidden_ssid;
+
+	if (settings->ssid && settings->ssid_len) {
+		struct wlan_bssid_ex *pbss_network = &adapter->mlmepriv.cur_network.network;
+		struct wlan_bssid_ex *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;
+
+		memcpy(pbss_network->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);
+		pbss_network->Ssid.SsidLength = settings->ssid_len;
+		memcpy(pbss_network_ext->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);
+		pbss_network_ext->Ssid.SsidLength = settings->ssid_len;
+	}
+
+	return ret;
+}
+
+static int cfg80211_rtw_change_beacon(struct wiphy *wiphy, struct net_device *ndev,
+                                struct cfg80211_beacon_data *info)
+{
+	int ret = 0;
+	struct rtw_adapter *adapter = wiphy_to_adapter(wiphy);
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	ret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);
+
+	return ret;
+}
+
+static int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) */
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14,0))
+static int cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
+			       const u8 *mac, struct station_parameters *params)
+#else
+static int cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,
+			       u8 *mac, struct station_parameters *params)
+#endif
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
+static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
+				    struct station_del_parameters *params)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14, 0))
+static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
+			       const u8 *mac)
+#else
+static int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,
+			       u8 *mac)
+#endif
+{
+	int ret=0;
+	struct list_head *phead, *plist;
+	u8 updated;
+	struct sta_info *psta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0))
+	const u8 *mac = params->mac;
+#endif
+
+	DBG_8192D("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+	{
+		DBG_8192D("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!mac)
+	{
+		DBG_8192D("flush all sta, and cam_entry\n");
+
+		flush_all_cam_entry(padapter);	/* clear CAM */
+
+		ret = rtw_sta_flush(padapter);
+
+		return ret;
+	}
+
+	DBG_8192D("free sta macaddr = %pM\n", mac);
+
+	if (mac[0] == 0xff && mac[1] == 0xff &&
+	    mac[2] == 0xff && mac[3] == 0xff &&
+	    mac[4] == 0xff && mac[5] == 0xff)
+	{
+		return -EINVAL;
+	}
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+
+	/* check asoc_queue */
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	{
+		psta = container_of(plist, struct sta_info, asoc_list);
+
+		plist = plist->next;
+
+		if (!memcmp(mac, psta->hwaddr, ETH_ALEN)) {
+			if (psta->dot8021xalg == 1 && psta->bpairwise_key_installed == false)
+			{
+				DBG_8192D("%s, sta's dot8021xalg = 1 and key_installed = false\n", __func__);
+			}
+			else
+			{
+				DBG_8192D("free psta=%p, aid=%d\n", psta, psta->aid);
+
+				list_del_init(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+
+				updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+
+				psta = NULL;
+
+				break;
+			}
+
+		}
+
+	}
+
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	associated_clients_update(padapter, updated);
+
+	DBG_8192D("-"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3, 14, 0))
+static int cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
+				  const u8 *mac, struct station_parameters *params)
+#else
+static int cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,
+				  u8 *mac, struct station_parameters *params)
+#endif
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	return 0;
+}
+
+static int	cfg80211_rtw_dump_station(struct wiphy *wiphy, struct net_device *ndev,
+			       int idx, u8 *mac, struct station_info *sinfo)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	/* TODO: dump scanned queue */
+
+	return -ENOENT;
+}
+
+static int	cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,
+			      struct bss_parameters *params)
+{
+	u8 i;
+
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	return 0;
+}
+
+static int	cfg80211_rtw_set_channel(struct wiphy *wiphy
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	, struct net_device *ndev
+	#endif
+	, struct ieee80211_channel *chan, enum nl80211_channel_type channel_type)
+{
+	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+	#endif
+
+	return 0;
+}
+#endif /* CONFIG_92D_AP_MODE */
+
+void rtw_cfg80211_rx_action_p2p(struct rtw_adapter *padapter, u8 *pmgmt_frame, uint frame_len)
+{
+	int type;
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	u8 category, action;
+	u32 flags = 0;
+
+	channel = rtw_get_oper_ch(padapter);
+
+	DBG_8192D("RTW_Rx:cur_ch=%d\n", channel);
+	rtw_action_frame_parse(pmgmt_frame, frame_len, &category, &action);
+	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
+
+indicate:
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, pmgmt_frame, frame_len, flags);
+}
+
+void rtw_cfg80211_rx_p2p_action_public(struct rtw_adapter *padapter, u8 *frame, uint frame_len)
+{
+	int type;
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+	u8 category, action;
+	u32 flags = 0;
+
+	channel = rtw_get_oper_ch(padapter);
+
+	DBG_8192D("RTW_Rx:cur_ch=%d\n", channel);
+	rtw_action_frame_parse(frame, frame_len, &category, &action);
+	DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
+
+indicate:
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	rtw_cfg80211_rx_mgmt(padapter, freq, 0, frame, frame_len, flags);
+}
+
+void rtw_cfg80211_rx_action(struct rtw_adapter *adapter, u8 *frame, uint frame_len, const char*msg)
+{
+	s32 freq;
+	int channel;
+	struct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
+	u8 category, action;
+	u32 flags = 0;
+
+	channel = rtw_get_oper_ch(adapter);
+
+	rtw_action_frame_parse(frame, frame_len, &category, &action);
+
+	DBG_8192D("RTW_Rx:cur_ch=%d\n", channel);
+	if (msg)
+		DBG_8192D("RTW_Rx:%s\n", msg);
+	else
+		DBG_8192D("RTW_Rx:category(%u), action(%u)\n", category, action);
+
+	if (channel <= RTW_CH_MAX_2G_CHANNEL)
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_2GHZ);
+	else
+		freq = rtw_ieee80211_channel_to_frequency(channel, IEEE80211_BAND_5GHZ);
+
+	rtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, flags);
+}
+
+static int _cfg80211_rtw_mgmt_tx(struct rtw_adapter *padapter, u8 tx_ch, const u8 *buf, size_t len)
+{
+	struct xmit_frame	*pmgntframe;
+	struct pkt_attrib	*pattrib;
+	unsigned char	*pframe;
+	int ret = _FAIL;
+	bool ack = true;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(padapter->rtw_wdev);
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
+
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	rtw_set_scan_deny(padapter, 1000);
+
+	rtw_scan_abort(padapter);
+	#ifdef CONFIG_CONCURRENT_MODE
+	if (rtw_buddy_adapter_up(padapter))
+		rtw_scan_abort(padapter->pbuddy_adapter);
+	#endif /* CONFIG_CONCURRENT_MODE */
+
+	if (padapter->cfg80211_wdinfo.is_ro_ch == true) {
+		#ifdef CONFIG_CONCURRENT_MODE
+		DBG_8192D("%s, extend ro ch time\n", __func__);
+		_set_timer(&padapter->cfg80211_wdinfo.remain_on_ch_timer, pwdinfo->ext_listen_period);
+		#endif /* CONFIG_CONCURRENT_MODE */
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_LINKED)) {
+		u8 co_channel=0xff;
+		PADAPTER pbuddy_adapter = padapter->pbuddy_adapter;
+		struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+
+		co_channel = rtw_get_oper_ch(padapter);
+
+		if (tx_ch != pbuddy_mlmeext->cur_channel) {
+			if (ATOMIC_READ(&pwdev_priv->switch_ch_to)==1) {
+				DBG_8192D("%s, issue nulldata pwrbit=1\n", __func__);
+				issue_nulldata(padapter->pbuddy_adapter, NULL, 1, 3, 500);
+
+				ATOMIC_SET(&pwdev_priv->switch_ch_to, 0);
+
+			}
+
+			DBG_8192D("%s, set switch ch timer, period=%d\n", __func__, pwdinfo->ext_listen_period);
+			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
+		}
+
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+			pmlmeext->cur_channel = tx_ch;
+
+		if (tx_ch != co_channel)
+			set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+	} else
+#endif /* CONFIG_CONCURRENT_MODE */
+	if (tx_ch != rtw_get_oper_ch(padapter)) {
+		if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
+			pmlmeext->cur_channel = tx_ch;
+		set_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
+	}
+
+	/* starting alloc mgmt frame to dump it */
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		/* ret = -ENOMEM; */
+		ret = _FAIL;
+		goto exit;
+	}
+
+	/* update attribute */
+	pattrib = &pmgntframe->attrib;
+	update_mgntframe_attrib(padapter, pattrib);
+	pattrib->retry_ctrl = false;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	memcpy(pframe, (void*)buf, len);
+	pattrib->pktlen = len;
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+	/* update seq number */
+	pmlmeext->mgnt_seq = GetSequence(pwlanhdr);
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+	pmlmeext->mgnt_seq++;
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)
+	{
+		ack = false;
+		ret = _FAIL;
+
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("%s, ack == _FAIL\n", __func__);
+		#endif
+	}
+	else
+	{
+		#ifdef CONFIG_DEBUG_CFG80211
+		DBG_8192D("%s, ack=%d, ok!\n", __func__, ack);
+		#endif
+		ret = _SUCCESS;
+	}
+
+exit:
+
+	#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D("%s, ret=%d\n", __func__, ret);
+	#endif
+
+	return ret;
+}
+
+static void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+	struct wireless_dev *wdev,
+#else
+	struct net_device *ndev,
+#endif
+	u16 frame_type, bool reg)
+{
+	struct rtw_adapter *adapter = wiphy_to_adapter(wiphy);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D(FUNC_ADPT_FMT" frame_type:%x, reg:%d\n", FUNC_ADPT_ARG(adapter),
+		frame_type, reg);
+#endif
+
+	if (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))
+		return;
+
+	return;
+}
+
+static int rtw_cfg80211_set_beacon_wpsp2pie(struct net_device *ndev, char *buf, int len)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;
+	u8 wps_oui[8]={0x0,0x50,0xf2,0x04};
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;
+	u8 *wfd_ie;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);
+
+	DBG_8192D(FUNC_NDEV_FMT" ielen=%d\n", FUNC_NDEV_ARG(ndev), len);
+
+	if (len>0)
+	{
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192D("bcn_wps_ielen=%d\n", wps_ielen);
+			#endif
+
+			if (pmlmepriv->wps_beacon_ie)
+			{
+				u32 free_len = pmlmepriv->wps_beacon_ie_len;
+				pmlmepriv->wps_beacon_ie_len = 0;
+				kfree(pmlmepriv->wps_beacon_ie);
+				pmlmepriv->wps_beacon_ie = NULL;
+			}
+
+			pmlmepriv->wps_beacon_ie = kmalloc(wps_ielen, GFP_KERNEL);
+			if (pmlmepriv->wps_beacon_ie == NULL) {
+				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+				return -EINVAL;
+
+			}
+
+			memcpy(pmlmepriv->wps_beacon_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_beacon_ie_len = wps_ielen;
+#ifdef CONFIG_92D_AP_MODE
+			update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
+#endif
+
+		}
+
+#ifdef CONFIG_92D_AP_MODE
+		pmlmeext->bstart_bss = true;
+#endif
+	}
+
+	return ret;
+}
+
+static int rtw_cfg80211_set_probe_resp_wpsp2pie(struct net_device *net, char *buf, int len)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u8 *wps_ie;
+	u32	p2p_ielen = 0;
+	u8 *p2p_ie;
+	u32	wfd_ielen = 0;
+	u8 *wfd_ie;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D("%s, ielen=%d\n", __func__, len);
+#endif
+
+	if (len>0)
+	{
+		if ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))
+		{
+			uint	attr_contentlen = 0;
+			u16	uconfig_method, *puconfig_method = NULL;
+
+			#ifdef CONFIG_DEBUG_CFG80211
+			DBG_8192D("probe_resp_wps_ielen=%d\n", wps_ielen);
+			#endif
+
+			if (pmlmepriv->wps_probe_resp_ie)
+			{
+				u32 free_len = pmlmepriv->wps_probe_resp_ie_len;
+				pmlmepriv->wps_probe_resp_ie_len = 0;
+				kfree(pmlmepriv->wps_probe_resp_ie);
+				pmlmepriv->wps_probe_resp_ie = NULL;
+			}
+
+			pmlmepriv->wps_probe_resp_ie = kmalloc(wps_ielen, GFP_KERNEL);
+			if (pmlmepriv->wps_probe_resp_ie == NULL) {
+				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+				return -EINVAL;
+
+			}
+
+			/* add PUSH_BUTTON config_method by driver self in wpsie of probe_resp at GO Mode */
+			if ((puconfig_method = (u16*)rtw_get_wps_attr_content(wps_ie, wps_ielen, WPS_ATTR_CONF_METHOD , NULL, &attr_contentlen)) != NULL)
+			{
+				*puconfig_method |= WPS_CM_PUSH_BUTTON;
+			}
+
+			memcpy(pmlmepriv->wps_probe_resp_ie, wps_ie, wps_ielen);
+			pmlmepriv->wps_probe_resp_ie_len = wps_ielen;
+
+		}
+
+	}
+	return ret;
+}
+
+static int rtw_cfg80211_set_assoc_resp_wpsp2pie(struct net_device *net, char *buf, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	DBG_8192D("%s, ielen=%d\n", __func__, len);
+
+	if (len>0) {
+		if (pmlmepriv->wps_assoc_resp_ie)
+		{
+			u32 free_len = pmlmepriv->wps_assoc_resp_ie_len;
+			pmlmepriv->wps_assoc_resp_ie_len = 0;
+			kfree(pmlmepriv->wps_assoc_resp_ie);
+			pmlmepriv->wps_assoc_resp_ie = NULL;
+		}
+
+		pmlmepriv->wps_assoc_resp_ie = kmalloc(len, GFP_KERNEL);
+		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
+			DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+			return -EINVAL;
+
+		}
+		memcpy(pmlmepriv->wps_assoc_resp_ie, buf, len);
+		pmlmepriv->wps_assoc_resp_ie_len = len;
+	}
+
+	return ret;
+}
+
+int rtw_cfg80211_set_mgnt_wpsp2pie(struct net_device *net, char *buf, int len,
+	int type)
+{
+	int ret = 0;
+	uint wps_ielen = 0;
+	u32	p2p_ielen = 0;
+
+#ifdef CONFIG_DEBUG_CFG80211
+	DBG_8192D("%s, ielen=%d\n", __func__, len);
+#endif
+
+	if ((rtw_get_wps_ie(buf, len, NULL, &wps_ielen) && (wps_ielen>0)))
+	{
+		if (net != NULL) {
+			switch (type) {
+			case 0x1: /* BEACON */
+				ret = rtw_cfg80211_set_beacon_wpsp2pie(net, buf, len);
+				break;
+			case 0x2: /* PROBE_RESP */
+				ret = rtw_cfg80211_set_probe_resp_wpsp2pie(net, buf, len);
+				break;
+			case 0x4: /* ASSOC_RESP */
+				ret = rtw_cfg80211_set_assoc_resp_wpsp2pie(net, buf, len);
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+        int     (*mgmt_tx)(struct wiphy *wiphy, struct wireless_dev *wdev,
+                          struct ieee80211_channel *chan, bool offchan,
+                          unsigned int wait, const u8 *buf, size_t len,
+                          bool no_cck, bool dont_wait_for_ack, u64 *cookie);
+static int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+				struct ieee80211_channel *chan, bool offchan,
+				unsigned int wait, const u8 *buf, size_t len,
+				bool no_cck, bool dont_wait_for_ack,
+#else
+				struct cfg80211_mgmt_tx_params *params,
+#endif
+				u64 *cookie)
+{
+	struct rtw_adapter *padapter =
+		(struct rtw_adapter *)wiphy_to_adapter(wiphy);
+	int ret = 0;
+	int tx_ret;
+	u32 dump_limit = RTW_MAX_MGMT_TX_CNT;
+	u32 dump_cnt = 0;
+	bool ack = true;
+	u8 category, action;
+	unsigned long start = jiffies;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	size_t len = params->len;
+	struct ieee80211_channel *chan = params->chan;
+	const u8 *buf = params->buf;
+#endif
+	struct ieee80211_mgmt *hdr = (struct ieee80211_mgmt *)buf;
+	u8 tx_ch = (u8) ieee80211_frequency_to_channel(chan->center_freq);
+
+	if (!ieee80211_is_action(hdr->frame_control))
+		return -EINVAL;
+
+	/* cookie generation */
+	*cookie = (unsigned long)buf;
+
+	DBG_8192D("%s(%s): len =%zu, ch =%d\n", __func__,
+		  padapter->pnetdev->name, len, tx_ch);
+
+	/* indicate ack before issue frame to avoid racing with rsp frame */
+	rtw_cfg80211_mgmt_tx_status(padapter, *cookie, buf, len, ack,
+				GFP_KERNEL);
+
+//	DBG_8192D("RTW_Tx:tx_ch =%d, da =" MAC_FMT "\n", tx_ch,
+//		  MAC_ARG(hdr->da));
+	category = hdr->u.action.category;
+	action = hdr->u.action.u.wme_action.action_code;
+	DBG_8192D("RTW_Tx:category(%u), action(%u)\n", category, action);
+
+	do {
+		dump_cnt++;
+		tx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);
+	} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);
+
+	if (tx_ret != _SUCCESS || dump_cnt > 1) {
+		DBG_8192D("%s(%s): %s (%d/%d) in %d ms\n",
+			  __func__, padapter->pnetdev->name,
+			  tx_ret == _SUCCESS ? "OK" : "FAIL", dump_cnt,
+			  dump_limit, jiffies_to_msecs(jiffies - start));
+	}
+
+	return ret;
+}
+
+static struct cfg80211_ops rtw_cfg80211_ops = {
+	.change_virtual_intf = cfg80211_rtw_change_iface,
+	.add_key = cfg80211_rtw_add_key,
+	.get_key = cfg80211_rtw_get_key,
+	.del_key = cfg80211_rtw_del_key,
+	.set_default_key = cfg80211_rtw_set_default_key,
+	.get_station = cfg80211_rtw_get_station,
+	.scan = cfg80211_rtw_scan,
+	.set_wiphy_params = cfg80211_rtw_set_wiphy_params,
+	.connect = cfg80211_rtw_connect,
+	.disconnect = cfg80211_rtw_disconnect,
+	.join_ibss = cfg80211_rtw_join_ibss,
+	.leave_ibss = cfg80211_rtw_leave_ibss,
+	.set_tx_power = cfg80211_rtw_set_txpower,
+	.get_tx_power = cfg80211_rtw_get_txpower,
+	.set_power_mgmt = cfg80211_rtw_set_power_mgmt,
+	.set_pmksa = cfg80211_rtw_set_pmksa,
+	.del_pmksa = cfg80211_rtw_del_pmksa,
+	.flush_pmksa = cfg80211_rtw_flush_pmksa,
+
+#ifdef CONFIG_92D_AP_MODE
+	.add_virtual_intf = cfg80211_rtw_add_virtual_intf,
+	.del_virtual_intf = cfg80211_rtw_del_virtual_intf,
+
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+	.add_beacon = cfg80211_rtw_add_beacon,
+	.set_beacon = cfg80211_rtw_set_beacon,
+	.del_beacon = cfg80211_rtw_del_beacon,
+	#else
+	.start_ap = cfg80211_rtw_start_ap,
+	.change_beacon = cfg80211_rtw_change_beacon,
+	.stop_ap = cfg80211_rtw_stop_ap,
+	#endif
+
+	.add_station = cfg80211_rtw_add_station,
+	.del_station = cfg80211_rtw_del_station,
+	.change_station = cfg80211_rtw_change_station,
+	.dump_station = cfg80211_rtw_dump_station,
+	.change_bss = cfg80211_rtw_change_bss,
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+	.set_channel = cfg80211_rtw_set_channel,
+	#endif
+#endif /* CONFIG_92D_AP_MODE */
+	.mgmt_tx = cfg80211_rtw_mgmt_tx,
+	.mgmt_frame_register = cfg80211_rtw_mgmt_frame_register,
+};
+
+static void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum ieee80211_band band, u8 rf_type)
+{
+
+#define MAX_BIT_RATE_40MHZ_MCS15	300	/* Mbps */
+#define MAX_BIT_RATE_40MHZ_MCS7		150	/* Mbps */
+
+	ht_cap->ht_supported = true;
+
+	ht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+					IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |
+					IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;
+
+	/*
+	 *Maximum length of AMPDU that the STA can receive.
+	 *Length = 2 ^ (13 + max_ampdu_length_exp) - 1 (octets)
+	 */
+	ht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;
+
+	/*Minimum MPDU start spacing , */
+	ht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;
+
+	ht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
+
+	/*
+	 *hw->wiphy->bands[IEEE80211_BAND_2GHZ]
+	 *base on ant_num
+	 *rx_mask: RX mask
+	 *if rx_ant =1 rx_mask[0]=0xff;==>MCS0-MCS7
+	 *if rx_ant =2 rx_mask[1]=0xff;==>MCS8-MCS15
+	 *if rx_ant >=3 rx_mask[2]=0xff;
+	 *if BW_40 rx_mask[4]=0x01;
+	 *highest supported RX rate
+	 */
+	if (rf_type == RF_1T1R)
+	{
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0x00;
+		ht_cap->mcs.rx_mask[4] = 0x01;
+
+		ht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS7);
+	}
+	else if ((rf_type == RF_1T2R) || (rf_type==RF_2T2R))
+	{
+		ht_cap->mcs.rx_mask[0] = 0xFF;
+		ht_cap->mcs.rx_mask[1] = 0xFF;
+		ht_cap->mcs.rx_mask[4] = 0x01;
+
+		ht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS15);
+	}
+	else
+	{
+		DBG_8192D("%s, error rf_type=%d\n", __func__, rf_type);
+	}
+}
+
+void rtw_cfg80211_init_wiphy(struct rtw_adapter *padapter)
+{
+	u8 rf_type;
+	struct ieee80211_supported_band *bands;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+	struct wiphy *wiphy = pwdev->wiphy;
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+	DBG_8192D("%s:rf_type=%d\n", __func__, rf_type);
+
+	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
+	{
+		bands = wiphy->bands[IEEE80211_BAND_2GHZ];
+		if (bands)
+			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_2GHZ, rf_type);
+	}
+
+	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
+	{
+		bands = wiphy->bands[IEEE80211_BAND_5GHZ];
+		if (bands)
+			rtw_cfg80211_init_ht_capab(&bands->ht_cap, IEEE80211_BAND_5GHZ, rf_type);
+	}
+}
+
+static void rtw_cfg80211_preinit_wiphy(struct rtw_adapter *padapter, struct wiphy *wiphy)
+{
+
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+
+	wiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;
+	wiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;
+	wiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38))
+	wiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;
+#endif
+
+	wiphy->interface_modes = BIT(NL80211_IFTYPE_ADHOC) |
+#ifdef CONFIG_92D_AP_MODE
+				 BIT(NL80211_IFTYPE_AP) |
+				 BIT(NL80211_IFTYPE_MONITOR) |
+#endif
+				 BIT(NL80211_IFTYPE_STATION);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+#ifdef CONFIG_92D_AP_MODE
+	wiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;
+#endif /* CONFIG_92D_AP_MODE */
+#endif
+
+	wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
+
+	/*
+	wiphy->iface_combinations = &rtw_combinations;
+	wiphy->n_iface_combinations = 1;
+	*/
+
+	wiphy->cipher_suites = rtw_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);
+
+	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11G) */
+		wiphy->bands[IEEE80211_BAND_2GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_2GHZ);
+	/* if (padapter->registrypriv.wireless_mode & WIRELESS_11A) */
+		wiphy->bands[IEEE80211_BAND_5GHZ] = rtw_spt_band_alloc(IEEE80211_BAND_5GHZ);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,38) && LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SEPARATE_DEFAULT_KEYS;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;
+#endif
+
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+		wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
+	else
+		wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+}
+
+int rtw_wdev_alloc(struct rtw_adapter *padapter, struct device *dev)
+{
+	int ret = 0;
+	struct wiphy *wiphy;
+	struct wireless_dev *wdev;
+	struct rtw_wdev_priv *pwdev_priv;
+	struct net_device *pnetdev = padapter->pnetdev;
+
+	DBG_8192D("%s(padapter=%p)\n", __func__, padapter);
+
+	/* wiphy */
+	wiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct rtw_wdev_priv));
+	if (!wiphy) {
+		DBG_8192D("Couldn't allocate wiphy device\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	set_wiphy_dev(wiphy, dev);
+	rtw_cfg80211_preinit_wiphy(padapter, wiphy);
+
+	ret = wiphy_register(wiphy);
+	if (ret < 0) {
+		DBG_8192D("Couldn't register wiphy device\n");
+		goto free_wiphy;
+	}
+
+	/*  wdev */
+	wdev = (struct wireless_dev *)kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);
+	if (!wdev) {
+		DBG_8192D("Couldn't allocate wireless device\n");
+		ret = -ENOMEM;
+		goto unregister_wiphy;
+	}
+	wdev->wiphy = wiphy;
+	wdev->netdev = pnetdev;
+	wdev->iftype = NL80211_IFTYPE_STATION;
+	padapter->rtw_wdev = wdev;
+	pnetdev->ieee80211_ptr = wdev;
+
+	/* init pwdev_priv */
+	pwdev_priv = wdev_to_priv(wdev);
+	pwdev_priv->rtw_wdev = wdev;
+	pwdev_priv->pmon_ndev = NULL;
+	pwdev_priv->ifname_mon[0] = '\0';
+	pwdev_priv->padapter = padapter;
+	pwdev_priv->scan_request = NULL;
+	_rtw_spinlock_init(&pwdev_priv->scan_req_lock);
+
+	pwdev_priv->p2p_enabled = false;
+	pwdev_priv->provdisc_req_issued = false;
+	rtw_wdev_invit_info_init(&pwdev_priv->invit_info);
+
+	pwdev_priv->bandroid_scan = false;
+
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+		pwdev_priv->power_mgmt = true;
+	else
+		pwdev_priv->power_mgmt = false;
+
+#ifdef CONFIG_CONCURRENT_MODE
+	ATOMIC_SET(&pwdev_priv->switch_ch_to, 1);
+	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
+#endif
+
+	return ret;
+
+	kfree(wdev);
+unregister_wiphy:
+	wiphy_unregister(wiphy);
+ free_wiphy:
+	wiphy_free(wiphy);
+exit:
+	return ret;
+}
+
+void rtw_wdev_free(struct wireless_dev *wdev)
+{
+	struct rtw_wdev_priv *pwdev_priv;
+
+	DBG_8192D("%s(wdev=%p)\n", __func__, wdev);
+
+	if (!wdev)
+		return;
+
+	pwdev_priv = wdev_to_priv(wdev);
+
+	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_2GHZ]);
+	rtw_spt_band_free(wdev->wiphy->bands[IEEE80211_BAND_5GHZ]);
+
+	wiphy_free(wdev->wiphy);
+
+	kfree(wdev);
+}
+
+void rtw_wdev_unregister(struct wireless_dev *wdev)
+{
+	struct rtw_wdev_priv *pwdev_priv;
+
+	DBG_8192D("%s(wdev=%p)\n", __func__, wdev);
+
+	if (!wdev)
+		return;
+
+	pwdev_priv = wdev_to_priv(wdev);
+
+	rtw_cfg80211_indicate_scan_done(pwdev_priv, true);
+
+	if (pwdev_priv->pmon_ndev) {
+		DBG_8192D("%s, unregister monitor interface\n", __func__);
+		unregister_netdev(pwdev_priv->pmon_ndev);
+	}
+
+	wiphy_unregister(wdev->wiphy);
+}
diff --git a/drivers/net/wireless/rtl8192du/os_dep/ioctl_linux.c b/drivers/net/wireless/rtl8192du/os_dep/ioctl_linux.c
new file mode 100644
index 0000000..8966989
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/ioctl_linux.c
@@ -0,0 +1,5731 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define  _IOCTL_LINUX_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <wlan_bssdef.h>
+#include <rtw_debug.h>
+#include <wifi.h>
+#include <rtw_mlme.h>
+#include <rtw_mlme_ext.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <rtw_mp_ioctl.h>
+#include <usb_osintf.h>
+#include <usb_ops.h>
+#include <linux/vmalloc.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27))
+#define  iwe_stream_add_event(a, b, c, d, e)  iwe_stream_add_event(b, c, d, e)
+#define  iwe_stream_add_point(a, b, c, d, e)  iwe_stream_add_point(b, c, d, e)
+#endif
+
+#define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV+30)
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+/*  combo scan */
+#define WEXT_CSCAN_AMOUNT 9
+#define WEXT_CSCAN_BUF_LEN		360
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+
+static u32 rtw_rates[] = {
+	1000000, 2000000, 5500000, 11000000,
+	6000000, 9000000, 12000000, 18000000,
+	24000000, 36000000, 48000000, 54000000
+};
+
+static const char * const iw_operation_mode[] = {
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater",
+	"Secondary", "Monitor"
+};
+
+static int hex2num_i(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
+
+static int hex2byte_i(const char *hex)
+{
+	int a, b;
+	a = hex2num_i(*hex++);
+	if (a < 0)
+		return -1;
+	b = hex2num_i(*hex++);
+	if (b < 0)
+		return -1;
+	return (a << 4) | b;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, u8 *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex2num_i(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex2num_i(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static void indicate_wx_custom_event(struct rtw_adapter *padapter, char *msg)
+{
+}
+
+static void request_wps_pbc_event(struct rtw_adapter *padapter)
+{
+}
+
+void indicate_wx_scan_complete_event(struct rtw_adapter *padapter)
+{
+}
+
+void rtw_indicate_wx_assoc_event(struct rtw_adapter *padapter)
+{
+}
+
+void rtw_indicate_wx_disassoc_event(struct rtw_adapter *padapter)
+{
+}
+
+static char *translate_scan(struct rtw_adapter *padapter,
+			    struct iw_request_info *info,
+			    struct wlan_network *pnetwork,
+			    char *start, char *stop)
+{
+	struct iw_event iwe;
+	__le16 cap;
+	u16 cpu_cap;
+	u32 ht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate = 0, rate, ht_cap = false;
+	u32 i = 0;
+	char	*current_val;
+	long rssi;
+	u8 bw_40MHz = 0, short_GI = 0;
+	u16 mcs_rate = 0;
+	struct registry_priv *pregpriv = &padapter->registrypriv;
+
+	/*  AP MAC address  */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/* parsing HT_CAP_IE */
+		p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
+
+	if (p && ht_ielen > 0)
+	{
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = true;
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;
+	}
+
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if (rtw_is_cckratesonly_included((u8 *)&pnetwork->network.SupportedRates)) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	} else if (rtw_is_cckrates_included((u8 *)&pnetwork->network.SupportedRates)) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	} else {
+		if (pnetwork->network.Configuration.DSConfig > 14) {
+			if (ht_cap == true)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
+		} else {
+			if (ht_cap == true)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	/* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	memcpy((u8 *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+
+	cpu_cap = le16_to_cpu(cap);
+
+	if (cpu_cap & (WLAN_CAPABILITY_IBSS |WLAN_CAPABILITY_BSS)) {
+		if (cpu_cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+
+	if (pnetwork->network.Configuration.DSConfig<1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe.u.freq.e = 1;
+	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cpu_cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/*Add basic and extended rates */
+	max_rate = 0;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while (pnetwork->network.SupportedRates[i] != 0) {
+		rate = pnetwork->network.SupportedRates[i]&0x7F;
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+
+	if (ht_cap == true) {
+		if (mcs_rate&0x8000) { /* MCS15 */
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+
+		} else if (mcs_rate&0x0080) { /* MCS7 */
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		} else { /* default MCS7 */
+			DBG_8192D("wx_get_scan, mcs_rate_bitmap = 0x%x\n", mcs_rate);
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;/* Mbps/2; */
+	}
+
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = max_rate * 500000;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
+
+	/* parsing WPA/WPA2 IE */
+	{
+		u8 buf[MAX_WPA_IE_LEN];
+		u8 wpa_ie[255], rsn_ie[255];
+		u16 wpa_len = 0, rsn_len = 0;
+		u8 *p;
+
+		rtw_get_sec_ie(pnetwork->network.IEs , pnetwork->network.IELength, rsn_ie,&rsn_len, wpa_ie,&wpa_len);
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: ssid =%s\n", pnetwork->network.Ssid.Ssid));
+		RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));
+
+		if (wpa_len > 0) {
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "wpa_ie =");
+			for (i = 0; i < wpa_len; i++)
+				p += sprintf(p, "%02x", wpa_ie[i]);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = wpa_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);
+		}
+		if (rsn_len > 0) {
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "rsn_ie =");
+			for (i = 0; i < rsn_len; i++)
+				p += sprintf(p, "%02x", rsn_ie[i]);
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);
+		}
+	}
+
+	{ /* parsing WPS IE */
+		uint cnt = 0, total_ielen;
+		u8 *wpsie_ptr = NULL;
+		uint wps_ielen = 0;
+
+		u8 *ie_ptr = pnetwork->network.IEs +_FIXED_IE_LENGTH_;
+		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+
+		while (cnt < total_ielen) {
+			if (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen>2)) {
+				wpsie_ptr = &ie_ptr[cnt];
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);
+			}
+			cnt+= ie_ptr[cnt+1]+2; /* goto next */
+		}
+	}
+
+{
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	u8 ss, sq;
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		| IW_QUAL_DBM
+	#endif
+	;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+	    is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+		ss = padapter->recvpriv.signal_strength;
+		sq = padapter->recvpriv.signal_qual;
+	} else {
+		ss = pnetwork->network.PhyInfo.SignalStrength;
+		sq = pnetwork->network.PhyInfo.SignalQuality;
+	}
+
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	iwe.u.qual.level = (u8) translate_percentage_to_dbm(ss);/* dbm */
+	#else
+	iwe.u.qual.level = (u8)ss;/*  */
+	#endif
+
+	iwe.u.qual.qual = (u8)sq;   /*  signal quality */
+
+	iwe.u.qual.noise = 0; /*  noise level */
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+}
+
+	return start;
+}
+
+static int wpa_set_auth_algs(struct net_device *dev, u32 value)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *) rtw_netdev_priv(dev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY)&&(value & AUTH_ALG_OPEN_SYSTEM)) {
+		DBG_8192D("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and  AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n", value);
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+		padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODESWITCH;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+	} else if (value & AUTH_ALG_SHARED_KEY) {
+		DBG_8192D("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n", value);
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+
+		padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODESHARED;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
+		DBG_8192D("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
+		if (padapter->securitypriv.ndisauthtype < NDIS802_11AUTHMODEWPAPSK) {
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		}
+	} else if (value & AUTH_ALG_LEAP) {
+		DBG_8192D("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
+	} else {
+		DBG_8192D("wpa_set_auth_algs, error!\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len, wep_total_len;
+	struct ndis_802_11_wep *pwep = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) +
+	    param->u.crypt.key_len) {
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("wpa_set_encryption, crypt.alg = WEP\n"));
+		DBG_8192D("wpa_set_encryption, crypt.alg = WEP\n");
+
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+		padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("(1)wep_key_idx =%d\n", wep_key_idx));
+		DBG_8192D("(1)wep_key_idx =%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("(2)wep_key_idx =%d\n", wep_key_idx));
+
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
+			pwep = (struct ndis_802_11_wep *) kmalloc(wep_total_len, GFP_KERNEL);
+			if (pwep == NULL) {
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, (" wpa_set_encryption: pwep allocate fail !!!\n"));
+				goto exit;
+			}
+
+			memset(pwep, 0, wep_total_len);
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if (wep_key_len == 13) {
+				padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+				padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
+			}
+		} else {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if (param->u.crypt.set_tx) {
+			DBG_8192D("wep, set_tx = 1\n");
+
+			if (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)
+				ret = -EOPNOTSUPP ;
+		} else {
+			DBG_8192D("wep, set_tx = 0\n");
+
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP ;
+				goto exit;
+			}
+
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx]= pwep->KeyLength;
+			rtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);
+		}
+
+		goto exit;
+	}
+
+	if (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) { /*  802_1x */
+		struct sta_info * psta,*pbcmc_sta;
+		struct sta_priv * pstapriv = &padapter->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE)) { /* sta mode */
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			if (psta) {
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					psta->ieee8021x_blocked = false;
+
+				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
+				    (padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
+					psta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+
+				if (param->u.crypt.set_tx == 1)/* pairwise key */ {
+					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0) { /* set mic key */
+						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						padapter->securitypriv.busetkipkey = false;
+					}
+
+					DBG_8192D("\n ~~~~stastakey:unicastkey\n");
+
+					rtw_setstakey_cmd(padapter, (unsigned char *)psta, true);
+				} else { /* group key */
+					memcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+					memcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]), 8);
+					memcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]), 8);
+					padapter->securitypriv.binstallGrpkey = true;
+					DBG_8192D("\n ~~~~stastakey:groupkey\n");
+
+					padapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+
+					rtw_set_key(padapter,&padapter->securitypriv, param->u.crypt.idx, 1);
+				}
+			}
+
+			pbcmc_sta = rtw_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta) {
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					pbcmc_sta->ieee8021x_blocked = false;
+
+				if ((padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION2ENABLED)||
+				    (padapter->securitypriv.ndisencryptstatus ==  NDIS802_11ENCRYPTION3ENABLED))
+					pbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;
+			}
+		}
+	}
+
+exit:
+
+	kfree(pwep);
+
+	return ret;
+}
+
+static int rtw_set_wpa_ie(struct rtw_adapter *padapter, char *pie, unsigned short ielen)
+{
+	u8 *buf = NULL;
+	u32 left;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	u8	null_addr[]= {0, 0, 0, 0, 0, 0};
+	int i;
+
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		if (pie == NULL)
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if (ielen) {
+		buf = kzalloc(ielen, GFP_KERNEL);
+		if (buf == NULL) {
+			ret =  -ENOMEM;
+			goto exit;
+		}
+
+		memcpy(buf, pie , ielen);
+
+		/* dump */
+		DBG_8192D("\n wpa_ie(length:%d):\n", ielen);
+		for (i = 0;i<ielen;i = i+8)
+			DBG_8192D("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n",
+				  buf[i], buf[i+1], buf[i+2], buf[i+3],
+				  buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
+
+		if (ielen < RSN_HEADER_LEN) {
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+				 ("Ie len too short %d\n", ielen));
+			ret  = -1;
+			goto exit;
+		}
+
+		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK;
+			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
+		}
+
+		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher) == _SUCCESS) {
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK;
+			memcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);
+		}
+
+		if (group_cipher == 0)
+			group_cipher = WPA_CIPHER_NONE;
+		if (pairwise_cipher == 0)
+			pairwise_cipher = WPA_CIPHER_NONE;
+
+		switch (group_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot118021XGrpPrivacy = _AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		}
+
+		switch (pairwise_cipher) {
+		case WPA_CIPHER_NONE:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			break;
+		case WPA_CIPHER_WEP40:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		case WPA_CIPHER_TKIP:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+			break;
+		case WPA_CIPHER_CCMP:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _AES_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+			break;
+		case WPA_CIPHER_WEP104:
+			padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			break;
+		}
+
+		_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);
+		{/* set wps_ie */
+			u16 cnt = 0;
+			u8 eid, wps_oui[4]={0x0, 0x50, 0xf2, 0x04};
+
+			while (cnt < ielen) {
+				eid = buf[cnt];
+
+				if ((eid == _VENDOR_SPECIFIC_IE_) && (!memcmp(&buf[cnt+2], wps_oui, 4))) {
+					DBG_8192D("SET WPS_IE\n");
+
+					padapter->securitypriv.wps_ie_len = ((buf[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (buf[cnt+1]+2):(MAX_WPA_IE_LEN<<2);
+
+					memcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);
+
+					set_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);
+					cnt += buf[cnt+1]+2;
+
+					break;
+				} else {
+					cnt += buf[cnt+1]+2; /* goto next */
+				}
+			}
+		}
+	}
+
+	/* TKIP and AES disallow multicast packets until installing group key */
+	if (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_ ||
+	    padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_ ||
+	    padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)
+		/* WPS open need to enable multicast */
+		rtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",
+		  pairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));
+
+exit:
+
+	kfree(buf);
+
+	return ret;
+}
+
+static int rtw_wx_get_name(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u16 cap;
+	u32 ht_ielen = 0;
+	char *p;
+	u8 ht_cap = false;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+	unsigned char prates[NDIS_802_11_LENGTH_RATES_EX] = {0};
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("cmd_code =%x\n", info->cmd));
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {
+		/* parsing HT_CAP_IE */
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if (p && ht_ielen > 0)
+			ht_cap = true;
+
+		memcpy(prates, pcur_bss->SupportedRates, NDIS_802_11_LENGTH_RATES_EX);
+
+		if (rtw_is_cckratesonly_included((u8 *)prates)) {
+			if (ht_cap)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
+		} else if ((rtw_is_cckrates_included((u8 *)prates))) {
+			if (ht_cap)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
+		} else {
+			if (pcur_bss->Configuration.DSConfig > 14) {
+				if (ht_cap)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
+			} else {
+				if (ht_cap)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+			}
+		}
+	} else {
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_freq(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));
+
+	return 0;
+}
+
+static int rtw_wx_get_freq(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED)) {
+		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+	} else {
+		wrqu->freq.m = rtw_ch2freq(padapter->mlmeextpriv.cur_channel) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = padapter->mlmeextpriv.cur_channel;
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
+			   union iwreq_data *wrqu, char *b)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	int ret = 0;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct __queue *queue = &pmlmepriv->scanned_queue;
+
+	if (_FAIL == rtw_pwr_wakeup(padapter)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (padapter->hw_init_completed == false) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	switch (wrqu->mode) {
+	case IW_MODE_AUTO:
+		networkType = NDIS802_11AUTOUNK;
+		DBG_8192D("set_mode = IW_MODE_AUTO\n");
+		break;
+	case IW_MODE_ADHOC:
+		networkType = NDIS802_11IBSS;
+		DBG_8192D("set_mode = IW_MODE_ADHOC\n");
+		break;
+	case IW_MODE_MASTER:
+		networkType = NDIS802_11APMODE;
+		DBG_8192D("set_mode = IW_MODE_MASTER\n");
+		break;
+	case IW_MODE_INFRA:
+		networkType = NDIS802_11INFRA;
+		DBG_8192D("set_mode = IW_MODE_INFRA\n");
+		break;
+	default :
+		ret = -EINVAL;;
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_,
+			 ("\n Mode: %s is not supported\n",
+			 iw_operation_mode[wrqu->mode]));
+		goto exit;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
+	if (rtw_set_802_11_infrastructure_mode(padapter, networkType) == false) {
+
+		ret = -EPERM;
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
+		goto exit;
+
+	}
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
+	rtw_setopmode_cmd(padapter, networkType);
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
+			   union iwreq_data *wrqu, char *b)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_get_mode\n"));
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		wrqu->mode = IW_MODE_INFRA;
+	else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		 (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+		wrqu->mode = IW_MODE_ADHOC;
+	else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+		wrqu->mode = IW_MODE_MASTER;
+	else
+		wrqu->mode = IW_MODE_AUTO;
+
+	return 0;
+}
+
+static int rtw_wx_set_pmkid(struct net_device *dev,
+	                    struct iw_request_info *a,
+			    union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv  *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct iw_pmksa*  pPMK = (struct iw_pmksa*) extra;
+	u8          j, blInserted = false;
+	int         intReturn = false;
+	u8     strZeroMacAddress[ETH_ALEN] = { 0x00 };
+	u8     strIssueBssid[ETH_ALEN] = { 0x00 };
+
+	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+	if (pPMK->cmd == IW_PMKSA_ADD) {
+		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");
+		if (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))
+			return(intReturn);
+		else
+			intReturn = true;
+		blInserted = false;
+
+		/* overwrite PMKID */
+		for (j = 0; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {
+				/*  BSSID is matched, the same AP => rewrite with new PMKID. */
+				DBG_8192D("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
+
+				memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+				psecuritypriv->PMKIDList[j].bUsed = true;
+				psecuritypriv->PMKIDIndex = j+1;
+				blInserted = true;
+				break;
+			}
+	        }
+
+	        if (!blInserted) {
+			/*  Find a new entry */
+			DBG_8192D("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
+				  psecuritypriv->PMKIDIndex);
+
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == 16)
+				psecuritypriv->PMKIDIndex = 0;
+		}
+	} else if (pPMK->cmd == IW_PMKSA_REMOVE) {
+		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");
+		intReturn = true;
+		for (j = 0; j < NUM_PMKID_CACHE; j++) {
+			if (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {
+				/*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
+				memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
+				psecuritypriv->PMKIDList[j].bUsed = false;
+				break;
+			}
+	        }
+	} else if (pPMK->cmd == IW_PMKSA_FLUSH) {
+		DBG_8192D("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");
+		memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		psecuritypriv->PMKIDIndex = 0;
+		intReturn = true;
+	}
+	return intReturn;
+}
+
+static int rtw_wx_get_sens(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	wrqu->sens.value = 0;
+	wrqu->sens.fixed = 0;	/* no auto select */
+	wrqu->sens.disabled = 1;
+	return 0;
+}
+
+static int rtw_wx_get_range(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+
+	u16 val;
+	int i;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_range. cmd_code =%x\n", info->cmd));
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;
+
+	/* Old Frequency (backward compat - moved lower) */
+	/* signal level threshold range */
+
+	/* percent values between 0 and 100. */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 178; /* -78 dBm */
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = rtw_rates[i];
+	}
+
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	range->pm_capa = 0;
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
+
+		/*  Include only legal frequencies for some countries */
+		if (pmlmeext->channel_set[i].ChannelNum != 0)
+		{
+			range->freq[val].i = pmlmeext->channel_set[i].ChannelNum;
+			range->freq[val].m = rtw_ch2freq(pmlmeext->channel_set[i].ChannelNum) * 100000;
+			range->freq[val].e = 1;
+			val++;
+		}
+
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+
+	range->num_channels = val;
+	range->num_frequency = val;
+
+/*  Commented by Albert 2009/10/13 */
+/*  The following code will proivde the security capability to network manager. */
+/*  If the driver doesn't provide this capability to network manager, */
+/*  the WPA/WPA2 routers can't be choosen in the network manager. */
+
+/*
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+*/
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
+			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
+#endif
+
+#ifdef IW_SCAN_CAPA_ESSID /* WIRELESS_EXT > 21 */
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |IW_SCAN_CAPA_BSSID|
+					IW_SCAN_CAPA_CHANNEL|IW_SCAN_CAPA_MODE|IW_SCAN_CAPA_RATE;
+#endif
+
+	return 0;
+}
+
+/* set bssid flow */
+/* s1. rtw_set_802_11_infrastructure_mode() */
+/* s2. rtw_set_802_11_authentication_mode() */
+/* s3. set_802_11_encryption_mode() */
+/* s4. rtw_set_802_11_bssid() */
+static int rtw_wx_set_wap(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	uint ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct sockaddr *temp = (struct sockaddr *)awrq;
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct list_head *phead;
+	u8 *dst_bssid, *src_bssid;
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+*/
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		DBG_8192D("set bssid, but buddy_intf is under scanning or linking\n");
+
+		ret = -EINVAL;
+
+		goto exit;
+	}
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		DBG_8192D("set bssid, but buddy_intf is under scanning or linking\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+
+	if (_FAIL == rtw_pwr_wakeup(padapter))
+	{
+		ret = -1;
+		goto exit;
+	}
+
+	if (!padapter->bup) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (temp->sa_family != ARPHRD_ETHER) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	authmode = padapter->securitypriv.ndisauthtype;
+	spin_lock_bh(&pmlmepriv->lock);
+	spin_lock_bh(&queue->lock);
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = phead->next;
+
+	while (1) {
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == true)
+			break;
+
+		pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+
+		pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+		dst_bssid = pnetwork->network.MacAddress;
+
+		src_bssid = temp->sa_data;
+
+		if ((!memcmp(dst_bssid, src_bssid, ETH_ALEN)) == true) {
+			if (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {
+				ret = -1;
+				spin_unlock_bh(&queue->lock);
+				spin_unlock_bh(&pmlmepriv->lock);
+				goto exit;
+			}
+
+				break;
+		}
+
+	}
+	spin_unlock_bh(&queue->lock);
+	spin_unlock_bh(&pmlmepriv->lock);
+	rtw_set_802_11_authentication_mode(padapter, authmode);
+	if (rtw_set_802_11_bssid(padapter, temp->sa_data) == false) {
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_get_wap(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
+{
+
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+
+	memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_wap\n"));
+
+	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||
+			((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||
+			((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == true))
+	{
+
+		memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	}
+	else
+	{
+		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_mlme(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	__le16 reason;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+	if (mlme == NULL)
+		return -1;
+
+	DBG_8192D("%s\n", __func__);
+
+	reason = cpu_to_le16(mlme->reason_code);
+
+	DBG_8192D("%s, cmd =%d, reason =%d\n", __func__, mlme->cmd, reason);
+
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+			if (!rtw_set_802_11_disassociate(padapter))
+			ret = -1;
+			break;
+	case IW_MLME_DISASSOC:
+			if (!rtw_set_802_11_disassociate(padapter))
+					ret = -1;
+			break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return ret;
+}
+
+static int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	u8 _status = false;
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));
+
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
+	#endif
+
+	if (_FAIL == rtw_pwr_wakeup(padapter))
+	{
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->bDriverStopped) {
+		DBG_8192D("bDriverStopped =%d\n", padapter->bDriverStopped);
+		ret = -1;
+		goto exit;
+	}
+
+	if (!padapter->bup) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (padapter->hw_init_completed == false) {
+		ret = -1;
+		goto exit;
+	}
+
+	/*  When Busy Traffic, driver do not site survey. So driver return success. */
+	/*  wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout. */
+	/*  modify by thomas 2011-02-22. */
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	}
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter,
+		_FW_UNDER_SURVEY|_FW_UNDER_LINKING|WIFI_UNDER_WPS) == true)
+	{
+		if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY))
+		{
+			DBG_8192D("scanning_via_buddy_intf\n");
+			pmlmepriv->scanning_via_buddy_intf = true;
+		}
+
+		indicate_wx_scan_complete_event(padapter);
+
+		goto exit;
+	}
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		indicate_wx_scan_complete_event(padapter);
+		goto exit;
+	}
+#endif
+
+/*	Mareded by Albert 20101103 */
+/*	For the DMP WiFi Display project, the driver won't to scan because */
+/*	the pmlmepriv->scan_interval is always equal to 3. */
+/*	So, the wpa_supplicant won't find out the WPS SoftAP. */
+
+	memset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);
+
+#if WIRELESS_EXT >= 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req))
+	{
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID)
+		{
+			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
+
+			memcpy(ssid[0].Ssid, req->essid, len);
+			ssid[0].SsidLength = len;
+
+			DBG_8192D("IW_SCAN_THIS_ESSID, ssid =%s, len =%d\n", req->essid, req->essid_len);
+
+			spin_lock_bh(&pmlmepriv->lock);
+
+			_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);
+
+			spin_unlock_bh(&pmlmepriv->lock);
+
+		}
+		else if (req->scan_type == IW_SCAN_TYPE_PASSIVE)
+		{
+			DBG_8192D("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+
+	}
+	else
+#endif
+
+	if (wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE &&
+	    !memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE)) {
+		int len = wrqu->data.length -WEXT_CSCAN_HEADER_SIZE;
+		char *pos = extra+WEXT_CSCAN_HEADER_SIZE;
+		char section;
+		char sec_len;
+		int ssid_index = 0;
+
+		while (len >= 1) {
+			section = *(pos++); len-= 1;
+
+			switch (section) {
+				case WEXT_CSCAN_SSID_SECTION:
+					if (len < 1) {
+						len = 0;
+						break;
+					}
+
+					sec_len = *(pos++); len-= 1;
+
+					if (sec_len > 0 && sec_len<= len) {
+						ssid[ssid_index].SsidLength = sec_len;
+						memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
+						ssid_index++;
+					}
+
+					pos+= sec_len; len-= sec_len;
+					break;
+
+				case WEXT_CSCAN_CHANNEL_SECTION:
+					pos+= 1; len-= 1;
+					break;
+				case WEXT_CSCAN_ACTV_DWELL_SECTION:
+					pos+= 2; len-= 2;
+					break;
+				case WEXT_CSCAN_PASV_DWELL_SECTION:
+					pos+= 2; len-= 2;
+					break;
+				case WEXT_CSCAN_HOME_DWELL_SECTION:
+					pos+= 2; len-= 2;
+					break;
+				case WEXT_CSCAN_TYPE_SECTION:
+					pos+= 1; len-= 1;
+					break;
+				default:
+					len = 0; /*  stop parsing */
+			}
+		}
+		/* jeff: it has still some scan paramater to parse, we only do this now... */
+		_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);
+
+	} else {
+		_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
+	}
+
+	if (_status == false)
+		ret = -1;
+
+exit:
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
+	#endif
+
+	return ret;
+}
+
+static int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct list_head *plist, *phead;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0;
+	u32 cnt = 0;
+	u32 wait_for_surveydone;
+	int wait_status;
+#ifdef CONFIG_CONCURRENT_MODE
+#endif
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan\n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, (" Start of Query SIOCGIWSCAN .\n"));
+
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
+	#endif
+
+	if (padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	wait_for_surveydone = 100;
+
+	wait_status = _FW_UNDER_SURVEY
+		#ifndef CONFIG_ANDROID
+		|_FW_UNDER_LINKING
+		#endif
+	;
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	while (dc_check_fwstate(padapter, wait_status) == true)
+	{
+		rtw_msleep_os(30);
+		cnt++;
+		if (cnt > wait_for_surveydone)
+			break;
+	}
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
+
+	while (check_fwstate(pmlmepriv, wait_status) == true)
+	{
+		rtw_msleep_os(30);
+		cnt++;
+		if (cnt > wait_for_surveydone)
+			break;
+	}
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	while (1)
+	{
+		if (rtw_end_of_queue_search(phead, plist) == true)
+			break;
+
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		/* report network only if the current channel set contains the channel to which this network belongs */
+		if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+			#ifdef CONFIG_VALIDATE_SSID
+			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
+			#endif
+		)
+		{
+			ev = translate_scan(padapter, a, pnetwork, ev, stop);
+		}
+
+		plist = plist->next;
+
+	}
+
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	wrqu->data.length = ev-extra;
+	wrqu->data.flags = 0;
+
+exit:
+
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
+	#endif
+
+	return ret ;
+}
+
+/* set ssid flow */
+/* s1. rtw_set_802_11_infrastructure_mode() */
+/* s2. set_802_11_authenticaion_mode() */
+/* s3. set_802_11_encryption_mode() */
+/* s4. rtw_set_802_11_ssid() */
+static int rtw_wx_set_essid(struct net_device *dev,
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct __queue *queue = &pmlmepriv->scanned_queue;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct list_head *phead;
+	s8 status = true;
+	struct wlan_network *pnetwork = NULL;
+	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
+	struct ndis_802_11_ssid ndis_ssid;
+	u8 *dst_ssid, *src_ssid;
+
+	uint ret = 0, len;
+
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d\n", __func__, __LINE__);
+	#endif
+
+/*
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->iface_type > PRIMARY_IFACE)
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+*/
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (check_buddy_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		DBG_8192D("set ssid, but buddy_intf is under scanning or linking\n");
+
+		ret = -EINVAL;
+
+		goto exit;
+	}
+#endif
+
+#ifdef CONFIG_DUALMAC_CONCURRENT
+	if (dc_check_fwstate(padapter, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+	{
+		DBG_8192D("set bssid, but buddy_intf is under scanning or linking\n");
+		ret = -EINVAL;
+		goto exit;
+	}
+#endif
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("+rtw_wx_set_essid: fw_state = 0x%08x\n", get_fwstate(pmlmepriv)));
+	if (_FAIL == rtw_pwr_wakeup(padapter))
+	{
+		ret = -1;
+		goto exit;
+	}
+
+	if (!padapter->bup) {
+		ret = -1;
+		goto exit;
+	}
+
+#if WIRELESS_EXT <= 20
+	if ((wrqu->essid.length-1) > IW_ESSID_MAX_SIZE) {
+#else
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE) {
+#endif
+		ret = -E2BIG;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -1;
+		goto exit;
+	}
+
+	authmode = padapter->securitypriv.ndisauthtype;
+	DBG_8192D("=>%s\n", __func__);
+	if (wrqu->essid.flags && wrqu->essid.length)
+	{
+		/*  Commented by Albert 20100519 */
+		/*  We got the codes in "set_info" function of iwconfig source code. */
+		/*	========================================= */
+		/*	wrq.u.essid.length = strlen(essid) + 1; */
+		/*	if (we_kernel_version > 20) */
+		/*		wrq.u.essid.length--; */
+		/*	========================================= */
+		/*	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1. */
+#if WIRELESS_EXT <= 20
+		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
+#else
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
+#endif
+
+		if (wrqu->essid.length != 33)
+			DBG_8192D("ssid =%s, len =%d\n", extra, wrqu->essid.length);
+
+		memset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));
+		ndis_ssid.SsidLength = len;
+		memcpy(ndis_ssid.Ssid, extra, len);
+		src_ssid = ndis_ssid.Ssid;
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid =[%s]\n", src_ssid));
+		spin_lock_bh(&pmlmepriv->lock);
+		spin_lock_bh(&queue->lock);
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = phead->next;
+
+		while (1) {
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
+			        RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_warning_,
+					 ("rtw_wx_set_essid: scan_q is empty, set ssid to check if scanning again!\n"));
+
+				break;
+			}
+
+			pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+
+			pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+
+			RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+				 ("rtw_wx_set_essid: dst_ssid =%s\n",
+				  pnetwork->network.Ssid.Ssid));
+
+			if (!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) &&
+			    pnetwork->network.Ssid.SsidLength == ndis_ssid.SsidLength) {
+				RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+					 ("rtw_wx_set_essid: find match, set infra mode\n"));
+
+				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+					if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+						continue;
+				}
+
+				if (rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode) == false)
+				{
+					ret = -1;
+					spin_unlock_bh(&queue->lock);
+					spin_unlock_bh(&pmlmepriv->lock);
+					goto exit;
+				}
+
+				break;
+			}
+		}
+		spin_unlock_bh(&queue->lock);
+		spin_unlock_bh(&pmlmepriv->lock);
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+			 ("set ssid: set_802_11_auth. mode =%d\n", authmode));
+		rtw_set_802_11_authentication_mode(padapter, authmode);
+		if (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {
+			ret = -1;
+			goto exit;
+		}
+	}
+
+exit:
+
+	DBG_8192D("<=%s, ret %d\n", __func__, ret);
+
+	#ifdef DBG_IOCTL
+	DBG_8192D("DBG_IOCTL %s:%d return %d\n", __func__, __LINE__, ret);
+	#endif
+
+	return ret;
+}
+
+static int rtw_wx_get_essid(struct net_device *dev,
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	u32 len, ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_essid\n"));
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+	      (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
+	{
+		len = pcur_bss->Ssid.SsidLength;
+
+		wrqu->essid.length = len;
+
+		memcpy(extra, pcur_bss->Ssid.Ssid, len);
+
+		wrqu->essid.flags = 1;
+	}
+	else
+	{
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_set_rate(struct net_device *dev,
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	int	i, ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u8	datarates[NUMRATES];
+	u32	target_rate = wrqu->bitrate.value;
+	u32	fixed = wrqu->bitrate.fixed;
+	u32	ratevalue = 0;
+	 u8 mpdatarate[NUMRATES]={11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_set_rate\n"));
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("target_rate = %d, fixed = %d\n", target_rate, fixed));
+
+	if (target_rate == -1) {
+		ratevalue = 11;
+		goto set_rate;
+	}
+	target_rate = target_rate/100000;
+
+	switch (target_rate) {
+		case 10:
+			ratevalue = 0;
+			break;
+		case 20:
+			ratevalue = 1;
+			break;
+		case 55:
+			ratevalue = 2;
+			break;
+		case 60:
+			ratevalue = 3;
+			break;
+		case 90:
+			ratevalue = 4;
+			break;
+		case 110:
+			ratevalue = 5;
+			break;
+		case 120:
+			ratevalue = 6;
+			break;
+		case 180:
+			ratevalue = 7;
+			break;
+		case 240:
+			ratevalue = 8;
+			break;
+		case 360:
+			ratevalue = 9;
+			break;
+		case 480:
+			ratevalue = 10;
+			break;
+		case 540:
+			ratevalue = 11;
+			break;
+		default:
+			ratevalue = 11;
+			break;
+	}
+
+set_rate:
+
+	for (i = 0; i < NUMRATES; i++) {
+		if (ratevalue == mpdatarate[i]) {
+			datarates[i] = mpdatarate[i];
+			if (fixed == 0)
+				break;
+		} else {
+			datarates[i] = 0xff;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("datarate_inx =%d\n", datarates[i]));
+	}
+
+	if (rtw_setdatarate_cmd(padapter, datarates) != _SUCCESS) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("rtw_wx_set_rate Fail!!!\n"));
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int rtw_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	u16 max_rate = 0;
+
+	max_rate = rtw_get_cur_max_rate((struct rtw_adapter *)rtw_netdev_priv(dev));
+
+	if (max_rate == 0)
+		return -EPERM;
+
+	wrqu->bitrate.fixed = 0;	/* no auto select */
+	wrqu->bitrate.value = max_rate * 100000;
+
+	return 0;
+}
+
+static int rtw_wx_set_rts(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	if (wrqu->rts.disabled)
+		padapter->registrypriv.rts_thresh = 2347;
+	else {
+		if (wrqu->rts.value < 0 ||
+		    wrqu->rts.value > 2347)
+			return -EINVAL;
+
+		padapter->registrypriv.rts_thresh = wrqu->rts.value;
+	}
+
+	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
+
+	return 0;
+}
+
+static int rtw_wx_get_rts(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	DBG_8192D("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);
+
+	wrqu->rts.value = padapter->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+
+	return 0;
+}
+
+static int rtw_wx_set_frag(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	if (wrqu->frag.disabled)
+		padapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+
+		padapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+
+	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
+
+	return 0;
+}
+
+static int rtw_wx_get_frag(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	DBG_8192D("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);
+
+	wrqu->frag.value = padapter->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+
+	return 0;
+}
+
+static int rtw_wx_get_retry(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+
+	return 0;
+}
+
+static int rtw_wx_set_enc(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	u32 key, ret = 0;
+	u32 keyindex_provided;
+	struct ndis_802_11_wep wep;
+	enum NDIS_802_11_AUTHENTICATION_MODE authmode;
+
+	struct iw_point *erq = &(wrqu->encoding);
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	DBG_8192D("+rtw_wx_set_enc, flags = 0x%x\n", erq->flags);
+
+	memset(&wep, 0, sizeof(struct ndis_802_11_wep));
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (erq->flags & IW_ENCODE_DISABLED)
+	{
+		DBG_8192D("EncryptionDisabled\n");
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+		authmode = NDIS802_11AUTHMODEOPEN;
+		padapter->securitypriv.ndisauthtype = authmode;
+
+		goto exit;
+	}
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	}
+	else
+	{
+		keyindex_provided = 0;
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+		DBG_8192D("rtw_wx_set_enc, key =%d\n", key);
+	}
+
+	/* set authentication mode */
+	if (erq->flags & IW_ENCODE_OPEN)
+	{
+		DBG_8192D("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;/* NDIS802_11ENCRYPTION_DISABLED; */
+
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+		authmode = NDIS802_11AUTHMODEOPEN;
+		padapter->securitypriv.ndisauthtype = authmode;
+	}
+	else if (erq->flags & IW_ENCODE_RESTRICTED)
+	{
+		DBG_8192D("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+
+		padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;
+		authmode = NDIS802_11AUTHMODESHARED;
+		padapter->securitypriv.ndisauthtype = authmode;
+	}
+	else
+	{
+		DBG_8192D("rtw_wx_set_enc():erq->flags = 0x%x\n", erq->flags);
+
+		padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;/* NDIS802_11ENCRYPTION_DISABLED; */
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+		padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+		authmode = NDIS802_11AUTHMODEOPEN;
+		padapter->securitypriv.ndisauthtype = authmode;
+	}
+
+	wep.KeyIndex = key;
+	if (erq->length > 0)
+	{
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+
+		wep.Length = wep.KeyLength + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
+	}
+	else
+	{
+		wep.KeyLength = 0 ;
+
+		if (keyindex_provided == 1)/*  set key_id only, no given KeyMaterial(erq->length == 0). */
+		{
+			padapter->securitypriv.dot11PrivacyKeyIndex = key;
+
+			DBG_8192D("(keyindex_provided == 1), keyid =%d, key_len =%d\n", key, padapter->securitypriv.dot11DefKeylen[key]);
+
+			switch (padapter->securitypriv.dot11DefKeylen[key])
+			{
+				case 5:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;
+					break;
+				case 13:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;
+					break;
+				default:
+					padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+					break;
+			}
+
+			goto exit;
+
+		}
+
+	}
+
+	wep.KeyIndex |= 0x80000000;
+
+	memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+
+	if (rtw_set_802_11_add_wep(padapter, &wep) == false) {
+		if (rf_on == pwrpriv->rf_pwrstate)
+			ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_get_enc(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) != true)
+	{
+		 if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true)
+		 {
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+		return 0;
+	}
+	}
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else
+	{
+		key = padapter->securitypriv.dot11PrivacyKeyIndex;
+	}
+
+	erq->flags = key + 1;
+
+	switch (padapter->securitypriv.ndisencryptstatus)
+	{
+		case NDIS802_11ENCRYPTIONNOTSUPPORTED:
+		case NDIS802_11ENCRYPTION_DISABLED:
+
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+
+		case NDIS802_11ENCRYPTION1ENABLED:
+
+		erq->length = padapter->securitypriv.dot11DefKeylen[key];
+
+		if (erq->length)
+		{
+			memcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);
+
+		erq->flags |= IW_ENCODE_ENABLED;
+
+			if (padapter->securitypriv.ndisauthtype == NDIS802_11AUTHMODEOPEN)
+			{
+				erq->flags |= IW_ENCODE_OPEN;
+			}
+			else if (padapter->securitypriv.ndisauthtype == NDIS802_11AUTHMODESHARED)
+			{
+		erq->flags |= IW_ENCODE_RESTRICTED;
+			}
+		}
+		else
+		{
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+
+		break;
+
+		case NDIS802_11ENCRYPTION2ENABLED:
+		case NDIS802_11ENCRYPTION3ENABLED:
+
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
+
+		break;
+
+		default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+
+	}
+
+	return ret;
+}
+
+static int rtw_wx_get_power(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+
+	return 0;
+}
+
+static int rtw_wx_set_gen_ie(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	ret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);
+
+	return ret;
+}
+
+static int rtw_wx_set_auth(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_param *param = (struct iw_param*)&(wrqu->param);
+	int ret = 0;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+
+		break;
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		if (param->value) {
+			/*  wpa_supplicant is enabling the tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = true;
+		} else {
+			/*  wpa_supplicant is disabling the tkip countermeasure. */
+			padapter->securitypriv.btkip_countermeasure = false;
+		}
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+
+		if (padapter->securitypriv.ndisencryptstatus == NDIS802_11ENCRYPTION1ENABLED) {
+			break;/* it means init value, or using wep, ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED, */
+					/*  then it needn't reset it; */
+		}
+
+		if (param->value) {
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION_DISABLED;
+			padapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;
+			padapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;
+			padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
+		}
+
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+
+		#if defined(CONFIG_ANDROID) || 1
+		/*
+		 *  It's the starting point of a link layer connection using wpa_supplicant
+		*/
+		if (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+			LeaveAllPowerSaveMode(padapter);
+			rtw_disassoc_cmd(padapter, 500, false);
+			DBG_8192D("%s...call rtw_indicate_disconnect\n ", __func__);
+			rtw_indicate_disconnect(padapter);
+			rtw_free_assoc_resources(padapter, 1);
+		}
+		#endif
+
+		ret = wpa_set_auth_algs(dev, (u32)param->value);
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int rtw_wx_set_enc_ext(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;
+	struct iw_point *pencoding = &wrqu->encoding;
+	struct iw_encode_ext *pext = (struct iw_encode_ext *)extra;
+	int ret = 0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)kmalloc(param_len, GFP_KERNEL);
+	if (param == NULL)
+		return -1;
+
+	memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		/* todo: remove key */
+		/* remove = 1; */
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -1;
+	}
+
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	if (pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)/*  */
+	{
+		param->u.crypt.set_tx = 0;
+	}
+
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)/*  */
+	{
+		param->u.crypt.set_tx = 1;
+	}
+
+	param->u.crypt.idx = (pencoding->flags&0x00FF) -1 ;
+
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)
+	{
+		memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	}
+
+	if (pext->key_len)
+	{
+		param->u.crypt.key_len = pext->key_len;
+		memcpy(param->u.crypt.key, pext + 1, pext->key_len);
+	}
+
+	if (pencoding->flags & IW_ENCODE_DISABLED)
+	{
+		/* todo: remove key */
+		/* remove = 1; */
+	}
+
+	ret =  wpa_set_encryption(dev, param, param_len);
+
+	kfree(param);
+
+	return ret;
+}
+
+static int rtw_wx_get_nick(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+
+	if (extra)
+	{
+		wrqu->data.length = 14;
+		wrqu->data.flags = 1;
+		memcpy(extra, "<WIFI@REALTEK>", 14);
+	}
+
+	return 0;
+}
+
+static int rtw_wx_read32(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter * padapter;
+	struct iw_point *p;
+	u16 len;
+	u32 addr;
+	u32 data32;
+	u32 bytes;
+	u8 *ptmp;
+
+	padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	p = &wrqu->data;
+	len = p->length;
+	ptmp = (u8 *)kmalloc(len, GFP_KERNEL);
+	if (NULL == ptmp)
+		return -ENOMEM;
+
+	if (copy_from_user(ptmp, p->pointer, len)) {
+		kfree(ptmp);
+		return -EFAULT;
+	}
+
+	bytes = 0;
+	addr = 0;
+	sscanf(ptmp, "%d,%x", &bytes, &addr);
+
+	switch (bytes) {
+		case 1:
+			data32 = rtw_read8(padapter, addr);
+			sprintf(extra, "0x%02X", data32);
+			break;
+		case 2:
+			data32 = rtw_read16(padapter, addr);
+			sprintf(extra, "0x%04X", data32);
+			break;
+		case 4:
+			data32 = rtw_read32(padapter, addr);
+			sprintf(extra, "0x%08X", data32);
+			break;
+		default:
+			DBG_8192D("%s: usage> read [bytes],[address(hex)]\n", __func__);
+			return -EINVAL;
+	}
+	DBG_8192D("%s: addr = 0x%08X data =%s\n", __func__, addr, extra);
+
+	kfree(ptmp);
+
+	return 0;
+}
+
+static int rtw_wx_write32(struct net_device *dev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter * padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	u32 addr;
+	u32 data32;
+	u32 bytes;
+
+	bytes = 0;
+	addr = 0;
+	data32 = 0;
+	sscanf(extra, "%d,%x,%x", &bytes, &addr, &data32);
+
+	switch (bytes) {
+		case 1:
+			rtw_write8(padapter, addr, (u8)data32);
+			DBG_8192D("%s: addr = 0x%08X data = 0x%02X\n", __func__, addr, (u8)data32);
+			break;
+		case 2:
+			rtw_write16(padapter, addr, (u16)data32);
+			DBG_8192D("%s: addr = 0x%08X data = 0x%04X\n", __func__, addr, (u16)data32);
+			break;
+		case 4:
+			rtw_write32(padapter, addr, data32);
+			DBG_8192D("%s: addr = 0x%08X data = 0x%08X\n", __func__, addr, data32);
+			break;
+		default:
+			DBG_8192D("%s: usage> write [bytes],[address(hex)],[data(hex)]\n", __func__);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rtw_wx_read_rf(struct net_device *dev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u32 path, addr, data32;
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = rtw_hal_read_rfreg(padapter, path, addr, 0xFFFFF);
+	/*
+	 * IMPORTANT!!
+	 * Only when wireless private ioctl is at odd order,
+	 * "extra" would be copied to user space.
+	 */
+	sprintf(extra, "0x%05x", data32);
+
+	return 0;
+}
+
+static int rtw_wx_write_rf(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	u32 path, addr, data32;
+
+	path = *(u32*)extra;
+	addr = *((u32*)extra + 1);
+	data32 = *((u32*)extra + 2);
+	rtw_hal_write_rfreg(padapter, path, addr, 0xFFFFF, data32);
+
+	return 0;
+}
+
+static int rtw_wx_priv_null(struct net_device *dev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	return -1;
+}
+
+static int dummy(struct net_device *dev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+
+	return -1;
+}
+
+static int rtw_wx_set_channel_plan(struct net_device *dev,
+				   struct iw_request_info *info,
+				   union iwreq_data *wrqu, char *extra)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv *pregistrypriv = &padapter->registrypriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	extern int rtw_channel_plan;
+	u8 channel_plan_req = (u8) (*((int *)wrqu));
+
+	if (_SUCCESS == rtw_set_chplan_cmd(padapter, channel_plan_req, 1)) {
+		DBG_8192D("%s set channel_plan = 0x%02X\n", __func__, pmlmepriv->ChannelPlan);
+	} else
+		return -EPERM;
+
+	return 0;
+}
+
+static int rtw_wx_set_mtk_wps_probe_ie(struct net_device *dev,
+		struct iw_request_info *a,
+		union iwreq_data *wrqu, char *b)
+{
+	return 0;
+}
+
+static int rtw_wx_get_sensitivity(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *buf)
+{
+	return 0;
+}
+
+static int rtw_wx_set_mtk_wps_ie(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+static  int rtw_drvext_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+
+#ifdef CONFIG_DRVEXT_MODULE
+	u8 res;
+	struct drvext_handler *phandler;
+	struct drvext_oidparam *poidparam;
+	int ret;
+	u16 len;
+	u8 *pparmbuf, bset;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+	bset = (u8)(p->flags&0xFFFF);
+	len = p->length;
+	pparmbuf = (u8 *)kmalloc(len, GFP_KERNEL);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+	if (bset)/* set info */
+	{
+		if (copy_from_user(pparmbuf, p->pointer, len)) {
+			kfree(pparmbuf);
+			ret = -EFAULT;
+			goto _rtw_drvext_hdl_exit;
+		}
+	}
+	else/* query info */
+	{
+
+	}
+
+	/*  */
+	poidparam = (struct drvext_oidparam *)pparmbuf;
+
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("drvext set oid subcode [%d], len[%d], InformationBufferLength[%d]\r\n",
+						 poidparam->subcode, poidparam->len, len));
+
+	/* check subcode */
+	if (poidparam->subcode >= MAX_DRVEXT_HANDLERS)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext handlers\r\n"));
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+	if (poidparam->subcode >= MAX_DRVEXT_OID_SUBCODES)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext subcodes\r\n"));
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+	phandler = drvextoidhandlers + poidparam->subcode;
+
+	if (poidparam->len != phandler->parmsize)
+	{
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext param size %d vs %d\r\n",
+						poidparam->len , phandler->parmsize));
+		ret = -EINVAL;
+		goto _rtw_drvext_hdl_exit;
+	}
+
+	res = phandler->handler(&padapter->drvextpriv, bset, poidparam->data);
+
+	if (res == 0)
+	{
+		ret = 0;
+
+		if (bset == 0x00) {/* query info */
+			if (copy_to_user(p->pointer, pparmbuf, len))
+				ret = -EFAULT;
+		}
+	}
+	else
+		ret = -EFAULT;
+
+_rtw_drvext_hdl_exit:
+
+	return ret;
+
+#endif
+
+	return 0;
+}
+
+static void rtw_dbg_mode_hdl(struct rtw_adapter *padapter, u32 id, u8 *pdata, u32 len)
+{
+	struct mp_rw_reg *RegRWStruct;
+	struct rf_reg_param *prfreg;
+	u8 path;
+	u8 offset;
+	u32 value;
+
+	DBG_8192D("%s\n", __func__);
+
+	switch (id)
+	{
+		case GEN_MP_IOCTL_SUBCODE(MP_START):
+			DBG_8192D("871x_driver is only for normal mode, can't enter mp mode\n");
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_REG):
+			RegRWStruct = (struct mp_rw_reg *)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					RegRWStruct->value = rtw_read8(padapter, RegRWStruct->offset);
+					break;
+				case 2:
+					RegRWStruct->value = rtw_read16(padapter, RegRWStruct->offset);
+					break;
+				case 4:
+					RegRWStruct->value = rtw_read32(padapter, RegRWStruct->offset);
+					break;
+				default:
+					break;
+			}
+
+			break;
+		case GEN_MP_IOCTL_SUBCODE(WRITE_REG):
+			RegRWStruct = (struct mp_rw_reg *)pdata;
+			switch (RegRWStruct->width)
+			{
+				case 1:
+					rtw_write8(padapter, RegRWStruct->offset, (u8)RegRWStruct->value);
+					break;
+				case 2:
+					rtw_write16(padapter, RegRWStruct->offset, (u16)RegRWStruct->value);
+					break;
+				case 4:
+					rtw_write32(padapter, RegRWStruct->offset, (u32)RegRWStruct->value);
+					break;
+				default:
+				break;
+			}
+
+			break;
+		case GEN_MP_IOCTL_SUBCODE(READ_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;
+			offset = (u8)prfreg->offset;
+
+			value = rtw_hal_read_rfreg(padapter, path, offset, 0xffffffff);
+
+			prfreg->value = value;
+
+			break;
+		case GEN_MP_IOCTL_SUBCODE(WRITE_RF_REG):
+
+			prfreg = (struct rf_reg_param *)pdata;
+
+			path = (u8)prfreg->path;
+			offset = (u8)prfreg->offset;
+			value = prfreg->value;
+
+			rtw_hal_write_rfreg(padapter, path, offset, 0xffffffff, value);
+			break;
+		case GEN_MP_IOCTL_SUBCODE(TRIGGER_GPIO):
+			DBG_8192D("==> trigger gpio 0\n");
+			rtw_hal_set_hwreg(padapter, HW_VAR_TRIGGER_GPIO_0, NULL);
+			break;
+#ifdef CONFIG_BT_COEXIST
+		case GEN_MP_IOCTL_SUBCODE(SET_DM_BT):
+			DBG_8192D("==> set dm_bt_coexist:%x\n",*(u8 *)pdata);
+			rtw_hal_set_hwreg(padapter, HW_VAR_BT_SET_COEXIST, pdata);
+			break;
+		case GEN_MP_IOCTL_SUBCODE(DEL_BA):
+			DBG_8192D("==> delete ba:%x\n",*(u8 *)pdata);
+			rtw_hal_set_hwreg(padapter, HW_VAR_BT_ISSUE_DELBA, pdata);
+			break;
+#endif
+#ifdef DBG_CONFIG_ERROR_DETECT
+		case GEN_MP_IOCTL_SUBCODE(GET_WIFI_STATUS):
+			*pdata = rtw_hal_sreset_get_wifi_status(padapter);
+			break;
+#endif
+
+		default:
+			break;
+	}
+}
+
+static int rtw_mp_ioctl_hdl(struct net_device *dev, struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	u32 BytesRead, BytesWritten, BytesNeeded;
+	struct oid_par_priv	oid_par;
+	struct mp_ioctl_handler	*phandler;
+	struct mp_ioctl_param	*poidparam;
+	uint status = 0;
+	u16 len;
+	u8 *pparmbuf = NULL, bset;
+	struct rtw_adapter * padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *p = &wrqu->data;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	pparmbuf = NULL;
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = (u8 *)kmalloc(len, GFP_KERNEL);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+	poidparam = (struct mp_ioctl_param *)pparmbuf;
+	RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,
+		 ("rtw_mp_ioctl_hdl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+		  poidparam->subcode, poidparam->len, len));
+
+	if (poidparam->subcode >= MAX_MP_IOCTL_SUBCODE) {
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("no matching drvext subcodes\r\n"));
+		ret = -EINVAL;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+	rtw_dbg_mode_hdl(padapter, poidparam->subcode, poidparam->data, poidparam->len);
+
+	if (bset == 0x00) {/* query info */
+		if (copy_to_user(p->pointer, pparmbuf, len))
+			ret = -EFAULT;
+	}
+
+	if (status) {
+		ret = -EFAULT;
+		goto _rtw_mp_ioctl_hdl_exit;
+	}
+
+_rtw_mp_ioctl_hdl_exit:
+
+	kfree(pparmbuf);
+
+	return ret;
+}
+
+static int rtw_get_ap_info(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	int bssid_match, ret = 0;
+	u32 cnt = 0, wpa_ielen;
+	struct list_head *plist, *phead;
+	unsigned char *pbuf;
+	u8 bssid[ETH_ALEN];
+	char data[32];
+	struct wlan_network *pnetwork = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct __queue *queue = &(pmlmepriv->scanned_queue);
+	struct iw_point *pdata = &wrqu->data;
+
+	DBG_8192D("+rtw_get_aplist_info\n");
+
+	if ((padapter->bDriverStopped) || (pdata == NULL)) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	while (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))) {
+		rtw_msleep_os(30);
+		cnt++;
+		if (cnt > 100)
+			break;
+	}
+
+	pdata->flags = 0;
+	if (pdata->length >= 32) {
+		if (copy_from_user(data, pdata->pointer, 32)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	while (1) {
+		if (rtw_end_of_queue_search(phead, plist) == true)
+			break;
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		if (hwaddr_aton_i(data, bssid)) {
+			DBG_8192D("Invalid BSSID '%s'.\n", (u8 *)data);
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			return -EINVAL;
+		}
+
+		if (!memcmp(bssid, pnetwork->network.MacAddress, ETH_ALEN)) {
+			/* BSSID match, then check if supporting wpa/wpa2 */
+			DBG_8192D("BSSID:%pM\n", bssid);
+
+			pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 1;
+				break;
+			}
+
+			pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+			if (pbuf && (wpa_ielen > 0)) {
+				pdata->flags = 2;
+				break;
+			}
+
+		}
+
+		plist = plist->next;
+
+	}
+
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	if (pdata->length>= 34) {
+		if (copy_to_user((u8 __user *)pdata->pointer+32, (u8 *)&pdata->flags, 1)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_set_pid(struct net_device *dev,
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
+	int *pdata = (int *)wrqu;
+	int selector;
+
+	if ((padapter->bDriverStopped) || (pdata == NULL))
+	{
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	selector = *pdata;
+	if (selector < 3 && selector >= 0) {
+		padapter->pid[selector] = *(pdata+1);
+		DBG_8192D("%s set pid[%d]=%d\n", __func__, selector , padapter->pid[selector]);
+	} else {
+		DBG_8192D("%s selector %d error\n", __func__, selector);
+	}
+exit:
+	return ret;
+}
+
+static int rtw_wps_start(struct net_device *dev,
+			 struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *pdata = &wrqu->data;
+	u32   u32wps_start = 0;
+	unsigned int uintRet = 0;
+
+	uintRet = copy_from_user((void*) &u32wps_start, pdata->pointer, 4);
+	if (uintRet || padapter->bDriverStopped || pdata == NULL) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (u32wps_start == 0)
+		u32wps_start = *extra;
+
+	DBG_8192D("[%s] wps_start = %d\n", __func__, u32wps_start);
+
+	if (u32wps_start == 1) /*  WPS Start */
+	{
+		rtw_led_control(padapter, LED_CTL_START_WPS);
+	}
+	else if (u32wps_start == 2) /*  WPS Stop because of wps success */
+	{
+		rtw_led_control(padapter, LED_CTL_STOP_WPS);
+	}
+	else if (u32wps_start == 3) /*  WPS Stop because of wps fail */
+	{
+		rtw_led_control(padapter, LED_CTL_STOP_WPS_FAIL);
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_p2p_set(struct net_device *dev,
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_p2p_get(struct net_device *dev,
+		       struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_p2p_get2(struct net_device *dev,
+						struct iw_request_info *info,
+						union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_rereg_nd_name(struct net_device *dev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
+	struct rereg_nd_name_data *rereg_priv = &padapter->rereg_nd_name_priv;
+	char new_ifname[IFNAMSIZ];
+
+	if (rereg_priv->old_ifname[0] == 0) {
+		char *reg_ifname;
+#ifdef CONFIG_CONCURRENT_MODE
+		if (padapter->isprimary)
+			reg_ifname = padapter->registrypriv.ifname;
+		else
+#endif
+		reg_ifname = padapter->registrypriv.if2name;
+
+		strncpy(rereg_priv->old_ifname, reg_ifname, IFNAMSIZ);
+		rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
+	}
+
+	/* DBG_8192D("%s wrqu->data.length:%d\n", __func__, wrqu->data.length); */
+	if (wrqu->data.length > IFNAMSIZ)
+		return -EFAULT;
+
+	if (copy_from_user(new_ifname, wrqu->data.pointer, IFNAMSIZ)) {
+		return -EFAULT;
+	}
+
+	if (0 == strcmp(rereg_priv->old_ifname, new_ifname)) {
+		return ret;
+	}
+
+	DBG_8192D("%s new_ifname:%s\n", __func__, new_ifname);
+	if (0 != (ret = rtw_change_ifname(padapter, new_ifname))) {
+		goto exit;
+	}
+
+	if (!memcmp(rereg_priv->old_ifname, "disable%d", 9)) {
+		padapter->ledpriv.bRegUseLed = rereg_priv->old_bRegUseLed;
+		rtw_hal_sw_led_init(padapter);
+		rtw_ips_mode_req(&padapter->pwrctrlpriv, rereg_priv->old_ips_mode);
+	}
+
+	strncpy(rereg_priv->old_ifname, new_ifname, IFNAMSIZ);
+	rereg_priv->old_ifname[IFNAMSIZ-1] = 0;
+
+	if (!memcmp(new_ifname, "disable%d", 9)) {
+		DBG_8192D("%s disable\n", __func__);
+		/*  free network queue for Android's timming issue */
+		rtw_free_network_queue(padapter, true);
+
+		/*  close led */
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
+		rereg_priv->old_bRegUseLed = padapter->ledpriv.bRegUseLed;
+		padapter->ledpriv.bRegUseLed = false;
+		rtw_hal_sw_led_deinit(padapter);
+
+		/*  the interface is being "disabled", we can do deeper IPS */
+		rereg_priv->old_ips_mode = rtw_get_ips_mode_req(&padapter->pwrctrlpriv);
+		rtw_ips_mode_req(&padapter->pwrctrlpriv, IPS_NORMAL);
+	}
+exit:
+	return ret;
+}
+
+static void mac_reg_dump(struct rtw_adapter *padapter)
+{
+	int i, j = 1;
+	DBG_8192D("\n ======= MAC REG =======\n");
+	for (i = 0x0; i < 0x300; i += 4) {
+		if (j%4 == 1)
+			DBG_8192D("0x%02x", i);
+		DBG_8192D(" 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			DBG_8192D("\n");
+	}
+	for (i = 0x400; i < 0x800; i+= 4) {
+		if (j%4 == 1)
+			DBG_8192D("0x%02x", i);
+		DBG_8192D(" 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			DBG_8192D("\n");
+	}
+}
+
+static void bb_reg_dump(struct rtw_adapter *padapter)
+{
+	int i, j = 1;
+	DBG_8192D("\n ======= BB REG =======\n");
+	for (i = 0x800; i < 0x1000; i += 4) {
+		if (j%4 == 1)
+			DBG_8192D("0x%02x", i);
+
+		DBG_8192D(" 0x%08x ", rtw_read32(padapter, i));
+		if ((j++)%4 == 0)
+			DBG_8192D("\n");
+	}
+}
+
+static void rf_reg_dump(struct rtw_adapter *padapter)
+{
+	int i, j = 1, path;
+	u32 value;
+	u8 rf_type, path_nums = 0;
+	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+
+	DBG_8192D("\n ======= RF REG =======\n");
+	if ((RF_1T2R == rf_type) || (RF_1T1R == rf_type))
+		path_nums = 1;
+	else
+		path_nums = 2;
+
+	for (path = 0; path < path_nums; path++) {
+		DBG_8192D("\nRF_Path(%x)\n", path);
+		for (i = 0; i < 0x100; i++) {
+			value = rtw_hal_read_rfreg(padapter, path, i, 0xffffffff);
+			if (j%4 == 1)
+				DBG_8192D("0x%02x ", i);
+			DBG_8192D(" 0x%08x ", value);
+			if ((j++)%4 == 0)
+				DBG_8192D("\n");
+		}
+	}
+}
+
+static int rtw_dbg_port(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	u8 major_cmd, minor_cmd;
+	u16 arg;
+	s32 extra_arg;
+	u32 *pdata, val32;
+	struct sta_info *psta;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	pdata = (u32*)&wrqu->data;
+
+	val32 = *pdata;
+	arg = (u16)(val32&0x0000ffff);
+	major_cmd = (u8)(val32>>24);
+	minor_cmd = (u8)((val32>>16)&0x00ff);
+
+	extra_arg = *(pdata+1);
+
+	switch (major_cmd)
+	{
+		case 0x70:/* read_reg */
+			switch (minor_cmd)
+			{
+				case 1:
+					DBG_8192D("rtw_read8(0x%x) = 0x%02x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					DBG_8192D("rtw_read16(0x%x) = 0x%04x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					DBG_8192D("rtw_read32(0x%x) = 0x%08x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}
+			break;
+		case 0x71:/* write_reg */
+			switch (minor_cmd)
+			{
+				case 1:
+					rtw_write8(padapter, arg, extra_arg);
+					DBG_8192D("rtw_write8(0x%x) = 0x%02x\n", arg, rtw_read8(padapter, arg));
+					break;
+				case 2:
+					rtw_write16(padapter, arg, extra_arg);
+					DBG_8192D("rtw_write16(0x%x) = 0x%04x\n", arg, rtw_read16(padapter, arg));
+					break;
+				case 4:
+					rtw_write32(padapter, arg, extra_arg);
+					DBG_8192D("rtw_write32(0x%x) = 0x%08x\n", arg, rtw_read32(padapter, arg));
+					break;
+			}
+			break;
+		case 0x72:/* read_bb */
+			DBG_8192D("read_bbreg(0x%x) = 0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
+			break;
+		case 0x73:/* write_bb */
+			rtw_hal_write_bbreg(padapter, arg, 0xffffffff, extra_arg);
+			DBG_8192D("write_bbreg(0x%x) = 0x%x\n", arg, rtw_hal_read_bbreg(padapter, arg, 0xffffffff));
+			break;
+		case 0x74:/* read_rf */
+			DBG_8192D("read RF_reg path(0x%02x), offset(0x%x), value(0x%08x)\n", minor_cmd, arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
+			break;
+		case 0x75:/* write_rf */
+			rtw_hal_write_rfreg(padapter, minor_cmd, arg, 0xffffffff, extra_arg);
+			DBG_8192D("write RF_reg path(0x%02x), offset(0x%x), value(0x%08x)\n", minor_cmd, arg, rtw_hal_read_rfreg(padapter, minor_cmd, arg, 0xffffffff));
+			break;
+
+		case 0x76:
+			switch (minor_cmd)
+			{
+				case 0x00: /* normal mode, */
+					padapter->recvpriv.is_signal_dbg = 0;
+					break;
+				case 0x01: /* dbg mode */
+					padapter->recvpriv.is_signal_dbg = 1;
+					extra_arg = extra_arg>100?100:extra_arg;
+					extra_arg = extra_arg<0?0:extra_arg;
+					padapter->recvpriv.signal_strength_dbg = extra_arg;
+					break;
+			}
+			break;
+		case 0x78: /* IOL test */
+			break;
+		case 0x7a:
+			receive_disconnect(padapter, pmlmeinfo->network.MacAddress
+				, WLAN_REASON_EXPIRATION_CHK);
+			break;
+
+		case 0x7F:
+			switch (minor_cmd)
+			{
+				case 0x0:
+					DBG_8192D("fwstate = 0x%x\n", get_fwstate(pmlmepriv));
+					break;
+				case 0x01:
+					DBG_8192D("auth_alg = 0x%x, enc_alg = 0x%x, auth_type = 0x%x, enc_type = 0x%x\n",
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+					break;
+				case 0x02:
+					DBG_8192D("pmlmeinfo->state = 0x%x\n", pmlmeinfo->state);
+					break;
+				case 0x03:
+					DBG_8192D("qos_option =%d\n", pmlmepriv->qospriv.qos_option);
+					DBG_8192D("ht_option =%d\n", pmlmepriv->htpriv.ht_option);
+					break;
+				case 0x04:
+					DBG_8192D("cur_ch =%d\n", pmlmeext->cur_channel);
+					DBG_8192D("cur_bw =%d\n", pmlmeext->cur_bwmode);
+					DBG_8192D("cur_ch_off =%d\n", pmlmeext->cur_ch_offset);
+					break;
+				case 0x05:
+					psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+					if (psta)
+					{
+						int i;
+						struct recv_reorder_ctrl *preorder_ctrl;
+
+						DBG_8192D("SSID =%s\n", cur_network->network.Ssid.Ssid);
+						DBG_8192D("sta's macaddr:%pM\n", psta->hwaddr);
+						DBG_8192D("cur_channel =%d, cur_bwmode =%d, cur_ch_offset =%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+						DBG_8192D("rtsen =%d, cts2slef =%d\n", psta->rtsen, psta->cts2self);
+						DBG_8192D("qos_en =%d, ht_en =%d, init_rate =%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+						DBG_8192D("state = 0x%x, aid =%d, macid =%d, raid =%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+						DBG_8192D("bwmode =%d, ch_offset =%d, sgi =%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+						DBG_8192D("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+						DBG_8192D("agg_enable_bitmap =%x, candidate_tid_bitmap =%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+
+						for (i = 0;i<16;i++)
+						{
+							preorder_ctrl = &psta->recvreorder_ctrl[i];
+							if (preorder_ctrl->enable)
+							{
+								DBG_8192D("tid =%d, indicate_seq =%d\n", i, preorder_ctrl->indicate_seq);
+							}
+						}
+
+					}
+					else
+					{
+						DBG_8192D("can't get sta's macaddr, cur_network's macaddr:%pM\n", cur_network->network.MacAddress);
+					}
+					break;
+				case 0x06:
+					{
+						u8	DMFlag;
+						rtw_hal_get_hwreg(padapter, HW_VAR_DM_FLAG, (u8 *)(&DMFlag));
+						DBG_8192D("(B)DMFlag = 0x%x, arg = 0x%x\n", DMFlag, arg);
+						DMFlag = (u8)(0x0f&arg);
+						DBG_8192D("(A)DMFlag = 0x%x\n", DMFlag);
+						rtw_hal_set_hwreg(padapter, HW_VAR_DM_FLAG, (u8 *)(&DMFlag));
+					}
+					break;
+				case 0x07:
+					DBG_8192D("bSurpriseRemoved =%d, bDriverStopped =%d\n",
+						padapter->bSurpriseRemoved, padapter->bDriverStopped);
+					break;
+				case 0x08: {
+					struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+					struct recv_priv  *precvpriv = &padapter->recvpriv;
+
+					DBG_8192D("free_xmitbuf_cnt =%d, free_xmitframe_cnt =%d, free_xmit_extbuf_cnt =%d\n",
+						pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmit_extbuf_cnt);
+					DBG_8192D("rx_urb_pending_cn =%d\n", precvpriv->rx_pending_cnt);
+					break; }
+				case 0x09:
+					{
+						int i, j;
+						struct list_head *plist, *phead;
+						struct recv_reorder_ctrl *preorder_ctrl;
+
+#ifdef CONFIG_92D_AP_MODE
+						DBG_8192D("sta_dz_bitmap = 0x%x, tim_bitmap = 0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+#endif
+						spin_lock_bh(&pstapriv->sta_hash_lock);
+
+						for (i = 0; i< NUM_STA; i++)
+						{
+							phead = &(pstapriv->sta_hash[i]);
+							plist = phead->next;
+
+							while ((rtw_end_of_queue_search(phead, plist)) == false)
+							{
+								psta = container_of(plist, struct sta_info, hash_list);
+
+								plist = plist->next;
+
+								if (extra_arg == psta->aid)
+								{
+									DBG_8192D("sta's macaddr:%pM\n", psta->hwaddr);
+									DBG_8192D("rtsen =%d, cts2slef =%d\n", psta->rtsen, psta->cts2self);
+									DBG_8192D("qos_en =%d, ht_en =%d, init_rate =%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);
+									DBG_8192D("state = 0x%x, aid =%d, macid =%d, raid =%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);
+									DBG_8192D("bwmode =%d, ch_offset =%d, sgi =%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);
+									DBG_8192D("ampdu_enable = %d\n", psta->htpriv.ampdu_enable);
+									DBG_8192D("agg_enable_bitmap =%x, candidate_tid_bitmap =%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+#ifdef CONFIG_92D_AP_MODE
+									DBG_8192D("capability = 0x%x\n", psta->capability);
+									DBG_8192D("flags = 0x%x\n", psta->flags);
+									DBG_8192D("wpa_psk = 0x%x\n", psta->wpa_psk);
+									DBG_8192D("wpa2_group_cipher = 0x%x\n", psta->wpa2_group_cipher);
+									DBG_8192D("wpa2_pairwise_cipher = 0x%x\n", psta->wpa2_pairwise_cipher);
+									DBG_8192D("qos_info = 0x%x\n", psta->qos_info);
+#endif
+									DBG_8192D("dot118021XPrivacy = 0x%x\n", psta->dot118021XPrivacy);
+
+									for (j = 0;j<16;j++)
+									{
+										preorder_ctrl = &psta->recvreorder_ctrl[j];
+										if (preorder_ctrl->enable)
+										{
+											DBG_8192D("tid =%d, indicate_seq =%d\n", j, preorder_ctrl->indicate_seq);
+										}
+									}
+
+								}
+
+							}
+						}
+
+						spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+					}
+					break;
+
+				case 0x0c:/* dump rx packet */
+					DBG_8192D("dump rx packet (%d)\n", extra_arg);
+					/* pHalData->bDumpRxPkt = extra_arg; */
+					rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DUMP_RXPKT, &(extra_arg));
+					break;
+		#ifdef DBG_CONFIG_ERROR_DETECT
+				case 0x0f:
+						{
+							if (extra_arg == 0) {
+								DBG_8192D("###### silent reset test.......#####\n");
+								rtw_hal_sreset_reset(padapter);
+							}
+
+						}
+				break;
+				case 0x15:
+					{
+						struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+						DBG_8192D("==>silent resete cnts:%d\n", pwrpriv->ips_enter_cnts);
+					}
+					break;
+
+		#endif
+
+				case 0x10:/*  driver version display */
+					DBG_8192D("rtw driver version =%s\n", DRIVERVERSION);
+					break;
+				case 0x11:
+					{
+						DBG_8192D("turn %s Rx RSSI display function\n", (extra_arg == 1)?"on":"off");
+						padapter->bRxRSSIDisplay = extra_arg ;
+					}
+					break;
+				case 0x12: /* set rx_stbc */
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					/*  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, 0x3: enable both 2.4g and 5g */
+					/* default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
+					if (pregpriv && (extra_arg == 0 || extra_arg == 1|| extra_arg == 2 || extra_arg == 3))
+					{
+						pregpriv->rx_stbc = extra_arg;
+						DBG_8192D("set rx_stbc =%d\n", pregpriv->rx_stbc);
+					}
+					else
+						DBG_8192D("get rx_stbc =%d\n", pregpriv->rx_stbc);
+
+				}
+				break;
+				case 0x13: /* set ampdu_enable */
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					/*  0: disable, 0x1:enable (but wifi_spec should be 0), 0x2: force enable (don't care wifi_spec) */
+					if (pregpriv && extra_arg >= 0 && extra_arg < 3)
+					{
+						pregpriv->ampdu_enable = extra_arg;
+						DBG_8192D("set ampdu_enable =%d\n", pregpriv->ampdu_enable);
+					}
+					else
+						DBG_8192D("get ampdu_enable =%d\n", pregpriv->ampdu_enable);
+
+				}
+				break;
+				case 0x14: /* get wifi_spec */
+				{
+					struct registry_priv	*pregpriv = &padapter->registrypriv;
+					DBG_8192D("get wifi_spec =%d\n", pregpriv->wifi_spec);
+
+				}
+				break;
+				case 0x22:
+					{
+						DBG_8192D("turn %s the ForceWriteInitGain Variable\n", (extra_arg == 1)?"on":"off");
+						padapter->bForceWriteInitGain = extra_arg;
+						break;
+					}
+				case 0x23:
+					{
+						DBG_8192D("turn %s the bNotifyChannelChange Variable\n", (extra_arg == 1)?"on":"off");
+						padapter->bNotifyChannelChange = extra_arg;
+						break;
+					}
+				case 0x24:
+					break;
+				case 0xdd:/* registers dump , 0 for mac reg, 1 for bb reg, 2 for rf reg */
+					if (extra_arg == 0) {
+						mac_reg_dump(padapter);
+					}
+					else if (extra_arg == 1) {
+						bb_reg_dump(padapter);
+					}
+					else if (extra_arg == 2) {
+						rf_reg_dump(padapter);
+					}
+
+					break;
+				case 0xee:/* turn on/off dynamic funcs */
+					{
+						u8 dm_flag;
+
+						if (0xf == extra_arg) {
+							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
+							DBG_8192D(" === DMFlag(0x%02x) ===\n", dm_flag);
+							DBG_8192D("extra_arg = 0  - disable all dynamic func\n");
+							DBG_8192D("extra_arg = 1  - disable DIG- BIT(0)\n");
+							DBG_8192D("extra_arg = 2  - disable High power - BIT(1)\n");
+							DBG_8192D("extra_arg = 3  - disable tx power tracking - BIT(2)\n");
+							DBG_8192D("extra_arg = 4  - disable BT coexistence - BIT(3)\n");
+							DBG_8192D("extra_arg = 5  - disable antenna diversity - BIT(4)\n");
+							DBG_8192D("extra_arg = 6  - enable all dynamic func\n");
+						}
+						else {
+							/*	extra_arg = 0  - disable all dynamic func
+								extra_arg = 1  - disable DIG
+								extra_arg = 2  - disable tx power tracking
+								extra_arg = 3  - turn on all dynamic func
+							*/
+							rtw_hal_set_def_var(padapter, HAL_DEF_DBG_DM_FUNC, &(extra_arg));
+							rtw_hal_get_def_var(padapter, HAL_DEF_DBG_DM_FUNC,&dm_flag);
+							DBG_8192D(" === DMFlag(0x%02x) ===\n", dm_flag);
+						}
+					}
+					break;
+
+				case 0xfd:
+					rtw_write8(padapter, 0xc50, arg);
+					DBG_8192D("wr(0xc50) = 0x%x\n", rtw_read8(padapter, 0xc50));
+					rtw_write8(padapter, 0xc58, arg);
+					DBG_8192D("wr(0xc58) = 0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xfe:
+					DBG_8192D("rd(0xc50) = 0x%x\n", rtw_read8(padapter, 0xc50));
+					DBG_8192D("rd(0xc58) = 0x%x\n", rtw_read8(padapter, 0xc58));
+					break;
+				case 0xff:
+					{
+						DBG_8192D("dbg(0x210) = 0x%x\n", rtw_read32(padapter, 0x210));
+						DBG_8192D("dbg(0x608) = 0x%x\n", rtw_read32(padapter, 0x608));
+						DBG_8192D("dbg(0x280) = 0x%x\n", rtw_read32(padapter, 0x280));
+						DBG_8192D("dbg(0x284) = 0x%x\n", rtw_read32(padapter, 0x284));
+						DBG_8192D("dbg(0x288) = 0x%x\n", rtw_read32(padapter, 0x288));
+
+						DBG_8192D("dbg(0x664) = 0x%x\n", rtw_read32(padapter, 0x664));
+
+						DBG_8192D("\n");
+
+						DBG_8192D("dbg(0x430) = 0x%x\n", rtw_read32(padapter, 0x430));
+						DBG_8192D("dbg(0x438) = 0x%x\n", rtw_read32(padapter, 0x438));
+
+						DBG_8192D("dbg(0x440) = 0x%x\n", rtw_read32(padapter, 0x440));
+
+						DBG_8192D("dbg(0x458) = 0x%x\n", rtw_read32(padapter, 0x458));
+
+						DBG_8192D("dbg(0x484) = 0x%x\n", rtw_read32(padapter, 0x484));
+						DBG_8192D("dbg(0x488) = 0x%x\n", rtw_read32(padapter, 0x488));
+
+						DBG_8192D("dbg(0x444) = 0x%x\n", rtw_read32(padapter, 0x444));
+						DBG_8192D("dbg(0x448) = 0x%x\n", rtw_read32(padapter, 0x448));
+						DBG_8192D("dbg(0x44c) = 0x%x\n", rtw_read32(padapter, 0x44c));
+						DBG_8192D("dbg(0x450) = 0x%x\n", rtw_read32(padapter, 0x450));
+					}
+					break;
+			}
+			break;
+		default:
+			DBG_8192D("error dbg cmd!\n");
+			break;
+	}
+
+	return ret;
+}
+
+static int wpa_set_param(struct net_device *dev, u8 name, u32 value)
+{
+	uint ret = 0;
+	u32 flags;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	switch (name) {
+	case IEEE_PARAM_WPA_ENABLED:
+
+		padapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; /* 802.1x */
+
+		/* ret = ieee80211_wpa_enable(ieee, value); */
+
+		switch ((value)&0xff)
+		{
+			case 1 : /* WPA */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPAPSK; /* WPA_PSK */
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION2ENABLED;
+				break;
+			case 2: /* WPA2 */
+			padapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEWPA2PSK; /* WPA2_PSK */
+			padapter->securitypriv.ndisencryptstatus = NDIS802_11ENCRYPTION3ENABLED;
+				break;
+		}
+
+		RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("wpa_set_param:padapter->securitypriv.ndisauthtype =%d\n", padapter->securitypriv.ndisauthtype));
+
+		break;
+
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		/* ieee->tkip_countermeasures = value; */
+		break;
+
+	case IEEE_PARAM_DROP_UNENCRYPTED:
+	{
+		/* HACK:
+		 *
+		 * wpa_supplicant calls set_wpa_enabled when the driver
+		 * is loaded and unloaded, regardless of if WPA is being
+		 * used.  No other calls are made which can be used to
+		 * determine if encryption will be used or not prior to
+		 * association being expected.  If encryption is not being
+		 * used, drop_unencrypted is set to false, else true -- we
+		 * can use this to determine if the CAP_PRIVACY_ON bit should
+		 * be set.
+		 */
+
+		break;
+
+	}
+	case IEEE_PARAM_PRIVACY_INVOKED:
+
+		/* ieee->privacy_invoked = value; */
+
+		break;
+
+	case IEEE_PARAM_AUTH_ALGS:
+
+		ret = wpa_set_auth_algs(dev, value);
+
+		break;
+
+	case IEEE_PARAM_IEEE_802_1X:
+
+		/* ieee->ieee802_1x = value; */
+
+		break;
+
+	case IEEE_PARAM_WPAX_SELECT:
+
+		/*  added for WPA2 mixed mode */
+		/* DBG_8192D(KERN_WARNING "------------------------>wpax value = %x\n", value); */
+		/*
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);
+		ieee->wpax_type_set = 1;
+		ieee->wpax_type_notify = value;
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);
+		*/
+
+		break;
+
+	default:
+
+		ret = -EOPNOTSUPP;
+
+		break;
+
+	}
+
+	return ret;
+}
+
+static int wpa_mlme(struct net_device *dev, u32 command, u32 reason)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	switch (command)
+	{
+		case IEEE_MLME_STA_DEAUTH:
+
+			if (!rtw_set_802_11_disassociate(padapter))
+				ret = -1;
+
+			break;
+
+		case IEEE_MLME_STA_DISASSOC:
+
+			if (!rtw_set_802_11_disassociate(padapter))
+				ret = -1;
+
+			break;
+
+		default:
+			ret = -EOPNOTSUPP;
+			break;
+	}
+
+	return ret;
+}
+
+static int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	uint ret = 0;
+
+	/* down(&ieee->wx_sem); */
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
+	if (param == NULL)
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user(param, p->pointer, p->length))
+	{
+		kfree(param);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd) {
+
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);
+		break;
+
+	case IEEE_CMD_SET_WPA_IE:
+		/* ret = wpa_set_wpa_ie(dev, param, p->length); */
+		ret =  rtw_set_wpa_ie((struct rtw_adapter *)rtw_netdev_priv(dev), (char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+		break;
+
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(dev, param, p->length);
+		break;
+
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);
+		break;
+
+	default:
+		DBG_8192D("Unknown WPA supplicant request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	kfree(param);
+
+out:
+
+	/* up(&ieee->wx_sem); */
+
+	return ret;
+}
+
+#ifdef CONFIG_92D_AP_MODE
+static u8 set_pairwise_key(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv				*pcmdpriv =&padapter->cmdpriv;
+	u8	res = _SUCCESS;
+
+	ph2c = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (ph2c == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);
+	if (psetstakey_para == NULL) {
+		kfree(ph2c);
+		res = _FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SETSTAKEY_CMD_);
+
+	psetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;
+
+	memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
+
+	memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+}
+
+static int set_group_key(struct rtw_adapter *padapter, u8 *key, u8 alg, int keyid)
+{
+	u8 keylen;
+	struct cmd_obj* pcmd;
+	struct setkey_parm *psetkeyparm;
+	struct cmd_priv	*pcmdpriv =&(padapter->cmdpriv);
+	int res = _SUCCESS;
+
+	DBG_8192D("%s\n", __func__);
+
+	pcmd = (struct cmd_obj*)kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);
+	if (pcmd == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	psetkeyparm = (struct setkey_parm*)kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);
+	if (psetkeyparm == NULL) {
+		kfree(pcmd);
+		res = _FAIL;
+		goto exit;
+	}
+
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	psetkeyparm->keyid = (u8)keyid;
+
+	psetkeyparm->algorithm = alg;
+
+	psetkeyparm->set_tx = 1;
+
+	switch (alg)
+	{
+		case _WEP40_:
+			keylen = 5;
+			break;
+		case _WEP104_:
+			keylen = 13;
+			break;
+		case _TKIP_:
+		case _TKIP_WTMIC_:
+		case _AES_:
+		default:
+			keylen = 16;
+	}
+
+	memcpy(&(psetkeyparm->key[0]), key, keylen);
+
+	pcmd->cmdcode = _SETKEY_CMD_;
+	pcmd->parmbuf = (u8 *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+
+}
+
+static int set_wep_key(struct rtw_adapter *padapter, u8 *key, u8 keylen, int keyid)
+{
+	u8 alg;
+
+	switch (keylen)
+	{
+		case 5:
+			alg = _WEP40_;
+			break;
+		case 13:
+			alg = _WEP104_;
+			break;
+		default:
+			alg = _NO_PRIVACY_;
+	}
+
+	return set_group_key(padapter, key, alg, keyid);
+}
+
+static int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len, wep_total_len;
+	struct ndis_802_11_wep *pwep = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	struct security_priv* psecuritypriv =&(padapter->securitypriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192D("%s\n", __func__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	/* sizeof(struct ieee_param) = 64 bytes; */
+	/* if (param_len !=  (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len) */
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len)
+	{
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		if (param->u.crypt.idx >= WEP_KEYS)
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+	}
+	else
+	{
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if (!psta)
+		{
+			/* ret = -EINVAL; */
+			DBG_8192D("rtw_set_encryption(), sta has already been removed or never been added\n");
+			goto exit;
+		}
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta == NULL))
+	{
+		/* todo:clear default encryption keys */
+
+		DBG_8192D("clear default encryption keys, keyid =%d\n", param->u.crypt.idx);
+
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL))
+	{
+		DBG_8192D("r871x_set_encryption, crypt.alg = WEP\n");
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		DBG_8192D("r871x_set_encryption, wep_key_idx =%d, len =%d\n", wep_key_idx, wep_key_len);
+
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len<= 0))
+		{
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		if (wep_key_len > 0)
+		{
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);
+			pwep = (struct ndis_802_11_wep *)kmalloc(wep_total_len, GFP_KERNEL);
+			if (pwep == NULL) {
+				DBG_8192D(" r871x_set_encryption: pwep allocate fail !!!\n");
+				goto exit;
+			}
+
+			memset(pwep, 0, wep_total_len);
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+
+		memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if (param->u.crypt.set_tx)
+		{
+			DBG_8192D("wep, set_tx = 1\n");
+
+			psecuritypriv->ndisencryptstatus = NDIS802_11ENCRYPTION1ENABLED;
+			psecuritypriv->dot11PrivacyAlgrthm = _WEP40_;
+			psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+
+			if (pwep->KeyLength == 13)
+			{
+				psecuritypriv->dot11PrivacyAlgrthm = _WEP104_;
+				psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+			}
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx]= pwep->KeyLength;
+
+			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
+
+		}
+		else
+		{
+			DBG_8192D("wep, set_tx = 0\n");
+
+			/* don't update "psecuritypriv->dot11PrivacyAlgrthm" and */
+			/* psecuritypriv->dot11PrivacyKeyIndex = keyid", but can rtw_set_key to cam */
+
+		      memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+
+			set_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);
+
+		}
+
+		goto exit;
+
+	}
+
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) /*  group key */
+	{
+		if (param->u.crypt.set_tx == 1)
+		{
+			if (strcmp(param->u.crypt.alg, "WEP") == 0)
+			{
+				DBG_8192D("%s, set group_key, WEP\n", __func__);
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+				if (param->u.crypt.key_len == 13)
+				{
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+				}
+
+			}
+			else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+			{
+				DBG_8192D("%s, set group_key, TKIP\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				/* DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); */
+				/* set mic key */
+				memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+				memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = true;
+
+			}
+			else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+			{
+				DBG_8192D("%s, set group_key, CCMP\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+			}
+			else
+			{
+				DBG_8192D("%s, set group_key, none\n", __func__);
+
+				psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = true;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
+
+			set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+			pbcmc_sta = rtw_get_bcmc_stainfo(padapter);
+			if (pbcmc_sta)
+			{
+				pbcmc_sta->ieee8021x_blocked = false;
+				pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
+			}
+
+		}
+
+		goto exit;
+
+	}
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) /*  psk/802_1x */
+	{
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
+		{
+			if (param->u.crypt.set_tx == 1)
+			{
+				memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					DBG_8192D("%s, set pairwise key, WEP\n", __func__);
+
+					psta->dot118021XPrivacy = _WEP40_;
+					if (param->u.crypt.key_len == 13)
+					{
+						psta->dot118021XPrivacy = _WEP104_;
+					}
+				}
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{
+					DBG_8192D("%s, set pairwise key, TKIP\n", __func__);
+
+					psta->dot118021XPrivacy = _TKIP_;
+
+					/* DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); */
+					/* set mic key */
+					memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				}
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+
+					DBG_8192D("%s, set pairwise key, CCMP\n", __func__);
+
+					psta->dot118021XPrivacy = _AES_;
+				}
+				else
+				{
+					DBG_8192D("%s, set pairwise key, none\n", __func__);
+
+					psta->dot118021XPrivacy = _NO_PRIVACY_;
+				}
+
+				set_pairwise_key(padapter, psta);
+
+				psta->ieee8021x_blocked = false;
+
+			}
+			else/* group key??? */
+			{
+				if (strcmp(param->u.crypt.alg, "WEP") == 0)
+				{
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					psecuritypriv->dot118021XGrpPrivacy = _WEP40_;
+					if (param->u.crypt.key_len == 13)
+					{
+						psecuritypriv->dot118021XGrpPrivacy = _WEP104_;
+					}
+				}
+				else if (strcmp(param->u.crypt.alg, "TKIP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _TKIP_;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+
+					/* DEBUG_ERR("set key length :param->u.crypt.key_len =%d\n", param->u.crypt.key_len); */
+					/* set mic key */
+					memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				}
+				else if (strcmp(param->u.crypt.alg, "CCMP") == 0)
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _AES_;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));
+				}
+				else
+				{
+					psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = true;
+
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/*  */
+
+				set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+				pbcmc_sta = rtw_get_bcmc_stainfo(padapter);
+				if (pbcmc_sta)
+				{
+					pbcmc_sta->ieee8021x_blocked = false;
+					pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
+				}
+
+			}
+
+		}
+
+	}
+
+exit:
+
+	kfree(pwep);
+
+	return ret;
+}
+
+static int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	unsigned char *pbuf = param->u.bcn_ie.buf;
+
+	DBG_8192D("%s, len =%d\n", __func__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
+
+	if ((pstapriv->max_num_sta>NUM_STA) || (pstapriv->max_num_sta<= 0))
+		pstapriv->max_num_sta = NUM_STA;
+
+	if (rtw_check_beacon_data(padapter, pbuf,  (len-12-2)) == _SUCCESS)/*  12 = param header, 2:no packed */
+		ret = 0;
+	else
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static int rtw_hostapd_sta_flush(struct net_device *dev)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	DBG_8192D("%s\n", __func__);
+
+	flush_all_cam_entry(padapter);	/* clear CAM */
+
+	ret = rtw_sta_flush(padapter);
+
+	return ret;
+}
+
+static int rtw_add_sta(struct net_device *dev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192D("rtw_add_sta(aid =%d) =%pM\n", param->u.add_sta.aid, param->sta_addr);
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+	{
+		return -EINVAL;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		return -EINVAL;
+	}
+
+/*
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta)
+	{
+		DBG_8192D("rtw_add_sta(), free has been added psta =%p\n", psta);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(padapter,  psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+		psta = NULL;
+	}
+*/
+	/* psta = rtw_alloc_stainfo(pstapriv, param->sta_addr); */
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta)
+	{
+		int flags = param->u.add_sta.flags;
+
+		/* DBG_8192D("rtw_add_sta(), init sta's variables, psta =%p\n", psta); */
+
+		psta->aid = param->u.add_sta.aid;/* aid = 1~2007 */
+
+		memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
+
+		/* check wmm cap. */
+		if (WLAN_STA_WME&flags)
+			psta->qos_option = 1;
+		else
+			psta->qos_option = 0;
+
+		if (pmlmepriv->qospriv.qos_option == 0)
+			psta->qos_option = 0;
+
+#ifdef CONFIG_80211N_HT
+		/* chec 802.11n ht cap. */
+		if (WLAN_STA_HT&flags)
+		{
+			psta->htpriv.ht_option = true;
+			psta->qos_option = 1;
+			memcpy((void*)&psta->htpriv.ht_cap, (void*)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+		}
+		else
+		{
+			psta->htpriv.ht_option = false;
+		}
+
+		if (pmlmepriv->htpriv.ht_option == false)
+			psta->htpriv.ht_option = false;
+#endif
+
+		update_sta_info_apmode(padapter, psta);
+
+	}
+	else
+	{
+		ret = -ENOMEM;
+	}
+
+	return ret;
+}
+
+static int rtw_del_sta(struct net_device *dev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192D("rtw_del_sta =%pM\n", param->sta_addr);
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+		return -EINVAL;
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta) {
+		u8 updated;
+
+		/* DBG_8192D("free psta =%p, aid =%d\n", psta, psta->aid); */
+
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if (rtw_is_list_empty(&psta->asoc_list) == false)
+		{
+			list_del_init(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			updated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+
+		}
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+		associated_clients_update(padapter, updated);
+
+		psta = NULL;
+
+	}
+	else
+	{
+		DBG_8192D("rtw_del_sta(), sta has already been removed or never been added\n");
+
+		/* ret = -1; */
+	}
+
+	return ret;
+}
+
+static int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	struct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;
+	struct sta_data *psta_data = (struct sta_data *)param_ex->data;
+
+	DBG_8192D("rtw_ioctl_get_sta_info, sta_addr: %pM\n", param_ex->sta_addr);
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+	{
+		return -EINVAL;
+	}
+
+	if (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&
+	    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&
+	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff)
+	{
+		return -EINVAL;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
+	if (psta)
+	{
+		psta_data->aid = (u16)psta->aid;
+		psta_data->capability = psta->capability;
+		psta_data->flags = psta->flags;
+
+/*
+		nonerp_set : BIT(0)
+		no_short_slot_time_set : BIT(1)
+		no_short_preamble_set : BIT(2)
+		no_ht_gf_set : BIT(3)
+		no_ht_set : BIT(4)
+		ht_20mhz_set : BIT(5)
+*/
+
+		psta_data->sta_set = ((psta->nonerp_set) |
+							(psta->no_short_slot_time_set <<1) |
+							(psta->no_short_preamble_set <<2) |
+							(psta->no_ht_gf_set <<3) |
+							(psta->no_ht_set <<4) |
+							(psta->ht_20mhz_set <<5));
+
+		psta_data->tx_supp_rates_len =  psta->bssratelen;
+		memcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);
+
+		memcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+
+		psta_data->rx_pkts = psta->sta_stats.rx_data_pkts;
+		psta_data->rx_bytes = psta->sta_stats.rx_bytes;
+		psta_data->rx_drops = psta->sta_stats.rx_drops;
+
+		psta_data->tx_pkts = psta->sta_stats.tx_pkts;
+		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
+		psta_data->tx_drops = psta->sta_stats.tx_drops;
+
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	DBG_8192D("rtw_get_sta_wpaie, sta_addr: %pM\n", param->sta_addr);
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)
+	{
+		return -EINVAL;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+	{
+		return -EINVAL;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta)
+	{
+		if ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC))
+		{
+			int wpa_ie_len;
+			int copy_len;
+
+			wpa_ie_len = psta->wpa_ie[1];
+
+			copy_len = ((wpa_ie_len+2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)):(wpa_ie_len+2);
+
+			param->u.wpa_ie.len = copy_len;
+
+			memcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);
+		}
+		else
+		{
+			/* ret = -1; */
+			DBG_8192D("sta's wpa_ie is NONE\n");
+		}
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	unsigned char wps_oui[4]={0x0, 0x50, 0xf2, 0x04};
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int ie_len;
+
+	DBG_8192D("%s, len =%d\n", __func__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
+
+	kfree(pmlmepriv->wps_beacon_ie);
+	pmlmepriv->wps_beacon_ie = NULL;
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_beacon_ie = kmalloc(ie_len, GFP_KERNEL);
+		pmlmepriv->wps_beacon_ie_len = ie_len;
+		if (pmlmepriv->wps_beacon_ie == NULL) {
+			DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+		memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
+
+		update_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);
+
+		pmlmeext->bstart_bss = true;
+
+	}
+	return ret;
+}
+
+static int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int ie_len;
+
+	DBG_8192D("%s, len =%d\n", __func__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
+
+	kfree(pmlmepriv->wps_probe_resp_ie);
+	pmlmepriv->wps_probe_resp_ie = NULL;
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_probe_resp_ie = kmalloc(ie_len, GFP_KERNEL);
+		pmlmepriv->wps_probe_resp_ie_len = ie_len;
+		if (pmlmepriv->wps_probe_resp_ie == NULL) {
+			DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+		memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
+	}
+	return ret;
+}
+
+static int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	int ie_len;
+
+	DBG_8192D("%s, len =%d\n", __func__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
+
+	kfree(pmlmepriv->wps_assoc_resp_ie);
+	pmlmepriv->wps_assoc_resp_ie = NULL;
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_assoc_resp_ie = kmalloc(ie_len, GFP_KERNEL);
+		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
+		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
+			DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+
+		memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);
+	}
+	return ret;
+}
+
+static int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *mlmepriv = &(adapter->mlmepriv);
+	struct mlme_ext_priv	*mlmeext = &(adapter->mlmeextpriv);
+	struct mlme_ext_info	*mlmeinfo = &(mlmeext->mlmext_info);
+	int ie_len;
+	u8 *ssid_ie;
+	char ssid[NDIS_802_11_LENGTH_SSID + 1];
+	int ssid_len;
+	u8 ignore_broadcast_ssid;
+
+	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != true)
+		return -EPERM;
+
+	if (param->u.bcn_ie.reserved[0] != 0xea)
+		return -EINVAL;
+
+	mlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];
+
+	ie_len = len-12-2;/*  12 = param header, 2:no packed */
+	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);
+
+	if (ssid_ie && ssid_len) {
+		struct wlan_bssid_ex *pbss_network = &mlmepriv->cur_network.network;
+		struct wlan_bssid_ex *pbss_network_ext = &mlmeinfo->network;
+
+		memcpy(ssid, ssid_ie+2, ssid_len);
+		ssid[ssid_len>NDIS_802_11_LENGTH_SSID?NDIS_802_11_LENGTH_SSID:ssid_len] = 0x0;
+
+		memcpy(pbss_network->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network->Ssid.SsidLength = ssid_len;
+		memcpy(pbss_network_ext->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network_ext->Ssid.SsidLength = ssid_len;
+
+	}
+
+	DBG_8192D(FUNC_ADPT_FMT" ignore_broadcast_ssid:%d, %s,%d\n", FUNC_ADPT_ARG(adapter),
+		ignore_broadcast_ssid, ssid, ssid_len);
+
+	return ret;
+}
+
+static int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+		return -EINVAL;
+
+	ret = rtw_acl_remove_sta(padapter, param->sta_addr);
+
+	return ret;
+}
+
+static int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)
+		return -EINVAL;
+
+	ret = rtw_acl_add_sta(padapter, param->sta_addr);
+
+	return ret;
+}
+
+static int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	rtw_set_macaddr_acl(padapter, param->u.mlme.command);
+
+	return ret;
+}
+
+static int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	/* DBG_8192D("%s\n", __func__); */
+
+	/*
+	* this function is expect to call in master mode, which allows no power saving
+	* so, we just check hw_init_completed instead of call rfpwrstate_check()
+	*/
+
+	if (padapter->hw_init_completed == false) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	/* if (p->length < sizeof(struct ieee_param) || !p->pointer) { */
+	if (!p->pointer) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
+	if (param == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user(param, p->pointer, p->length)) {
+		kfree(param);
+		ret = -EFAULT;
+		goto out;
+	}
+	switch (param->cmd) {
+	case RTL871X_HOSTAPD_FLUSH:
+		ret = rtw_hostapd_sta_flush(dev);
+		break;
+	case RTL871X_HOSTAPD_ADD_STA:
+		ret = rtw_add_sta(dev, param);
+		break;
+	case RTL871X_HOSTAPD_REMOVE_STA:
+		ret = rtw_del_sta(dev, param);
+		break;
+	case RTL871X_HOSTAPD_SET_BEACON:
+		ret = rtw_set_beacon(dev, param, p->length);
+		break;
+	case RTL871X_SET_ENCRYPTION:
+		ret = rtw_set_encryption(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_GET_WPAIE_STA:
+		ret = rtw_get_sta_wpaie(dev, param);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_BEACON:
+		ret = rtw_set_wps_beacon(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
+		ret = rtw_set_wps_probe_resp(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
+		ret = rtw_set_wps_assoc_resp(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
+		ret = rtw_set_hidden_ssid(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_GET_INFO_STA:
+		ret = rtw_ioctl_get_sta_data(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_SET_MACADDR_ACL:
+		ret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_ACL_ADD_STA:
+		ret = rtw_ioctl_acl_add_sta(dev, param, p->length);
+		break;
+	case RTL871X_HOSTAPD_ACL_REMOVE_STA:
+		ret = rtw_ioctl_acl_remove_sta(dev, param, p->length);
+		break;
+	default:
+		DBG_8192D("Unknown hostapd request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	kfree(param);
+
+out:
+
+	return ret;
+}
+#endif
+
+#include <rtw_android.h>
+static int rtw_wx_set_priv(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+
+#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	char *ext_dbg;
+#endif
+
+	int ret = 0;
+	int len = 0;
+	char *ext;
+	int i;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_point *dwrq = (struct iw_point*)awrq;
+
+	if (dwrq->length == 0)
+		return -EFAULT;
+	len = dwrq->length;
+	if (!(ext = vmalloc(len)))
+		return -ENOMEM;
+
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		vfree(ext);
+		return -EFAULT;
+	}
+
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	if (!(ext_dbg = rtw_vmalloc(len))) {
+		vfree(ext);
+		return -ENOMEM;
+	}
+
+	memcpy(ext_dbg, ext, len);
+	#endif
+
+	/* added for wps2.0 @20110524 */
+	if (dwrq->flags == 0x8766 && len > 8) {
+		u32 cp_sz;
+		struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+		u8 *probereq_wpsie = ext;
+		int probereq_wpsie_len = len;
+		u8 wps_oui[4]={0x0, 0x50, 0xf2, 0x04};
+
+		if ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
+		    !memcmp(&probereq_wpsie[2], wps_oui, 4)) {
+			cp_sz = probereq_wpsie_len>MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN:probereq_wpsie_len;
+
+			/* memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz); */
+			/* pmlmepriv->probereq_wpsie_len = cp_sz; */
+
+			DBG_8192D("probe_req_wps_ielen =%d\n", cp_sz);
+
+			if (pmlmepriv->wps_probe_req_ie) {
+				u32 free_len = pmlmepriv->wps_probe_req_ie_len;
+				pmlmepriv->wps_probe_req_ie_len = 0;
+				kfree(pmlmepriv->wps_probe_req_ie);
+				pmlmepriv->wps_probe_req_ie = NULL;
+			}
+
+			pmlmepriv->wps_probe_req_ie = kmalloc(cp_sz, GFP_KERNEL);
+			if (pmlmepriv->wps_probe_req_ie == NULL) {
+				DBG_8192D("%s()-%d: kmalloc() ERROR!\n", __func__, __LINE__);
+				ret =  -EINVAL;
+				goto FREE_EXT;
+
+			}
+
+			memcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);
+			pmlmepriv->wps_probe_req_ie_len = cp_sz;
+
+		}
+
+		goto FREE_EXT;
+
+	}
+
+	if (len >= WEXT_CSCAN_HEADER_SIZE &&
+	    !memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE)) {
+		ret = rtw_wx_set_scan(dev, info, awrq, ext);
+		goto FREE_EXT;
+	}
+
+#ifdef CONFIG_ANDROID
+	/* DBG_8192D("rtw_wx_set_priv: %s req =%s\n", dev->name, ext); */
+
+	i = rtw_android_cmdstr_to_num(ext);
+
+	switch (i) {
+	case ANDROID_WIFI_CMD_START :
+		indicate_wx_custom_event(padapter, "START");
+		break;
+	case ANDROID_WIFI_CMD_STOP :
+		indicate_wx_custom_event(padapter, "STOP");
+		break;
+	case ANDROID_WIFI_CMD_RSSI : {
+		struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+		struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+			sprintf(ext, "%s rssi %d", pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+		else
+			sprintf(ext, "OK");
+		break; }
+	case ANDROID_WIFI_CMD_LINKSPEED : {
+		u16 mbps = rtw_get_cur_max_rate(padapter)/10;
+		sprintf(ext, "LINKSPEED %d", mbps);
+		break; }
+	case ANDROID_WIFI_CMD_MACADDR :
+		sprintf(ext, "MACADDR = %pM", dev->dev_addr);
+		break;
+	case ANDROID_WIFI_CMD_SCAN_ACTIVE :
+		/* rtw_set_scan_mode(padapter, SCAN_ACTIVE); */
+		sprintf(ext, "OK");
+		break;
+	case ANDROID_WIFI_CMD_SCAN_PASSIVE :
+		/* rtw_set_scan_mode(padapter, SCAN_PASSIVE); */
+		sprintf(ext, "OK");
+		break;
+
+	case ANDROID_WIFI_CMD_COUNTRY : {
+		char country_code[10];
+		sscanf(ext, "%*s %s", country_code);
+		rtw_set_country(padapter, country_code);
+		sprintf(ext, "OK");
+		break; }
+	default :
+		#ifdef  CONFIG_DEBUG_RTW_WX_SET_PRIV
+		DBG_8192D("%s: %s unknowned req =%s\n", __func__,
+			dev->name, ext_dbg);
+		#endif
+
+		sprintf(ext, "OK");
+	}
+
+	if (copy_to_user(dwrq->pointer, ext, min(dwrq->length, (u16)(strlen(ext)+1))))
+		ret = -EFAULT;
+
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	DBG_8192D("%s: %s req =%s rep =%s dwrq->length =%d, strlen(ext)+1 =%d\n", __func__,
+		dev->name, ext_dbg , ext, dwrq->length, (u16)(strlen(ext)+1));
+	#endif
+#endif /* end of CONFIG_ANDROID */
+
+FREE_EXT:
+
+	vfree(ext);
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	vfree(ext_dbg);
+	#endif
+
+	/* DBG_8192D("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret =%d\n", */
+	/*		dev->name, ret); */
+
+	return ret;
+}
+
+static int rtw_mp_efuse_get(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu = (struct iw_point *)wdata;
+	struct rtw_adapter * padapter = rtw_netdev_priv(dev);
+	struct mp_priv *pmp_priv;
+
+	int i, j = 0;
+	u8 data[EFUSE_MAP_SIZE];
+	u8 rawdata[EFUSE_MAX_SIZE];
+	u16 mapLen = 0;
+	char *pch, *ptmp, *token, *tmp[3] = {NULL, NULL, NULL};
+	u16 addr = 0, cnts = 0, max_available_size = 0, raw_cursize = 0, raw_maxsize = 0;
+
+	memset(data, '\0', sizeof(data));
+	memset(rawdata, '\0', sizeof(rawdata));
+
+	if (copy_from_user(extra, wrqu->pointer, wrqu->length))
+		return -EFAULT;
+
+	pch = extra;
+	DBG_8192D("%s: in =%s\n", __func__, extra);
+
+	i = 0;
+	/* mac 16 "00e04c871200" rmap, 00, 2 */
+	while ((token = strsep(&pch,",")) != NULL) {
+		if (i > 2)
+			 break;
+		tmp[i] = token;
+		i++;
+	}
+
+	if (strcmp(tmp[0],"realmap") == 0) {
+
+		DBG_8192D("strcmp OK =	%s\n" , tmp[0]);
+
+		mapLen = EFUSE_MAP_SIZE;
+
+		if (rtw_efuse_map_read(padapter, 0, mapLen, data) == _SUCCESS) {
+			DBG_8192D("\t  rtw_efuse_map_read\n");
+		} else {
+			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
+			return -EFAULT;
+		}
+		memset(extra, '\0', 1);
+		DBG_8192D("\tOFFSET\tVALUE(hex)\n");
+		sprintf(extra, "%s\n", extra);
+		for (i = 0; i < EFUSE_MAP_SIZE; i += 16) {
+			DBG_8192D("\t0x%02x\t", i);
+			sprintf(extra, "%s \t0x%02x\t", extra, i);
+			for (j = 0; j < 8; j++) {
+				DBG_8192D("%02X ", data[i+j]);
+				sprintf(extra, "%s %02X", extra, data[i+j]);
+			}
+			DBG_8192D("\t");
+			sprintf(extra,"%s\t", extra);
+			for (; j < 16; j++) {
+				DBG_8192D("%02X ", data[i+j]);
+				sprintf(extra, "%s %02X", extra, data[i+j]);
+			}
+			DBG_8192D("\n");
+			sprintf(extra,"%s\n", extra);
+		}
+		DBG_8192D("\n");
+		wrqu->length = strlen(extra);
+
+		return 0;
+	} else if (strcmp(tmp[0],"rmap") == 0) {
+		if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
+		/*  rmap addr cnts */
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+
+		DBG_8192D("addr = %x\n" , addr);
+
+		cnts = simple_strtoul(tmp[2], &ptmp, 10);
+		if (cnts == 0)
+			return -EINVAL;
+
+		DBG_8192D("cnts = %d\n" , cnts);
+		/* memset(extra, '\0', wrqu->data.length); */
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+		if ((addr + cnts) > max_available_size) {
+			DBG_8192D("(addr + cnts parameter error\n");
+			return -EFAULT;
+		}
+
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+			DBG_8192D("rtw_efuse_access error\n");
+		else
+			DBG_8192D("rtw_efuse_access ok\n");
+
+		memset(extra, '\0', 1);
+		for (i = 0; i < cnts; i ++) {
+			DBG_8192D("0x%02x", data[i]);
+			sprintf(extra, "%s 0x%02X", extra, data[i]);
+			DBG_8192D(" ");
+			sprintf(extra,"%s ", extra);
+		}
+
+		wrqu->length = strlen(extra)+1;
+
+		DBG_8192D("extra = %s ", extra);
+
+		return 0;
+	} else if (strcmp(tmp[0],"realraw") == 0) {
+		addr = 0;
+		mapLen = EFUSE_MAX_SIZE;
+
+		if (rtw_efuse_access(padapter, false, addr, mapLen, rawdata) == _FAIL) {
+			DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
+			return -EFAULT;
+		} else {
+			DBG_8192D("\t  rtw_efuse_access raw ok\n");
+		}
+
+		memset(extra, '\0', 1);
+		for (i = 0; i < mapLen; i++) {
+			DBG_8192D(" %02x", rawdata[i]);
+			sprintf(extra, "%s %02x", extra, rawdata[i]);
+
+			if ((i & 0xF) == 0xF) {
+				DBG_8192D("\n\t");
+				sprintf(extra, "%s\n\t", extra);
+			} else if ((i & 0x7) == 0x7) {
+				DBG_8192D("\t");
+				sprintf(extra, "%s\t", extra);
+			}
+		}
+		wrqu->length = strlen(extra);
+		return 0;
+	} else if (strcmp(tmp[0],"mac") == 0) {
+		if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
+		addr = 0x19;
+		cnts = 6;
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+		if ((addr + mapLen) > max_available_size) {
+			DBG_8192D("(addr + cnts parameter error\n");
+			return -EFAULT;
+		}
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL)
+			DBG_8192D("rtw_efuse_access error\n");
+		else
+			DBG_8192D("rtw_efuse_access ok\n");
+		memset(extra, '\0', 1);
+		for (i = 0; i < cnts; i ++) {
+			DBG_8192D("0x%02x", data[i]);
+			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
+			DBG_8192D(" ");
+			sprintf(extra,"%s ", extra);
+		}
+		wrqu->length = strlen(extra);
+		return 0;
+	} else if (strcmp(tmp[0],"vidpid") == 0) {
+		if (tmp[1]== NULL || tmp[2]== NULL)
+			return	-EINVAL;
+		addr = 0x0c;
+		cnts = 4;
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+		if ((addr + mapLen) > max_available_size) {
+			DBG_8192D("(addr + cnts parameter error\n");
+			return -EFAULT;
+		}
+		if (rtw_efuse_map_read(padapter, addr, cnts, data) == _FAIL) {
+			DBG_8192D("rtw_efuse_access error\n");
+		} else {
+			DBG_8192D("rtw_efuse_access ok\n");
+		}
+		memset(extra, '\0', 1);
+		for (i = 0; i < cnts; i ++) {
+			DBG_8192D("0x%02x", data[i]);
+			sprintf(extra, "%s 0x%02X", extra, data[i+j]);
+			DBG_8192D(" ");
+			sprintf(extra,"%s ", extra);
+		}
+		wrqu->length = strlen(extra);
+		return 0;
+	} else if (strcmp(tmp[0],"ableraw") == 0) {
+		efuse_GetCurrentSize(padapter,&raw_cursize);
+		raw_maxsize = efuse_GetMaxSize(padapter);
+		sprintf(extra, "%s : [available raw size] = %d", extra, raw_maxsize-raw_cursize);
+		wrqu->length = strlen(extra);
+
+		return 0;
+	} else {
+		 sprintf(extra, "%s : Command not found\n", extra);
+		  wrqu->length = strlen(extra);
+		  return 0;
+	}
+
+	return 0;
+}
+
+static int rtw_mp_efuse_set(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wdata, char *extra)
+{
+	struct iw_point *wrqu = (struct iw_point *)wdata;
+	struct rtw_adapter *padapter = rtw_netdev_priv(dev);
+
+	u8 buffer[40];
+	u32 i, jj, kk;
+	u8 setdata[EFUSE_MAP_SIZE];
+	u8 setrawdata[EFUSE_MAX_SIZE];
+	char *pch, *ptmp, *token, *edata, *tmp[3] = {NULL, NULL, NULL};
+
+	u16 addr = 0, max_available_size = 0;
+	u32  cnts = 0;
+
+	pch = extra;
+	DBG_8192D("%s: in =%s\n", __func__, extra);
+
+	i = 0;
+	while ((token = strsep (&pch,","))!= NULL) {
+		if (i>2) break;
+		tmp[i] = token;
+		i++;
+	}
+
+	/*  tmp[0],[1],[2] */
+	/*  wmap, addr, 00e04c871200 */
+	if (strcmp(tmp[0],"wmap") == 0) {
+		 if (tmp[1]== NULL || tmp[2]== NULL)
+			return	-EINVAL;
+		if (!strlen(tmp[2])/2 > 1)
+			return -EFAULT;
+
+		addr = simple_strtoul(tmp[1], &ptmp, 16);
+		addr = addr & 0xFF;
+		DBG_8192D("addr = %x\n" , addr);
+
+		cnts = strlen(tmp[2])/2;
+		if (cnts == 0) return -EFAULT;
+
+		DBG_8192D("cnts = %d\n" , cnts);
+		DBG_8192D("target data = %s\n" , tmp[2]);
+
+		for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
+			setdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
+
+		EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+
+		if ((addr + cnts) > max_available_size) {
+					DBG_8192D("parameter error\n");
+					return -EFAULT;
+		}
+		if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+				DBG_8192D("rtw_efuse_map_write error\n");
+				return -EFAULT;
+		} else
+		   DBG_8192D("rtw_efuse_map_write ok\n");
+
+		return 0;
+	} else if (strcmp(tmp[0],"wraw") == 0) {
+			 if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
+			 if (! strlen(tmp[2])/2 > 1) return -EFAULT;
+			addr = simple_strtoul(tmp[1], &ptmp, 16);
+			addr = addr & 0xFF;
+			DBG_8192D("addr = %x\n" , addr);
+
+			cnts = strlen(tmp[2])/2;
+			if (cnts == 0) return -EFAULT;
+
+			DBG_8192D(" cnts = %d\n" , cnts);
+			DBG_8192D("target data = %s\n" , tmp[2]);
+
+			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
+					setrawdata[jj] = key_2char2num(tmp[2][kk], tmp[2][kk+ 1]);
+
+			if (rtw_efuse_access(padapter, true, addr, cnts, setrawdata) == _FAIL) {
+					DBG_8192D("\t  rtw_efuse_map_read : Fail\n");
+						return -EFAULT;
+			} else {
+			  DBG_8192D("\t  rtw_efuse_access raw ok\n");
+			}
+			return 0;
+		} else if (strcmp(tmp[0],"mac") == 0) {
+			 if (tmp[1]== NULL || tmp[2]== NULL) return	-EINVAL;
+			/* mac, 00e04c871200 */
+				addr = 0x19;
+				cnts = strlen(tmp[1])/2;
+				if (cnts == 0) return -EFAULT;
+				if (cnts > 6) {
+						DBG_8192D("error data for mac addr = %s\n" , tmp[1]);
+						return -EFAULT;
+				}
+
+				DBG_8192D("target data = %s\n" , tmp[1]);
+
+				for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
+					setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
+
+				EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+
+				if ((addr + cnts) > max_available_size) {
+						DBG_8192D("parameter error\n");
+						return -EFAULT;
+				}
+				if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+					DBG_8192D("rtw_efuse_map_write error\n");
+					return -EFAULT;
+				} else
+					DBG_8192D("rtw_efuse_map_write ok\n");
+
+			return 0;
+		} else if (strcmp(tmp[0],"vidpid") == 0) {
+			if (tmp[1]== NULL || tmp[2]== NULL)
+				return	-EINVAL;
+				/*  pidvid, da0b7881 */
+			addr = 0x0c;
+
+			cnts = strlen(tmp[1])/2;
+			if (cnts == 0)
+				return -EFAULT;
+			DBG_8192D("target data = %s\n" , tmp[1]);
+
+			for (jj = 0, kk = 0; jj < cnts; jj++, kk += 2)
+				setdata[jj] = key_2char2num(tmp[1][kk], tmp[1][kk+ 1]);
+
+			EFUSE_GetEfuseDefinition(padapter, EFUSE_WIFI, TYPE_AVAILABLE_EFUSE_BYTES_TOTAL, (void *)&max_available_size, false);
+
+			if ((addr + cnts) > max_available_size) {
+				DBG_8192D("parameter error\n");
+				return -EFAULT;
+			}
+
+			if (rtw_efuse_map_write(padapter, addr, cnts, setdata) == _FAIL) {
+				DBG_8192D("rtw_efuse_map_write error\n");
+				return -EFAULT;
+			} else
+				DBG_8192D("rtw_efuse_map_write ok\n");
+
+			return 0;
+		} else {
+			DBG_8192D("Command not found\n");
+			return 0;
+		}
+
+	  return 0;
+}
+
+static int rtw_wfd_tdls_enable(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_weaksec(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_enable(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_setup(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_teardown(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_discovery(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_ch_switch (struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_pson(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+		return ret;
+}
+
+static int rtw_tdls_psoff(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_setip(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_getip(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_getport(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/* WFDTDLS, for sigma test */
+static int rtw_tdls_dis_result(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+
+	return ret;
+}
+
+/* WFDTDLS, for sigma test */
+static int rtw_wfd_tdls_status(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_ch_switch_off(struct net_device *dev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls(struct net_device *dev,
+		    struct iw_request_info *info,
+		    union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int rtw_tdls_get(struct net_device *dev,
+			struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+static int rtw_pm_set(struct net_device *dev,
+		      struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	unsigned	mode = 0;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	DBG_8192D("[%s] extra = %s\n", __func__, extra);
+
+	if (!memcmp(extra, "lps =", 4)) {
+		sscanf(extra+4, "%u", &mode);
+		ret = rtw_pm_set_lps(padapter, mode);
+	} else if (!memcmp(extra, "ips =", 4)) {
+		sscanf(extra+4, "%u", &mode);
+		ret = rtw_pm_set_ips(padapter, mode);
+	} else {
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_WOWLAN
+static int rtw_wowlan_ctrl(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct oid_par_priv	oid_par;
+	struct wowlan_ioctl_param *poidparam;
+	uint status = 0;
+	u16 len;
+	u8 *pparmbuf = NULL, bset;
+	struct rtw_adapter *padapter =  (struct rtw_adapter *)rtw_netdev_priv(dev);
+
+	struct iw_point *p = &wrqu->data;
+
+	if ((!p->length) || (!p->pointer)) {
+		ret = -EINVAL;
+		goto _rtw_wowlan_ctrl_exit;
+	}
+
+	pparmbuf = NULL;
+	bset = (u8)(p->flags & 0xFFFF);
+	len = p->length;
+	pparmbuf = (u8 *)kmalloc(len, GFP_KERNEL);
+	if (pparmbuf == NULL) {
+		ret = -ENOMEM;
+		goto _rtw_wowlan_ctrl_exit;
+	}
+
+	if (copy_from_user(pparmbuf, p->pointer, len)) {
+		ret = -EFAULT;
+		goto _rtw_wowlan_ctrl_exit_free;
+	}
+	poidparam = (struct wowlan_ioctl_param *)pparmbuf;
+
+	if (!padapter->pwrctrlpriv.bSupportRemoteWakeup) {
+		ret = -EPERM;
+		DBG_8192D("+rtw_wowlan_ctrl: Device didn't support the remote wakeup!!\n");
+		goto _rtw_wowlan_ctrl_exit_free;
+	}
+	rtw_hal_set_hwreg(padapter, HW_VAR_WOWLAN, (u8 *)poidparam);
+
+	DBG_8192D("rtw_wowlan_ctrl: subcode [%d], len[%d], buffer_len[%d]\r\n",
+		  poidparam->subcode, poidparam->len, len);
+
+	if (copy_to_user(p->pointer, pparmbuf, len))
+		ret = -EFAULT;
+
+_rtw_wowlan_ctrl_exit_free:
+	kfree(pparmbuf);
+_rtw_wowlan_ctrl_exit:
+
+	return ret;
+}
+#endif /* CONFIG_WOWLAN */
+
+static int rtw_test(struct net_device *dev, struct iw_request_info *info,
+		    union iwreq_data *wrqu, char *extra)
+{
+	DBG_8192D("%s\n", __func__);
+	return 0;
+}
+
+#include <rtw_android.h>
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret = 0;
+
+	switch (cmd) {
+	case RTL_IOCTL_WPA_SUPPLICANT:
+		ret = wpa_supplicant_ioctl(dev, &wrq->u.data);
+		break;
+#ifdef CONFIG_92D_AP_MODE
+	case RTL_IOCTL_HOSTAPD:
+		ret = rtw_hostapd_ioctl(dev, &wrq->u.data);
+		break;
+#ifdef CONFIG_NO_WIRELESS_HANDLERS
+	case SIOCSIWMODE:
+		ret = rtw_wx_set_mode(dev, NULL, &wrq->u, NULL);
+		break;
+#endif
+#endif
+	case (SIOCDEVPRIVATE+1):
+		ret = rtw_android_priv_cmd(dev, rq, cmd);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static iw_handler rtw_handlers[] = {
+	NULL,			/* SIOCSIWCOMMIT */
+	rtw_wx_get_name,	/* SIOCGIWNAME */
+	dummy,			/* SIOCSIWNWID */
+	dummy,			/* SIOCGIWNWID */
+	rtw_wx_set_freq,	/* SIOCSIWFREQ */
+	rtw_wx_get_freq,	/* SIOCGIWFREQ */
+	rtw_wx_set_mode,	/* SIOCSIWMODE */
+	rtw_wx_get_mode,	/* SIOCGIWMODE */
+	dummy,			/* SIOCSIWSENS */
+	rtw_wx_get_sens,	/* SIOCGIWSENS */
+	NULL,			/* SIOCSIWRANGE */
+	rtw_wx_get_range,	/* SIOCGIWRANGE */
+	rtw_wx_set_priv,	/* SIOCSIWPRIV */
+	NULL,			/* SIOCGIWPRIV */
+	NULL,			/* SIOCSIWSTATS */
+	NULL,			/* SIOCGIWSTATS */
+	dummy,			/* SIOCSIWSPY */
+	dummy,			/* SIOCGIWSPY */
+	NULL,			/* SIOCGIWTHRSPY */
+	NULL,			/* SIOCWIWTHRSPY */
+	rtw_wx_set_wap,		/* SIOCSIWAP */
+	rtw_wx_get_wap,		/* SIOCGIWAP */
+	rtw_wx_set_mlme,	/* request MLME op; uses struct iw_mlme */
+	dummy,			/* SIOCGIWAPLIST -- depricated */
+	rtw_wx_set_scan,	/* SIOCSIWSCAN */
+	rtw_wx_get_scan,	/* SIOCGIWSCAN */
+	rtw_wx_set_essid,	/* SIOCSIWESSID */
+	rtw_wx_get_essid,	/* SIOCGIWESSID */
+	dummy,			/* SIOCSIWNICKN */
+	rtw_wx_get_nick,	/* SIOCGIWNICKN */
+	NULL,			/* -- hole -- */
+	NULL,			/* -- hole -- */
+	rtw_wx_set_rate,	/* SIOCSIWRATE */
+	rtw_wx_get_rate,	/* SIOCGIWRATE */
+	rtw_wx_set_rts,		/* SIOCSIWRTS */
+	rtw_wx_get_rts,		/* SIOCGIWRTS */
+	rtw_wx_set_frag,	/* SIOCSIWFRAG */
+	rtw_wx_get_frag,	/* SIOCGIWFRAG */
+	dummy,			/* SIOCSIWTXPOW */
+	dummy,			/* SIOCGIWTXPOW */
+	dummy,			/* SIOCSIWRETRY */
+	rtw_wx_get_retry,	/* SIOCGIWRETRY */
+	rtw_wx_set_enc,		/* SIOCSIWENCODE */
+	rtw_wx_get_enc,		/* SIOCGIWENCODE */
+	dummy,			/* SIOCSIWPOWER */
+	rtw_wx_get_power,	/* SIOCGIWPOWER */
+	NULL,			/*---hole---*/
+	NULL,			/*---hole---*/
+	rtw_wx_set_gen_ie,	/* SIOCSIWGENIE */
+	NULL,			/* SIOCGWGENIE */
+	rtw_wx_set_auth,	/* SIOCSIWAUTH */
+	NULL,			/* SIOCGIWAUTH */
+	rtw_wx_set_enc_ext,	/* SIOCSIWENCODEEXT */
+	NULL,			/* SIOCGIWENCODEEXT */
+	rtw_wx_set_pmkid,	/* SIOCSIWPMKSA */
+	NULL,			/*---hole---*/
+};
+
+static const struct iw_priv_args rtw_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_CHAR | 0x7FF, 0, "write"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_CHAR | 0x7FF,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
+	},
+
+	{
+		SIOCIWFIRSTPRIV + 0xA,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "channel_plan"
+	},
+
+	{
+		SIOCIWFIRSTPRIV + 0xB,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xC,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xD,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR |
+		IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
+	},
+#ifdef CONFIG_WOWLAN
+	{
+		SIOCIWFIRSTPRIV + 0xE, 0, 0, "wowlan_ctrl"
+	},
+#endif /*  CONFIG_WOWLAN */
+	{
+		SIOCIWFIRSTPRIV + 0x10,
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, 0, "p2p_set"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x11,
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED |
+		P2P_PRIVATE_IOCTL_SET_LEN , "p2p_get"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x12, 0, 0, "NULL"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x13,
+		IW_PRIV_TYPE_CHAR | 64, IW_PRIV_TYPE_CHAR | 64 , "p2p_get2"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x14,
+		IW_PRIV_TYPE_CHAR  | 64, 0, "tdls"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x15,
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED |
+		P2P_PRIVATE_IOCTL_SET_LEN, "tdls_get"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x16,
+		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
+	},
+
+	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 ,
+	 "rereg_nd_name"},
+
+	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 128, 0, "efuse_set"},
+	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR |
+	 IW_PRIV_SIZE_FIXED | 0x700, "efuse_get"},
+	{
+		SIOCIWFIRSTPRIV + 0x1D,
+		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
+	},
+};
+
+static iw_handler rtw_private_handler[] = {
+	rtw_wx_write32,			/* 0x00 */
+	rtw_wx_read32,			/* 0x01 */
+	rtw_drvext_hdl,			/* 0x02 */
+	rtw_mp_ioctl_hdl,		/* 0x03 */
+
+/*  for MM DTV platform */
+	rtw_get_ap_info,		/* 0x04 */
+
+	rtw_set_pid,			/* 0x05 */
+	rtw_wps_start,			/* 0x06 */
+
+	rtw_wx_get_sensitivity,		/* 0x07 */
+	rtw_wx_set_mtk_wps_probe_ie,	/* 0x08 */
+	rtw_wx_set_mtk_wps_ie,		/* 0x09 */
+
+/*  Set Channel depend on the country code */
+	rtw_wx_set_channel_plan,	/* 0x0A */
+
+	rtw_dbg_port,			/* 0x0B */
+	rtw_wx_write_rf,		/* 0x0C */
+	rtw_wx_read_rf,			/* 0x0D */
+
+#ifdef CONFIG_WOWLAN
+	rtw_wowlan_ctrl,		/* 0x0E */
+#else
+	rtw_wx_priv_null,		/* 0x0E */
+#endif /* CONFIG_WOWLAN */
+	rtw_wx_priv_null,		/* 0x0F */
+
+	rtw_p2p_set,			/* 0x10 */
+	rtw_p2p_get,			/* 0x11 */
+	NULL,				/* 0x12 */
+	rtw_p2p_get2,			/* 0x13 */
+
+	rtw_tdls,			/* 0x14 */
+	rtw_tdls_get,			/* 0x15 */
+
+	rtw_pm_set,			/* 0x16 */
+	rtw_wx_priv_null,		/* 0x17 */
+	rtw_rereg_nd_name,		/* 0x18 */
+	rtw_wx_priv_null,		/* 0x19 */
+
+	rtw_mp_efuse_set,		/* 0x1A */
+	rtw_mp_efuse_get,		/* 0x1B */
+	NULL,				/*  0x1C is reserved for hostapd */
+	rtw_test	,		/*  0x1D */
+};
+
+#if WIRELESS_EXT >= 17
+static struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)
+{
+	struct rtw_adapter *padapter =
+		(struct rtw_adapter *)rtw_netdev_priv(dev);
+	struct iw_statistics *piwstats = &padapter->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+	} else {
+		#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+		tmp_level = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);
+		#else
+		tmp_level = padapter->recvpriv.signal_strength;
+		#endif
+
+		tmp_qual = padapter->recvpriv.signal_qual;
+		tmp_noise = padapter->recvpriv.noise;
+
+		piwstats->qual.level = tmp_level;
+		piwstats->qual.qual = tmp_qual;
+		piwstats->qual.noise = tmp_noise;
+	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14))
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;/* IW_QUAL_DBM; */
+#else
+#endif
+
+	#ifdef CONFIG_SIGNAL_DISPLAY_DBM
+	piwstats->qual.updated = piwstats->qual.updated | IW_QUAL_DBM;
+	#endif
+
+	return &padapter->iwstats;
+}
+#endif
+
+#ifdef CONFIG_WIRELESS_EXT
+struct iw_handler_def rtw_handlers_def = {
+	.standard = rtw_handlers,
+	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)) || defined(CONFIG_WEXT_PRIV)
+	.private = rtw_private_handler,
+	.private_args = (struct iw_priv_args *)rtw_private_args,
+	.num_private = sizeof(rtw_private_handler) / sizeof(iw_handler),
+	.num_private_args = sizeof(rtw_private_args) /
+			    sizeof(struct iw_priv_args),
+#endif
+#if WIRELESS_EXT >= 17
+	.get_wireless_stats = rtw_get_wireless_stats,
+#endif
+};
+#endif
diff --git a/drivers/net/wireless/rtl8192du/os_dep/mlme_linux.c b/drivers/net/wireless/rtl8192du/os_dep/mlme_linux.c
new file mode 100644
index 0000000..d4c1a93
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/mlme_linux.c
@@ -0,0 +1,416 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#define _MLME_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <mlme_osdep.h>
+
+void rtw_join_timeout_handler (void *FunctionContext)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+	_rtw_join_timeout_handler(adapter);
+}
+
+void _rtw_scan_timeout_handler (void *FunctionContext)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+	rtw_scan_timeout_handler(adapter);
+}
+
+static void _dynamic_check_timer_handlder (void *FunctionContext)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+
+	rtw_dynamic_check_timer_handlder(adapter);
+
+	_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);
+}
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+static void _rtw_set_scan_deny_timer_hdl(void *FunctionContext)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
+	rtw_set_scan_deny_timer_hdl(adapter);
+}
+#endif
+
+void rtw_init_mlme_timer(struct rtw_adapter *padapter)
+{
+	struct	mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), padapter->pnetdev, rtw_join_timeout_handler, padapter);
+	_init_timer(&(pmlmepriv->scan_to_timer), padapter->pnetdev, _rtw_scan_timeout_handler, padapter);
+
+	_init_timer(&(pmlmepriv->dynamic_chk_timer), padapter->pnetdev, _dynamic_check_timer_handlder, padapter);
+
+	#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	_init_timer(&(pmlmepriv->set_scan_deny_timer), padapter->pnetdev, _rtw_set_scan_deny_timer_hdl, padapter);
+	#endif
+}
+
+void rtw_os_indicate_connect(struct rtw_adapter *adapter)
+{
+
+	rtw_cfg80211_indicate_connect(adapter);
+
+	rtw_indicate_wx_assoc_event(adapter);
+	netif_carrier_on(adapter->pnetdev);
+
+	if (adapter->pid[2] !=0)
+		rtw_signal_process(adapter->pid[2], SIGALRM);
+
+}
+
+void rtw_os_indicate_scan_done(struct rtw_adapter *padapter, bool aborted)
+{
+	rtw_cfg80211_indicate_scan_done(wdev_to_priv(padapter->rtw_wdev), aborted);
+	indicate_wx_scan_complete_event(padapter);
+}
+
+static struct RT_PMKID_LIST   backupPMKIDList[NUM_PMKID_CACHE];
+void rtw_reset_securitypriv(struct rtw_adapter *adapter)
+{
+	u8	backupPMKIDIndex = 0;
+	u8	backupTKIPCountermeasure = 0x00;
+	u32	backupTKIPcountermeasure_time = 0;
+
+	if (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)/* 802.1x */
+	{
+		/*  Added by Albert 2009/02/18 */
+		/*  We have to backup the PMK information for WiFi PMK Caching test item. */
+		/*  */
+		/*  Backup the btkip_countermeasure information. */
+		/*  When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds. */
+
+		memset(&backupPMKIDList[0], 0x00, sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+
+		memcpy(&backupPMKIDList[0], &adapter->securitypriv.PMKIDList[0], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		backupPMKIDIndex = adapter->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = adapter->securitypriv.btkip_countermeasure;
+		backupTKIPcountermeasure_time = adapter->securitypriv.btkip_countermeasure_time;
+
+		memset((unsigned char *)&adapter->securitypriv, 0, sizeof (struct security_priv));
+
+		/*  Added by Albert 2009/02/18 */
+		/*  Restore the PMK information to securitypriv structure for the following connection. */
+		memcpy(&adapter->securitypriv.PMKIDList[0], &backupPMKIDList[0], sizeof(struct RT_PMKID_LIST) * NUM_PMKID_CACHE);
+		adapter->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		adapter->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
+		adapter->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
+
+		adapter->securitypriv.ndisauthtype = NDIS802_11AUTHMODEOPEN;
+		adapter->securitypriv.ndisencryptstatus = NDIS802_11WEPDISABLED;
+
+	}
+	else /* reset values in securitypriv */
+	{
+		struct security_priv *psec_priv=&adapter->securitypriv;
+
+		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  /* open system */
+		psec_priv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+		psec_priv->dot11PrivacyKeyIndex = 0;
+
+		psec_priv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+		psec_priv->dot118021XGrpKeyid = 1;
+
+		psec_priv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
+		psec_priv->ndisencryptstatus = NDIS802_11WEPDISABLED;
+		/*  */
+	}
+}
+
+void rtw_os_indicate_disconnect(struct rtw_adapter *adapter)
+{
+
+	netif_carrier_off(adapter->pnetdev); /*  Do it first for tx broadcast pkt after disconnection issue! */
+
+	rtw_cfg80211_indicate_disconnect(adapter);
+
+	rtw_indicate_wx_disassoc_event(adapter);
+
+	 rtw_reset_securitypriv(adapter);
+
+}
+
+void rtw_report_sec_ie(struct rtw_adapter *adapter,u8 authmode,u8 *sec_ie)
+{
+	uint	len;
+	u8	*buff,*p,i;
+	union iwreq_data wrqu;
+
+	RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("+rtw_report_sec_ie, authmode=%d\n", authmode));
+
+	buff = NULL;
+	if (authmode==_WPA_IE_ID_) {
+		RT_TRACE(_module_mlme_osdep_c_,_drv_info_,("rtw_report_sec_ie, authmode=%d\n", authmode));
+
+		buff = kmalloc(IW_CUSTOM_MAX, GFP_ATOMIC);
+
+		memset(buff,0,IW_CUSTOM_MAX);
+
+		p=buff;
+
+		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
+
+		len = sec_ie[1]+2;
+		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+
+		for (i=0;i<len;i++) {
+			p+=sprintf(p,"%02x",sec_ie[i]);
+		}
+
+		p+=sprintf(p,")");
+
+		memset(&wrqu,0,sizeof(wrqu));
+
+		wrqu.data.length=p-buff;
+
+		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+		wireless_send_event(adapter->pnetdev,IWEVCUSTOM,&wrqu,buff);
+
+		kfree(buff);
+
+	}
+
+}
+
+static void _survey_timer_hdl (void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+
+	survey_timer_hdl(padapter);
+}
+
+static void _link_timer_hdl (void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+	link_timer_hdl(padapter);
+}
+
+static void _addba_timer_hdl(void *FunctionContext)
+{
+	struct sta_info *psta = (struct sta_info *)FunctionContext;
+	addba_timer_hdl(psta);
+}
+
+void init_addba_retry_timer(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+
+	_init_timer(&psta->addba_retry_timer, padapter->pnetdev, _addba_timer_hdl, psta);
+}
+
+/*
+void _reauth_timer_hdl(void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+	reauth_timer_hdl(padapter);
+}
+
+void _reassoc_timer_hdl(void *FunctionContext)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)FunctionContext;
+	reassoc_timer_hdl(padapter);
+}
+*/
+
+void init_mlme_ext_timer(struct rtw_adapter *padapter)
+{
+	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+
+	_init_timer(&pmlmeext->survey_timer, padapter->pnetdev, _survey_timer_hdl, padapter);
+	_init_timer(&pmlmeext->link_timer, padapter->pnetdev, _link_timer_hdl, padapter);
+}
+
+#ifdef CONFIG_92D_AP_MODE
+
+void rtw_indicate_sta_assoc_event(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	if (psta==NULL)
+		return;
+
+	if (psta->aid > NUM_STA)
+		return;
+
+	if (pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+
+	wrqu.addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_8192D("+rtw_indicate_sta_assoc_event\n");
+
+	wireless_send_event(padapter->pnetdev, IWEVREGISTERED, &wrqu, NULL);
+}
+
+void rtw_indicate_sta_disassoc_event(struct rtw_adapter *padapter, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &padapter->stapriv;
+
+	if (psta==NULL)
+		return;
+
+	if (psta->aid > NUM_STA)
+		return;
+
+	if (pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+
+	wrqu.addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_8192D("+rtw_indicate_sta_disassoc_event\n");
+
+	wireless_send_event(padapter->pnetdev, IWEVEXPIRED, &wrqu, NULL);
+}
+
+#ifdef CONFIG_HOSTAPD_MLME
+
+static int mgnt_xmit_entry(struct sk_buff *skb, struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+	struct rtw_adapter *padapter = (struct rtw_adapter *)phostapdpriv->padapter;
+
+	return rtw_hal_hostap_mgnt_xmit_entry(padapter, skb);
+}
+
+static int mgnt_netdev_open(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+
+	DBG_8192D("mgnt_netdev_open: MAC Address:%pM\n", pnetdev->dev_addr);
+
+	init_usb_anchor(&phostapdpriv->anchored);
+
+	if (!netif_queue_stopped(pnetdev))
+		netif_start_queue(pnetdev);
+	else
+		netif_wake_queue(pnetdev);
+
+	netif_carrier_on(pnetdev);
+
+	return 0;
+}
+static int mgnt_netdev_close(struct net_device *pnetdev)
+{
+	struct hostapd_priv *phostapdpriv = rtw_netdev_priv(pnetdev);
+
+	DBG_8192D("%s\n", __func__);
+
+	usb_kill_anchored_urbs(&phostapdpriv->anchored);
+
+	netif_carrier_off(pnetdev);
+
+	if (!rtw_netif_queue_stopped(pnetdev))
+		rtw_netif_stop_queue(pnetdev);
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+static const struct net_device_ops rtl871x_mgnt_netdev_ops = {
+	.ndo_open = mgnt_netdev_open,
+       .ndo_stop = mgnt_netdev_close,
+       .ndo_start_xmit = mgnt_xmit_entry,
+};
+#endif
+
+int hostapd_mode_init(struct rtw_adapter *padapter)
+{
+	unsigned char mac[ETH_ALEN];
+	struct hostapd_priv *phostapdpriv;
+	struct net_device *pnetdev;
+
+	pnetdev = rtw_alloc_etherdev(sizeof(struct hostapd_priv));
+	if (!pnetdev)
+	   return -ENOMEM;
+
+       ether_setup(pnetdev);
+
+	phostapdpriv = rtw_netdev_priv(pnetdev);
+	phostapdpriv->pmgnt_netdev = pnetdev;
+	phostapdpriv->padapter= padapter;
+	padapter->phostapdpriv = phostapdpriv;
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,29))
+
+	DBG_8192D("register rtl871x_mgnt_netdev_ops to netdev_ops\n");
+
+	pnetdev->netdev_ops = &rtl871x_mgnt_netdev_ops;
+
+#else
+
+	pnetdev->open = mgnt_netdev_open;
+
+	pnetdev->stop = mgnt_netdev_close;
+
+	pnetdev->hard_start_xmit = mgnt_xmit_entry;
+
+#endif
+
+	pnetdev->watchdog_timeo = HZ; /* 1 second timeout */
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif
+	if (dev_alloc_name(pnetdev,"mgnt.wlan%d") < 0)
+		DBG_8192D("hostapd_mode_init(): dev_alloc_name, fail!\n");
+
+	mac[0]=0x00;
+	mac[1]=0xe0;
+	mac[2]=0x4c;
+	mac[3]=0x87;
+	mac[4]=0x11;
+	mac[5]=0x12;
+
+	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+
+	netif_carrier_off(pnetdev);
+
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0)
+	{
+		DBG_8192D("hostapd_mode_init(): register_netdev fail!\n");
+
+		if (pnetdev)
+		{
+			rtw_free_netdev(pnetdev);
+		}
+	}
+
+	return 0;
+}
+
+void hostapd_mode_unload(struct rtw_adapter *padapter)
+{
+	struct hostapd_priv *phostapdpriv = padapter->phostapdpriv;
+	struct net_device *pnetdev = phostapdpriv->pmgnt_netdev;
+
+	unregister_netdev(pnetdev);
+	rtw_free_netdev(pnetdev);
+}
+
+#endif
+#endif
diff --git a/drivers/net/wireless/rtl8192du/os_dep/os_intfs.c b/drivers/net/wireless/rtl8192du/os_dep/os_intfs.c
new file mode 100644
index 0000000..802f5a4
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/os_intfs.c
@@ -0,0 +1,2201 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _OS_INTFS_C_
+
+#include <drv_conf.h>
+
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <xmit_osdep.h>
+#include <recv_osdep.h>
+#include <hal_intf.h>
+#include <rtw_ioctl.h>
+#include <usb_osintf.h>
+#include <rtl8192d_hal.h>
+#include <linux/vmalloc.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
+MODULE_AUTHOR("Realtek Semiconductor Corp.");
+MODULE_VERSION(DRIVERVERSION);
+
+/* module param defaults */
+static int rtw_chip_version = 0x00;
+static int rtw_rfintfs = HWPI;
+static int rtw_lbkmode = 0;/* RTL8712_AIR_TRX; */
+
+static int rtw_network_mode = NDIS802_11IBSS;
+static int rtw_channel = 1;/* ad-hoc support requirement */
+static int rtw_wireless_mode = WIRELESS_11BG_24N;
+static int rtw_vrtl_carrier_sense = AUTO_VCS;
+static int rtw_vcs_type = RTS_CTS;/*  */
+static int rtw_rts_thresh = 2347;/*  */
+static int rtw_frag_thresh = 2346;/*  */
+static int rtw_preamble = PREAMBLE_LONG;/* long, short, auto */
+static int rtw_scan_mode = 1;/* active, passive */
+static int rtw_adhoc_tx_pwr = 1;
+static int rtw_soft_ap;
+static int debug = 1;
+/* int smart_ps = 1; */
+#ifdef CONFIG_POWER_SAVING
+static int rtw_power_mgnt = 1;
+#ifdef CONFIG_IPS_LEVEL_2
+static int rtw_ips_mode = IPS_LEVEL_2;
+#else
+static int rtw_ips_mode = IPS_NORMAL;
+#endif
+#else
+int rtw_power_mgnt = PS_MODE_ACTIVE;
+int rtw_ips_mode = IPS_NONE;
+#endif
+module_param(rtw_ips_mode, int, 0644);
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(rtw_ips_mode,"The default IPS mode");
+MODULE_PARM_DESC(debug, "Set debug level (0-7) (default 1)");
+
+static int rtw_radio_enable = 1;
+static int rtw_long_retry_lmt = 7;
+static int rtw_short_retry_lmt = 7;
+static int rtw_busy_thresh = 40;
+static int rtw_ack_policy = NORMAL_ACK;
+static int rtw_mp_mode;
+static int rtw_software_encrypt;
+static int rtw_software_decrypt;
+
+static int rtw_acm_method;/*  0:By SW 1:By HW. */
+
+static int rtw_wmm_enable = 1;/*  default is set to enable the wmm. */
+static int rtw_uapsd_enable;
+static int rtw_uapsd_max_sp = NO_LIMIT;
+static int rtw_uapsd_acbk_en;
+static int rtw_uapsd_acbe_en;
+static int rtw_uapsd_acvi_en;
+static int rtw_uapsd_acvo_en;
+
+#ifdef CONFIG_80211N_HT
+int rtw_ht_enable = 1;
+int rtw_cbw40_enable = 3; /*  0 :diable, bit(0): enable 2.4g, bit(1): enable 5g */
+int rtw_ampdu_enable = 1;/* for enable tx_ampdu */
+static int rtw_rx_stbc = 1;/*  0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
+static int rtw_ampdu_amsdu;/*  0: disabled, 1:enabled, 2:auto */
+#endif
+
+static int rtw_lowrate_two_xmit = 1;/* Use 2 path Tx to transmit MCS0~7 and legacy mode */
+
+/* int rf_config = RF_1T2R;   1T2R */
+static int rtw_rf_config = RF_819X_MAX_TYPE;  /* auto */
+static int rtw_low_power;
+#ifdef CONFIG_WIFI_TEST
+int rtw_wifi_spec = 1;/* for wifi test */
+#else
+static int rtw_wifi_spec;
+#endif
+
+static int rtw_special_rf_path = 0; /* 0: 2T2R , 1: only turn on path A 1T1R, 2: only turn on path B 1T1R */
+
+static int rtw_channel_plan = RT_CHANNEL_DOMAIN_MAX;
+
+#ifdef CONFIG_BT_COEXIST
+int rtw_bt_iso = 2;/*  0:Low, 1:High, 2:From Efuse */
+int rtw_bt_sco = 3;/*  0:Idle, 1:None-SCO, 2:SCO, 3:From Counter, 4.Busy, 5.OtherBusy */
+int rtw_bt_ampdu = 1 ;/*  0:Disable BT control A-MPDU, 1:Enable BT control A-MPDU. */
+#endif
+static int rtw_AcceptAddbaReq = true;/*  0:Reject AP's Add BA req, 1:Accept AP's Add BA req. */
+
+static int  rtw_antdiv_cfg = 2; /*  0:OFF , 1:ON, 2:decide by Efuse config */
+
+#ifdef CONFIG_USB_AUTOSUSPEND
+int rtw_enusbss = 1;/* 0:disable, 1:enable */
+#else
+static int rtw_enusbss = 0;/* 0:disable, 1:enable */
+#endif
+
+static int rtw_hwpdn_mode = 2;/* 0:disable, 1:enable, 2: by EFUSE config */
+
+#ifdef CONFIG_HW_PWRP_DETECTION
+int rtw_hwpwrp_detect = 1;
+#else
+static int rtw_hwpwrp_detect = 0; /* HW power  ping detect 0:disable , 1:enable */
+#endif
+
+static int rtw_hw_wps_pbc = 1;
+
+int rtw_mc2u_disable = 0;
+
+static int rtw_mac_phy_mode; /* 0:by efuse, 1:smsp, 2:dmdp, 3:dmsp. */
+
+#ifdef CONFIG_80211D
+static int rtw_80211d = 0;
+#endif
+
+static char *ifname = "wlan%d";
+module_param(ifname, charp, 0644);
+MODULE_PARM_DESC(ifname, "The default name to allocate for first interface");
+
+static char *if2name = "wlan%d";
+module_param(if2name, charp, 0644);
+MODULE_PARM_DESC(if2name, "The default name to allocate for second interface");
+
+char *rtw_initmac = NULL;  /*  temp mac address if users want to use instead of the mac address in Efuse */
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+int rtw_ext_iface_num  = 1;/* primary/secondary iface is excluded */
+module_param(rtw_ext_iface_num, int, 0644);
+#endif /* CONFIG_MULTI_VIR_IFACES */
+
+module_param(rtw_initmac, charp, 0644);
+module_param(rtw_channel_plan, int, 0644);
+module_param(rtw_chip_version, int, 0644);
+module_param(rtw_rfintfs, int, 0644);
+module_param(rtw_lbkmode, int, 0644);
+module_param(rtw_network_mode, int, 0644);
+module_param(rtw_channel, int, 0644);
+module_param(rtw_mp_mode, int, 0644);
+module_param(rtw_wmm_enable, int, 0644);
+module_param(rtw_vrtl_carrier_sense, int, 0644);
+module_param(rtw_vcs_type, int, 0644);
+module_param(rtw_busy_thresh, int, 0644);
+#ifdef CONFIG_80211N_HT
+module_param(rtw_ht_enable, int, 0644);
+module_param(rtw_cbw40_enable, int, 0644);
+module_param(rtw_ampdu_enable, int, 0644);
+module_param(rtw_rx_stbc, int, 0644);
+module_param(rtw_ampdu_amsdu, int, 0644);
+#endif
+
+module_param(rtw_lowrate_two_xmit, int, 0644);
+
+module_param(rtw_rf_config, int, 0644);
+module_param(rtw_power_mgnt, int, 0644);
+module_param(rtw_low_power, int, 0644);
+module_param(rtw_wifi_spec, int, 0644);
+
+module_param(rtw_special_rf_path, int, 0644);
+
+module_param(rtw_antdiv_cfg, int, 0644);
+
+module_param(rtw_enusbss, int, 0644);
+module_param(rtw_hwpdn_mode, int, 0644);
+module_param(rtw_hwpwrp_detect, int, 0644);
+
+module_param(rtw_hw_wps_pbc, int, 0644);
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+char *rtw_adaptor_info_caching_file_path = "/data/misc/wifi/rtw_cache";
+module_param(rtw_adaptor_info_caching_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_adaptor_info_caching_file_path, "The path of adapter info cache file");
+#endif /* CONFIG_ADAPTOR_INFO_CACHING_FILE */
+
+#ifdef CONFIG_LAYER2_ROAMING
+static uint rtw_max_roaming_times = 2;
+module_param(rtw_max_roaming_times, uint, 0644);
+MODULE_PARM_DESC(rtw_max_roaming_times,"The max roaming times to try");
+#endif /* CONFIG_LAYER2_ROAMING */
+
+#ifdef CONFIG_FILE_FWIMG
+char *rtw_fw_file_path = "";
+module_param(rtw_fw_file_path, charp, 0644);
+MODULE_PARM_DESC(rtw_fw_file_path, "The path of fw image");
+#endif /* CONFIG_FILE_FWIMG */
+
+module_param(rtw_mc2u_disable, int, 0644);
+
+module_param(rtw_mac_phy_mode, int, 0644);
+
+#ifdef CONFIG_80211D
+module_param(rtw_80211d, int, 0644);
+#endif
+
+static uint rtw_notch_filter = RTW_NOTCH_FILTER;
+module_param(rtw_notch_filter, uint, 0644);
+MODULE_PARM_DESC(rtw_notch_filter, "0:Disable, 1:Enable, 2:Enable only for P2P");
+
+int netdev_open (struct net_device *pnetdev);
+static int netdev_close (struct net_device *pnetdev);
+
+#ifdef CONFIG_PROC_DEBUG
+#define RTL8192C_PROC_NAME "rtl819xC"
+#define RTL8192D_PROC_NAME "rtl819xD"
+static char rtw_proc_name[IFNAMSIZ];
+static struct proc_dir_entry *rtw_proc = NULL;
+static int	rtw_proc_cnt = 0;
+
+#define RTW_PROC_NAME DRV_NAME
+
+#ifndef create_proc_entry
+/* dummy routines */
+void rtw_proc_remove_one(struct net_device *dev)
+{
+}
+
+void rtw_proc_init_one(struct net_device *dev)
+{
+}
+
+#else	/* LINUX_VERSION_CODE > KERNEL_VERSION(3, 8. 0) */
+void rtw_proc_init_one(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_dev = NULL;
+	struct proc_dir_entry *entry = NULL;
+	struct rtw_adapter	*padapter = rtw_netdev_priv(dev);
+	u8 rf_type;
+
+	if (rtw_proc == NULL) {
+		if (padapter->chip_type == RTL8188C_8192C)
+			memcpy(rtw_proc_name, RTL8192C_PROC_NAME, sizeof(RTL8192C_PROC_NAME));
+		else if (padapter->chip_type == RTL8192D)
+			memcpy(rtw_proc_name, RTL8192D_PROC_NAME, sizeof(RTL8192D_PROC_NAME));
+		else if (padapter->chip_type == RTL8723A)
+			memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
+		else if (padapter->chip_type == RTL8188E)
+			memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
+		else
+			memcpy(rtw_proc_name, RTW_PROC_NAME, sizeof(RTW_PROC_NAME));
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
+#else
+		rtw_proc = create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
+#endif
+		if (rtw_proc == NULL) {
+			DBG_8192D(KERN_ERR "Unable to create rtw_proc directory\n");
+			return;
+		}
+
+		entry = create_proc_read_entry("ver_info", S_IFREG | S_IRUGO, rtw_proc, proc_get_drv_version, dev);
+		if (!entry) {
+			DBG_8192D("Unable to create_proc_read_entry!\n");
+			return;
+		}
+
+		entry = create_proc_read_entry("log_level", S_IFREG | S_IRUGO,
+				   rtw_proc, proc_get_log_level, dev);
+		if (!entry) {
+			DBG_8192D("Unable to create_proc_read_entry!\n");
+			return;
+		}
+		entry->write_proc = proc_set_log_level;
+	}
+
+	if (padapter->dir_dev == NULL) {
+		padapter->dir_dev = create_proc_entry(dev->name,
+					  S_IFDIR | S_IRUGO | S_IXUGO,
+					  rtw_proc);
+
+		dir_dev = padapter->dir_dev;
+
+		if (dir_dev == NULL) {
+			if (rtw_proc_cnt == 0) {
+				if (rtw_proc) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+					remove_proc_entry(rtw_proc_name, proc_net);
+#else
+					remove_proc_entry(rtw_proc_name, init_net.proc_net);
+#endif
+					rtw_proc = NULL;
+				}
+			}
+
+			DBG_8192D("Unable to create dir_dev directory\n");
+			return;
+		}
+	} else {
+		return;
+	}
+
+	rtw_proc_cnt++;
+
+	entry = create_proc_read_entry("write_reg", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_write_reg, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_write_reg;
+
+	entry = create_proc_read_entry("read_reg", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_read_reg, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_read_reg;
+
+	entry = create_proc_read_entry("fwstate", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_fwstate, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_sec_info, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_mlmext_state, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_qos_option, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("ht_option", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ht_option, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("rf_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rf_info, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("ap_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ap_info, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("adapter_state", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_adapter_state, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("trx_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_trx_info, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("mac_reg_dump1", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_mac_reg_dump1, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("mac_reg_dump2", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_mac_reg_dump2, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("mac_reg_dump3", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_mac_reg_dump3, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("bb_reg_dump1", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_bb_reg_dump1, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("bb_reg_dump2", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_bb_reg_dump2, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("bb_reg_dump3", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_bb_reg_dump3, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("rf_reg_dump1", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rf_reg_dump1, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("rf_reg_dump2", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rf_reg_dump2, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+	if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type))	{
+		entry = create_proc_read_entry("rf_reg_dump3", S_IFREG | S_IRUGO,
+					   dir_dev, proc_get_rf_reg_dump3, dev);
+		if (!entry) {
+			DBG_8192D("Unable to create_proc_read_entry!\n");
+			return;
+		}
+
+		entry = create_proc_read_entry("rf_reg_dump4", S_IFREG | S_IRUGO,
+					   dir_dev, proc_get_rf_reg_dump4, dev);
+		if (!entry) {
+			DBG_8192D("Unable to create_proc_read_entry!\n");
+			return;
+		}
+	}
+
+#ifdef CONFIG_92D_AP_MODE
+
+	entry = create_proc_read_entry("all_sta_info", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_all_sta_info, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+	entry = create_proc_read_entry("best_channel", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_best_channel, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+#endif
+
+	entry = create_proc_read_entry("rx_signal", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rx_signal, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_rx_signal;
+
+	entry = create_proc_read_entry("ht_enable", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ht_enable, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_ht_enable;
+
+	entry = create_proc_read_entry("cbw40_enable", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_cbw40_enable, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_cbw40_enable;
+
+	entry = create_proc_read_entry("ampdu_enable", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_ampdu_enable, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_ampdu_enable;
+
+	entry = create_proc_read_entry("rx_stbc", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rx_stbc, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_rx_stbc;
+
+	entry = create_proc_read_entry("path_rssi", S_IFREG | S_IRUGO,
+					dir_dev, proc_get_two_path_rssi, dev);
+
+	entry = create_proc_read_entry("vid", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_vid, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("pid", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_pid, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+
+	entry = create_proc_read_entry("rssi_disp", S_IFREG | S_IRUGO,
+				   dir_dev, proc_get_rssi_disp, dev);
+	if (!entry) {
+		DBG_8192D("Unable to create_proc_read_entry!\n");
+		return;
+	}
+	entry->write_proc = proc_set_rssi_disp;
+}
+
+void rtw_proc_remove_one(struct net_device *dev)
+{
+	struct proc_dir_entry *dir_dev = NULL;
+	struct rtw_adapter	*padapter = rtw_netdev_priv(dev);
+	u8 rf_type;
+
+	dir_dev = padapter->dir_dev;
+	padapter->dir_dev = NULL;
+
+	if (dir_dev) {
+
+		remove_proc_entry("write_reg", dir_dev);
+		remove_proc_entry("read_reg", dir_dev);
+		remove_proc_entry("fwstate", dir_dev);
+		remove_proc_entry("sec_info", dir_dev);
+		remove_proc_entry("mlmext_state", dir_dev);
+		remove_proc_entry("qos_option", dir_dev);
+		remove_proc_entry("ht_option", dir_dev);
+		remove_proc_entry("rf_info", dir_dev);
+		remove_proc_entry("ap_info", dir_dev);
+		remove_proc_entry("adapter_state", dir_dev);
+		remove_proc_entry("trx_info", dir_dev);
+
+		remove_proc_entry("mac_reg_dump1", dir_dev);
+		remove_proc_entry("mac_reg_dump2", dir_dev);
+		remove_proc_entry("mac_reg_dump3", dir_dev);
+		remove_proc_entry("bb_reg_dump1", dir_dev);
+		remove_proc_entry("bb_reg_dump2", dir_dev);
+		remove_proc_entry("bb_reg_dump3", dir_dev);
+		remove_proc_entry("rf_reg_dump1", dir_dev);
+		remove_proc_entry("rf_reg_dump2", dir_dev);
+		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
+		if ((RF_1T2R == rf_type) ||(RF_1T1R == rf_type))	{
+			remove_proc_entry("rf_reg_dump3", dir_dev);
+			remove_proc_entry("rf_reg_dump4", dir_dev);
+		}
+#ifdef CONFIG_92D_AP_MODE
+		remove_proc_entry("all_sta_info", dir_dev);
+#endif
+
+#ifdef CONFIG_FIND_BEST_CHANNEL
+		remove_proc_entry("best_channel", dir_dev);
+#endif
+		remove_proc_entry("rx_signal", dir_dev);
+
+		remove_proc_entry("cbw40_enable", dir_dev);
+
+		remove_proc_entry("ht_enable", dir_dev);
+
+		remove_proc_entry("ampdu_enable", dir_dev);
+
+		remove_proc_entry("rx_stbc", dir_dev);
+
+		remove_proc_entry("path_rssi", dir_dev);
+
+		remove_proc_entry("vid", dir_dev);
+
+		remove_proc_entry("pid", dir_dev);
+
+		remove_proc_entry("rssi_disp", dir_dev);
+
+		remove_proc_entry(dev->name, rtw_proc);
+		dir_dev = NULL;
+
+	}
+	else
+	{
+		return;
+	}
+
+	rtw_proc_cnt--;
+
+	if (rtw_proc_cnt == 0)
+	{
+		if (rtw_proc) {
+			remove_proc_entry("ver_info", rtw_proc);
+
+			remove_proc_entry("log_level", rtw_proc);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+			remove_proc_entry(rtw_proc_name, proc_net);
+#else
+			remove_proc_entry(rtw_proc_name, init_net.proc_net);
+#endif
+			rtw_proc = NULL;
+		}
+	}
+}
+#endif
+#endif
+static uint loadparam(struct rtw_adapter *padapter, struct net_device *pnetdev)
+{
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &padapter->registrypriv;
+
+	registry_par->chip_version = (u8)rtw_chip_version;
+	registry_par->rfintfs = (u8)rtw_rfintfs;
+	registry_par->lbkmode = (u8)rtw_lbkmode;
+	/* registry_par->hci = (u8)hci; */
+	registry_par->network_mode  = (u8)rtw_network_mode;
+
+	memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+
+	registry_par->channel = (u8)rtw_channel;
+	registry_par->wireless_mode = (u8)rtw_wireless_mode;
+	registry_par->vrtl_carrier_sense = (u8)rtw_vrtl_carrier_sense ;
+	registry_par->vcs_type = (u8)rtw_vcs_type;
+	registry_par->rts_thresh = (u16)rtw_rts_thresh;
+	registry_par->frag_thresh = (u16)rtw_frag_thresh;
+	registry_par->preamble = (u8)rtw_preamble;
+	registry_par->scan_mode = (u8)rtw_scan_mode;
+	registry_par->adhoc_tx_pwr = (u8)rtw_adhoc_tx_pwr;
+	registry_par->soft_ap =  (u8)rtw_soft_ap;
+	/* registry_par->smart_ps =  (u8)rtw_smart_ps; */
+	registry_par->power_mgnt = (u8)rtw_power_mgnt;
+	registry_par->ips_mode = (u8)rtw_ips_mode;
+	registry_par->radio_enable = (u8)rtw_radio_enable;
+	registry_par->long_retry_lmt = (u8)rtw_long_retry_lmt;
+	registry_par->short_retry_lmt = (u8)rtw_short_retry_lmt;
+	registry_par->busy_thresh = (u16)rtw_busy_thresh;
+	/* registry_par->qos_enable = (u8)rtw_qos_enable; */
+	registry_par->ack_policy = (u8)rtw_ack_policy;
+	registry_par->mp_mode = (u8)rtw_mp_mode;
+	registry_par->software_encrypt = (u8)rtw_software_encrypt;
+	registry_par->software_decrypt = (u8)rtw_software_decrypt;
+
+	registry_par->acm_method = (u8)rtw_acm_method;
+
+	 /* UAPSD */
+	registry_par->wmm_enable = (u8)rtw_wmm_enable;
+	registry_par->uapsd_enable = (u8)rtw_uapsd_enable;
+	registry_par->uapsd_max_sp = (u8)rtw_uapsd_max_sp;
+	registry_par->uapsd_acbk_en = (u8)rtw_uapsd_acbk_en;
+	registry_par->uapsd_acbe_en = (u8)rtw_uapsd_acbe_en;
+	registry_par->uapsd_acvi_en = (u8)rtw_uapsd_acvi_en;
+	registry_par->uapsd_acvo_en = (u8)rtw_uapsd_acvo_en;
+
+#ifdef CONFIG_80211N_HT
+	registry_par->ht_enable = (u8)rtw_ht_enable;
+	registry_par->cbw40_enable = (u8)rtw_cbw40_enable;
+	registry_par->ampdu_enable = (u8)rtw_ampdu_enable;
+	registry_par->rx_stbc = (u8)rtw_rx_stbc;
+	registry_par->ampdu_amsdu = (u8)rtw_ampdu_amsdu;
+#endif
+
+	registry_par->lowrate_two_xmit = (u8)rtw_lowrate_two_xmit;
+	registry_par->rf_config = (u8)rtw_rf_config;
+	registry_par->low_power = (u8)rtw_low_power;
+
+	registry_par->wifi_spec = (u8)rtw_wifi_spec;
+	registry_par->special_rf_path = (u8)rtw_special_rf_path;
+	registry_par->channel_plan = (u8)rtw_channel_plan;
+
+#ifdef CONFIG_BT_COEXIST
+	registry_par->bt_iso = (u8)rtw_bt_iso;
+	registry_par->bt_sco = (u8)rtw_bt_sco;
+	registry_par->bt_ampdu = (u8)rtw_bt_ampdu;
+#endif
+	registry_par->bAcceptAddbaReq = (u8)rtw_AcceptAddbaReq;
+
+	registry_par->antdiv_cfg = (u8)rtw_antdiv_cfg;
+
+#ifdef CONFIG_AUTOSUSPEND
+	registry_par->usbss_enable = (u8)rtw_enusbss;/* 0:disable, 1:enable */
+#endif
+	registry_par->hw_wps_pbc = (u8)rtw_hw_wps_pbc;
+
+#ifdef CONFIG_ADAPTOR_INFO_CACHING_FILE
+	snprintf(registry_par->adaptor_info_caching_file_path, PATH_LENGTH_MAX, "%s", rtw_adaptor_info_caching_file_path);
+	registry_par->adaptor_info_caching_file_path[PATH_LENGTH_MAX-1]= 0;
+#endif
+
+#ifdef CONFIG_LAYER2_ROAMING
+	registry_par->max_roaming_times = (u8)rtw_max_roaming_times;
+#endif
+
+	registry_par->mac_phy_mode = rtw_mac_phy_mode;
+	GlobalDebugLevel = debug;
+
+#ifdef CONFIG_80211D
+	registry_par->enable80211d = (u8)rtw_80211d;
+#endif
+
+	snprintf(registry_par->ifname, 16, "%s", ifname);
+	snprintf(registry_par->if2name, 16, "%s", if2name);
+
+	registry_par->notch_filter = (u8)rtw_notch_filter;
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+	registry_par->ext_iface_num = (u8)rtw_ext_iface_num;
+#endif /* CONFIG_MULTI_VIR_IFACES */
+
+	return status;
+}
+
+static int rtw_net_set_mac_address(struct net_device *pnetdev, void *p)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct sockaddr *addr = p;
+
+	if (padapter->bup == false)
+	{
+		/* addr->sa_data[4], addr->sa_data[5]); */
+		memcpy(padapter->eeprompriv.mac_addr, addr->sa_data, ETH_ALEN);
+	}
+
+	return 0;
+}
+
+static struct net_device_stats *rtw_net_get_stats(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &(padapter->xmitpriv);
+	struct recv_priv *precvpriv = &(padapter->recvpriv);
+
+	padapter->stats.tx_packets = pxmitpriv->tx_pkts;/* pxmitpriv->tx_pkts++; */
+	padapter->stats.rx_packets = precvpriv->rx_pkts;/* precvpriv->rx_pkts++; */
+	padapter->stats.tx_dropped = pxmitpriv->tx_drop;
+	padapter->stats.rx_dropped = precvpriv->rx_drop;
+	padapter->stats.tx_bytes = pxmitpriv->tx_bytes;
+	padapter->stats.rx_bytes = precvpriv->rx_bytes;
+
+	return &padapter->stats;
+}
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
+/*
+ * AC to queue mapping
+ *
+ * AC_VO -> queue 0
+ * AC_VI -> queue 1
+ * AC_BE -> queue 2
+ * AC_BK -> queue 3
+ */
+static const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };
+
+/* Given a data frame determine the 802.1p/1d tag to use. */
+static unsigned int rtw_classify8021d(struct sk_buff *skb)
+{
+	unsigned int dscp;
+
+	/* skb->priority values from 256->263 are magic values to
+	 * directly indicate a specific 802.1d priority.  This is used
+	 * to allow 802.1d priority to be passed directly in from VLAN
+	 * tags, etc.
+	 */
+	if (skb->priority >= 256 && skb->priority <= 263)
+		return skb->priority - 256;
+
+	switch (skb->protocol) {
+	case htons(ETH_P_IP):
+		dscp = ip_hdr(skb)->tos & 0xfc;
+		break;
+	default:
+		return 0;
+	}
+
+	return dscp >> 5;
+}
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 12, 0))
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,
+			    void *accel, select_queue_fallback_t fallback)
+#else
+static u16 rtw_select_queue(struct net_device *dev, struct sk_buff *skb,
+			    void *accel)
+#endif
+{
+	struct rtw_adapter	*padapter = rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+
+	skb->priority = rtw_classify8021d(skb);
+
+	if (pmlmepriv->acm_mask != 0)
+	{
+		skb->priority = qos_acm(pmlmepriv->acm_mask, skb->priority);
+	}
+
+	return rtw_1d_to_queue[skb->priority];
+}
+
+u16 rtw_recv_select_queue(struct sk_buff *skb)
+{
+	struct iphdr *piphdr;
+	unsigned int dscp;
+	u16	eth_type;
+	u32 priority;
+	u8 *pdata = skb->data;
+	__be16 be_tmp;
+
+	memcpy(&be_tmp, pdata+(ETH_ALEN<<1), 2);
+	eth_type = be16_to_cpu(be_tmp);
+
+	switch (eth_type) {
+	case ETH_P_IP:
+		piphdr = (struct iphdr *)(pdata+ETH_HLEN);
+		dscp = piphdr->tos & 0xfc;
+		priority = dscp >> 5;
+		break;
+	default:
+		priority = 0;
+	}
+
+	return rtw_1d_to_queue[priority];
+}
+
+#endif
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+static const struct net_device_ops rtw_netdev_ops = {
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_close,
+	.ndo_start_xmit = rtw_xmit_entry,
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+	.ndo_set_mac_address = rtw_net_set_mac_address,
+	.ndo_get_stats = rtw_net_get_stats,
+	.ndo_do_ioctl = rtw_ioctl,
+};
+#endif
+
+int rtw_init_netdev_name(struct net_device *pnetdev, const char *ifname)
+{
+	struct rtw_adapter *padapter = rtw_netdev_priv(pnetdev);
+
+#ifdef CONFIG_EASY_REPLACEMENT
+	struct net_device	*TargetNetdev = NULL;
+	struct rtw_adapter			*target_adapter = NULL;
+	struct net		*devnet = NULL;
+
+	if (padapter->bDongle == 1)
+	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+		TargetNetdev = dev_get_by_name("wlan0");
+#else
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+		devnet = pnetdev->nd_net;
+	#else
+		devnet = dev_net(pnetdev);
+	#endif
+		TargetNetdev = dev_get_by_name(devnet, "wlan0");
+#endif
+		if (TargetNetdev) {
+			DBG_8192D("Force onboard module driver disappear !!!\n");
+			target_adapter = rtw_netdev_priv(TargetNetdev);
+			target_adapter->DriverState = DRIVER_DISAPPEAR;
+
+			padapter->pid[0] = target_adapter->pid[0];
+			padapter->pid[1] = target_adapter->pid[1];
+			padapter->pid[2] = target_adapter->pid[2];
+
+			dev_put(TargetNetdev);
+			unregister_netdev(TargetNetdev);
+
+			if (target_adapter->chip_type == padapter->chip_type)
+				rtw_proc_remove_one(TargetNetdev);
+
+			padapter->DriverState = DRIVER_REPLACE_DONGLE;
+		}
+	}
+#endif
+
+	if (dev_alloc_name(pnetdev, ifname) < 0)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("dev_alloc_name, fail!\n"));
+	}
+
+	netif_carrier_off(pnetdev);
+	return 0;
+}
+
+static const struct device_type wlan_type = {
+	.name = "wlan",
+};
+
+struct net_device *rtw_init_netdev(struct rtw_adapter *old_padapter)
+{
+	struct rtw_adapter *padapter;
+	struct net_device *pnetdev;
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+init_net_dev\n"));
+
+	if (old_padapter != NULL)
+		pnetdev = rtw_alloc_etherdev_with_old_priv(sizeof(struct rtw_adapter), (void *)old_padapter);
+	else
+		pnetdev = rtw_alloc_etherdev(sizeof(struct rtw_adapter));
+
+	if (!pnetdev)
+		return NULL;
+
+	pnetdev->dev.type = &wlan_type;
+	padapter = rtw_netdev_priv(pnetdev);
+	padapter->pnetdev = pnetdev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	SET_MODULE_OWNER(pnetdev);
+#endif
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+	DBG_8192D("register rtw_netdev_ops to netdev_ops\n");
+	pnetdev->netdev_ops = &rtw_netdev_ops;
+#else
+	pnetdev->open = netdev_open;
+	pnetdev->stop = netdev_close;
+	pnetdev->hard_start_xmit = rtw_xmit_entry;
+	pnetdev->set_mac_address = rtw_net_set_mac_address;
+	pnetdev->get_stats = rtw_net_get_stats;
+	pnetdev->do_ioctl = rtw_ioctl;
+#endif
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	pnetdev->features |= NETIF_F_IP_CSUM;
+#endif
+	pnetdev->watchdog_timeo = HZ*3; /* 3 second timeout */
+#ifdef CONFIG_WIRELESS_EXT
+	pnetdev->wireless_handlers = (struct iw_handler_def *)&rtw_handlers_def;
+#endif
+
+	/* step 2. */
+	loadparam(padapter, pnetdev);
+
+	return pnetdev;
+}
+
+u32 rtw_start_drv_threads(struct rtw_adapter *padapter)
+{
+
+	u32 _status = _SUCCESS;
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_start_drv_threads\n"));
+#ifdef CONFIG_XMIT_THREAD_MODE
+	padapter->xmitThread = kthread_run(rtw_xmit_thread, padapter, "RTW_XMIT_THREAD");
+	if (IS_ERR(padapter->xmitThread))
+		_status = _FAIL;
+#endif
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->isprimary == true)
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		padapter->cmdThread = kthread_run(rtw_cmd_thread, padapter, "RTW_CMD_THREAD");
+		if (IS_ERR(padapter->cmdThread))
+			_status = _FAIL;
+		else
+			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema); /* wait for cmd_thread to run */
+	}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+	padapter->evtThread = kthread_run(event_thread, padapter, "RTW_EVENT_THREAD");
+	if (IS_ERR(padapter->evtThread))
+		_status = _FAIL;
+#endif
+
+	return _status;
+}
+
+void rtw_stop_drv_threads (struct rtw_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_stop_drv_threads\n"));
+
+#ifdef CONFIG_CONCURRENT_MODE
+	if (padapter->isprimary == true)
+#endif /* CONFIG_CONCURRENT_MODE */
+	{
+		/* Below is to termindate rtw_cmd_thread & event_thread... */
+		_rtw_up_sema(&padapter->cmdpriv.cmd_queue_sema);
+		if (padapter->cmdThread) {
+			_rtw_down_sema(&padapter->cmdpriv.terminate_cmdthread_sema);
+		}
+	}
+
+#ifdef CONFIG_EVENT_THREAD_MODE
+        _rtw_up_sema(&padapter->evtpriv.evt_notify);
+	if (padapter->evtThread) {
+		_rtw_down_sema(&padapter->evtpriv.terminate_evtthread_sema);
+	}
+#endif
+
+#ifdef CONFIG_XMIT_THREAD_MODE
+	/*  Below is to termindate tx_thread... */
+	_rtw_up_sema(&padapter->xmitpriv.xmit_sema);
+	_rtw_down_sema(&padapter->xmitpriv.terminate_xmitthread_sema);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("\n drv_halt: rtw_xmit_thread can be terminated !\n"));
+#endif
+}
+
+static u8 rtw_init_default_value(struct rtw_adapter *padapter)
+{
+	u8 ret  = _SUCCESS;
+	struct registry_priv* pregistrypriv = &padapter->registrypriv;
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+
+	/* xmit_priv */
+	pxmitpriv->vcs_setting = pregistrypriv->vrtl_carrier_sense;
+	pxmitpriv->vcs = pregistrypriv->vcs_type;
+	pxmitpriv->vcs_type = pregistrypriv->vcs_type;
+	pxmitpriv->frag_len = pregistrypriv->frag_thresh;
+
+	/* recv_priv */
+
+	/* mlme_priv */
+	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
+	pmlmepriv->scan_mode = SCAN_ACTIVE;
+
+	/* qos_priv */
+
+	/* ht_priv */
+#ifdef CONFIG_80211N_HT
+	pmlmepriv->htpriv.ampdu_enable = false;/* set to disabled */
+#endif
+
+	/* security_priv */
+	psecuritypriv->binstallGrpkey = _FAIL;
+	psecuritypriv->sw_encrypt = pregistrypriv->software_encrypt;
+	psecuritypriv->sw_decrypt = pregistrypriv->software_decrypt;
+
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+	psecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;
+
+	psecuritypriv->dot11PrivacyKeyIndex = 0;
+
+	psecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;
+	psecuritypriv->dot118021XGrpKeyid = 1;
+
+	psecuritypriv->ndisauthtype = NDIS802_11AUTHMODEOPEN;
+	psecuritypriv->ndisencryptstatus = NDIS802_11WEPDISABLED;
+
+	/* pwrctrl_priv */
+
+	/* registry_priv */
+	rtw_init_registrypriv_dev_network(padapter);
+	rtw_update_registrypriv_dev_network(padapter);
+
+	/* hal_priv */
+	rtw_hal_def_value_init(padapter);
+
+	/* misc. */
+	padapter->bReadPortCancel = false;
+	padapter->bWritePortCancel = false;
+	padapter->bRxRSSIDisplay = 0;
+	padapter->bForceWriteInitGain = 1;
+	padapter->bNotifyChannelChange = 0;
+	return ret;
+}
+
+u8 rtw_reset_drv_sw(struct rtw_adapter *padapter)
+{
+	u8	ret8 = _SUCCESS;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
+
+	/* hal_priv */
+	rtw_hal_def_value_init(padapter);
+	padapter->bReadPortCancel = false;
+	padapter->bWritePortCancel = false;
+	padapter->bRxRSSIDisplay = 0;
+	pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
+
+	pwrctrlpriv->bips_processing = false;
+	pwrctrlpriv->rf_pwrstate = rf_on;
+
+	padapter->xmitpriv.tx_pkts = 0;
+	padapter->recvpriv.rx_pkts = 0;
+
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY |_FW_UNDER_LINKING);
+
+#ifdef CONFIG_AUTOSUSPEND
+	#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 22) && LINUX_VERSION_CODE<= KERNEL_VERSION(2, 6, 34))
+		adapter_to_dvobj(padapter)->pusbdev->autosuspend_disabled = 1;/* autosuspend disabled by the user */
+	#endif
+#endif
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	rtw_hal_sreset_reset_value(padapter);
+#endif
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+
+	/* mlmeextpriv */
+	padapter->mlmeextpriv.sitesurvey_res.state = SCAN_DISABLE;
+
+	rtw_set_signal_stat_timer(&padapter->recvpriv);
+	return ret8;
+}
+
+u8 rtw_init_drv_sw(struct rtw_adapter *padapter)
+{
+
+	u8	ret8 = _SUCCESS;
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_init_drv_sw\n"));
+
+	if ((rtw_init_cmd_priv(&padapter->cmdpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init cmd_priv\n"));
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	padapter->cmdpriv.padapter = padapter;
+
+	if ((rtw_init_evt_priv(&padapter->evtpriv)) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init evt_priv\n"));
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (rtw_init_mlme_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_priv\n"));
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (init_mlme_ext_priv(padapter) == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("\n Can't init mlme_ext_priv\n"));
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (_rtw_init_xmit_priv(&padapter->xmitpriv, padapter) == _FAIL)
+	{
+		DBG_8192D("Can't _rtw_init_xmit_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (_rtw_init_recv_priv(&padapter->recvpriv, padapter) == _FAIL)
+	{
+		DBG_8192D("Can't _rtw_init_recv_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	/* We don't need to memset padapter->XXX to zero, because adapter
+	 * is allocated by vzalloc().
+	 */
+	if (_rtw_init_sta_priv(&padapter->stapriv) == _FAIL)
+	{
+		DBG_8192D("Can't _rtw_init_sta_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	padapter->stapriv.padapter = padapter;
+	padapter->setband = GHZ24_50;
+	rtw_init_bcmc_stainfo(padapter);
+
+	rtw_init_pwrctrl_priv(padapter);
+
+	ret8 = rtw_init_default_value(padapter);
+
+	rtw_hal_dm_init(padapter);
+	rtw_hal_sw_led_init(padapter);
+
+#ifdef DBG_CONFIG_ERROR_DETECT
+	rtw_hal_sreset_init(padapter);
+#endif
+exit:
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_init_drv_sw\n"));
+	return ret8;
+}
+
+void rtw_cancel_all_timer(struct rtw_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+rtw_cancel_all_timer\n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.assoc_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel association timer complete!\n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.scan_to_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel scan_to_timer!\n"));
+
+	_cancel_timer_ex(&padapter->mlmepriv.dynamic_chk_timer);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel dynamic_chk_timer!\n"));
+
+	/*  cancel sw led timer */
+	rtw_hal_sw_led_deinit(padapter);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel DeInitSwLeds!\n"));
+
+	_cancel_timer_ex(&padapter->pwrctrlpriv.pwr_state_check_timer);
+
+#ifdef CONFIG_SET_SCAN_DENY_TIMER
+	_cancel_timer_ex(&padapter->mlmepriv.set_scan_deny_timer);
+	rtw_clear_scan_deny(padapter);
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("rtw_cancel_all_timer:cancel set_scan_deny_timer!\n"));
+#endif
+
+	_cancel_timer_ex(&padapter->recvpriv.signal_stat_timer);
+
+	/*  cancel dm  timer */
+	rtw_hal_dm_deinit(padapter);
+}
+
+u8 rtw_free_drv_sw(struct rtw_adapter *padapter)
+{
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("==>rtw_free_drv_sw"));
+
+	free_mlme_ext_priv(&padapter->mlmeextpriv);
+	rtw_free_cmd_priv(&padapter->cmdpriv);
+	rtw_free_evt_priv(&padapter->evtpriv);
+	rtw_free_mlme_priv(&padapter->mlmepriv);
+	_rtw_free_xmit_priv(&padapter->xmitpriv);
+	_rtw_free_sta_priv(&padapter->stapriv); /* will free bcmc_stainfo here */
+	_rtw_free_recv_priv(&padapter->recvpriv);
+	rtw_free_pwrctrl_priv(padapter);
+
+#ifdef CONFIG_DRVEXT_MODULE
+	free_drvext(&padapter->drvextpriv);
+#endif
+
+	rtw_hal_free_data(padapter);
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("<== rtw_free_drv_sw\n"));
+
+	/* free the old_pnetdev */
+	if (padapter->rereg_nd_name_priv.old_pnetdev) {
+		free_netdev(padapter->rereg_nd_name_priv.old_pnetdev);
+		padapter->rereg_nd_name_priv.old_pnetdev = NULL;
+	}
+
+	/*  clear pbuddy_adapter to avoid access wrong pointer. */
+	if (padapter->pbuddy_adapter != NULL)
+	{
+		padapter->pbuddy_adapter->pbuddy_adapter = NULL;
+	}
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-rtw_free_drv_sw\n"));
+
+	return _SUCCESS;
+}
+
+#ifdef CONFIG_CONCURRENT_MODE
+
+#include <usb_hal.h>
+
+#ifdef CONFIG_MULTI_VIR_IFACES
+int _netdev_vir_if_open(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct rtw_adapter *primary_padapter = GET_PRIMARY_ADAPTER(padapter);
+
+	DBG_8192D(FUNC_NDEV_FMT" enter\n", FUNC_NDEV_ARG(pnetdev));
+
+	if (!primary_padapter)
+		goto _netdev_virtual_iface_open_error;
+
+	if (primary_padapter->bup == false || primary_padapter->hw_init_completed == false)
+		netdev_open(primary_padapter->pnetdev);
+
+	if (padapter->bup == false && primary_padapter->bup == true &&
+		primary_padapter->hw_init_completed == true)
+	{
+		int i;
+
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
+
+		memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
+
+		padapter->bFWReady = primary_padapter->bFWReady;
+
+		if (rtw_start_drv_threads(padapter) == _FAIL)
+		{
+			goto _netdev_virtual_iface_open_error;
+		}
+
+		padapter->dir_dev = NULL;
+		rtw_proc_init_one(pnetdev);
+
+		rtw_cfg80211_init_wiphy(padapter);
+
+		padapter->bup = true;
+		padapter->hw_init_completed = true;
+
+		rtw_start_mbssid_cam(padapter);/* start mbssid_cam after bup = true & hw_init_completed = true */
+
+	}
+
+	padapter->net_closed = false;
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+	if (!rtw_netif_queue_stopped(pnetdev))
+		rtw_netif_start_queue(pnetdev);
+	else
+		rtw_netif_wake_queue(pnetdev);
+
+	DBG_8192D(FUNC_NDEV_FMT" exit\n", FUNC_NDEV_ARG(pnetdev));
+	return 0;
+
+_netdev_virtual_iface_open_error:
+
+	padapter->bup = false;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	return (-1);
+}
+
+int netdev_vir_if_open(struct net_device *pnetdev)
+{
+	int ret;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex));
+	ret = _netdev_vir_if_open(pnetdev);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex));
+	return ret;
+}
+
+static int netdev_vir_if_close(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+
+	padapter->net_closed = true;
+
+	if (pnetdev)
+	{
+		if (!rtw_netif_queue_stopped(pnetdev))
+			rtw_netif_stop_queue(pnetdev);
+	}
+
+	rtw_scan_abort(padapter);
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+static const struct net_device_ops rtw_netdev_vir_if_ops = {
+	 .ndo_open = netdev_vir_if_open,
+        .ndo_stop = netdev_vir_if_close,
+        .ndo_start_xmit = rtw_xmit_entry,
+        .ndo_set_mac_address = rtw_net_set_mac_address,
+        .ndo_get_stats = rtw_net_get_stats,
+        .ndo_do_ioctl = rtw_ioctl,
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+};
+#endif
+
+_adapter *rtw_drv_add_vir_if (struct rtw_adapter *primary_padapter, char *name,
+	void (*set_intf_ops)(struct _io_ops *pops))
+{
+
+	int res = _FAIL;
+	struct net_device *pnetdev;
+	struct rtw_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	u8 mac[ETH_ALEN];
+
+/*
+	if ((primary_padapter->bup == false) ||
+		(rtw_buddy_adapter_up(primary_padapter) == false))
+	{
+		goto error_rtw_drv_add_iface;
+	}
+
+*/
+	/****** init netdev ******/
+	pnetdev = rtw_init_netdev(NULL);
+	if (!pnetdev)
+		goto error_rtw_drv_add_iface;
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+	DBG_8192D("register rtw_netdev_virtual_iface_ops to netdev_ops\n");
+	pnetdev->netdev_ops = &rtw_netdev_vir_if_ops;
+#else
+	pnetdev->open = netdev_vir_if_open;
+	pnetdev->stop = netdev_vir_if_close;
+#endif
+
+#ifdef CONFIG_NO_WIRELESS_HANDLERS
+	pnetdev->wireless_handlers = NULL;
+#endif
+
+	/****** init adapter ******/
+	padapter = rtw_netdev_priv(pnetdev);
+	memcpy(padapter, primary_padapter, sizeof(struct rtw_adapter));
+
+	/*  */
+	padapter->bup = false;
+	padapter->net_closed = true;
+	padapter->hw_init_completed = false;
+
+	/* set adapter_type/iface type */
+	padapter->isprimary = false;
+	padapter->adapter_type = MAX_ADAPTER;
+	padapter->pbuddy_adapter = primary_padapter;
+	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
+	/* extended virtual interfaces always are set to port0 */
+	padapter->iface_type = IFACE_PORT0;
+	/*  */
+	padapter->pnetdev = pnetdev;
+
+	/****** setup dvobj ******/
+	pdvobjpriv = adapter_to_dvobj(padapter);
+	padapter->iface_id = pdvobjpriv->iface_nums;
+	pdvobjpriv->padapters[pdvobjpriv->iface_nums++] = padapter;
+
+	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(pdvobjpriv));
+	rtw_wdev_alloc(padapter, dvobj_to_dev(pdvobjpriv));
+
+	/* set interface_type/chip_type/HardwareType */
+	padapter->interface_type = primary_padapter->interface_type;
+	padapter->chip_type = primary_padapter->chip_type;
+	padapter->HardwareType = primary_padapter->HardwareType;
+
+	/* set hal data & hal ops */
+	rtl8192du_set_hal_ops(padapter);
+
+	padapter->HalFunc.inirp_init = NULL;
+	padapter->HalFunc.inirp_deinit = NULL;
+	padapter->intf_start = NULL;
+	padapter->intf_stop = NULL;
+
+	/* step init_io_priv */
+	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("\n Can't init io_reqs\n"));
+	}
+
+	/* step read_chip_version */
+	rtw_hal_read_chip_version(padapter);
+
+	/* step usb endpoint mapping */
+	rtw_hal_chip_configure(padapter);
+
+	/* init drv data */
+	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
+		goto error_rtw_drv_add_iface;
+
+	/*  alloc dev name after got efuse data. */
+	if (name == NULL)
+		name = padapter->registrypriv.if2name;
+
+	rtw_init_netdev_name(pnetdev, name);
+	/* get mac address from primary_padapter */
+	memcpy(mac, primary_padapter->eeprompriv.mac_addr, ETH_ALEN);
+
+	if (((mac[0]== 0xff) &&(mac[1]== 0xff) && (mac[2]== 0xff) &&
+	     (mac[3]== 0xff) && (mac[4]== 0xff) &&(mac[5]== 0xff)) ||
+	    ((mac[0]== 0x0) && (mac[1]== 0x0) && (mac[2]== 0x0) &&
+	     (mac[3]== 0x0) && (mac[4]== 0x0) &&(mac[5]== 0x0)))
+	{
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x11;
+		mac[5] = 0x22;
+	} else {
+		/* If the BIT1 is 0, the address is universally administered. */
+		/* If it is 1, the address is locally administered */
+		mac[0] |= BIT(1); /*  locally administered */
+		mac[0] |= (padapter->iface_id-1)<<4;
+	}
+
+	memcpy(padapter->eeprompriv.mac_addr, mac, ETH_ALEN);
+
+	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+
+	padapter->dir_dev = NULL;
+
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0)
+	/* if (register_netdevice(pnetdev) != 0) */
+	{
+		goto error_rtw_drv_add_iface;
+	}
+
+	DBG_8192D("MAC Address(%s) = %pM\n", pnetdev->name, mac);
+
+	res = _SUCCESS;
+
+	return padapter;
+
+error_rtw_drv_add_iface:
+
+	if (padapter)
+		rtw_free_drv_sw(padapter);
+
+	if (pnetdev)
+		rtw_free_netdev(pnetdev);
+
+	return NULL;
+}
+
+void rtw_drv_stop_vir_if (struct rtw_adapter *padapter)
+{
+	struct net_device *pnetdev = NULL;
+
+	if (padapter == NULL)
+		return;
+
+	pnetdev = padapter->pnetdev;
+
+	if (pnetdev) {
+		unregister_netdev(pnetdev); /* will call netdev_close() */
+		rtw_proc_remove_one(pnetdev);
+	}
+
+	rtw_cancel_all_timer(padapter);
+
+	if (padapter->bup == true) {
+		padapter->bDriverStopped = true;
+
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+
+		if (padapter->intf_stop)
+			padapter->intf_stop(padapter);
+
+		rtw_stop_drv_threads(padapter);
+
+		padapter->bup = false;
+	}
+
+	rtw_wdev_unregister(padapter->rtw_wdev);
+}
+
+void rtw_drv_free_vir_if (struct rtw_adapter *padapter)
+{
+	struct net_device *pnetdev = NULL;
+
+	if (padapter == NULL)
+		return;
+
+	padapter->pbuddy_adapter = NULL;
+	pr_debug("pbuddy_adapter: %p\n", NULL);
+
+	pnetdev = padapter->pnetdev;
+
+	rtw_wdev_free(padapter->rtw_wdev);
+
+	rtw_free_drv_sw(padapter);
+
+	rtw_free_netdev(pnetdev);
+}
+
+void rtw_drv_stop_vir_ifaces(struct dvobj_priv *dvobj)
+{
+	int i;
+	/* struct dvobj_priv *dvobj = primary_padapter->dvobj; */
+
+	for (i = 2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_stop_vir_if (dvobj->padapters[i]);
+	}
+}
+
+void rtw_drv_free_vir_ifaces(struct dvobj_priv *dvobj)
+{
+	int i;
+	/* struct dvobj_priv *dvobj = primary_padapter->dvobj; */
+
+	for (i = 2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_free_vir_if (dvobj->padapters[i]);
+	}
+}
+
+void rtw_drv_del_vir_if (struct rtw_adapter *padapter)
+{
+	rtw_drv_stop_vir_if (padapter);
+	rtw_drv_free_vir_if (padapter);
+}
+
+void rtw_drv_del_vir_ifaces(struct rtw_adapter *primary_padapter)
+{
+	int i;
+	struct dvobj_priv *dvobj = primary_padapter->dvobj;
+
+	for (i = 2;i<dvobj->iface_nums;i++)
+	{
+		rtw_drv_del_vir_if (dvobj->padapters[i]);
+	}
+}
+#endif /* CONFIG_MULTI_VIR_IFACES */
+
+static int _netdev_if2_open(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct rtw_adapter *primary_padapter = padapter->pbuddy_adapter;
+
+	DBG_8192D("+871x_drv - if2_open, bup =%d\n", padapter->bup);
+
+	if (primary_padapter->bup == false || primary_padapter->hw_init_completed == false)
+	{
+		netdev_open(primary_padapter->pnetdev);
+	}
+
+	if (padapter->bup == false && primary_padapter->bup == true &&
+		primary_padapter->hw_init_completed == true)
+	{
+		int i;
+
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
+
+		memcpy(padapter->HalData, primary_padapter->HalData, padapter->hal_data_sz);
+
+		padapter->bFWReady = primary_padapter->bFWReady;
+
+		rtw_hal_set_hwreg(padapter, HW_VAR_DM_INIT_PWDB, NULL);
+
+		if (rtw_start_drv_threads(padapter) == _FAIL)
+			goto netdev_if2_open_error;
+
+		if (padapter->intf_start)
+			padapter->intf_start(padapter);
+
+		padapter->hw_init_completed = true;
+
+		padapter->dir_dev = NULL;
+		rtw_proc_init_one(pnetdev);
+
+		rtw_cfg80211_init_wiphy(padapter);
+
+		padapter->bup = true;
+
+	}
+
+	padapter->net_closed = false;
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+	if (!rtw_netif_queue_stopped(pnetdev))
+		rtw_netif_start_queue(pnetdev);
+	else
+		rtw_netif_wake_queue(pnetdev);
+
+	DBG_8192D("-871x_drv - if2_open, bup =%d\n", padapter->bup);
+	return 0;
+
+netdev_if2_open_error:
+
+	padapter->bup = false;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	return (-1);
+}
+
+static int netdev_if2_open(struct net_device *pnetdev)
+{
+	int ret;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+
+	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex));
+	ret = _netdev_if2_open(pnetdev);
+	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->hw_init_mutex));
+	return ret;
+}
+
+static int netdev_if2_close(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+
+	padapter->net_closed = true;
+
+	if (pnetdev)
+	{
+		if (!rtw_netif_queue_stopped(pnetdev))
+			rtw_netif_stop_queue(pnetdev);
+	}
+
+	rtw_scan_abort(padapter);
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+static const struct net_device_ops rtw_netdev_if2_ops = {
+	.ndo_open = netdev_if2_open,
+        .ndo_stop = netdev_if2_close,
+        .ndo_start_xmit = rtw_xmit_entry,
+        .ndo_set_mac_address = rtw_net_set_mac_address,
+        .ndo_get_stats = rtw_net_get_stats,
+        .ndo_do_ioctl = rtw_ioctl,
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 35))
+	.ndo_select_queue	= rtw_select_queue,
+#endif
+};
+#endif
+
+struct rtw_adapter *rtw_drv_if2_init(struct rtw_adapter *primary_padapter, char *name,
+	void (*set_intf_ops)(struct _io_ops *pops))
+{
+	struct net_device *pnetdev;
+	struct rtw_adapter *padapter = NULL;
+	struct dvobj_priv *pdvobjpriv;
+	u8 mac[ETH_ALEN];
+
+	/****** init netdev ******/
+	pnetdev = rtw_init_netdev(NULL);
+	if (!pnetdev)
+		goto error_rtw_drv_if2_init;
+
+#if (LINUX_VERSION_CODE>= KERNEL_VERSION(2, 6, 29))
+	DBG_8192D("register rtw_netdev_if2_ops to netdev_ops\n");
+	pnetdev->netdev_ops = &rtw_netdev_if2_ops;
+#else
+	pnetdev->open = netdev_if2_open;
+	pnetdev->stop = netdev_if2_close;
+#endif
+
+#ifdef CONFIG_NO_WIRELESS_HANDLERS
+	pnetdev->wireless_handlers = NULL;
+#endif
+
+	/****** init adapter ******/
+	padapter = rtw_netdev_priv(pnetdev);
+	memcpy(padapter, primary_padapter, sizeof(struct rtw_adapter));
+
+	/*  */
+	padapter->bup = false;
+	padapter->net_closed = true;
+	padapter->hw_init_completed = false;
+
+	/* set adapter_type/iface type */
+	padapter->isprimary = false;
+	padapter->adapter_type = SECONDARY_ADAPTER;
+	padapter->pbuddy_adapter = primary_padapter;
+	pr_debug("pbuddy_adapter: %p\n", primary_padapter);
+        padapter->iface_id = IFACE_ID1;
+#ifndef CONFIG_HWPORT_SWAP			/* Port0 -> Pri , Port1 -> Sec */
+	padapter->iface_type = IFACE_PORT1;
+#else
+	padapter->iface_type = IFACE_PORT0;
+#endif  /* CONFIG_HWPORT_SWAP */
+	/*  */
+	padapter->pnetdev = pnetdev;
+
+	/****** setup dvobj ******/
+	pdvobjpriv = adapter_to_dvobj(padapter);
+	pdvobjpriv->if2 = padapter;
+	pdvobjpriv->padapters[pdvobjpriv->iface_nums++] = padapter;
+
+	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(pdvobjpriv));
+	rtw_wdev_alloc(padapter, dvobj_to_dev(pdvobjpriv));
+
+	/* set interface_type/chip_type/HardwareType */
+	padapter->interface_type = primary_padapter->interface_type;
+	padapter->chip_type = primary_padapter->chip_type;
+	padapter->HardwareType = primary_padapter->HardwareType;
+
+	/* set hal data & hal ops */
+	rtl8192du_set_hal_ops(padapter);
+
+	padapter->HalFunc.inirp_init = NULL;
+	padapter->HalFunc.inirp_deinit = NULL;
+
+	/*  */
+	padapter->intf_start = primary_padapter->intf_start;
+	padapter->intf_stop = primary_padapter->intf_stop;
+
+	/* step init_io_priv */
+	if ((rtw_init_io_priv(padapter, set_intf_ops)) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("\n Can't init io_reqs\n"));
+	}
+
+	/* step read_chip_version */
+	rtw_hal_read_chip_version(padapter);
+
+	/* step usb endpoint mapping */
+	rtw_hal_chip_configure(padapter);
+
+	/* init drv data */
+	if (rtw_init_drv_sw(padapter)!= _SUCCESS)
+		goto error_rtw_drv_if2_init;
+
+	/*  alloc dev name after got efuse data. */
+	if (name == NULL)
+		name = padapter->registrypriv.if2name;
+
+	rtw_init_netdev_name(pnetdev, name);
+
+	/* get mac address from primary_padapter */
+	memcpy(mac, primary_padapter->eeprompriv.mac_addr, ETH_ALEN);
+
+	if (((mac[0]== 0xff) &&(mac[1]== 0xff) && (mac[2]== 0xff) &&
+	     (mac[3]== 0xff) && (mac[4]== 0xff) &&(mac[5]== 0xff)) ||
+	    ((mac[0]== 0x0) && (mac[1]== 0x0) && (mac[2]== 0x0) &&
+	     (mac[3]== 0x0) && (mac[4]== 0x0) &&(mac[5]== 0x0)))
+	{
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x11;
+		mac[5] = 0x22;
+	}
+	else
+	{
+		/* If the BIT1 is 0, the address is universally administered. */
+		/* If it is 1, the address is locally administered */
+		mac[0] |= BIT(1); /*  locally administered */
+
+	}
+
+	memcpy(padapter->eeprompriv.mac_addr, mac, ETH_ALEN);
+	rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
+
+	memcpy(pnetdev->dev_addr, mac, ETH_ALEN);
+
+	DBG_8192D("MAC Address (if2) = %pM\n", mac);
+
+	primary_padapter->pbuddy_adapter = padapter;
+	pr_debug("pbuddy_adapter: %p\n", padapter);
+
+	padapter->dir_dev = NULL;
+	/* Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0)
+	{
+		goto error_rtw_drv_if2_init;
+	}
+
+	return padapter;
+
+error_rtw_drv_if2_init:
+
+	if (padapter)
+		rtw_free_drv_sw(padapter);
+
+	if (pnetdev)
+		rtw_free_netdev(pnetdev);
+
+	return NULL;
+}
+
+void rtw_drv_if2_free(struct rtw_adapter *if2)
+{
+	struct rtw_adapter *padapter = if2;
+	struct net_device *pnetdev = NULL;
+
+	if (padapter == NULL)
+		return;
+
+	pnetdev = padapter->pnetdev;
+
+	rtw_wdev_free(padapter->rtw_wdev);
+
+	rtw_free_drv_sw(padapter);
+
+	rtw_free_netdev(pnetdev);
+}
+
+void rtw_drv_if2_stop(struct rtw_adapter *if2)
+{
+	struct rtw_adapter *padapter = if2;
+	struct net_device *pnetdev = NULL;
+
+	if (padapter == NULL)
+		return;
+
+	pnetdev = padapter->pnetdev;
+
+	if (pnetdev) {
+		unregister_netdev(pnetdev); /* will call netdev_close() */
+		rtw_proc_remove_one(pnetdev);
+	}
+
+	rtw_cancel_all_timer(padapter);
+
+	if (padapter->bup == true) {
+		padapter->bDriverStopped = true;
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+
+		if (padapter->intf_stop)
+			padapter->intf_stop(padapter);
+
+		rtw_stop_drv_threads(padapter);
+
+		padapter->bup = false;
+	}
+
+	rtw_wdev_unregister(padapter->rtw_wdev);
+}
+#endif /* end of CONFIG_CONCURRENT_MODE */
+
+int netdev_open(struct net_device *pnetdev)
+{
+	uint status;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct pwrctrl_priv *pwrctrlpriv;
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - dev_open\n"));
+	DBG_8192D("+871x_drv - drv_open, bup =%d\n", padapter->bup);
+
+	mutex_lock(&adapter_to_dvobj(padapter)->hw_init_mutex);
+
+	pwrctrlpriv = &padapter->pwrctrlpriv;
+	if (pwrctrlpriv->ps_flag) {
+		padapter->net_closed = false;
+		goto netdev_open_normal_process;
+	}
+
+	if (!padapter->bup) {
+		padapter->bDriverStopped = false;
+		padapter->bSurpriseRemoved = false;
+		padapter->bCardDisableWOHSM = false;
+
+		status = rtw_hal_init(padapter);
+		if (status == _FAIL) {
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("rtl871x_hal_init(): Can't init h/w!\n"));
+			goto netdev_open_error;
+		}
+
+		DBG_8192D("MAC Address = %pM\n", pnetdev->dev_addr);
+
+		status = rtw_start_drv_threads(padapter);
+		if (status == _FAIL) {
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("Initialize driver software resource Failed!\n"));
+			goto netdev_open_error;
+		}
+
+		if (init_hw_mlme_ext(padapter) == _FAIL) {
+			RT_TRACE(_module_os_intfs_c_, _drv_err_, ("can't init mlme_ext_priv\n"));
+			goto netdev_open_error;
+		}
+
+#ifdef CONFIG_DRVEXT_MODULE
+		init_drvext(padapter);
+#endif
+
+		if (padapter->intf_start)
+			padapter->intf_start(padapter);
+		rtw_proc_init_one(pnetdev);
+
+		rtw_cfg80211_init_wiphy(padapter);
+
+		rtw_led_control(padapter, LED_CTL_NO_LINK);
+
+		padapter->bup = true;
+	}
+	padapter->net_closed = false;
+
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 2000);
+
+	padapter->pwrctrlpriv.bips_processing = false;
+	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
+
+	if (!rtw_netif_queue_stopped(pnetdev))
+		rtw_netif_start_queue(pnetdev);
+	else
+		rtw_netif_wake_queue(pnetdev);
+
+netdev_open_normal_process:
+
+	#ifdef CONFIG_CONCURRENT_MODE
+	{
+		struct rtw_adapter *sec_adapter = padapter->pbuddy_adapter;
+		if (sec_adapter && (sec_adapter->bup == false || sec_adapter->hw_init_completed == false))
+			_netdev_if2_open(sec_adapter->pnetdev);
+	}
+	#endif
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-871x_drv - dev_open\n"));
+	DBG_8192D("-871x_drv - drv_open, bup =%d\n", padapter->bup);
+	mutex_unlock(&adapter_to_dvobj(padapter)->hw_init_mutex);
+
+	return 0;
+
+netdev_open_error:
+
+	padapter->bup = false;
+
+	netif_carrier_off(pnetdev);
+	rtw_netif_stop_queue(pnetdev);
+
+	RT_TRACE(_module_os_intfs_c_, _drv_err_, ("-871x_drv - dev_open, fail!\n"));
+	DBG_8192D("-871x_drv - drv_open fail, bup =%d\n", padapter->bup);
+
+	mutex_unlock(&adapter_to_dvobj(padapter)->hw_init_mutex);
+	return -1;
+}
+
+#ifdef CONFIG_IPS
+static int  ips_netdrv_open(struct rtw_adapter *padapter)
+{
+	int status = _SUCCESS;
+	padapter->net_closed = false;
+	DBG_8192D("===> %s.........\n", __func__);
+
+	padapter->bDriverStopped = false;
+	padapter->bSurpriseRemoved = false;
+	padapter->bCardDisableWOHSM = false;
+
+	status = rtw_hal_init(padapter);
+	if (status == _FAIL)
+	{
+		RT_TRACE(_module_os_intfs_c_, _drv_err_, ("ips_netdrv_open(): Can't init h/w!\n"));
+		goto netdev_open_error;
+	}
+
+	if (padapter->intf_start)
+	{
+		padapter->intf_start(padapter);
+	}
+
+	rtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);
+	_set_timer(&padapter->mlmepriv.dynamic_chk_timer, 5000);
+
+	 return _SUCCESS;
+
+netdev_open_error:
+	DBG_8192D("-ips_netdrv_open - drv_open failure, bup =%d\n", padapter->bup);
+
+	return _FAIL;
+}
+
+int rtw_ips_pwr_up(struct rtw_adapter *padapter)
+{
+	int result;
+	u32 start_time = rtw_get_current_time();
+	DBG_8192D("===>  rtw_ips_pwr_up..............\n");
+	rtw_reset_drv_sw(padapter);
+
+	result = ips_netdrv_open(padapter);
+
+	rtw_led_control(padapter, LED_CTL_NO_LINK);
+
+	DBG_8192D("<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
+	return result;
+}
+
+void rtw_ips_pwr_down(struct rtw_adapter *padapter)
+{
+	u32 start_time = rtw_get_current_time();
+	DBG_8192D("===> rtw_ips_pwr_down...................\n");
+
+	padapter->bCardDisableWOHSM = true;
+	padapter->net_closed = true;
+
+	rtw_led_control(padapter, LED_CTL_POWER_OFF);
+
+	rtw_ips_dev_unload(padapter);
+	padapter->bCardDisableWOHSM = false;
+	DBG_8192D("<=== rtw_ips_pwr_down..................... in %dms\n", rtw_get_passing_time_ms(start_time));
+}
+#endif
+void rtw_ips_dev_unload(struct rtw_adapter *padapter)
+{
+	struct net_device *pnetdev = (struct net_device*)padapter->pnetdev;
+	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
+	DBG_8192D("====> %s...\n", __func__);
+
+	rtw_hal_set_hwreg(padapter, HW_VAR_FIFO_CLEARN_UP, NULL);
+
+	if (padapter->intf_stop)
+		padapter->intf_stop(padapter);
+
+	/* s5. */
+	if (padapter->bSurpriseRemoved == false)
+		rtw_hal_deinit(padapter);
+}
+
+int pm_netdev_open(struct net_device *pnetdev, u8 bnormal)
+{
+	int status;
+	if (bnormal)
+		status = netdev_open(pnetdev);
+#ifdef CONFIG_IPS
+	else
+		status =  (_SUCCESS == ips_netdrv_open((struct rtw_adapter *)rtw_netdev_priv(pnetdev)))?(0):(-1);
+#endif
+
+	return status;
+}
+
+static int netdev_close(struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("+871x_drv - drv_close\n"));
+
+	if (padapter->pwrctrlpriv.bInternalAutoSuspend) {
+		if (padapter->pwrctrlpriv.rf_pwrstate == rf_off)
+			padapter->pwrctrlpriv.ps_flag = true;
+	}
+	padapter->net_closed = true;
+
+	if (padapter->pwrctrlpriv.rf_pwrstate == rf_on) {
+		DBG_8192D("(2)871x_drv - drv_close, bup =%d, hw_init_completed =%d\n", padapter->bup, padapter->hw_init_completed);
+
+		/* s1. */
+		if (pnetdev) {
+			if (!rtw_netif_queue_stopped(pnetdev))
+				rtw_netif_stop_queue(pnetdev);
+		}
+
+#ifndef CONFIG_ANDROID
+		/* s2. */
+		LeaveAllPowerSaveMode(padapter);
+		rtw_disassoc_cmd(padapter, 500, false);
+		/* s2-2.  indicate disconnect to os */
+		rtw_indicate_disconnect(padapter);
+		/* s2-3. */
+		rtw_free_assoc_resources(padapter, 1);
+		/* s2-4. */
+		rtw_free_network_queue(padapter, true);
+#endif
+		/*  Close LED */
+		rtw_led_control(padapter, LED_CTL_POWER_OFF);
+	}
+
+	rtw_scan_abort(padapter);
+	wdev_to_priv(padapter->rtw_wdev)->bandroid_scan = false;
+	padapter->rtw_wdev->iftype = NL80211_IFTYPE_MONITOR; /* set this at the end */
+
+	RT_TRACE(_module_os_intfs_c_, _drv_info_, ("-871x_drv - drv_close\n"));
+	DBG_8192D("-871x_drv - drv_close, bup =%d\n", padapter->bup);
+
+	if (padapter->firmware) {
+		vfree(padapter->firmware->buffer);
+		kfree(padapter->firmware);
+		padapter->firmware = NULL;
+	}
+	return 0;
+}
+
+void rtw_ndev_destructor(struct net_device *ndev)
+{
+	DBG_8192D(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	kfree(ndev->ieee80211_ptr);
+	free_netdev(ndev);
+}
diff --git a/drivers/net/wireless/rtl8192du/os_dep/osdep_service.c b/drivers/net/wireless/rtl8192du/os_dep/osdep_service.c
new file mode 100644
index 0000000..e9650dd
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/osdep_service.c
@@ -0,0 +1,856 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#define _OSDEP_SERVICE_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <linux/vmalloc.h>
+#include <rtw_ioctl_set.h>
+/*
+* Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
+* @return: one of RTW_STATUS_CODE
+*/
+inline int RTW_STATUS_CODE(int error_code) {
+	if (error_code >=0)
+		return _SUCCESS;
+
+	switch (error_code) {
+		default:
+			return _FAIL;
+	}
+}
+
+u32 rtw_atoi(u8* s)
+{
+
+	int num=0,flag=0;
+	int i;
+	for (i=0;i<=strlen(s);i++)
+	{
+	  if (s[i] >= '0' && s[i] <= '9')
+		 num = num * 10 + s[i] -'0';
+	  else if (s[0] == '-' && i==0)
+		 flag =1;
+	  else
+		  break;
+	 }
+
+	if (flag == 1)
+	   num = num * -1;
+
+	 return(num);
+}
+
+inline u8* _rtw_vmalloc(u32 sz)
+{
+	u8	*pbuf;
+
+	pbuf = vmalloc(sz);
+	return pbuf;
+}
+
+int	_rtw_memcmp(void *dst, void *src, u32 sz)
+{
+/* under Linux/GNU/GLibc, the return value of memcmp for two same mem. chunk is 0 */
+	if (!(memcmp(dst, src, sz)))
+		return true;
+	else
+		return false;
+}
+
+/*
+For the following list_xxx operations,
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+u32	rtw_is_list_empty(struct list_head *phead)
+{
+	if (list_empty(phead))
+		return true;
+	else
+		return false;
+}
+
+void rtw_list_insert_head(struct list_head *plist, struct list_head *phead)
+{
+	list_add(plist, phead);
+}
+
+void rtw_list_insert_tail(struct list_head *plist, struct list_head *phead)
+{
+	list_add_tail(plist, phead);
+}
+
+/* Caller must check if the list is empty before calling list_del_init */
+
+void _rtw_init_sema(struct  semaphore *sema, int init_val)
+{
+	sema_init(sema, init_val);
+}
+
+void _rtw_free_sema(struct  semaphore *sema)
+{
+}
+
+void _rtw_up_sema(struct  semaphore *sema)
+{
+	up(sema);
+}
+
+u32 _rtw_down_sema(struct  semaphore *sema)
+{
+	if (down_interruptible(sema))
+		return _FAIL;
+	else
+		return _SUCCESS;
+}
+
+void	_rtw_mutex_init(_mutex *pmutex)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	mutex_init(pmutex);
+#else
+	init_MUTEX(pmutex);
+#endif
+}
+
+void	_rtw_mutex_free(_mutex *pmutex)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+	mutex_destroy(pmutex);
+#endif
+}
+
+void	_rtw_spinlock_init(spinlock_t *plock)
+{
+	spin_lock_init(plock);
+}
+
+void	_rtw_spinlock_free(spinlock_t *plock)
+{
+}
+
+inline void	_rtw_spinlock(spinlock_t *plock)
+{
+	spin_lock(plock);
+}
+
+inline void	_rtw_spinunlock(spinlock_t *plock)
+{
+	spin_unlock(plock);
+}
+
+inline void	_rtw_spinlock_ex(spinlock_t *plock)
+{
+	spin_lock(plock);
+}
+
+inline void	_rtw_spinunlock_ex(spinlock_t *plock)
+{
+	spin_unlock(plock);
+}
+
+void	_rtw_init_queue(struct __queue *pqueue)
+{
+
+	INIT_LIST_HEAD(&(pqueue->queue));
+
+	_rtw_spinlock_init(&(pqueue->lock));
+}
+
+u32	  _rtw_queue_empty(struct __queue *pqueue)
+{
+	return (rtw_is_list_empty(&(pqueue->queue)));
+}
+
+u32 rtw_end_of_queue_search(struct list_head *head, struct list_head *plist)
+{
+	if (head == plist)
+		return true;
+	else
+		return false;
+}
+
+u32	rtw_get_current_time(void)
+{
+	return jiffies;
+}
+
+inline u32 rtw_systime_to_ms(u32 systime)
+{
+	return systime * 1000 / HZ;
+}
+
+inline u32 rtw_ms_to_systime(u32 ms)
+{
+	return ms * HZ / 1000;
+}
+
+/*  the input parameter start use the same unit as returned by rtw_get_current_time */
+inline s32 rtw_get_passing_time_ms(u32 start)
+{
+	return rtw_systime_to_ms(jiffies-start);
+}
+
+inline s32 rtw_get_time_interval_ms(u32 start, u32 end)
+{
+	return rtw_systime_to_ms(end-start);
+}
+
+void rtw_sleep_schedulable(int ms)
+{
+    u32 delta;
+
+    delta = (ms * HZ)/1000;/* ms) */
+    if (delta == 0) {
+        delta = 1;/*  1 ms */
+    }
+    set_current_state(TASK_INTERRUPTIBLE);
+    if (schedule_timeout(delta) != 0) {
+        return ;
+    }
+    return;
+}
+
+void rtw_msleep_os(int ms)
+{
+	msleep((unsigned int)ms);
+}
+
+void rtw_usleep_os(int us)
+{
+      if (1 < (us/1000))
+                msleep(1);
+      else
+		msleep((us/1000) + 1);
+}
+
+#ifdef DBG_DELAY_OS
+void _rtw_mdelay_os(int ms, const char *func, const int line)
+{
+	DBG_8192D("%s:%d %s(%d)\n", func, line, __func__, ms);
+	mdelay((unsigned long)ms);
+}
+
+void _rtw_udelay_os(int us, const char *func, const int line)
+{
+	DBG_8192D("%s:%d %s(%d)\n", func, line, __func__, us);
+      udelay((unsigned long)us);
+}
+#else
+void rtw_mdelay_os(int ms)
+{
+	mdelay((unsigned long)ms);
+}
+
+void rtw_udelay_os(int us)
+{
+      udelay((unsigned long)us);
+}
+#endif
+
+void rtw_yield_os(void)
+{
+	yield();
+}
+
+#define RTW_SUSPEND_LOCK_NAME "rtw_wifi"
+
+#ifdef CONFIG_WAKELOCK
+static struct wake_lock rtw_suspend_lock;
+#elif defined(CONFIG_ANDROID_POWER)
+static android_suspend_lock_t rtw_suspend_lock ={
+	.name = RTW_SUSPEND_LOCK_NAME
+};
+#endif
+
+inline void rtw_suspend_lock_init(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_init(&rtw_suspend_lock, WAKE_LOCK_SUSPEND, RTW_SUSPEND_LOCK_NAME);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_init_suspend_lock(&rtw_suspend_lock);
+	#endif
+}
+
+inline void rtw_suspend_lock_uninit(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock_destroy(&rtw_suspend_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_uninit_suspend_lock(&rtw_suspend_lock);
+	#endif
+}
+
+inline void rtw_lock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_lock(&rtw_suspend_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_lock_suspend(&rtw_suspend_lock);
+	#endif
+}
+
+inline void rtw_unlock_suspend(void)
+{
+	#ifdef CONFIG_WAKELOCK
+	wake_unlock(&rtw_suspend_lock);
+	#elif defined(CONFIG_ANDROID_POWER)
+	android_unlock_suspend(&rtw_suspend_lock);
+	#endif
+}
+
+inline void ATOMIC_SET(ATOMIC_T *v, int i)
+{
+	atomic_set(v,i);
+}
+
+inline int ATOMIC_READ(ATOMIC_T *v)
+{
+	return atomic_read(v);
+}
+
+inline void ATOMIC_ADD(ATOMIC_T *v, int i)
+{
+	atomic_add(i,v);
+}
+
+inline void ATOMIC_SUB(ATOMIC_T *v, int i)
+{
+	atomic_sub(i,v);
+}
+
+inline void ATOMIC_INC(ATOMIC_T *v)
+{
+	atomic_inc(v);
+}
+
+inline void ATOMIC_DEC(ATOMIC_T *v)
+{
+	atomic_dec(v);
+}
+
+inline int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
+{
+	return atomic_add_return(i,v);
+}
+
+inline int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
+{
+	return atomic_sub_return(i,v);
+}
+
+inline int ATOMIC_INC_RETURN(ATOMIC_T *v)
+{
+	return atomic_inc_return(v);
+}
+
+inline int ATOMIC_DEC_RETURN(ATOMIC_T *v)
+{
+	return atomic_dec_return(v);
+}
+
+/*
+* Open a file with the specific @param path, @param flag, @param mode
+* @param fpp the pointer of struct file pointer to get struct file pointer while file opening is success
+* @param path the path of the file to open
+* @param flag file operation flags, please refer to linux document
+* @param mode please refer to linux document
+* @return Linux specific error code
+*/
+static int openFile(struct file **fpp, char *path, int flag, int mode)
+{
+	struct file *fp;
+
+	fp=filp_open(path, flag, mode);
+	if (IS_ERR(fp)) {
+		*fpp=NULL;
+		return PTR_ERR(fp);
+	}
+	else {
+		*fpp=fp;
+		return 0;
+	}
+}
+
+/*
+* Close the file with the specific @param fp
+* @param fp the pointer of struct file to close
+* @return always 0
+*/
+static int closeFile(struct file *fp)
+{
+	filp_close(fp,NULL);
+	return 0;
+}
+
+static int readFile(struct file *fp,char __user *buf,int len)
+{
+	int rlen=0, sum=0;
+
+	if (!fp->f_op || !fp->f_op->read)
+		return -EPERM;
+
+	while (sum<len) {
+		rlen=fp->f_op->read(fp,buf+sum,len-sum, &fp->f_pos);
+		if (rlen>0)
+			sum+=rlen;
+		else if (0 != rlen)
+			return rlen;
+		else
+			break;
+	}
+
+	return  sum;
+}
+
+static int writeFile(struct file *fp,char __user *buf,int len)
+{
+	int wlen=0, sum=0;
+
+	if (!fp->f_op || !fp->f_op->write)
+		return -EPERM;
+
+	while (sum<len) {
+		wlen=fp->f_op->write(fp, buf+sum, len-sum, &fp->f_pos);
+		if (wlen>0)
+			sum+=wlen;
+		else if (0 != wlen)
+			return wlen;
+		else
+			break;
+	}
+
+	return sum;
+}
+
+/*
+* Test if the specifi @param path is a file and readable
+* @param path the path of the file to test
+* @return Linux specific error code
+*/
+static int isFileReadable(char *path)
+{
+	struct file *fp;
+	int ret = 0;
+	mm_segment_t oldfs;
+	char __user buf;
+
+	fp=filp_open(path, O_RDONLY, 0);
+	if (IS_ERR(fp)) {
+		ret = PTR_ERR(fp);
+	}
+	else {
+		oldfs = get_fs(); set_fs(get_ds());
+
+		if (1!=readFile(fp, &buf, 1))
+			ret = PTR_ERR(fp);
+
+		set_fs(oldfs);
+		filp_close(fp,NULL);
+	}
+	return ret;
+}
+
+/*
+* Open the file with @param path and retrive the file content into memory starting from @param buf for @param sz at most
+* @param path the path of the file to open and read
+* @param buf the starting address of the buffer to store file content
+* @param sz how many bytes to read at most
+* @return the byte we've read, or Linux specific error code
+*/
+static int retriveFromFile(char *path, u8 __user *buf, u32 sz)
+{
+	int ret =-1;
+	mm_segment_t oldfs;
+	struct file *fp;
+
+	if (path && buf) {
+		if (0 == (ret=openFile(&fp,path, O_RDONLY, 0))) {
+			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
+
+			oldfs = get_fs(); set_fs(get_ds());
+			ret=readFile(fp, buf, sz);
+			set_fs(oldfs);
+			closeFile(fp);
+
+			DBG_8192D("%s readFile, ret:%d\n",__func__, ret);
+
+		} else {
+			DBG_8192D("%s openFile path:%s Fail, ret:%d\n",__func__, path, ret);
+		}
+	} else {
+		DBG_8192D("%s NULL pointer\n",__func__);
+		ret =  -EINVAL;
+	}
+	return ret;
+}
+
+/*
+* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
+* @param path the path of the file to open and write
+* @param buf the starting address of the data to write into file
+* @param sz how many bytes to write at most
+* @return the byte we've written, or Linux specific error code
+*/
+static int storeToFile(char *path, u8 __user *buf, u32 sz)
+{
+	int ret =0;
+	mm_segment_t oldfs;
+	struct file *fp;
+
+	if (path && buf) {
+		if (0 == (ret=openFile(&fp, path, O_CREAT|O_WRONLY, 0666))) {
+			DBG_8192D("%s openFile path:%s fp=%p\n",__func__, path ,fp);
+
+			oldfs = get_fs(); set_fs(get_ds());
+			ret=writeFile(fp, buf, sz);
+			set_fs(oldfs);
+			closeFile(fp);
+
+			DBG_8192D("%s writeFile, ret:%d\n",__func__, ret);
+
+		} else {
+			DBG_8192D("%s openFile path:%s Fail, ret:%d\n",__func__, path, ret);
+		}
+	} else {
+		DBG_8192D("%s NULL pointer\n",__func__);
+		ret =  -EINVAL;
+	}
+	return ret;
+}
+
+/*
+* Test if the specifi @param path is a file and readable
+* @param path the path of the file to test
+* @return true or false
+*/
+int rtw_is_file_readable(char *path)
+{
+	if (isFileReadable(path) == 0)
+		return true;
+	else
+		return false;
+}
+
+/*
+* Open the file with @param path and retrive the file content into memory starting from @param buf for @param sz at most
+* @param path the path of the file to open and read
+* @param buf the starting address of the buffer to store file content
+* @param sz how many bytes to read at most
+* @return the byte we've read
+*/
+int rtw_retrive_from_file(char *path, u8 __user *buf, u32 sz)
+{
+	int ret =retriveFromFile(path, buf, sz);
+	return ret>=0?ret:0;
+}
+
+/*
+* Open the file with @param path and wirte @param sz byte of data starting from @param buf into the file
+* @param path the path of the file to open and write
+* @param buf the starting address of the data to write into file
+* @param sz how many bytes to write at most
+* @return the byte we've written
+*/
+int rtw_store_to_file(char *path, u8 __user *buf, u32 sz)
+{
+	int ret =storeToFile(path, buf, sz);
+	return ret>=0?ret:0;
+}
+
+struct net_device *rtw_alloc_etherdev_with_old_priv(int sizeof_priv, void *old_priv)
+{
+	struct net_device *pnetdev;
+	struct rtw_netdev_priv_indicator *pnpi;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
+#else
+	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+#endif
+	if (!pnetdev)
+		goto RETURN;
+
+	pnpi = netdev_priv(pnetdev);
+	pnpi->priv=old_priv;
+	pnpi->sizeof_priv=sizeof_priv;
+
+RETURN:
+	return pnetdev;
+}
+
+struct net_device *rtw_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *pnetdev;
+	struct rtw_netdev_priv_indicator *pnpi;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	pnetdev = alloc_etherdev_mq(sizeof(struct rtw_netdev_priv_indicator), 4);
+#else
+	pnetdev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));
+#endif
+	if (!pnetdev)
+		goto RETURN;
+
+	pnpi = netdev_priv(pnetdev);
+
+	pnpi->priv = vzalloc(sizeof_priv);
+	if (!pnpi->priv) {
+		free_netdev(pnetdev);
+		pnetdev = NULL;
+		goto RETURN;
+	}
+
+	pnpi->sizeof_priv=sizeof_priv;
+RETURN:
+	return pnetdev;
+}
+
+void rtw_free_netdev(struct net_device * netdev)
+{
+	struct rtw_netdev_priv_indicator *pnpi;
+
+	if (!netdev)
+		goto RETURN;
+
+	pnpi = netdev_priv(netdev);
+
+	if (!pnpi->priv)
+		goto RETURN;
+
+	vfree(pnpi->priv);
+	free_netdev(netdev);
+
+RETURN:
+	return;
+}
+
+/*
+* Jeff: this function should be called under ioctl (rtnl_lock is accquired) while
+* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+*/
+int rtw_change_ifname(struct rtw_adapter *padapter, const char *ifname)
+{
+	struct net_device *pnetdev;
+	struct net_device *cur_pnetdev;
+	struct rereg_nd_name_data *rereg_priv;
+	int ret;
+
+	if (!padapter)
+		goto error;
+
+	cur_pnetdev = padapter->pnetdev;
+	rereg_priv = &padapter->rereg_nd_name_priv;
+
+	/* free the old_pnetdev */
+	if (rereg_priv->old_pnetdev) {
+		free_netdev(rereg_priv->old_pnetdev);
+		rereg_priv->old_pnetdev = NULL;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (!rtnl_is_locked())
+		unregister_netdev(cur_pnetdev);
+	else
+#endif
+		unregister_netdevice(cur_pnetdev);
+
+	rtw_proc_remove_one(cur_pnetdev);
+
+	rereg_priv->old_pnetdev=cur_pnetdev;
+
+	pnetdev = rtw_init_netdev(padapter);
+	if (!pnetdev)  {
+		ret = -1;
+		goto error;
+	}
+
+	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(adapter_to_dvobj(padapter)));
+
+	rtw_init_netdev_name(pnetdev, ifname);
+
+	memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (!rtnl_is_locked())
+		ret = register_netdev(pnetdev);
+	else
+#endif
+		ret = register_netdevice(pnetdev);
+
+	if (ret != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto error;
+	}
+
+	rtw_proc_init_one(pnetdev);
+
+	return 0;
+
+error:
+
+	return -1;
+}
+
+u64 rtw_modular64(u64 x, u64 y)
+{
+	return do_div(x, y);
+}
+
+u64 rtw_division64(u64 x, u64 y)
+{
+	do_div(x, y);
+	return x;
+}
+
+void rtw_buf_free(u8 **buf, u32 *buf_len)
+{
+	if (!buf || !buf_len)
+		return;
+
+	if (*buf) {
+		*buf_len = 0;
+		kfree(*buf);
+		*buf = NULL;
+	}
+}
+
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)
+{
+	u32 ori_len = 0, dup_len = 0;
+	u8 *ori = NULL;
+	u8 *dup = NULL;
+
+	if (!buf || !buf_len)
+		return;
+
+	if (!src || !src_len)
+		goto keep_ori;
+
+	/* duplicate src */
+	dup = kmalloc(src_len, GFP_ATOMIC);
+	if (dup) {
+		dup_len = src_len;
+		memcpy(dup, src, dup_len);
+	}
+
+keep_ori:
+	ori = *buf;
+	ori_len = *buf_len;
+
+	/* replace buf with dup */
+	*buf_len = 0;
+	*buf = dup;
+	*buf_len = dup_len;
+
+	/* free ori */
+	if (ori && ori_len > 0)
+		kfree(ori);
+}
+
+/**
+ * rtw_cbuf_full - test if cbuf is full
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Returns: true if cbuf is full
+ */
+inline bool rtw_cbuf_full(struct rtw_cbuf *cbuf)
+{
+	return (cbuf->write == cbuf->read-1)? true : false;
+}
+
+/**
+ * rtw_cbuf_empty - test if cbuf is empty
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Returns: true if cbuf is empty
+ */
+inline bool rtw_cbuf_empty(struct rtw_cbuf *cbuf)
+{
+	return (cbuf->write == cbuf->read)? true : false;
+}
+
+/**
+ * rtw_cbuf_push - push a pointer into cbuf
+ * @cbuf: pointer of struct rtw_cbuf
+ * @buf: pointer to push in
+ *
+ * Lock free operation, be careful of the use scheme
+ * Returns: true push success
+ */
+bool rtw_cbuf_push(struct rtw_cbuf *cbuf, void *buf)
+{
+	if (rtw_cbuf_full(cbuf))
+		return _FAIL;
+
+	cbuf->bufs[cbuf->write] = buf;
+	cbuf->write = (cbuf->write+1)%cbuf->size;
+
+	return _SUCCESS;
+}
+
+/**
+ * rtw_cbuf_pop - pop a pointer from cbuf
+ * @cbuf: pointer of struct rtw_cbuf
+ *
+ * Lock free operation, be careful of the use scheme
+ * Returns: pointer popped out
+ */
+void *rtw_cbuf_pop(struct rtw_cbuf *cbuf)
+{
+	void *buf;
+	if (rtw_cbuf_empty(cbuf))
+		return NULL;
+
+	buf = cbuf->bufs[cbuf->read];
+	cbuf->read = (cbuf->read+1)%cbuf->size;
+
+	return buf;
+}
+
+/**
+ * rtw_cbuf_alloc - allocte a rtw_cbuf with given size and do initialization
+ * @size: size of pointer
+ *
+ * Returns: pointer of srtuct rtw_cbuf, NULL for allocation failure
+ */
+struct rtw_cbuf *rtw_cbuf_alloc(u32 size)
+{
+	struct rtw_cbuf *cbuf;
+
+	cbuf = (struct rtw_cbuf *)kmalloc(sizeof(*cbuf) + sizeof(void*) * size,
+					  GFP_KERNEL);
+
+	if (cbuf) {
+		cbuf->write = cbuf->read = 0;
+		cbuf->size = size;
+	}
+
+	return cbuf;
+}
+
+/**
+ * rtw_cbuf_free - free the given rtw_cbuf
+ * @cbuf: pointer of struct rtw_cbuf to free
+ */
+void rtw_cbuf_free(struct rtw_cbuf *cbuf)
+{
+	kfree(cbuf);
+}
diff --git a/drivers/net/wireless/rtl8192du/os_dep/recv_linux.c b/drivers/net/wireless/rtl8192du/os_dep/recv_linux.c
new file mode 100644
index 0000000..7b27c17
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/recv_linux.c
@@ -0,0 +1,315 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _RECV_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <wifi.h>
+#include <recv_osdep.h>
+
+#include <osdep_intf.h>
+#include <ethernet.h>
+
+#include <usb_ops.h>
+
+/* alloc os related resource in struct recv_frame_hdr */
+int rtw_os_recv_resource_alloc(struct rtw_adapter *padapter, struct recv_frame_hdr *precvframe)
+{
+	int	res=_SUCCESS;
+
+	precvframe->pkt_newalloc = precvframe->pkt = NULL;
+
+	return res;
+}
+
+/* free os related resource in struct recv_frame_hdr */
+void rtw_os_recv_resource_free(struct recv_priv *precvpriv)
+{
+}
+
+/* alloc os related resource in struct recv_buf */
+int rtw_os_recvbuf_resource_alloc(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+	precvbuf->irp_pending = false;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if (precvbuf->purb == NULL) {
+		res = _FAIL;
+	}
+
+	precvbuf->pskb = NULL;
+
+	precvbuf->reuse = false;
+
+	precvbuf->pallocated_buf  = precvbuf->pbuf = NULL;
+
+	precvbuf->pdata = precvbuf->phead = precvbuf->ptail = precvbuf->pend = NULL;
+
+	precvbuf->transfer_len = 0;
+
+	precvbuf->len = 0;
+
+	return res;
+}
+
+/* free os related resource in struct recv_buf */
+int rtw_os_recvbuf_resource_free(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
+{
+	int ret = _SUCCESS;
+
+	if (precvbuf->purb)
+		usb_free_urb(precvbuf->purb);
+
+	if (precvbuf->pskb)
+		dev_kfree_skb_any(precvbuf->pskb);
+
+	return ret;
+}
+
+void rtw_handle_tkip_mic_err(struct rtw_adapter *padapter,u8 bgroup)
+{
+	enum nl80211_key_type key_type;
+	union iwreq_data wrqu;
+	struct iw_michaelmicfailure    ev;
+	struct mlme_priv*              pmlmepriv  = &padapter->mlmepriv;
+	struct security_priv	*psecuritypriv = &padapter->securitypriv;
+	u32 cur_time = 0;
+
+	if (psecuritypriv->last_mic_err_time == 0)
+	{
+		psecuritypriv->last_mic_err_time = rtw_get_current_time();
+	}
+	else
+	{
+		cur_time = rtw_get_current_time();
+
+		if (cur_time - psecuritypriv->last_mic_err_time < 60*HZ)
+		{
+			psecuritypriv->btkip_countermeasure = true;
+			psecuritypriv->last_mic_err_time = 0;
+			psecuritypriv->btkip_countermeasure_time = cur_time;
+		}
+		else
+		{
+			psecuritypriv->last_mic_err_time = rtw_get_current_time();
+		}
+	}
+
+	if (bgroup)
+		key_type |= NL80211_KEYTYPE_GROUP;
+	else
+		key_type |= NL80211_KEYTYPE_PAIRWISE;
+
+	cfg80211_michael_mic_failure(padapter->pnetdev, (u8 *)&pmlmepriv->assoc_bssid[0], key_type, -1,
+		NULL, GFP_ATOMIC);
+
+	memset(&ev, 0x00, sizeof(ev));
+	if (bgroup)
+	    ev.flags |= IW_MICFAILURE_GROUP;
+	else
+	    ev.flags |= IW_MICFAILURE_PAIRWISE;
+
+	ev.src_addr.sa_family = ARPHRD_ETHER;
+	memcpy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0], ETH_ALEN);
+
+	memset(&wrqu, 0x00, sizeof(wrqu));
+	wrqu.data.length = sizeof(ev);
+
+	wireless_send_event(padapter->pnetdev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev);
+}
+
+void rtw_hostapd_mlme_rx(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame)
+{
+#ifdef CONFIG_HOSTAPD_MLME
+	struct sk_buff *skb;
+	struct hostapd_priv *phostapdpriv  = padapter->phostapdpriv;
+	struct net_device *pmgnt_netdev = phostapdpriv->pmgnt_netdev;
+
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_, ("+rtw_hostapd_mlme_rx\n"));
+
+	skb = precv_frame->pkt;
+
+	if (skb == NULL)
+		return;
+
+	skb->data = precv_frame->rx_data;
+	skb->tail = precv_frame->rx_tail;
+	skb->len = precv_frame->len;
+
+	skb->dev = pmgnt_netdev;
+	skb->ip_summed = CHECKSUM_NONE;
+	skb->pkt_type = PACKET_OTHERHOST;
+	skb->protocol = __constant_htons(0x0003); /*ETH_P_80211_RAW*/
+
+	skb_reset_mac_header(skb);
+
+       memset(skb->cb, 0, sizeof(skb->cb));
+
+	netif_rx(skb);
+
+	precv_frame->pkt = NULL; /*  set pointer to NULL before rtw_free_recvframe() if call netif_rx() */
+#endif
+}
+
+int rtw_recv_indicatepkt(struct rtw_adapter *padapter, struct recv_frame_hdr *precv_frame)
+{
+	struct recv_priv *precvpriv;
+	struct __queue *pfree_recv_queue;
+	struct sk_buff *skb;
+	struct mlme_priv*pmlmepriv = &padapter->mlmepriv;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+#endif
+
+	precvpriv = &(padapter->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+#ifdef CONFIG_DRVEXT_MODULE
+	if (drvext_rx_handler(padapter, precv_frame->rx_data, precv_frame->len) == _SUCCESS)
+		goto _recv_indicatepkt_drop;
+#endif
+
+	skb = precv_frame->pkt;
+	if (skb == NULL) {
+		RT_TRACE(_module_recv_osdep_c_,_drv_err_,("rtw_recv_indicatepkt():skb==NULL something wrong!!!!\n"));
+		goto _recv_indicatepkt_drop;
+	}
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,
+		 ("rtw_recv_indicatepkt():skb != NULL !!!\n"));
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_,
+		 ("rtw_recv_indicatepkt():precv_frame->rx_head=%p  precv_frame->hdr.rx_data=%p\n",
+		 precv_frame->rx_head, precv_frame->rx_data));
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_,
+		 ("precv_frame->hdr.rx_tail=%p precv_frame->rx_end=%p precv_frame->hdr.len=%d\n",
+		 precv_frame->rx_tail,
+		 precv_frame->rx_end,
+		 precv_frame->len));
+
+	skb->data = precv_frame->rx_data;
+
+	skb_set_tail_pointer(skb, precv_frame->len);
+
+	skb->len = precv_frame->len;
+
+	RT_TRACE(_module_recv_osdep_c_, _drv_info_,
+		 ("\n skb->head=%p skb->data=%p skb->tail=%p skb->end=%p skb->len=%d\n",
+		 skb->head, skb->data, skb_tail_pointer(skb),
+		 skb_end_pointer(skb), skb->len));
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		struct sk_buff *pskb2 = NULL;
+		struct sta_info *psta = NULL;
+		struct sta_priv *pstapriv = &padapter->stapriv;
+		struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+		int bmcast = IS_MCAST(pattrib->dst);
+
+		if (_rtw_memcmp(pattrib->dst, myid(&padapter->eeprompriv), ETH_ALEN)==false) {
+			if (bmcast) {
+				psta = rtw_get_bcmc_stainfo(padapter);
+				pskb2 = skb_clone(skb, GFP_ATOMIC);
+			} else {
+				psta = rtw_get_stainfo(pstapriv, pattrib->dst);
+			}
+
+			if (psta) {
+				struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+
+				skb->dev = pnetdev;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+				skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
+#endif /* LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35) */
+
+				rtw_xmit_entry(skb, pnetdev);
+
+				if (bmcast)
+					skb = pskb2;
+				else
+					goto _recv_indicatepkt_end;
+			}
+
+		}
+	}
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
+	if ((pattrib->tcpchk_valid == 1) && (pattrib->tcp_chkrpt == 1)) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+#else /* !CONFIG_TCP_CSUM_OFFLOAD_RX */
+
+	skb->ip_summed = CHECKSUM_NONE;
+
+#endif
+
+	skb->dev = padapter->pnetdev;
+	skb->protocol = eth_type_trans(skb, padapter->pnetdev);
+
+	netif_rx(skb);
+
+_recv_indicatepkt_end:
+
+	precv_frame->pkt = NULL; /*  pointers to NULL before rtw_free_recvframe() */
+
+	rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	RT_TRACE(_module_recv_osdep_c_,_drv_info_,("\n rtw_recv_indicatepkt :after netif_rx!!!!\n"));
+
+        return _SUCCESS;
+
+_recv_indicatepkt_drop:
+
+	 /* enqueue back to free_recv_queue */
+	 rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	 return _FAIL;
+}
+
+void rtw_os_read_port(struct rtw_adapter *padapter, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &padapter->recvpriv;
+
+	precvbuf->ref_cnt--;
+
+	/* free skb in recv_buf */
+	dev_kfree_skb_any(precvbuf->pskb);
+
+	precvbuf->pskb = NULL;
+	precvbuf->reuse = false;
+
+	if (precvbuf->irp_pending == false)
+		rtw_read_port(padapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf);
+}
+
+static void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	struct rtw_adapter *padapter = preorder_ctrl->padapter;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), padapter->pnetdev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
+}
diff --git a/drivers/net/wireless/rtl8192du/os_dep/rtw_android.c b/drivers/net/wireless/rtl8192du/os_dep/rtw_android.c
new file mode 100644
index 0000000..dd475a0
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/rtw_android.c
@@ -0,0 +1,694 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+#include <rtw_android.h>
+#include <osdep_service.h>
+#include <rtw_debug.h>
+#include <ioctl_cfg80211.h>
+#include <rtw_ioctl_set.h>
+
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+#include <linux/platform_device.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+#include <linux/wlan_plat.h>
+#else
+#include <linux/wifi_tiwlan.h>
+#endif
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
+
+static const char *android_wifi_cmd_str[ANDROID_WIFI_CMD_MAX] = {
+	"START",
+	"STOP",
+	"SCAN-ACTIVE",
+	"SCAN-PASSIVE",
+	"RSSI",
+	"LINKSPEED",
+	"RXFILTER-START",
+	"RXFILTER-STOP",
+	"RXFILTER-ADD",
+	"RXFILTER-REMOVE",
+	"BTCOEXSCAN-START",
+	"BTCOEXSCAN-STOP",
+	"BTCOEXMODE",
+	"SETSUSPENDOPT",
+	"P2P_DEV_ADDR",
+	"SETFWPATH",
+	"SETBAND",
+	"GETBAND",
+	"COUNTRY",
+	"P2P_SET_NOA",
+	"P2P_GET_NOA",
+	"P2P_SET_PS",
+	"SET_AP_WPS_P2P_IE",
+#ifdef PNO_SUPPORT
+	"PNOSSIDCLR",
+	"PNOSETUP ",
+	"PNOFORCE",
+	"PNODEBUG",
+#endif
+
+	"MACADDR",
+
+	"BLOCK",
+	"WFD-ENABLE",
+	"WFD-DISABLE",
+	"WFD-SET-TCPPORT",
+	"WFD-SET-MAXTPUT",
+	"WFD-SET-DEVTYPE",
+};
+
+#ifdef PNO_SUPPORT
+#define PNO_TLV_PREFIX			'S'
+#define PNO_TLV_VERSION			'1'
+#define PNO_TLV_SUBVERSION		'2'
+#define PNO_TLV_RESERVED		'0'
+#define PNO_TLV_TYPE_SSID_IE		'S'
+#define PNO_TLV_TYPE_TIME		'T'
+#define PNO_TLV_FREQ_REPEAT		'R'
+#define PNO_TLV_FREQ_EXPO_MAX		'M'
+
+struct cmd_tlv {
+	char prefix;
+	char version;
+	char subver;
+	char reserved;
+};
+#endif /* PNO_SUPPORT */
+
+struct android_wifi_priv_cmd {
+	const char __user *buf;
+	int used_len;
+	int total_len;
+};
+
+/**
+ * Local (static) functions and variables
+ */
+
+/* Initialize g_wifi_on to 1 so dhd_bus_start will be called for the first
+ * time (only) in dhd_open, subsequential wifi on will be handled by
+ * wl_android_wifi_on
+ */
+static int g_wifi_on = true;
+
+#ifdef PNO_SUPPORT
+static int wl_android_set_pno_setup(struct net_device *dev, char *command, int total_len)
+{
+	wlc_ssid_t ssids_local[MAX_PFN_LIST_COUNT];
+	int res = -1;
+	int nssid = 0;
+	struct cmd_tlv *struct cmd_tlvemp;
+	char *str_ptr;
+	int tlv_size_left;
+	int pno_time = 0;
+	int pno_repeat = 0;
+	int pno_freq_expo_max = 0;
+
+#ifdef PNO_SET_DEBUG
+	int i;
+	char pno_in_example[] = {
+		'P', 'N', 'O', 'S', 'E', 'T', 'U', 'P', ' ',
+		'S', '1', '2', '0',
+		'S',
+		0x05,
+		'd', 'l', 'i', 'n', 'k',
+		'S',
+		0x04,
+		'G', 'O', 'O', 'G',
+		'T',
+		'0', 'B',
+		'R',
+		'2',
+		'M',
+		'2',
+		0x00
+		};
+#endif /* PNO_SET_DEBUG */
+
+	DHD_INFO(("%s: command=%s, len=%d\n", __func__, command, total_len));
+
+	if (total_len < (strlen(CMD_PNOSETUP_SET) + sizeof(struct cmd_tlv))) {
+		DBG_8192D("%s argument=%d less min size\n", __func__, total_len);
+		goto exit_proc;
+	}
+
+#ifdef PNO_SET_DEBUG
+	memcpy(command, pno_in_example, sizeof(pno_in_example));
+	for (i = 0; i < sizeof(pno_in_example); i++)
+		printf("%02X ", command[i]);
+	printf("\n");
+	total_len = sizeof(pno_in_example);
+#endif
+
+	str_ptr = command + strlen(CMD_PNOSETUP_SET);
+	tlv_size_left = total_len - strlen(CMD_PNOSETUP_SET);
+
+	struct cmd_tlvemp = (struct cmd_tlv *)str_ptr;
+	memset(ssids_local, 0, sizeof(ssids_local));
+
+	if ((struct cmd_tlvemp->prefix == PNO_TLV_PREFIX) &&
+		(struct cmd_tlvemp->version == PNO_TLV_VERSION) &&
+		(struct cmd_tlvemp->subver == PNO_TLV_SUBVERSION)) {
+
+		str_ptr += sizeof(struct cmd_tlv);
+		tlv_size_left -= sizeof(struct cmd_tlv);
+
+		if ((nssid = wl_iw_parse_ssid_list_tlv(&str_ptr, ssids_local,
+			MAX_PFN_LIST_COUNT, &tlv_size_left)) <= 0) {
+			DBG_8192D("SSID is not presented or corrupted ret=%d\n", nssid);
+			goto exit_proc;
+		} else {
+			if ((str_ptr[0] != PNO_TLV_TYPE_TIME) || (tlv_size_left <= 1)) {
+				DBG_8192D("%s scan duration corrupted field size %d\n",
+					__func__, tlv_size_left);
+				goto exit_proc;
+			}
+			str_ptr++;
+			pno_time = simple_strtoul(str_ptr, &str_ptr, 16);
+			DHD_INFO(("%s: pno_time=%d\n", __func__, pno_time));
+
+			if (str_ptr[0] != 0) {
+				if ((str_ptr[0] != PNO_TLV_FREQ_REPEAT)) {
+					DBG_8192D("%s pno repeat : corrupted field\n",
+						__func__);
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_repeat = simple_strtoul(str_ptr, &str_ptr, 16);
+				DHD_INFO(("%s :got pno_repeat=%d\n", __func__, pno_repeat));
+				if (str_ptr[0] != PNO_TLV_FREQ_EXPO_MAX) {
+					DBG_8192D("%s FREQ_EXPO_MAX corrupted field size\n",
+						__func__);
+					goto exit_proc;
+				}
+				str_ptr++;
+				pno_freq_expo_max = simple_strtoul(str_ptr, &str_ptr, 16);
+				DHD_INFO(("%s: pno_freq_expo_max=%d\n",
+					__func__, pno_freq_expo_max));
+			}
+		}
+	} else {
+		DBG_8192D("%s get wrong TLV command\n", __func__);
+		goto exit_proc;
+	}
+
+	res = dhd_dev_pno_set(dev, ssids_local, nssid, pno_time, pno_repeat, pno_freq_expo_max);
+
+exit_proc:
+	return res;
+}
+#endif /* PNO_SUPPORT */
+
+int rtw_android_cmdstr_to_num(char *cmdstr)
+{
+	int cmd_num;
+	for (cmd_num=0 ; cmd_num<ANDROID_WIFI_CMD_MAX; cmd_num++)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0))
+		if (!strncasecmp(cmdstr, android_wifi_cmd_str[cmd_num],
+		    strlen(android_wifi_cmd_str[cmd_num])))
+#else
+		if (0 == strnicmp(cmdstr , android_wifi_cmd_str[cmd_num],
+				  strlen(android_wifi_cmd_str[cmd_num])))
+#endif
+			break;
+
+	return cmd_num;
+}
+
+static int rtw_android_get_rssi(struct net_device *net, char *command, int total_len)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		bytes_written += snprintf(&command[bytes_written], total_len, "%s rssi %d",
+			pcur_network->network.Ssid.Ssid, padapter->recvpriv.rssi);
+	}
+
+	return bytes_written;
+}
+
+static int rtw_android_get_link_speed(struct net_device *net, char *command, int total_len)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	struct	mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
+	struct	wlan_network	*pcur_network = &pmlmepriv->cur_network;
+	int bytes_written = 0;
+	u16 link_speed = 0;
+
+	link_speed = rtw_get_cur_max_rate(padapter)/10;
+	bytes_written = snprintf(command, total_len, "LinkSpeed %d", link_speed);
+
+	return bytes_written;
+}
+
+static int rtw_android_get_macaddr(struct net_device *net, char *command, int total_len)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	int bytes_written = 0;
+
+	bytes_written = snprintf(command, total_len, "Macaddr = %pM", net->dev_addr);
+	return bytes_written;
+}
+
+static int rtw_android_set_country(struct net_device *net, char *command, int total_len)
+{
+	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	char *country_code = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_COUNTRY]) + 1;
+	int ret;
+
+	ret = rtw_set_country(adapter, country_code);
+
+	return (ret==_SUCCESS)?0:-1;
+}
+
+static int rtw_android_get_p2p_dev_addr(struct net_device *net, char *command, int total_len)
+{
+	int ret;
+	int bytes_written = 0;
+
+	/* We use the same address as our HW MAC address */
+	memcpy(command, net->dev_addr, ETH_ALEN);
+
+	bytes_written = ETH_ALEN;
+	return bytes_written;
+}
+
+static int rtw_android_set_block(struct net_device *net, char *command, int total_len)
+{
+	int ret;
+	struct rtw_adapter *adapter = (struct rtw_adapter *)rtw_netdev_priv(net);
+	char *block_value = command + strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_BLOCK]) + 1;
+
+	wdev_to_priv(adapter->rtw_wdev)->block = (*block_value=='0')?false:true;
+
+	return 0;
+}
+
+static int get_int_from_command(char* pcmd)
+{
+	int i = 0;
+
+	for (i = 0; i < strlen(pcmd); i++)
+	{
+		if (pcmd[i] == '=')
+		{
+			/*	Skip the '=' and space characters. */
+			i += 2;
+			break;
+		}
+	}
+	return (rtw_atoi(pcmd + i));
+}
+
+int rtw_android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+	int ret = 0;
+	char *command = NULL;
+	int cmd_num;
+	int bytes_written = 0;
+	struct android_wifi_priv_cmd priv_cmd;
+
+	rtw_lock_suspend();
+
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(struct android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	command = kzalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!command)
+	{
+		DBG_8192D("%s: failed to allocate memory\n", __func__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if (!access_ok(VERIFY_READ, priv_cmd.buf, priv_cmd.total_len)) {
+		DBG_8192D("%s: failed to access memory\n", __func__);
+		ret = -EFAULT;
+		goto exit;
+	 }
+	if (copy_from_user(command, (char __user *)priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	DBG_8192D("%s: Android private cmd \"%s\" on %s\n"
+		, __func__, command, ifr->ifr_name);
+
+	cmd_num = rtw_android_cmdstr_to_num(command);
+
+	switch (cmd_num) {
+	case ANDROID_WIFI_CMD_START:
+		goto response;
+	case ANDROID_WIFI_CMD_SETFWPATH:
+		goto response;
+	}
+
+	if (!g_wifi_on) {
+		DBG_8192D("%s: Ignore private cmd \"%s\" - iface %s is down\n"
+			,__func__, command, ifr->ifr_name);
+		ret = 0;
+		goto exit;
+	}
+
+	switch (cmd_num) {
+	case ANDROID_WIFI_CMD_STOP:
+		break;
+	case ANDROID_WIFI_CMD_SCAN_ACTIVE:
+		break;
+	case ANDROID_WIFI_CMD_SCAN_PASSIVE:
+		break;
+	case ANDROID_WIFI_CMD_RSSI:
+		bytes_written = rtw_android_get_rssi(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_LINKSPEED:
+		bytes_written = rtw_android_get_link_speed(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_MACADDR:
+		bytes_written = rtw_android_get_macaddr(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_BLOCK:
+		bytes_written = rtw_android_set_block(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_START:
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_STOP:
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_ADD:
+		break;
+	case ANDROID_WIFI_CMD_RXFILTER_REMOVE:
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_START:
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXSCAN_STOP:
+		break;
+	case ANDROID_WIFI_CMD_BTCOEXMODE:
+		break;
+	case ANDROID_WIFI_CMD_SETSUSPENDOPT:
+		break;
+	case ANDROID_WIFI_CMD_SETBAND:
+	{
+		uint band = *(command + strlen("SETBAND") + 1) - '0';
+		struct rtw_adapter*	padapter = (struct rtw_adapter *) rtw_netdev_priv(net);
+
+		if (padapter->chip_type == RTL8192D)
+			padapter->setband = band;
+
+		break;
+	}
+	case ANDROID_WIFI_CMD_GETBAND:
+		break;
+	case ANDROID_WIFI_CMD_COUNTRY:
+		bytes_written = rtw_android_set_country(net, command, priv_cmd.total_len);
+		break;
+#ifdef PNO_SUPPORT
+	case ANDROID_WIFI_CMD_PNOSSIDCLR_SET:
+		break;
+	case ANDROID_WIFI_CMD_PNOSETUP_SET:
+		break;
+	case ANDROID_WIFI_CMD_PNOENABLE_SET:
+		break;
+#endif
+	case ANDROID_WIFI_CMD_P2P_DEV_ADDR:
+		bytes_written = rtw_android_get_p2p_dev_addr(net, command, priv_cmd.total_len);
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_NOA:
+		break;
+	case ANDROID_WIFI_CMD_P2P_GET_NOA:
+		break;
+	case ANDROID_WIFI_CMD_P2P_SET_PS:
+		break;
+	case ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE:
+	{
+		int skip = strlen(android_wifi_cmd_str[ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE]) + 3;
+		bytes_written = rtw_cfg80211_set_mgnt_wpsp2pie(net, command + skip, priv_cmd.total_len - skip, *(command + skip - 2) - '0');
+		break;
+	}
+
+	default:
+		DBG_8192D("Unknown PRIVATE command %s - ignored\n", command);
+		snprintf(command, 3, "OK");
+		bytes_written = strlen("OK");
+	}
+
+response:
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0))
+			command[0] = '\0';
+		if (bytes_written >= priv_cmd.total_len) {
+			DBG_8192D("%s: bytes_written = %d\n", __func__, bytes_written);
+			bytes_written = priv_cmd.total_len;
+		} else {
+			bytes_written++;
+		}
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user((char __user *)priv_cmd.buf, command, bytes_written)) {
+			DBG_8192D("%s: failed to copy data to user buffer\n", __func__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		ret = bytes_written;
+	}
+
+exit:
+	rtw_unlock_suspend();
+	if (command) {
+		kfree(command);
+	}
+
+	return ret;
+}
+
+/**
+ * Functions for Android WiFi card detection
+ */
+#if defined(RTW_ENABLE_WIFI_CONTROL_FUNC)
+
+static int g_wifidev_registered = 0;
+static struct semaphore wifi_control_sem;
+static struct wifi_platform_data *wifi_control_data = NULL;
+static struct resource *wifi_irqres = NULL;
+
+static int wifi_add_dev(void);
+static void wifi_del_dev(void);
+
+int rtw_android_wifictrl_func_add(void)
+{
+	int ret = 0;
+	sema_init(&wifi_control_sem, 0);
+
+	ret = wifi_add_dev();
+	if (ret) {
+		DBG_8192D("%s: platform_driver_register failed\n", __func__);
+		return ret;
+	}
+	g_wifidev_registered = 1;
+
+	/* Waiting callback after platform_driver_register is done or exit with error */
+	if (down_timeout(&wifi_control_sem,  msecs_to_jiffies(1000)) != 0) {
+		ret = -EINVAL;
+		DBG_8192D("%s: platform_driver_register timeout\n", __func__);
+	}
+
+	return ret;
+}
+
+void rtw_android_wifictrl_func_del(void)
+{
+	if (g_wifidev_registered)
+	{
+		wifi_del_dev();
+		g_wifidev_registered = 0;
+	}
+}
+
+void *wl_android_prealloc(int section, unsigned long size)
+{
+	void *alloc_ptr = NULL;
+	if (wifi_control_data && wifi_control_data->mem_prealloc) {
+		alloc_ptr = wifi_control_data->mem_prealloc(section, size);
+		if (alloc_ptr) {
+			DBG_8192D("success alloc section %d\n", section);
+			if (size != 0L)
+				memset(alloc_ptr, 0, size);
+			return alloc_ptr;
+		}
+	}
+
+	DBG_8192D("can't alloc section %d\n", section);
+	return NULL;
+}
+
+int wifi_get_irq_number(unsigned long *irq_flags_ptr)
+{
+	if (wifi_irqres) {
+		*irq_flags_ptr = wifi_irqres->flags & IRQF_TRIGGER_MASK;
+		return (int)wifi_irqres->start;
+	}
+#ifdef CUSTOM_OOB_GPIO_NUM
+	return CUSTOM_OOB_GPIO_NUM;
+#else
+	return -1;
+#endif
+}
+
+int wifi_set_power(int on, unsigned long msec)
+{
+	DBG_8192D("%s = %d\n", __func__, on);
+	if (wifi_control_data && wifi_control_data->set_power) {
+		wifi_control_data->set_power(on);
+	}
+	if (msec)
+		msleep(msec);
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
+int wifi_get_mac_addr(unsigned char *buf)
+{
+	DBG_8192D("%s\n", __func__);
+	if (!buf)
+		return -EINVAL;
+	if (wifi_control_data && wifi_control_data->get_mac_addr) {
+		return wifi_control_data->get_mac_addr(buf);
+	}
+	return -EOPNOTSUPP;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)) */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+void *wifi_get_country_code(char *ccode)
+{
+	DBG_8192D("%s\n", __func__);
+	if (!ccode)
+		return NULL;
+	if (wifi_control_data && wifi_control_data->get_country_code) {
+		return wifi_control_data->get_country_code(ccode);
+	}
+	return NULL;
+}
+#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) */
+
+static int wifi_set_carddetect(int on)
+{
+	DBG_8192D("%s = %d\n", __func__, on);
+	if (wifi_control_data && wifi_control_data->set_carddetect) {
+		wifi_control_data->set_carddetect(on);
+	}
+	return 0;
+}
+
+static int wifi_probe(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	DBG_8192D("## %s\n", __func__);
+	wifi_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "bcmdhd_wlan_irq");
+	if (wifi_irqres == NULL)
+		wifi_irqres = platform_get_resource_byname(pdev,
+			IORESOURCE_IRQ, "bcm4329_wlan_irq");
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(1, 0);	/* Power On */
+	wifi_set_carddetect(1);	/* CardDetect (0->1) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_remove(struct platform_device *pdev)
+{
+	struct wifi_platform_data *wifi_ctrl =
+		(struct wifi_platform_data *)(pdev->dev.platform_data);
+
+	DBG_8192D("## %s\n", __func__);
+	wifi_control_data = wifi_ctrl;
+
+	wifi_set_power(0, 0);	/* Power Off */
+	wifi_set_carddetect(0);	/* CardDetect (1->0) */
+
+	up(&wifi_control_sem);
+	return 0;
+}
+
+static int wifi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	DBG_8192D("##> %s\n", __func__);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	bcmsdh_oob_intr_set(0);
+#endif
+	return 0;
+}
+
+static int wifi_resume(struct platform_device *pdev)
+{
+	DBG_8192D("##> %s\n", __func__);
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY)
+	if (dhd_os_check_if_up(bcmsdh_get_drvdata()))
+		bcmsdh_oob_intr_set(1);
+#endif
+	return 0;
+}
+
+/* temporarily use these two */
+static struct platform_driver wifi_device = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+	.driver         = {
+	.name   = "bcmdhd_wlan",
+	}
+};
+
+static struct platform_driver wifi_device_legacy = {
+	.probe          = wifi_probe,
+	.remove         = wifi_remove,
+	.suspend        = wifi_suspend,
+	.resume         = wifi_resume,
+	.driver         = {
+	.name   = "bcm4329_wlan",
+	}
+};
+
+static int wifi_add_dev(void)
+{
+	DBG_8192D("## Calling platform_driver_register\n");
+	platform_driver_register(&wifi_device);
+	platform_driver_register(&wifi_device_legacy);
+	return 0;
+}
+
+static void wifi_del_dev(void)
+{
+	DBG_8192D("## Unregister platform_driver_register\n");
+	platform_driver_unregister(&wifi_device);
+	platform_driver_unregister(&wifi_device_legacy);
+}
+#endif /* defined(RTW_ENABLE_WIFI_CONTROL_FUNC) */
diff --git a/drivers/net/wireless/rtl8192du/os_dep/usb_intf.c b/drivers/net/wireless/rtl8192du/os_dep/usb_intf.c
new file mode 100644
index 0000000..2cedd2d
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/usb_intf.c
@@ -0,0 +1,1060 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _HCI_INTF_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+#include <recv_osdep.h>
+#include <xmit_osdep.h>
+#include <hal_intf.h>
+#include <usb_vendor_req.h>
+#include <usb_ops.h>
+#include <usb_osintf.h>
+#include <usb_hal.h>
+#include <linux/vmalloc.h>
+#include <linux/nl80211.h>
+
+static int rtw_suspend(struct usb_interface *intf, pm_message_t message);
+static int rtw_resume(struct usb_interface *intf);
+int rtw_resume_process(struct rtw_adapter *padapter);
+
+static int rtw_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
+static void rtw_dev_remove(struct usb_interface *pusb_intf);
+
+#define USB_VENDER_ID_REALTEK		0x0BDA
+
+#define RTL8192D_USB_IDS \
+	/*=== Realtek demoboard ===*/ \
+	/****** 8192DU ********/ \
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8193)},/* 8192DU-VC */ \
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8194)},/* 8192DU-VS */ \
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8111)},/* Realtek 5G dongle for WiFi Display */ \
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x0193)},/* 8192DE-VAU */ \
+	/*=== Customer ID ===*/ \
+	/****** 8192DU-VC ********/ \
+	{USB_DEVICE(0x2019, 0xAB2C)},/* PCI - Abocm */ \
+	{USB_DEVICE(0x2019, 0x4903)},/* PCI - ETOP */ \
+	{USB_DEVICE(0x2019, 0x4904)},/* PCI - ETOP */ \
+	{USB_DEVICE(0x07B8, 0x8193)},/* Abocom - Abocom */ \
+	/****** 8192DU-VS ********/ \
+	{USB_DEVICE(0x20F4, 0x664B)}, /* TRENDnet - Cameo */ \
+	{USB_DEVICE(0x04DD, 0x954F)},  /* Sharp */ \
+	{USB_DEVICE(0x04DD, 0x96A6)},  /* Sharp */ \
+	{USB_DEVICE(0x050D, 0x110A)}, /* Belkin - Edimax */ \
+	{USB_DEVICE(0x050D, 0x1105)}, /* Belkin - Edimax */ \
+	{USB_DEVICE(0x050D, 0x120A)}, /* Belkin - Edimax */ \
+	{USB_DEVICE(0x1668, 0x8102)}, /*  -  */ \
+	{USB_DEVICE(0x0BDA, 0xE194)}, /*  - Edimax */ \
+	/****** 8192DU-WiFi Display Dongle ********/ \
+	{USB_DEVICE(0x2019, 0xAB2D)},/* Planex - Abocom ,5G dongle for WiFi Display */
+
+	#undef RTL8192C_USB_IDS
+	#define RTL8192C_USB_IDS
+
+static struct usb_device_id rtw_usb_id_tbl[] ={
+	RTL8192D_USB_IDS
+	{}	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl);
+
+static int const rtw_usb_id_len = sizeof(rtw_usb_id_tbl) / sizeof(struct usb_device_id);
+
+static struct specific_device_id specific_device_id_tbl[] = {
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x8177, .flags=SPEC_DEV_ID_DISABLE_HT},/* 8188cu 1*1 dongole, (b/g mode only) */
+	{.idVendor=USB_VENDER_ID_REALTEK, .idProduct=0x817E, .flags=SPEC_DEV_ID_DISABLE_HT},/* 8188CE-VAU USB minCard (b/g mode only) */
+	{.idVendor=0x0b05, .idProduct=0x1791, .flags=SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor=0x13D3, .idProduct=0x3311, .flags=SPEC_DEV_ID_DISABLE_HT},
+	{.idVendor=0x13D3, .idProduct=0x3359, .flags=SPEC_DEV_ID_DISABLE_HT},/* Russian customer -Azwave (8188CE-VAU  g mode) */
+	{}
+};
+
+struct rtw_usb_drv {
+	struct usb_driver usbdrv;
+	int drv_registered;
+};
+
+static struct usb_device_id rtl8192d_usb_id_tbl[] ={
+	RTL8192D_USB_IDS
+	{}	/* Terminating entry */
+};
+
+static struct rtw_usb_drv rtl8192d_usb_drv = {
+	.usbdrv.name = (char*)"rtl8192du",
+	.usbdrv.probe = rtw_drv_init,
+	.usbdrv.disconnect = rtw_dev_remove,
+	.usbdrv.id_table = rtl8192d_usb_id_tbl,
+	.usbdrv.suspend =  rtw_suspend,
+	.usbdrv.resume = rtw_resume,
+	#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+	.usbdrv.reset_resume   = rtw_resume,
+	#endif
+	#ifdef CONFIG_AUTOSUSPEND
+	.usbdrv.supports_autosuspend = 1,
+	#endif
+};
+static struct rtw_usb_drv *usb_drv = &rtl8192d_usb_drv;
+
+static inline int RT_usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
+}
+
+static inline int RT_usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
+}
+
+static inline int RT_usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT);
+}
+
+static inline int RT_usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK);
+}
+
+static inline int RT_usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (RT_usb_endpoint_xfer_bulk(epd) && RT_usb_endpoint_dir_in(epd));
+}
+
+static inline int RT_usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd)
+{
+	return (RT_usb_endpoint_xfer_bulk(epd) && RT_usb_endpoint_dir_out(epd));
+}
+
+static inline int RT_usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (RT_usb_endpoint_xfer_int(epd) && RT_usb_endpoint_dir_in(epd));
+}
+
+static inline int RT_usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+}
+
+static u8 rtw_init_intf_priv(struct dvobj_priv *dvobj)
+{
+	u8 rst = _SUCCESS;
+
+	_rtw_mutex_init(&dvobj->usb_vendor_req_mutex);
+
+	dvobj->usb_alloc_vendor_req_buf = kzalloc(MAX_USB_IO_CTL_SIZE, GFP_KERNEL);
+	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
+		DBG_8192D("alloc usb_vendor_req_buf failed... /n");
+		rst = _FAIL;
+		goto exit;
+	}
+	dvobj->usb_vendor_req_buf  =
+		(u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(dvobj->usb_alloc_vendor_req_buf), ALIGNMENT_UNIT);
+exit:
+	return rst;
+}
+
+static u8 rtw_deinit_intf_priv(struct dvobj_priv *dvobj)
+{
+	u8 rst = _SUCCESS;
+
+	kfree(dvobj->usb_alloc_vendor_req_buf);
+	_rtw_mutex_free(&dvobj->usb_vendor_req_mutex);
+	return rst;
+}
+
+static struct dvobj_priv *usb_dvobj_init(struct usb_interface *usb_intf)
+{
+	int	i;
+	u8	val8;
+	int	status = _FAIL;
+	struct dvobj_priv *pdvobjpriv = NULL;
+	struct usb_device				*pusbd;
+	struct usb_host_config			*phost_conf;
+	struct usb_config_descriptor		*pconf_desc;
+	struct usb_host_interface		*phost_iface;
+	struct usb_interface_descriptor	*piface_desc;
+	struct usb_host_endpoint		*phost_endp;
+	struct usb_endpoint_descriptor	*pendp_desc;
+
+	pdvobjpriv = (struct dvobj_priv*)kzalloc(sizeof(*pdvobjpriv), GFP_KERNEL);
+	if (!pdvobjpriv)
+		goto exit;
+
+	_rtw_mutex_init(&pdvobjpriv->hw_init_mutex);
+	_rtw_mutex_init(&pdvobjpriv->h2c_fwcmd_mutex);
+	_rtw_mutex_init(&pdvobjpriv->setch_mutex);
+	_rtw_mutex_init(&pdvobjpriv->setbw_mutex);
+
+	pdvobjpriv->pusbintf = usb_intf ;
+	pusbd = pdvobjpriv->pusbdev = interface_to_usbdev(usb_intf);
+	usb_set_intfdata(usb_intf, pdvobjpriv);
+
+	pdvobjpriv->RtNumInPipes = 0;
+	pdvobjpriv->RtNumOutPipes = 0;
+
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+
+	phost_iface = &usb_intf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+
+	pdvobjpriv->NumInterfaces = pconf_desc->bNumInterfaces;
+	pdvobjpriv->InterfaceNumber = piface_desc->bInterfaceNumber;
+	pdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;
+
+	for (i = 0; i < pdvobjpriv->nr_endpoint; i++) {
+		phost_endp = phost_iface->endpoint + i;
+		if (phost_endp) {
+			pendp_desc = &phost_endp->desc;
+
+			DBG_8192D("\nusb_endpoint_descriptor(%d):\n", i);
+			DBG_8192D("bLength=%x\n",pendp_desc->bLength);
+			DBG_8192D("bDescriptorType=%x\n",pendp_desc->bDescriptorType);
+			DBG_8192D("bEndpointAddress=%x\n",pendp_desc->bEndpointAddress);
+			DBG_8192D("wMaxPacketSize=%x\n",le16_to_cpu(pendp_desc->wMaxPacketSize));
+			DBG_8192D("bInterval=%x\n",pendp_desc->bInterval);
+
+			if (RT_usb_endpoint_is_bulk_in(pendp_desc)) {
+				DBG_8192D("RT_usb_endpoint_is_bulk_in = %x\n", RT_usb_endpoint_num(pendp_desc));
+				pdvobjpriv->RtNumInPipes++;
+			} else if (RT_usb_endpoint_is_int_in(pendp_desc)) {
+				DBG_8192D("RT_usb_endpoint_is_int_in = %x, Interval = %x\n", RT_usb_endpoint_num(pendp_desc),pendp_desc->bInterval);
+				pdvobjpriv->RtNumInPipes++;
+			} else if (RT_usb_endpoint_is_bulk_out(pendp_desc)) {
+				DBG_8192D("RT_usb_endpoint_is_bulk_out = %x\n", RT_usb_endpoint_num(pendp_desc));
+				pdvobjpriv->RtNumOutPipes++;
+			}
+			pdvobjpriv->ep_num[i] = RT_usb_endpoint_num(pendp_desc);
+		}
+	}
+
+	DBG_8192D("nr_endpoint=%d, in_num=%d, out_num=%d\n\n", pdvobjpriv->nr_endpoint, pdvobjpriv->RtNumInPipes, pdvobjpriv->RtNumOutPipes);
+
+	if (pusbd->speed == USB_SPEED_HIGH) {
+		pdvobjpriv->ishighspeed = true;
+		DBG_8192D("USB_SPEED_HIGH\n");
+	} else {
+		pdvobjpriv->ishighspeed = false;
+		DBG_8192D("NON USB_SPEED_HIGH\n");
+	}
+
+	if (rtw_init_intf_priv(pdvobjpriv) == _FAIL) {
+		RT_TRACE(_module_os_intfs_c_,_drv_err_,("\n Can't INIT rtw_init_intf_priv\n"));
+		goto free_dvobj;
+	}
+
+	/* 3 misc */
+	_rtw_init_sema(&(pdvobjpriv->usb_suspend_sema), 0);
+
+	rtw_reset_continual_urb_error(pdvobjpriv);
+
+	usb_get_dev(pusbd);
+
+	status = _SUCCESS;
+
+free_dvobj:
+	if (status != _SUCCESS && pdvobjpriv) {
+		usb_set_intfdata(usb_intf, NULL);
+		_rtw_mutex_free(&pdvobjpriv->hw_init_mutex);
+		_rtw_mutex_free(&pdvobjpriv->h2c_fwcmd_mutex);
+		_rtw_mutex_free(&pdvobjpriv->setch_mutex);
+		_rtw_mutex_free(&pdvobjpriv->setbw_mutex);
+		kfree(pdvobjpriv);
+		pdvobjpriv = NULL;
+	}
+exit:
+
+	return pdvobjpriv;
+}
+
+static void usb_dvobj_deinit(struct usb_interface *usb_intf)
+{
+	struct dvobj_priv *dvobj = usb_get_intfdata(usb_intf);
+
+	usb_set_intfdata(usb_intf, NULL);
+	if (dvobj) {
+		/* Modify condition for 92DU DMDP 2010.11.18, by Thomas */
+		rtw_deinit_intf_priv(dvobj);
+		_rtw_mutex_free(&dvobj->hw_init_mutex);
+		_rtw_mutex_free(&dvobj->h2c_fwcmd_mutex);
+		_rtw_mutex_free(&dvobj->setch_mutex);
+		_rtw_mutex_free(&dvobj->setbw_mutex);
+		kfree(dvobj);
+	}
+
+	usb_put_dev(interface_to_usbdev(usb_intf));
+
+}
+
+static void decide_chip_type_by_usb_device_id(struct rtw_adapter *padapter, const struct usb_device_id *pdid)
+{
+	padapter->chip_type = NULL_CHIP_TYPE;
+	padapter->chip_type = RTL8192D;
+	padapter->HardwareType = HARDWARE_TYPE_RTL8192DU;
+	DBG_8192D("CHIP TYPE: RTL8192D\n");
+}
+
+static void usb_intf_start(struct rtw_adapter *padapter)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+usb_intf_start\n"));
+	rtw_hal_inirp_init(padapter);
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-usb_intf_start\n"));
+}
+
+static void usb_intf_stop(struct rtw_adapter *padapter)
+{
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+usb_intf_stop\n"));
+
+	/* disabel_hw_interrupt */
+	if (padapter->bSurpriseRemoved == false)
+	{
+		/* device still exists, so driver can do i/o operation */
+		/* TODO: */
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("SurpriseRemoved==false\n"));
+	}
+
+	/* cancel in irp */
+	rtw_hal_inirp_deinit(padapter);
+
+	/* cancel out irp */
+	rtw_write_port_cancel(padapter);
+
+	/* todo:cancel other irps */
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-usb_intf_stop\n"));
+}
+
+static void rtw_dev_unload(struct rtw_adapter *padapter)
+{
+	struct net_device *pnetdev= (struct net_device*)padapter->pnetdev;
+	u8 val8;
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_dev_unload\n"));
+
+	if (padapter->bup == true)
+	{
+		DBG_8192D("===> rtw_dev_unload\n");
+
+		padapter->bDriverStopped = true;
+		if (padapter->xmitpriv.ack_tx)
+			rtw_ack_tx_done(&padapter->xmitpriv, RTW_SCTX_DONE_DRV_STOP);
+
+		/* s3. */
+		if (padapter->intf_stop)
+			padapter->intf_stop(padapter);
+
+		/* s4. */
+		if (!padapter->pwrctrlpriv.bInternalAutoSuspend)
+		rtw_stop_drv_threads(padapter);
+
+		/* s5. */
+		if (padapter->bSurpriseRemoved == false) {
+#ifdef CONFIG_WOWLAN
+			if ((padapter->pwrctrlpriv.bSupportRemoteWakeup==true)&&(padapter->pwrctrlpriv.wowlan_mode==true)) {
+				DBG_8192D("%s bSupportWakeOnWlan==true  do not run rtw_hal_deinit()\n",__func__);
+			}
+			else
+#endif /* CONFIG_WOWLAN */
+			{
+				rtw_hal_deinit(padapter);
+			}
+			padapter->bSurpriseRemoved = true;
+		}
+
+		padapter->bup = false;
+#ifdef CONFIG_WOWLAN
+		padapter->hw_init_completed=false;
+#endif /* CONFIG_WOWLAN */
+	}
+	else
+	{
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("r871x_dev_unload():padapter->bup == false\n"));
+	}
+
+	DBG_8192D("<=== rtw_dev_unload\n");
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-rtw_dev_unload\n"));
+}
+
+static void process_spec_devid(const struct usb_device_id *pdid)
+{
+	u16 vid, pid;
+	u32 flags;
+	int i;
+	int num = sizeof(specific_device_id_tbl)/sizeof(struct specific_device_id);
+
+	for (i=0; i<num; i++)
+	{
+		vid = specific_device_id_tbl[i].idVendor;
+		pid = specific_device_id_tbl[i].idProduct;
+		flags = specific_device_id_tbl[i].flags;
+
+#ifdef CONFIG_80211N_HT
+		if ((pdid->idVendor==vid) && (pdid->idProduct==pid) && (flags&SPEC_DEV_ID_DISABLE_HT))
+		{
+			 rtw_ht_enable = 0;
+			 rtw_cbw40_enable = 0;
+			 rtw_ampdu_enable = 0;
+		}
+#endif
+
+	}
+}
+
+static int rtw_suspend(struct usb_interface *pusb_intf, pm_message_t message)
+{
+	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
+	struct rtw_adapter *padapter = dvobj->if1;
+	struct net_device *pnetdev = padapter->pnetdev;
+	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
+#ifdef CONFIG_WOWLAN
+	struct wowlan_ioctl_param poidparam;
+#endif /*  CONFIG_WOWLAN */
+	int ret = 0;
+	u32 start_time = rtw_get_current_time();
+
+	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
+
+	if ((!padapter->bup) || (padapter->bDriverStopped)||(padapter->bSurpriseRemoved))
+	{
+		DBG_8192D("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
+			padapter->bup, padapter->bDriverStopped,padapter->bSurpriseRemoved);
+		goto exit;
+	}
+
+	pwrpriv->bInSuspend = true;
+	rtw_cancel_all_timer(padapter);
+	LeaveAllPowerSaveMode(padapter);
+
+	_enter_pwrlock(&pwrpriv->lock);
+	/* s1. */
+	if (pnetdev)
+	{
+		netif_carrier_off(pnetdev);
+		rtw_netif_stop_queue(pnetdev);
+	}
+#ifdef CONFIG_WOWLAN
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup==true&&padapter->pwrctrlpriv.wowlan_mode==true) {
+		u8 ps_mode=PS_MODE_MIN;
+		/* set H2C command */
+		poidparam.subcode=WOWLAN_ENABLE;
+		rtw_hal_set_hwreg(padapter,HW_VAR_WOWLAN,(u8 *)&poidparam);
+	}
+	else
+#endif /* CONFIG_WOWLAN */
+	{
+		/* s2. */
+		rtw_disassoc_cmd(padapter, 0, false);
+	}
+
+#ifdef CONFIG_LAYER2_ROAMING_RESUME
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) && check_fwstate(pmlmepriv, _FW_LINKED))
+	{
+		DBG_8192D("%s:%d %s(%pM), length:%d assoc_ssid.length:%d\n",__func__, __LINE__,
+				pmlmepriv->cur_network.network.Ssid.Ssid,
+				pmlmepriv->cur_network.network.MacAddress,
+				pmlmepriv->cur_network.network.Ssid.SsidLength,
+				pmlmepriv->assoc_ssid.SsidLength);
+		rtw_set_roaming(padapter, 1);
+		}
+#endif
+	/* s2-2.  indicate disconnect to os */
+	rtw_indicate_disconnect(padapter);
+	/* s2-3. */
+	rtw_free_assoc_resources(padapter, 1);
+#ifdef CONFIG_AUTOSUSPEND
+	if (!pwrpriv->bInternalAutoSuspend)
+#endif
+	/* s2-4. */
+	rtw_free_network_queue(padapter, true);
+
+	rtw_dev_unload(padapter);
+#ifdef CONFIG_AUTOSUSPEND
+	pwrpriv->rf_pwrstate = rf_off;
+	pwrpriv->bips_processing = false;
+#endif
+	_exit_pwrlock(&pwrpriv->lock);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		rtw_indicate_scan_done(padapter, 1);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+		rtw_indicate_disconnect(padapter);
+
+exit:
+	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
+		, ret, rtw_get_passing_time_ms(start_time));
+
+	return ret;
+}
+
+static int rtw_resume(struct usb_interface *pusb_intf)
+{
+	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
+	struct rtw_adapter *padapter = dvobj->if1;
+	struct net_device *pnetdev = padapter->pnetdev;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	 int ret = 0;
+
+	if (pwrpriv->bInternalAutoSuspend) {
+		ret = rtw_resume_process(padapter);
+	} else {
+#ifdef CONFIG_RESUME_IN_WORKQUEUE
+		rtw_resume_in_workqueue(pwrpriv);
+#else
+		if (rtw_is_earlysuspend_registered(pwrpriv)
+			#ifdef CONFIG_WOWLAN
+			&& !padapter->pwrctrlpriv.wowlan_mode
+			#endif /* CONFIG_WOWLAN */
+		) {
+			/* jeff: bypass resume here, do in late_resume */
+			rtw_set_do_late_resume(pwrpriv, true);
+		} else {
+			ret = rtw_resume_process(padapter);
+		}
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+	}
+
+	return ret;
+}
+
+int rtw_resume_process(struct rtw_adapter *padapter)
+{
+	struct net_device *pnetdev;
+	struct pwrctrl_priv *pwrpriv = NULL;
+	int ret = -1;
+	u32 start_time = rtw_get_current_time();
+
+	DBG_8192D("==> %s (%s:%d)\n",__func__, current->comm, current->pid);
+
+	if (padapter) {
+		pnetdev= padapter->pnetdev;
+		pwrpriv = &padapter->pwrctrlpriv;
+	} else {
+		goto exit;
+	}
+
+	_enter_pwrlock(&pwrpriv->lock);
+	rtw_reset_drv_sw(padapter);
+	pwrpriv->bkeepfwalive = false;
+
+	DBG_8192D("bkeepfwalive(%x)\n",pwrpriv->bkeepfwalive);
+	if (pm_netdev_open(pnetdev,true) != 0)
+		goto exit;
+
+	netif_device_attach(pnetdev);
+	netif_carrier_on(pnetdev);
+
+#ifdef CONFIG_AUTOSUSPEND
+	if (pwrpriv->bInternalAutoSuspend) {
+		pwrpriv->bInternalAutoSuspend = false;
+		pwrpriv->brfoffbyhw = false;
+		DBG_8192D("enc_algorithm(%x),wepkeymask(%x)\n",
+			padapter->securitypriv.dot11PrivacyAlgrthm,pwrpriv->wepkeymask);
+		if (	(_WEP40_ == padapter->securitypriv.dot11PrivacyAlgrthm) ||
+			(_WEP104_ == padapter->securitypriv.dot11PrivacyAlgrthm))
+		{
+			int keyid;
+
+			for (keyid=0;keyid<4;keyid++) {
+				if (pwrpriv->wepkeymask & BIT(keyid)) {
+					if (keyid == padapter->securitypriv.dot11PrivacyKeyIndex)
+						rtw_set_key(padapter,&padapter->securitypriv, keyid, 1);
+					else
+						rtw_set_key(padapter,&padapter->securitypriv, keyid, 0);
+				}
+			}
+		}
+	}
+#endif
+	_exit_pwrlock(&pwrpriv->lock);
+
+	if (padapter->pid[1]!=0) {
+		DBG_8192D("pid[1]:%d\n",padapter->pid[1]);
+		rtw_signal_process(padapter->pid[1], SIGUSR2);
+	}
+
+	#ifdef CONFIG_LAYER2_ROAMING_RESUME
+	rtw_roaming(padapter, NULL);
+	#endif
+
+	ret = 0;
+exit:
+	#ifdef CONFIG_RESUME_IN_WORKQUEUE
+	rtw_unlock_suspend();
+	#endif /* CONFIG_RESUME_IN_WORKQUEUE */
+
+	if (pwrpriv)
+		pwrpriv->bInSuspend = false;
+	DBG_8192D("<===  %s return %d.............. in %dms\n", __func__
+		, ret, rtw_get_passing_time_ms(start_time));
+
+	return ret;
+}
+
+#ifdef CONFIG_AUTOSUSPEND
+void autosuspend_enter(struct rtw_adapter* padapter)
+{
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+
+	pwrpriv->bInternalAutoSuspend = true;
+	pwrpriv->bips_processing = true;
+
+	DBG_8192D("==>autosuspend_enter...........\n");
+
+	if (rf_off == pwrpriv->change_rfpwrstate)
+	{
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+		usb_enable_autosuspend(dvobj->pusbdev);
+		#else
+		dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
+		#endif
+
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
+			usb_autopm_put_interface(dvobj->pusbintf);
+		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))
+			usb_autopm_enable(dvobj->pusbintf);
+		#else
+			usb_autosuspend_device(dvobj->pusbdev, 1);
+		#endif
+	}
+	#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+	DBG_8192D("...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
+	#else
+	DBG_8192D("...pm_usage_cnt(%d).....\n", dvobj->pusbintf->pm_usage_cnt);
+	#endif
+}
+
+int autoresume_enter(struct rtw_adapter* padapter)
+{
+	int result = _SUCCESS;
+	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
+	struct security_priv* psecuritypriv=&(padapter->securitypriv);
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct dvobj_priv *dvobj = adapter_to_dvobj(padapter);
+
+	DBG_8192D("====> autoresume_enter\n");
+
+	if (rf_off == pwrpriv->rf_pwrstate)
+	{
+		pwrpriv->ps_flag = false;
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,33))
+			if (usb_autopm_get_interface(dvobj->pusbintf) < 0)
+			{
+				DBG_8192D("can't get autopm: %d\n", result);
+				result = _FAIL;
+				goto error_exit;
+			}
+		#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,20))
+			usb_autopm_disable(dvobj->pusbintf);
+		#else
+			usb_autoresume_device(dvobj->pusbdev, 1);
+		#endif
+
+		#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+		DBG_8192D("...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
+		#else
+		DBG_8192D("...pm_usage_cnt(%d).....\n", dvobj->pusbintf->pm_usage_cnt);
+		#endif
+	}
+	DBG_8192D("<==== autoresume_enter\n");
+error_exit:
+
+	return result;
+}
+#endif
+
+static struct rtw_adapter *rtw_usb_if1_init(struct dvobj_priv *dvobj,
+					    struct usb_interface *pusb_intf,
+					    const struct usb_device_id *pdid)
+{
+	struct rtw_adapter *padapter = NULL;
+	struct net_device *pnetdev = NULL;
+	int status = _FAIL;
+
+	padapter = (struct rtw_adapter *)vzalloc(sizeof(*padapter));
+	if (!padapter)
+		goto exit;
+	padapter->dvobj = dvobj;
+	dvobj->if1 = padapter;
+
+	padapter->bDriverStopped=true;
+
+#if defined(CONFIG_CONCURRENT_MODE) || defined(CONFIG_DUALMAC_CONCURRENT)
+	/* set adapter_type/iface type for primary padapter */
+	padapter->isprimary = true;
+	padapter->adapter_type = PRIMARY_ADAPTER;
+	padapter->iface_id = IFACE_ID0;
+	#ifndef CONFIG_HWPORT_SWAP
+	padapter->iface_type = IFACE_PORT0;
+	#else
+	padapter->iface_type = IFACE_PORT1;
+	#endif
+	dvobj->padapters[dvobj->iface_nums++] = padapter;
+#endif
+
+	#ifndef RTW_DVOBJ_CHIP_HW_TYPE
+	/* step 1-1., decide the chip_type via vid/pid */
+	padapter->interface_type = RTW_USB;
+	decide_chip_type_by_usb_device_id(padapter, pdid);
+	#endif
+
+	if ((pnetdev = rtw_init_netdev(padapter)) == NULL) {
+		goto free_adapter;
+	}
+	SET_NETDEV_DEV(pnetdev, dvobj_to_dev(dvobj));
+	padapter = rtw_netdev_priv(pnetdev);
+
+	if (rtw_handle_dualmac(padapter, 1) != _SUCCESS)
+		goto free_adapter;
+
+	if (rtw_wdev_alloc(padapter, dvobj_to_dev(dvobj)) != 0)
+		goto handle_dualmac;
+
+	/* step 2. hook HalFunc, allocate HalData */
+	if (padapter->chip_type == RTL8192D) {
+		rtl8192du_set_hal_ops(padapter);
+	} else {
+		DBG_8192D("Detect NULL_CHIP_TYPE\n");
+		goto free_wdev;
+	}
+
+	/* step 3. */
+	padapter->intf_start=&usb_intf_start;
+	padapter->intf_stop=&usb_intf_stop;
+
+	/* 2 */
+	if ((rtw_init_io_priv(padapter, usb_set_intf_ops)) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("\n Can't init io_reqs\n"));
+		goto free_hal_data;
+	}
+
+	rtw_hal_read_chip_version(padapter);
+
+	/* 4 usb endpoint mapping */
+	rtw_hal_chip_configure(padapter);
+
+	/* step 4. read efuse/eeprom data and get mac_addr */
+	rtw_hal_read_chip_info(padapter);
+
+	/* step 5. */
+	if (rtw_init_drv_sw(padapter) == _FAIL) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("Initialize driver software resource Failed!\n"));
+		goto free_hal_data;
+	}
+
+#ifdef CONFIG_PM
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
+	if (padapter->pwrctrlpriv.bSupportRemoteWakeup)
+	{
+		dvobj->pusbdev->do_remote_wakeup=1;
+		pusb_intf->needs_remote_wakeup = 1;
+		device_init_wakeup(&pusb_intf->dev, 1);
+		DBG_8192D("\n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
+		DBG_8192D("\n  padapter->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",device_may_wakeup(&pusb_intf->dev));
+	}
+#endif
+#endif
+
+#ifdef CONFIG_AUTOSUSPEND
+	if (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)
+	{
+		if (padapter->registrypriv.usbss_enable) {	/* autosuspend (2s delay) */
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,38))
+			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
+			#else
+			dvobj->pusbdev->autosuspend_delay = 0 * HZ;/* 15 * HZ; idle-delay time */
+			#endif
+
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+			usb_enable_autosuspend(dvobj->pusbdev);
+			#elif  (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
+			padapter->bDisableAutosuspend = dvobj->pusbdev->autosuspend_disabled ;
+			dvobj->pusbdev->autosuspend_disabled = 0;/* autosuspend disabled by the user */
+			#endif
+
+			usb_autopm_get_interface(dvobj->pusbintf);/* init pm_usage_cnt ,let it start from 1 */
+
+			#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,32))
+			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, atomic_read(&(dvobj->pusbintf ->pm_usage_cnt)));
+			#else
+			DBG_8192D("%s...pm_usage_cnt(%d).....\n",__func__, dvobj->pusbintf ->pm_usage_cnt);
+			#endif
+		}
+	}
+#endif
+
+	/*  alloc dev name after read efuse. */
+	rtw_init_netdev_name(pnetdev, padapter->registrypriv.ifname);
+	rtw_macaddr_cfg(padapter->eeprompriv.mac_addr);
+	rtw_init_wifidirect_addrs(padapter, padapter->eeprompriv.mac_addr, padapter->eeprompriv.mac_addr);
+	memcpy(pnetdev->dev_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);
+	DBG_8192D("MAC Address from pnetdev->dev_addr= %pM\n", pnetdev->dev_addr);
+
+#ifdef CONFIG_HOSTAPD_MLME
+	hostapd_mode_init(padapter);
+#endif
+
+	/* step 6. Tell the network stack we exist */
+	if (register_netdev(pnetdev) != 0) {
+		RT_TRACE(_module_hci_intfs_c_,_drv_err_,("register_netdev() failed\n"));
+		goto free_hal_data;
+	}
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-drv_init - adapter->bDriverStopped=%d, adapter->bSurpriseRemoved=%d\n",padapter->bDriverStopped, padapter->bSurpriseRemoved));
+	DBG_8192D("bDriverStopped:%d, bSurpriseRemoved:%d, bup:%d, hw_init_completed:%d\n"
+		,padapter->bDriverStopped
+		,padapter->bSurpriseRemoved
+		,padapter->bup
+		,padapter->hw_init_completed
+	);
+
+	status = _SUCCESS;
+
+free_hal_data:
+	if (status != _SUCCESS && padapter->HalData)
+		kfree(padapter->HalData);
+free_wdev:
+	if (status != _SUCCESS) {
+		rtw_wdev_unregister(padapter->rtw_wdev);
+		rtw_wdev_free(padapter->rtw_wdev);
+	}
+handle_dualmac:
+	if (status != _SUCCESS)
+		rtw_handle_dualmac(padapter, 0);
+free_adapter:
+	if (status != _SUCCESS) {
+		if (pnetdev)
+			rtw_free_netdev(pnetdev);
+		else if (padapter)
+			vfree(padapter);
+		padapter = NULL;
+	}
+exit:
+	return padapter;
+}
+
+static void rtw_usb_if1_deinit(struct rtw_adapter *if1)
+{
+	struct net_device *pnetdev = if1->pnetdev;
+	struct mlme_priv *pmlmepriv= &if1->mlmepriv;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED))
+		rtw_disassoc_cmd(if1, 0, false);
+
+#ifdef CONFIG_92D_AP_MODE
+	free_mlme_ap_info(if1);
+	#ifdef CONFIG_HOSTAPD_MLME
+	hostapd_mode_unload(if1);
+	#endif
+#endif
+
+	if (if1->DriverState != DRIVER_DISAPPEAR)
+	{
+		if (pnetdev) {
+			unregister_netdev(pnetdev); /* will call netdev_close() */
+			rtw_proc_remove_one(pnetdev);
+		}
+	}
+
+	rtw_cancel_all_timer(if1);
+#ifdef CONFIG_WOWLAN
+	if1->pwrctrlpriv.wowlan_mode=false;
+#endif /* CONFIG_WOWLAN */
+	rtw_dev_unload(if1);
+
+	DBG_8192D("%s, hw_init_completed=%d\n", __func__, if1->hw_init_completed);
+
+	/* s6. */
+	rtw_handle_dualmac(if1, 0);
+
+	rtw_wdev_unregister(if1->rtw_wdev);
+	rtw_wdev_free(if1->rtw_wdev);
+
+	rtw_free_drv_sw(if1);
+
+	if (pnetdev)
+		rtw_free_netdev(pnetdev);
+}
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us to support.
+ *        We accept the new device by returning 0.
+*/
+
+static struct rtw_adapter  *rtw_sw_export = NULL;
+
+static int rtw_drv_init(struct usb_interface *pusb_intf, const struct usb_device_id *did)
+{
+	uint status = _FAIL;
+	struct rtw_adapter *if1 = NULL, *if2 = NULL;
+	struct dvobj_priv *dvobj = NULL;
+#ifdef CONFIG_MULTI_VIR_IFACES
+	int i;
+#endif /* CONFIG_MULTI_VIR_IFACES */
+
+	/* step 0. */
+	process_spec_devid(did);
+
+	/* Initialize dvobj_priv */
+	if ((dvobj = usb_dvobj_init(pusb_intf)) == NULL) {
+		RT_TRACE(_module_hci_intfs_c_, _drv_err_, ("initialize device object priv Failed!\n"));
+		goto exit;
+	}
+
+	/* Initialize if1 */
+	if ((if1 = rtw_usb_if1_init(dvobj, pusb_intf, did)) == NULL) {
+		DBG_8192D("rtw_usb_if1_init Failed!\n");
+		goto free_dvobj;
+	}
+
+	/* Initialize if2 */
+#ifdef CONFIG_CONCURRENT_MODE
+	if ((if2 = rtw_drv_if2_init(if1, NULL, usb_set_intf_ops)) == NULL) {
+		goto free_if1;
+	}
+#ifdef CONFIG_MULTI_VIR_IFACES
+	for (i=0; i<if1->registrypriv.ext_iface_num;i++) {
+		if (rtw_drv_add_vir_if (if1, "wlan%d", usb_set_intf_ops) == NULL) {
+			DBG_8192D("rtw_drv_add_iface failed! (%d)\n", i);
+			break;
+		}
+	}
+#endif /* CONFIG_MULTI_VIR_IFACES */
+#endif
+
+	status = _SUCCESS;
+
+free_if1:
+	if (status != _SUCCESS && if1)
+		rtw_usb_if1_deinit(if1);
+free_dvobj:
+	if (status != _SUCCESS)
+		usb_dvobj_deinit(pusb_intf);
+exit:
+	return status == _SUCCESS ? 0 : -ENODEV;
+}
+
+/*
+ * dev_remove() - our device is being removed
+*/
+/* rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both */
+static void rtw_dev_remove(struct usb_interface *pusb_intf)
+{
+	struct dvobj_priv *dvobj = usb_get_intfdata(pusb_intf);
+	struct rtw_adapter *padapter = dvobj->if1;
+	struct wireless_dev *pwdev = padapter->rtw_wdev;
+
+	DBG_8192D("+rtw_dev_remove\n");
+
+	if (usb_drv->drv_registered )
+		padapter->bSurpriseRemoved = true;
+
+	/* to avoid WARN_ON in __cfg80211_disconnected() */
+	pwdev->iftype = NL80211_IFTYPE_STATION;
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
+	rtw_unregister_early_suspend(&padapter->pwrctrlpriv);
+#endif
+
+	rtw_pm_set_ips(padapter, IPS_NONE);
+	rtw_pm_set_lps(padapter, PS_MODE_ACTIVE);
+
+	LeaveAllPowerSaveMode(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_MULTI_VIR_IFACES
+	rtw_drv_stop_vir_ifaces(dvobj);
+#endif /* CONFIG_MULTI_VIR_IFACES */
+	rtw_drv_if2_stop(dvobj->if2);
+#endif	/* CONFIG_CONCURRENT_MODE */
+
+	rtw_usb_if1_deinit(padapter);
+
+#ifdef CONFIG_CONCURRENT_MODE
+#ifdef CONFIG_MULTI_VIR_IFACES
+	rtw_drv_free_vir_ifaces(dvobj);
+#endif /* CONFIG_MULTI_VIR_IFACES */
+	rtw_drv_if2_free(dvobj->if2);
+#endif /* CONFIG_CONCURRENT_MODE */
+
+	usb_dvobj_deinit(pusb_intf);
+
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("-dev_remove()\n"));
+	DBG_8192D("-r871xu_dev_remove, done\n");
+
+	return;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
+extern int console_suspend_enabled;
+#endif
+
+static int __init rtw_drv_entry(void)
+{
+	rtw_suspend_lock_init();
+	usb_drv->drv_registered = true;
+	return usb_register(&usb_drv->usbdrv);
+}
+
+static void __exit rtw_drv_halt(void)
+{
+	RT_TRACE(_module_hci_intfs_c_,_drv_err_,("+rtw_drv_halt\n"));
+	DBG_8192D("+rtw_drv_halt\n");
+
+	rtw_suspend_lock_uninit();
+
+	usb_drv->drv_registered = false;
+	usb_deregister(&usb_drv->usbdrv);
+
+	DBG_8192D("-rtw_drv_halt\n");
+}
+
+module_init(rtw_drv_entry);
+module_exit(rtw_drv_halt);
+
+#ifdef CONFIG_WOWLAN
+#ifdef CONFIG_WOWLAN_MANUAL
+
+int rtw_resume_toshiba(struct rtw_adapter * adapter)
+{
+	struct dvobj_priv *pdvobjpriv;
+	pdvobjpriv = adapter_to_dvobj(adapter);
+
+	rtw_resume(pdvobjpriv->pusbintf);
+	return 0;
+}
+
+int rtw_suspend_toshiba(struct rtw_adapter * adapter)
+{
+	pm_message_t msg;
+	struct dvobj_priv *pdvobjpriv;
+	pdvobjpriv = adapter_to_dvobj(adapter);
+	msg.event=0;
+	/* for Toshiba only, they should call rtw_suspend before suspend */
+	rtw_suspend(pdvobjpriv->pusbintf, msg);
+	return 0;
+}
+EXPORT_SYMBOL(rtw_suspend_toshiba);
+EXPORT_SYMBOL(rtw_resume_toshiba);
+#endif /* CONFIG_WOWLAN_MANUAL */
+#endif /* CONFIG_WOWLAN */
diff --git a/drivers/net/wireless/rtl8192du/os_dep/usb_ops_linux.c b/drivers/net/wireless/rtl8192du/os_dep/usb_ops_linux.c
new file mode 100644
index 0000000..e8b6333
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/usb_ops_linux.c
@@ -0,0 +1,365 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *******************************************************************************/
+#define _USB_OPS_LINUX_C_
+
+#include <drv_types.h>
+#include <usb_ops_linux.h>
+#include <rtw_sreset.h>
+
+unsigned int ffaddr2pipehdl(struct dvobj_priv *pdvobj, u32 addr)
+{
+	unsigned int pipe=0;
+	int ep_num=0;
+	struct rtw_adapter *padapter = pdvobj->if1;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct hal_data_8192du  *pHalData = GET_HAL_DATA(padapter);
+
+	if (addr == RECV_BULK_IN_ADDR) {
+		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtBulkInPipe);
+
+	} else if (addr == RECV_INT_IN_ADDR) {
+		pipe=usb_rcvbulkpipe(pusbd, pHalData->RtIntInPipe);
+
+	} else if (addr < HW_QUEUE_ENTRY) {
+		ep_num = pHalData->Queue2EPNum[addr];
+		pipe = usb_sndbulkpipe(pusbd, ep_num);
+	}
+
+	return pipe;
+}
+
+struct zero_bulkout_context{
+	void *pbuf;
+	void *purb;
+	void *pirp;
+	void *padapter;
+};
+
+static void usb_bulkout_zero_complete(struct urb *purb, struct pt_regs *regs)
+{
+	struct zero_bulkout_context *pcontext = (struct zero_bulkout_context *)purb->context;
+
+	if (pcontext) {
+		kfree(pcontext->pbuf);
+
+		if (pcontext->purb && (pcontext->purb==purb))
+			usb_free_urb(pcontext->purb);
+
+		kfree(pcontext);
+	}
+}
+
+static u32 usb_bulkout_zero(struct intf_hdl *pintfhdl, u32 addr)
+{
+	int pipe, status, len;
+	u32 ret;
+	unsigned char *pbuf;
+	struct zero_bulkout_context *pcontext;
+	struct urb *	purb = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)pintfhdl->padapter;
+	struct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);
+	struct usb_device *pusbd = pdvobj->pusbdev;
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||
+	    (padapter->pwrctrlpriv.pnp_bstop_trx))
+		return _FAIL;
+
+	pcontext = (struct zero_bulkout_context *)kzalloc(sizeof(struct zero_bulkout_context), GFP_KERNEL);
+
+	pbuf = (unsigned char *)kzalloc(sizeof(int), GFP_KERNEL);
+	purb = usb_alloc_urb(0, GFP_ATOMIC);
+
+	len = 0;
+	pcontext->pbuf = pbuf;
+	pcontext->purb = purb;
+	pcontext->pirp = NULL;
+	pcontext->padapter = padapter;
+
+	/* translate DMA FIFO addr to pipehandle */
+
+	usb_fill_bulk_urb(purb, pusbd, pipe, pbuf, len,
+			  usb_bulkout_zero_complete, pcontext);
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+
+	if (!status)
+		ret= _SUCCESS;
+	else
+		ret= _FAIL;
+
+	return ret;
+}
+
+void usb_read_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *rmem)
+{
+}
+
+void usb_write_mem(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+}
+
+void usb_read_port_cancel(struct intf_hdl *pintfhdl)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	struct rtw_adapter	*padapter = pintfhdl->padapter;
+	precvbuf = (struct recv_buf *)padapter->recvpriv.precv_buf;
+
+	DBG_8192D("%s\n", __func__);
+
+	padapter->bReadPortCancel = true;
+
+	for (i = 0; i < NR_RECVBUFF; i++) {
+
+		precvbuf->reuse = true;
+		if (precvbuf->purb)
+			usb_kill_urb(precvbuf->purb);
+		precvbuf++;
+	}
+}
+
+static void usb_write_port_complete(struct urb *purb, struct pt_regs *regs)
+{
+	long unsigned int irqL;
+	int i;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
+	struct rtw_adapter	*padapter = pxmitbuf->padapter;
+       struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+
+	switch (pxmitbuf->flags)
+	{
+		case VO_QUEUE_INX:
+			pxmitpriv->voq_cnt--;
+			break;
+		case VI_QUEUE_INX:
+			pxmitpriv->viq_cnt--;
+			break;
+		case BE_QUEUE_INX:
+			pxmitpriv->beq_cnt--;
+			break;
+		case BK_QUEUE_INX:
+			pxmitpriv->bkq_cnt--;
+			break;
+		case HIGH_QUEUE_INX:
+#ifdef CONFIG_92D_AP_MODE
+			rtw_chk_hi_queue_cmd(padapter);
+#endif
+			break;
+		default:
+			break;
+	}
+
+	if (padapter->bSurpriseRemoved || padapter->bDriverStopped ||padapter->bWritePortCancel)
+	{
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped(%d) OR bSurpriseRemoved(%d)", padapter->bDriverStopped, padapter->bSurpriseRemoved));
+		DBG_8192D("%s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->ext_tag(%x)\n",
+		__func__,padapter->bDriverStopped, padapter->bSurpriseRemoved,padapter->bReadPortCancel,pxmitbuf->ext_tag);
+
+		goto check_completion;
+	}
+
+	if (purb->status==0) {
+
+	} else {
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete : purb->status(%d) != 0\n", purb->status));
+		DBG_8192D("###=> urb_write_port_complete status(%d)\n",purb->status);
+		if ((purb->status==-EPIPE)||(purb->status==-EPROTO))
+		{
+			sreset_set_wifi_error_status(padapter, USB_WRITE_PORT_FAIL);
+		} else if (purb->status == -EINPROGRESS) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: EINPROGESS\n"));
+			goto check_completion;
+
+		} else if (purb->status == -ENOENT) {
+			DBG_8192D("%s: -ENOENT\n", __func__);
+			goto check_completion;
+
+		} else if (purb->status == -ECONNRESET) {
+			DBG_8192D("%s: -ECONNRESET\n", __func__);
+			goto check_completion;
+
+		} else if (purb->status == -ESHUTDOWN) {
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete: ESHUTDOWN\n"));
+			padapter->bDriverStopped=true;
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bDriverStopped=TRUE\n"));
+
+			goto check_completion;
+		}
+		else
+		{
+			padapter->bSurpriseRemoved=true;
+			DBG_8192D("bSurpriseRemoved=TRUE\n");
+			RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port_complete:bSurpriseRemoved=TRUE\n"));
+
+			goto check_completion;
+		}
+	}
+
+	#ifdef DBG_CONFIG_ERROR_DETECT
+	{
+		struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+		pHalData->srestpriv.last_tx_complete_time = rtw_get_current_time();
+	}
+	#endif
+
+check_completion:
+	rtw_sctx_done_err(&pxmitbuf->sctx,
+		purb->status ? RTW_SCTX_DONE_WRITE_PORT_ERR : RTW_SCTX_DONE_SUCCESS);
+
+	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+
+	{
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+
+}
+
+u32 usb_write_port(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *wmem)
+{
+	long unsigned int irqL;
+	unsigned int pipe;
+	int status;
+	u32 ret = _FAIL, bwritezero = false;
+	struct urb *purb = NULL;
+	struct rtw_adapter *padapter = (struct rtw_adapter *)pintfhdl->padapter;
+	struct dvobj_priv	*pdvobj = adapter_to_dvobj(padapter);
+	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)wmem;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
+	struct usb_device *pusbd = pdvobj->pusbdev;
+	struct pkt_attrib *pattrib = &pxmitframe->attrib;
+
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("+usb_write_port\n"));
+
+	if ((padapter->bDriverStopped) || (padapter->bSurpriseRemoved) ||(padapter->pwrctrlpriv.pnp_bstop_trx)) {
+		#ifdef DBG_TX
+		DBG_8192D(" DBG_TX %s:%d bDriverStopped%d, bSurpriseRemoved:%d, pnp_bstop_trx:%d\n",__func__, __LINE__
+			,padapter->bDriverStopped, padapter->bSurpriseRemoved, padapter->pwrctrlpriv.pnp_bstop_trx);
+		#endif
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port:(padapter->bDriverStopped ||padapter->bSurpriseRemoved ||adapter->pwrctrlpriv.pnp_bstop_trx)!!!\n"));
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_TX_DENY);
+		goto exit;
+	}
+
+	spin_lock_irqsave(&pxmitpriv->lock, irqL);
+
+	switch (addr)
+	{
+		case VO_QUEUE_INX:
+			pxmitpriv->voq_cnt++;
+			pxmitbuf->flags = VO_QUEUE_INX;
+			break;
+		case VI_QUEUE_INX:
+			pxmitpriv->viq_cnt++;
+			pxmitbuf->flags = VI_QUEUE_INX;
+			break;
+		case BE_QUEUE_INX:
+			pxmitpriv->beq_cnt++;
+			pxmitbuf->flags = BE_QUEUE_INX;
+			break;
+		case BK_QUEUE_INX:
+			pxmitpriv->bkq_cnt++;
+			pxmitbuf->flags = BK_QUEUE_INX;
+			break;
+		case HIGH_QUEUE_INX:
+			pxmitbuf->flags = HIGH_QUEUE_INX;
+			break;
+		default:
+			pxmitbuf->flags = MGT_QUEUE_INX;
+			break;
+	}
+
+	spin_unlock_irqrestore(&pxmitpriv->lock, irqL);
+
+	purb	= pxmitbuf->pxmit_urb[0];
+
+	/* translate DMA FIFO addr to pipehandle */
+	pipe = ffaddr2pipehdl(pdvobj, addr);
+
+#ifdef CONFIG_REDUCE_USB_TX_INT
+	if ((pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0) ||
+	    (pxmitbuf->ext_tag == true))
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	else
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+#endif
+
+	usb_fill_bulk_urb(purb, pusbd, pipe,
+				pxmitframe->buf_addr, /*  pxmitbuf->pbuf */
+				cnt,
+				usb_write_port_complete,
+				pxmitbuf);/* context is pxmitbuf */
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+	if (!status) {
+		#ifdef DBG_CONFIG_ERROR_DETECT
+		{
+			struct hal_data_8192du	*pHalData = GET_HAL_DATA(padapter);
+			pHalData->srestpriv.last_tx_time = rtw_get_current_time();
+		}
+		#endif
+	} else {
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_WRITE_PORT_ERR);
+		DBG_8192D("usb_write_port, status=%d\n", status);
+		RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_write_port(): usb_submit_urb, status=%x\n", status));
+
+		switch (status) {
+		case -ENODEV:
+			padapter->bDriverStopped=true;
+			break;
+		default:
+			break;
+		}
+		goto exit;
+	}
+	ret= _SUCCESS;
+	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("-usb_write_port\n"));
+
+exit:
+	if (ret != _SUCCESS)
+		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+
+	return ret;
+}
+
+void usb_write_port_cancel(struct intf_hdl *pintfhdl)
+{
+	int i, j;
+	struct rtw_adapter	*padapter = pintfhdl->padapter;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)padapter->xmitpriv.pxmitbuf;
+
+	DBG_8192D("%s\n", __func__);
+
+	padapter->bWritePortCancel = true;
+
+	for (i=0; i<NR_XMITBUFF; i++) {
+		for (j=0; j<8; j++) {
+			if (pxmitbuf->pxmit_urb[j]) {
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+			}
+		}
+		pxmitbuf++;
+	}
+
+	pxmitbuf = (struct xmit_buf*)padapter->xmitpriv.pxmit_extbuf;
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+		for (j=0; j<8; j++) {
+			if (pxmitbuf->pxmit_urb[j]) {
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+			}
+		}
+		pxmitbuf++;
+	}
+}
diff --git a/drivers/net/wireless/rtl8192du/os_dep/xmit_linux.c b/drivers/net/wireless/rtl8192du/os_dep/xmit_linux.c
new file mode 100644
index 0000000..18e1797
--- /dev/null
+++ b/drivers/net/wireless/rtl8192du/os_dep/xmit_linux.c
@@ -0,0 +1,266 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ *
+ ******************************************************************************/
+#define _XMIT_OSDEP_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#include <linux/if_ether.h>
+#include <linux/ip.h>
+#include <wifi.h>
+#include <mlme_osdep.h>
+#include <xmit_osdep.h>
+#include <osdep_intf.h>
+#include <usb_osintf.h>
+
+void rtw_set_tx_chksum_offload(struct sk_buff *pkt, struct pkt_attrib *pattrib)
+{
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	struct sk_buff *skb = (struct sk_buff *)pkt;
+	pattrib->hw_tcp_csum = 0;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_shinfo(skb)->nr_frags == 0)
+		{
+                        const struct iphdr *ip = ip_hdr(skb);
+                        if (ip->protocol == IPPROTO_TCP) {
+                                /*  TCP checksum offload by HW */
+                                DBG_8192D("CHECKSUM_PARTIAL TCP\n");
+                                pattrib->hw_tcp_csum = 1;
+                                /* skb_checksum_help(skb); */
+                        } else if (ip->protocol == IPPROTO_UDP) {
+                                skb_checksum_help(skb);
+                        } else {
+				DBG_8192D("%s-%d TCP CSUM offload Error!!\n", __func__, __LINE__);
+                                WARN_ON(1);     /* we need a WARN() */
+			    }
+		} else { /*  IP fragmentation case */
+			DBG_8192D("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __func__, __LINE__);
+			skb_checksum_help(skb);
+		}
+	}
+#endif
+}
+
+int rtw_os_xmit_resource_alloc(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 alloc_sz)
+{
+	int i;
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+
+	pxmitbuf->pallocated_buf = kzalloc(alloc_sz, GFP_KERNEL);
+	if (pxmitbuf->pallocated_buf == NULL)
+		return _FAIL;
+
+	pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
+	pxmitbuf->dma_transfer_addr = 0;
+
+	for (i = 0; i < 8; i++) {
+		pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (pxmitbuf->pxmit_urb[i] == NULL) {
+			DBG_8192D("pxmitbuf->pxmit_urb[i]==NULL");
+			return _FAIL;
+		}
+
+	}
+	return _SUCCESS;
+}
+
+void rtw_os_xmit_resource_free(struct rtw_adapter *padapter, struct xmit_buf *pxmitbuf,u32 free_sz)
+{
+	struct dvobj_priv	*pdvobjpriv = adapter_to_dvobj(padapter);
+	struct usb_device	*pusbd = pdvobjpriv->pusbdev;
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		if (pxmitbuf->pxmit_urb[i])
+			usb_free_urb(pxmitbuf->pxmit_urb[i]);
+	}
+	kfree(pxmitbuf->pallocated_buf);
+}
+
+void rtw_os_pkt_complete(struct rtw_adapter *padapter, struct sk_buff *pkt)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	u16	queue;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+
+	queue = skb_get_queue_mapping(pkt);
+	if (__netif_subqueue_stopped(padapter->pnetdev, queue) &&
+		(pxmitpriv->hwxmits[queue].accnt < NR_XMITFRAME/2))
+	{
+		netif_wake_subqueue(padapter->pnetdev, queue);
+	}
+#else
+	if (netif_queue_stopped(padapter->pnetdev))
+		netif_wake_queue(padapter->pnetdev);
+#endif
+
+	dev_kfree_skb_any(pkt);
+}
+
+void rtw_os_xmit_complete(struct rtw_adapter *padapter, struct xmit_frame *pxframe)
+{
+	if (pxframe->pkt)
+	{
+
+		rtw_os_pkt_complete(padapter, pxframe->pkt);
+
+	}
+
+	pxframe->pkt = NULL;
+}
+
+void rtw_os_xmit_schedule(struct rtw_adapter *padapter)
+{
+	struct xmit_priv *pxmitpriv;
+
+	if (!padapter)
+		return;
+
+	pxmitpriv = &padapter->xmitpriv;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	if (rtw_txframes_pending(padapter))
+	{
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+
+	spin_unlock_bh(&pxmitpriv->lock);
+}
+
+static int rtw_mlcst2unicst(struct rtw_adapter *padapter, struct sk_buff *skb)
+{
+	struct	sta_priv *pstapriv = &padapter->stapriv;
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct list_head *phead, *plist;
+	struct sk_buff *newskb;
+	struct sta_info *psta = NULL;
+	s32	res;
+
+#ifdef CONFIG_92D_AP_MODE
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+#endif
+	/* free sta asoc_queue */
+	while ((rtw_end_of_queue_search(phead, plist)) == false)
+	{
+		psta = container_of(plist, struct sta_info, asoc_list);
+
+		plist = plist->next;
+
+		/* avoid   come from STA1 and send back STA1 */
+		if (!memcmp(psta->hwaddr, &skb->data[6], 6))
+			continue;
+
+		newskb = skb_copy(skb, GFP_ATOMIC);
+
+		if (newskb) {
+			memcpy(newskb->data, psta->hwaddr, 6);
+			res = rtw_xmit(padapter, &newskb);
+			if (res < 0) {
+				DBG_8192D("%s()-%d: rtw_xmit() return error!\n", __func__, __LINE__);
+				pxmitpriv->tx_drop++;
+				dev_kfree_skb_any(newskb);
+			} else
+				pxmitpriv->tx_pkts++;
+		} else {
+			DBG_8192D("%s-%d: skb_copy() failed!\n", __func__, __LINE__);
+			pxmitpriv->tx_drop++;
+
+#ifdef CONFIG_92D_AP_MODE
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+#endif
+			return false;	/*  Caller shall tx this multicast frame via normal way. */
+		}
+	}
+
+#ifdef CONFIG_92D_AP_MODE
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+#endif
+	dev_kfree_skb_any(skb);
+	return true;
+}
+
+int rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev)
+{
+	struct rtw_adapter *padapter = (struct rtw_adapter *)rtw_netdev_priv(pnetdev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	s32 res = 0;
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	u16 queue;
+#endif
+
+	RT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("+xmit_enry\n"));
+
+	if (rtw_if_up(padapter) == false) {
+		RT_TRACE(_module_xmit_osdep_c_, _drv_err_, ("rtw_xmit_entry: rtw_if_up fail\n"));
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_8192D("DBG_TX_DROP_FRAME %s if_up fail\n", __func__);
+		#endif
+		goto drop_packet;
+	}
+
+#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
+	queue = skb_get_queue_mapping(pkt);
+	/* No free space for Tx, tx_worker is too slow */
+	if (pxmitpriv->hwxmits[queue].accnt > NR_XMITFRAME/2) {
+		netif_stop_subqueue(padapter->pnetdev, queue);
+		return NETDEV_TX_BUSY;
+	}
+#endif
+
+	if (!rtw_mc2u_disable
+		&& check_fwstate(pmlmepriv, WIFI_AP_STATE) == true
+		&& (IP_MCAST_MAC(pkt->data)
+			|| ICMPV6_MCAST_MAC(pkt->data))
+		&& (padapter->registrypriv.wifi_spec == 0)
+		)
+	{
+		if (pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4)) {
+			res = rtw_mlcst2unicst(padapter, pkt);
+			if (res == true) {
+				goto exit;
+			}
+		}
+	}
+
+	res = rtw_xmit(padapter, &pkt);
+	if (res < 0) {
+		#ifdef DBG_TX_DROP_FRAME
+		DBG_8192D("DBG_TX_DROP_FRAME %s rtw_xmit fail\n", __func__);
+		#endif
+		goto drop_packet;
+	}
+
+	pxmitpriv->tx_pkts++;
+	RT_TRACE(_module_xmit_osdep_c_, _drv_info_, ("rtw_xmit_entry: tx_pkts=%d\n", (u32)pxmitpriv->tx_pkts));
+	goto exit;
+
+drop_packet:
+	pxmitpriv->tx_drop++;
+	dev_kfree_skb_any(pkt);
+	RT_TRACE(_module_xmit_osdep_c_, _drv_notice_, ("rtw_xmit_entry: drop, tx_drop=%d\n", (u32)pxmitpriv->tx_drop));
+
+exit:
+
+	return 0;
+}
