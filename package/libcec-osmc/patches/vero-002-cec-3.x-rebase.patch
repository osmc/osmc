From 2b84be34961010cbe1851db8a0c5a246e65f98d0 Mon Sep 17 00:00:00 2001
From: mkreisl <manfred.kreisl@nexgo.de>
Date: Tue, 9 Jun 2015 00:45:17 +0200
Subject: [PATCH] Corrections for rebase to libcec version 3 - RPi2 tested
 successfully - i.MX6 build sucessfully

---
 include/cectypes.h                                 |   5 -
 src/lib/Makefile.am                                |  68 ----
 src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp | 379 ---------------------
 src/lib/adapter/IMX/IMXCECAdapterCommunication.h   | 139 --------
 src/lib/adapter/IMX/IMXCECAdapterDetection.cpp     |  42 ---
 src/lib/adapter/IMX/IMXCECAdapterDetection.h       |  36 --
 src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h    | 118 -------
 src/lib/adapter/IMX/mxc_hdmi-cec.h                 |  47 ---
 .../adapter/IMX/IMXCECAdapterCommunication.cpp     | 379 +++++++++++++++++++++
 .../adapter/IMX/IMXCECAdapterCommunication.h       | 139 ++++++++
 src/libcec/adapter/IMX/IMXCECAdapterDetection.cpp  |  42 +++
 src/libcec/adapter/IMX/IMXCECAdapterDetection.h    |  36 ++
 src/libcec/adapter/IMX/IMXCECAdapterMessageQueue.h | 118 +++++++
 src/libcec/adapter/IMX/mxc_hdmi-cec.h              |  47 +++
 src/libcec/cmake/CheckPlatformSupport.cmake        |  40 ++-
 src/libcec/env.h.in                                |   3 +
 16 files changed, 787 insertions(+), 851 deletions(-)
 delete mode 100644 src/lib/Makefile.am
 delete mode 100644 src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
 delete mode 100644 src/lib/adapter/IMX/IMXCECAdapterCommunication.h
 delete mode 100644 src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
 delete mode 100644 src/lib/adapter/IMX/IMXCECAdapterDetection.h
 delete mode 100644 src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
 delete mode 100644 src/lib/adapter/IMX/mxc_hdmi-cec.h
 create mode 100644 src/libcec/adapter/IMX/IMXCECAdapterCommunication.cpp
 create mode 100644 src/libcec/adapter/IMX/IMXCECAdapterCommunication.h
 create mode 100644 src/libcec/adapter/IMX/IMXCECAdapterDetection.cpp
 create mode 100644 src/libcec/adapter/IMX/IMXCECAdapterDetection.h
 create mode 100644 src/libcec/adapter/IMX/IMXCECAdapterMessageQueue.h
 create mode 100644 src/libcec/adapter/IMX/mxc_hdmi-cec.h

diff --git a/include/cectypes.h b/include/cectypes.h
index c43a921..675d641 100644
--- a/include/cectypes.h
+++ b/include/cectypes.h
@@ -321,11 +321,6 @@ namespace CEC {
 /*!
  * Mimimum client version
  */
-#define CEC_MIN_LIB_VERSION          2
-
-/*!
- * libCEC's major version number
- */
 #define CEC_MIN_LIB_VERSION          3
 
 #define MSGSTART                     0xFF
diff --git a/src/lib/Makefile.am b/src/lib/Makefile.am
deleted file mode 100644
index 6788303..0000000
--- a/src/lib/Makefile.am
+++ /dev/null
@@ -1,68 +0,0 @@
-lib_LTLIBRARIES = libcec.la
-library_includedir=$(includedir)/libcec
-library_include_HEADERS = ../../include/cec.h \
-                          ../../include/cecc.h \
-                          ../../include/cectypes.h \
-                          ../../include/cecloader.h
-
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = libcec.pc
-
-## libCEC core
-libcec_la_SOURCES = CECProcessor.cpp \
-                    LibCEC.cpp \
-                    LibCECC.cpp \
-                    CECClient.cpp \
-                    adapter/AdapterFactory.cpp \
-                    devices/CECAudioSystem.cpp \
-                    devices/CECBusDevice.cpp \
-                    devices/CECDeviceMap.cpp \
-                    devices/CECPlaybackDevice.cpp \
-                    devices/CECRecordingDevice.cpp \
-                    devices/CECTuner.cpp \
-                    devices/CECTV.cpp \
-                    implementations/ANCommandHandler.cpp \
-                    implementations/CECCommandHandler.cpp \
-                    implementations/SLCommandHandler.cpp \
-                    implementations/VLCommandHandler.cpp \
-                    implementations/RLCommandHandler.cpp \
-                    implementations/PHCommandHandler.cpp \
-                    implementations/RHCommandHandler.cpp \
-                    implementations/AQCommandHandler.cpp
-
-## server sockets, currently unused
-##libcec_la_SOURCES += platform/posix/serversocket.cpp
-
-## Pulse-Eight USB-CEC support
-if USE_P8_USB
-libcec_la_SOURCES += adapter/Pulse-Eight/USBCECAdapterMessage.cpp \
-                     adapter/Pulse-Eight/USBCECAdapterCommands.cpp \
-                     adapter/Pulse-Eight/USBCECAdapterCommunication.cpp \
-                     adapter/Pulse-Eight/USBCECAdapterMessageQueue.cpp \
-                     adapter/Pulse-Eight/USBCECAdapterDetection.cpp \
-                     platform/posix/serialport.cpp \
-                     platform/posix/os-edid.cpp \
-                     platform/adl/adl-edid.cpp \
-                     platform/nvidia/nv-edid.cpp
-endif
-
-## Raspberry Pi support
-if USE_RPI_API
-libcec_la_SOURCES += adapter/RPi/RPiCECAdapterDetection.cpp \
-                     adapter/RPi/RPiCECAdapterCommunication.cpp \
-                     adapter/RPi/RPiCECAdapterMessageQueue.cpp
-endif
-
-## CuBox (NXP) support
-if USE_TDA995X_API
-libcec_la_SOURCES += adapter/TDA995x/TDA995xCECAdapterDetection.cpp \
-                     adapter/TDA995x/TDA995xCECAdapterCommunication.cpp
-endif
-
-## i.MX6 support
-if USE_IMX_API
-libcec_la_SOURCES += adapter/IMX/IMXCECAdapterDetection.cpp \
-                     adapter/IMX/IMXCECAdapterCommunication.cpp
-endif
-
-libcec_la_LDFLAGS = @LIBS_LIBCEC@ -version-info @VERSION@
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp b/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
deleted file mode 100644
index de5f282..0000000
--- a/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- * 
- * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
- *                     Copyright (C) 2014 by Matus Kral
- * 
- * You can redistribute this file and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- */
-
-#include "env.h"
-
-#if defined(HAVE_IMX_API)
-#include "IMXCECAdapterCommunication.h"
-
-#include "lib/CECTypeUtils.h"
-#include "lib/LibCEC.h"
-#include "lib/platform/sockets/cdevsocket.h"
-#include "lib/platform/util/StdString.h"
-#include "platform/util/util.h"
-
-using namespace std;
-using namespace CEC;
-using namespace PLATFORM;
-
-#include "IMXCECAdapterMessageQueue.h"
-
-#define LIB_CEC m_callback->GetLib()
-
-// these are defined in nxp private header file
-#define CEC_MSG_SUCCESS                 0x00	/*Message transmisson Succeed*/
-#define CEC_CSP_OFF_STATE               0x80	/*CSP in Off State*/
-#define CEC_BAD_REQ_SERVICE             0x81	/*Bad .req service*/
-#define CEC_MSG_FAIL_UNABLE_TO_ACCESS	0x82	/*Message transmisson failed: Unable to access CEC line*/
-#define CEC_MSG_FAIL_ARBITRATION_ERROR	0x83	/*Message transmisson failed: Arbitration error*/
-#define CEC_MSG_FAIL_BIT_TIMMING_ERROR	0x84	/*Message transmisson failed: Bit timming error*/
-#define CEC_MSG_FAIL_DEST_NOT_ACK       0x85	/*Message transmisson failed: Destination Address not aknowledged*/
-#define CEC_MSG_FAIL_DATA_NOT_ACK       0x86	/*Message transmisson failed: Databyte not acknowledged*/
-
-CIMXCECAdapterCommunication::CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback) :
-    IAdapterCommunication(callback),
-    m_PAReporter(NULL)
-{
-  CLockObject lock(m_mutex);
-
-  m_iNextMessage = 0;
-  m_logicalAddress = CECDEVICE_UNKNOWN;
-  m_bLogicalAddressRegistered = false;
-  m_bInitialised = false;
-  m_dev = new CCDevSocket(CEC_IMX_PATH);
-  m_physicalAddress = -1;
-}
-
-CIMXCECAdapterCommunication::~CIMXCECAdapterCommunication(void)
-{
-  Close();
-  DELETE_AND_NULL(m_PAReporter);
-  delete m_dev;
-  m_dev = 0;
-}
-
-bool CIMXCECAdapterCommunication::IsOpen(void)
-{
-  return IsInitialised() && m_dev->IsOpen();
-}
-
-bool CIMXCECAdapterCommunication::Open(uint32_t iTimeoutMs, bool UNUSED(bSkipChecks), bool bStartListening)
-{
-  if (m_dev->Open(iTimeoutMs))
-  {
-    if (!bStartListening || CreateThread()) {
-      if (m_dev->Ioctl(HDMICEC_IOC_STARTDEVICE, NULL) == 0) {
-        m_bInitialised = true;
-        RegisterLogicalAddress(CECDEVICE_BROADCAST);
-        return true;
-      }
-      LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to start device\n", __func__);
-    }
-    m_dev->Close();
-  }
-
-  return false;
-}
-
-
-void CIMXCECAdapterCommunication::Close(void)
-{
-  m_bInitialised = false;
-  if (m_dev->Ioctl(HDMICEC_IOC_STOPDEVICE, NULL) != 0)
-  {
-    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to stop device\n", __func__);
-  }
-  StopThread(false);
-  m_dev->Close();
-}
-
-
-std::string CIMXCECAdapterCommunication::GetError(void) const
-{
-  std::string strError(m_strError);
-  return strError;
-}
-
-
-cec_adapter_message_state CIMXCECAdapterCommunication::Write(
-  const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool UNUSED(bIsReply))
-{
-  unsigned char message[MAX_MESSAGE_LEN];
-  CIMXCECAdapterMessageQueueEntry *entry;
-  int msg_len = 1;
-  cec_adapter_message_state rc = ADAPTER_MESSAGE_STATE_ERROR;
-
-  bRetry = true;
-  if ((size_t)data.parameters.size + data.opcode_set + 1 > sizeof(message))
-  {
-    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: data size too large !", __func__);
-    bRetry = false;
-    return rc;
-  }
-
-  message[0] = (data.initiator << 4) | (data.destination & 0x0f);
-  if (data.opcode_set)
-  {
-    message[1] = data.opcode;
-    msg_len++;
-    memcpy(&message[2], data.parameters.data, data.parameters.size);
-    msg_len+=data.parameters.size;
-  }
-
-  entry = new CIMXCECAdapterMessageQueueEntry(message[0], data.opcode);
-  m_messageMutex.Lock();
-  uint32_t msgKey = ++m_iNextMessage;
-  m_messages.insert(make_pair(msgKey, entry));
-  m_messageMutex.Unlock();
-
-  if (m_dev->Write(message, msg_len) > 0)
-  { 
-    if (entry->Wait(data.transmit_timeout ? data.transmit_timeout : iLineTimeout *1000))
-    {
-      int status = entry->Result();
-
-      if (status == MESSAGE_TYPE_NOACK)
-        rc = ADAPTER_MESSAGE_STATE_SENT_NOT_ACKED;
-      else if (status == MESSAGE_TYPE_SEND_SUCCESS)
-        rc = ADAPTER_MESSAGE_STATE_SENT_ACKED;
-
-      bRetry = false;
-    }
-    else
-    {
-      rc = ADAPTER_MESSAGE_STATE_WAITING_TO_BE_SENT;
-#ifdef CEC_DEBUGGING
-      LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: command timed out !", __func__);
-#endif
-    }
-  }
-  else
-  {
-    Sleep(CEC_DEFAULT_TRANSMIT_RETRY_WAIT);
-#ifdef CEC_DEBUGGING
-    LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: write failed !", __func__);
-#endif
-  }
-
-  m_messageMutex.Lock();
-  m_messages.erase(msgKey);
-  m_messageMutex.Unlock();
-
-  delete entry;
-
-  return rc;
-}
-
-
-uint16_t CIMXCECAdapterCommunication::GetFirmwareVersion(void)
-{
-  /* FIXME add ioctl ? */
-  return 0;
-}
-
-
-cec_vendor_id CIMXCECAdapterCommunication::GetVendorId(void)
-{
-  return CEC_VENDOR_UNKNOWN;
-}
-
-
-uint16_t CIMXCECAdapterCommunication::GetPhysicalAddress(void)
-{
-  uint8_t phy_addr[4];
-  uint16_t pa_tmp;
-
-  if (m_dev->Ioctl(HDMICEC_IOC_GETPHYADDRESS, &phy_addr) != 0)
-  {
-    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_GETPHYADDRESS failed !", __func__);
-    return CEC_INVALID_PHYSICAL_ADDRESS; 
-  }
-
-  if ((pa_tmp = ((phy_addr[0] << 4 | phy_addr[1]) << 8) | (phy_addr[2] << 4 | phy_addr[3])))
-    m_physicalAddress = pa_tmp;
-
-  return m_physicalAddress;
-}
-
-
-cec_logical_addresses CIMXCECAdapterCommunication::GetLogicalAddresses(void)
-{
-  cec_logical_addresses addresses;
-  addresses.Clear();
-
-  CLockObject lock(m_mutex);
-  if (m_bLogicalAddressRegistered)
-    addresses.Set(m_logicalAddress);
-
-  return addresses;
-}
-
-void CIMXCECAdapterCommunication::HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress))
-{
-  UnregisterLogicalAddress();
-}
-
-bool CIMXCECAdapterCommunication::UnregisterLogicalAddress(void)
-{
-  {
-    CLockObject lock(m_mutex);
-    if (!m_bLogicalAddressRegistered)
-      return true;
-  }
-
-#ifdef CEC_DEBUGGING
-  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s - releasing previous logical address", __func__);
-#endif
-  return RegisterLogicalAddress(CECDEVICE_BROADCAST);
-}
-
-bool CIMXCECAdapterCommunication::RegisterLogicalAddress(const cec_logical_address address)
-{
-  {
-    CLockObject lock(m_mutex);
-    if ((m_logicalAddress == address && m_bLogicalAddressRegistered) ||
-        (m_logicalAddress == address && address == CECDEVICE_BROADCAST))
-    {
-      return true;
-    }
-  }
-
-#ifdef CEC_DEBUGGING
-  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %x to %x", __func__, m_logicalAddress, address);
-#endif
-
-  if (m_dev->Ioctl(HDMICEC_IOC_SETLOGICALADDRESS, (void *)address) != 0)
-  {
-    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_SETLOGICALADDRESS failed !", __func__);
-    return false;
-  }
-
-  CLockObject lock(m_mutex);
-
-  m_logicalAddress = address;
-  m_bLogicalAddressRegistered = (address != CECDEVICE_BROADCAST) ? true : false;
-  return true;
-}
-
-bool CIMXCECAdapterCommunication::SetLogicalAddresses(const cec_logical_addresses &addresses)
-{
-  int log_addr = addresses.primary;
-
-  return RegisterLogicalAddress((cec_logical_address)log_addr);
-}
-
-
-void *CIMXCECAdapterCommunication::Process(void)
-{
-  bool bHandled;
-  hdmi_cec_event event;
-  int ret;
-
-  cec_logical_address initiator, destination;
-
-  while (!IsStopped())
-  {
-    if (IsInitialised() && (ret = m_dev->Read((char *)&event, sizeof(event), 1000)) > 0)
-    {
-
-      initiator = cec_logical_address(event.msg[0] >> 4);
-      destination = cec_logical_address(event.msg[0] & 0x0f);
-
-        if (event.event_type == MESSAGE_TYPE_RECEIVE_SUCCESS)
-        {
-            cec_command cmd;
-
-            cec_command::Format(
-                cmd, initiator, destination,
-                ( event.msg_len > 1 ) ? cec_opcode(event.msg[1]) : CEC_OPCODE_NONE);
-
-            for( uint8_t i = 2; i < event.msg_len; i++ )
-                cmd.parameters.PushBack(event.msg[i]);
-
-            if (!IsStopped()) {
-              m_callback->OnCommandReceived(cmd);
-            }
-        }
-        else if (event.event_type == MESSAGE_TYPE_SEND_SUCCESS 
-                || event.event_type == MESSAGE_TYPE_NOACK)
-        {
-            bHandled = false;
-
-            m_messageMutex.Lock();
-            for (map<uint32_t, CIMXCECAdapterMessageQueueEntry *>::iterator it = m_messages.begin();
-              !bHandled && it != m_messages.end(); it++)
-              {
-                bHandled = it->second->Received(event.event_type, event.msg[0], (cec_opcode)event.msg[1]);
-              }
-            m_messageMutex.Unlock();
-
-            if (!bHandled)
-              LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: response not matched !", __func__);
-        }
-        else if (event.event_type == MESSAGE_TYPE_DISCONNECTED)
-        {
-            /* HDMI Hotplug event - disconnect */
-        }
-        else if (event.event_type == MESSAGE_TYPE_CONNECTED && m_physicalAddress != 0xffff)
-        {
-            /* HDMI Hotplug event - connect */
-            uint16_t oldAddress = m_physicalAddress;
-
-            if (oldAddress != GetPhysicalAddress()) {
-              if (m_PAReporter)
-                while (m_PAReporter->IsRunning()) Sleep(5);
-              delete m_PAReporter;
-
-              m_PAReporter = new CCECPAChangedReporter(m_callback, m_physicalAddress);
-              m_PAReporter->CreateThread(false);
-            }
-#ifdef CEC_DEBUGGING
-            LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: plugin event received", __func__);
-#endif
-        }
-        else
-            LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: unhandled response received %d!", __func__, event.event_type);
-    }
-  }
-
-  return 0;
-}
-
-CCECPAChangedReporter::CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA) :
-    m_callback(callback),
-    m_newPA(newPA)
-{
-}
-
-void* CCECPAChangedReporter::Process(void)
-{
-  m_callback->HandlePhysicalAddressChanged(m_newPA);
-  return NULL;
-}
-
-#endif	// HAVE_IMX_API
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.h b/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
deleted file mode 100644
index 7fe4acb..0000000
--- a/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
+++ /dev/null
@@ -1,139 +0,0 @@
-#pragma once
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- *
- * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
- *                     Copyright (C) 2014 by Matus Kral
- * 
- * You can redistribute this file and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- */
-
-#if defined(HAVE_IMX_API)
-
-#include "lib/platform/threads/mutex.h"
-#include "lib/platform/threads/threads.h"
-#include "lib/platform/sockets/socket.h"
-#include "lib/adapter/IMX/mxc_hdmi-cec.h"
-#include "lib/adapter/AdapterCommunication.h"
-#include <map>
-
-#define IMX_ADAPTER_VID 0x0471 /*FIXME TBD*/
-#define IMX_ADAPTER_PID 0x1001
-
-typedef struct hdmi_cec_event{
-  uint8_t event_type;
-  uint8_t msg_len;
-  uint8_t msg[MAX_MESSAGE_LEN];
-}hdmi_cec_event;
-
-
-namespace PLATFORM
-{
-  class CCDevSocket;
-};
-
-namespace CEC
-{
-  class CIMXCECAdapterMessageQueueEntry;
-
-  class CCECPAChangedReporter : public PLATFORM::CThread
-  {
-  public:
-    CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA);
-    void* Process(void);
-
-  private:
-    IAdapterCommunicationCallback *m_callback;
-    uint16_t                       m_newPA;
-  };
-
-  class CIMXCECAdapterCommunication : public IAdapterCommunication, public PLATFORM::CThread
-  {
-  public:
-    /*!
-     * @brief Create a new USB-CEC communication handler.
-     * @param callback The callback to use for incoming CEC commands.
-     */
-    CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback);
-    virtual ~CIMXCECAdapterCommunication(void);
-
-    /** @name IAdapterCommunication implementation */
-    ///{
-    bool Open(uint32_t iTimeoutMs = CEC_DEFAULT_CONNECT_TIMEOUT, bool bSkipChecks = false, bool bStartListening = true);
-    void Close(void);
-    bool IsOpen(void);
-    std::string GetError(void) const;
-    cec_adapter_message_state Write(const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool bIsReply);
-
-    bool SetLineTimeout(uint8_t UNUSED(iTimeout)) { return true; }
-    bool StartBootloader(void) { return false; }
-    bool SetLogicalAddresses(const cec_logical_addresses &addresses);
-    cec_logical_addresses GetLogicalAddresses(void);
-    bool PingAdapter(void) { return IsInitialised(); }
-    uint16_t GetFirmwareVersion(void);
-    uint32_t GetFirmwareBuildDate(void) { return 0; }
-    bool IsRunningLatestFirmware(void) { return true; }
-    bool PersistConfiguration(const libcec_configuration & UNUSED(configuration)) { return false; }
-    bool GetConfiguration(libcec_configuration & UNUSED(configuration)) { return false; }
-    std::string GetPortName(void) { return std::string("IMX"); }
-    uint16_t GetPhysicalAddress(void);
-    bool SetControlledMode(bool UNUSED(controlled)) { return true; }
-    cec_vendor_id GetVendorId(void);
-    void HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress));
-    bool SupportsSourceLogicalAddress(const cec_logical_address address) { return address > CECDEVICE_TV && address <= CECDEVICE_BROADCAST; }
-    cec_adapter_type GetAdapterType(void) { return ADAPTERTYPE_IMX; }
-    uint16_t GetAdapterVendorId(void) const { return IMX_ADAPTER_VID; }
-    uint16_t GetAdapterProductId(void) const { return IMX_ADAPTER_PID; }
-    void SetActiveSource(bool UNUSED(bSetTo), bool UNUSED(bClientUnregistered)) {}
-    ///}
-
-    /** @name PLATFORM::CThread implementation */
-    ///{
-    void *Process(void);
-    ///}
-
-  private:
-    bool IsInitialised(void) { return m_bInitialised; };
-    bool RegisterLogicalAddress(const cec_logical_address address);
-    bool UnregisterLogicalAddress(void);
-
-    std::string                 m_strError; /**< current error message */
-
-    cec_logical_address         m_logicalAddress;
-    uint16_t                    m_physicalAddress;
-
-    PLATFORM::CMutex            m_mutex;
-    PLATFORM::CCDevSocket       *m_dev;	/**< the device connection */
-    
-    PLATFORM::CMutex            m_messageMutex;
-    uint32_t                    m_iNextMessage;
-    std::map<uint32_t, CIMXCECAdapterMessageQueueEntry *> m_messages;
-
-    bool                        m_bLogicalAddressRegistered;
-    bool                        m_bInitialised;
-
-    CCECPAChangedReporter       *m_PAReporter;
-  };
-  
-};
-
-#endif
diff --git a/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp b/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
deleted file mode 100644
index 6c93c45..0000000
--- a/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- * 
- * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
- * 
- * You can redistribute this file and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- */
-
-#include "env.h"
-#include <stdio.h>
-
-#if defined(HAVE_IMX_API)
-#include "IMXCECAdapterDetection.h"
-
-
-using namespace CEC;
-
-bool CIMXCECAdapterDetection::FindAdapter(void)
-{
-  return access(CEC_IMX_PATH, 0) == 0;
-}
-
-#endif
diff --git a/src/lib/adapter/IMX/IMXCECAdapterDetection.h b/src/lib/adapter/IMX/IMXCECAdapterDetection.h
deleted file mode 100644
index d54891d..0000000
--- a/src/lib/adapter/IMX/IMXCECAdapterDetection.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#pragma once
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- * 
- * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
- * 
- * You can redistribute this file and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- */
-
-namespace CEC
-{
-  class CIMXCECAdapterDetection
-  {
-  public:
-    static bool FindAdapter(void);
-  };
-}
diff --git a/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h b/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
deleted file mode 100644
index 340b702..0000000
--- a/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
+++ /dev/null
@@ -1,118 +0,0 @@
-#pragma once
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- *
- * This program is dual-licensed; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- * Alternatively, you can license this library under a commercial license,
- * please contact Pulse-Eight Licensing for more information.
- *
- * For more information contact:
- * Pulse-Eight Licensing       <license@pulse-eight.com>
- *     http://www.pulse-eight.com/
- *     http://www.pulse-eight.net/
- */
-
-#include "lib/platform/threads/mutex.h"
-
-namespace CEC
-{
-  using namespace PLATFORM;
-  
-  class CIMXCECAdapterMessageQueueEntry
-  {
-  public:
-    CIMXCECAdapterMessageQueueEntry(uint8_t addrs, cec_opcode opcode)
-       : m_bWaiting(true), m_retval((uint32_t)-1), m_bSucceeded(false)
-    {
-      m_opcode = opcode;
-      m_addrs = addrs; 
-    }
-    
-    virtual ~CIMXCECAdapterMessageQueueEntry(void) {}
-
-    /*!
-     * @brief Query result from worker thread
-     */
-    uint32_t Result() const
-    {
-      return m_retval;
-    }
-    
-    /*!
-     * @brief Signal waiting threads
-     */
-    void Broadcast(void)
-    {
-      CLockObject lock(m_mutex);
-      m_condition.Broadcast();
-    }
-
-    /*!
-     * @brief Signal waiting thread(s) when message matches this entry
-     */
-    bool Received(int response, uint8_t addrs, cec_opcode opcode)
-    {
-      CLockObject lock(m_mutex);
-
-      if (!(m_addrs == addrs && m_opcode == opcode))
-        return false;
-
-      m_retval = response;
-      m_bSucceeded = true;
-      m_condition.Signal();
-      return true;
-    }
-
-    /*!
-     * @brief Wait for a response to this command.
-     * @param iTimeout The timeout to use while waiting.
-     * @return True when a response was received before the timeout passed, false otherwise.
-     */
-    bool Wait(uint32_t iTimeout)
-    {
-      CLockObject lock(m_mutex);
-      
-      bool bReturn = m_bSucceeded ? true : m_condition.Wait(m_mutex, m_bSucceeded, iTimeout);
-      m_bWaiting = false;
-      return bReturn;
-    }
-
-    /*!
-     * @return True while a thread is waiting for a signal or isn't waiting yet, false otherwise.
-     */
-    bool IsWaiting(void)
-    {
-      CLockObject lock(m_mutex);
-      return m_bWaiting;
-    }
-
-  private:    
-    bool                         m_bWaiting;     /**< true while a thread is waiting or when it hasn't started waiting yet */
-    PLATFORM::CCondition<bool>   m_condition;    /**< the condition to wait on */
-    PLATFORM::CMutex             m_mutex;        /**< mutex for changes to this class */
-    int                          m_retval;
-    bool                         m_bSucceeded;
-    uint8_t                      m_addrs;
-    cec_opcode                   m_opcode;
-  };
- 
-};
diff --git a/src/lib/adapter/IMX/mxc_hdmi-cec.h b/src/lib/adapter/IMX/mxc_hdmi-cec.h
deleted file mode 100644
index bc5bbce..0000000
--- a/src/lib/adapter/IMX/mxc_hdmi-cec.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef _HDMICEC_H_
-#define _HDMICEC_H_
-#include <linux/ioctl.h>
-
-/*
- * Ioctl definitions
- */
-
-/* Use 'k' as magic number */
-#define HDMICEC_IOC_MAGIC  'H'
-/*
- * S means "Set" through a ptr,
- * T means "Tell" directly with the argument value
- * G means "Get": reply by setting through a pointer
- * Q means "Query": response is on the return value
- * X means "eXchange": G and S atomically
- * H means "sHift": T and Q atomically
- */
-#define HDMICEC_IOC_SETLOGICALADDRESS  \
-				_IOW(HDMICEC_IOC_MAGIC, 1, unsigned char)
-#define HDMICEC_IOC_STARTDEVICE	_IO(HDMICEC_IOC_MAGIC,  2)
-#define HDMICEC_IOC_STOPDEVICE	_IO(HDMICEC_IOC_MAGIC,  3)
-#define HDMICEC_IOC_GETPHYADDRESS	\
-				_IOR(HDMICEC_IOC_MAGIC, 4, unsigned char[4])
-
-#define MAX_MESSAGE_LEN				16
-
-#define MESSAGE_TYPE_RECEIVE_SUCCESS		1
-#define MESSAGE_TYPE_NOACK			2
-#define MESSAGE_TYPE_DISCONNECTED		3
-#define MESSAGE_TYPE_CONNECTED			4
-#define MESSAGE_TYPE_SEND_SUCCESS		5
-
-#endif				/* !_HDMICEC_H_ */
-
diff --git a/src/libcec/adapter/IMX/IMXCECAdapterCommunication.cpp b/src/libcec/adapter/IMX/IMXCECAdapterCommunication.cpp
new file mode 100644
index 0000000..7e11492
--- /dev/null
+++ b/src/libcec/adapter/IMX/IMXCECAdapterCommunication.cpp
@@ -0,0 +1,379 @@
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ *                     Copyright (C) 2014 by Matus Kral
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#include "env.h"
+
+#if defined(HAVE_IMX_API)
+#include "IMXCECAdapterCommunication.h"
+
+#include "CECTypeUtils.h"
+#include "LibCEC.h"
+#include "platform/sockets/cdevsocket.h"
+#include "platform/util/StdString.h"
+#include "platform/util/util.h"
+
+using namespace std;
+using namespace CEC;
+using namespace PLATFORM;
+
+#include "IMXCECAdapterMessageQueue.h"
+
+#define LIB_CEC m_callback->GetLib()
+
+// these are defined in nxp private header file
+#define CEC_MSG_SUCCESS                 0x00	/*Message transmisson Succeed*/
+#define CEC_CSP_OFF_STATE               0x80	/*CSP in Off State*/
+#define CEC_BAD_REQ_SERVICE             0x81	/*Bad .req service*/
+#define CEC_MSG_FAIL_UNABLE_TO_ACCESS	0x82	/*Message transmisson failed: Unable to access CEC line*/
+#define CEC_MSG_FAIL_ARBITRATION_ERROR	0x83	/*Message transmisson failed: Arbitration error*/
+#define CEC_MSG_FAIL_BIT_TIMMING_ERROR	0x84	/*Message transmisson failed: Bit timming error*/
+#define CEC_MSG_FAIL_DEST_NOT_ACK       0x85	/*Message transmisson failed: Destination Address not aknowledged*/
+#define CEC_MSG_FAIL_DATA_NOT_ACK       0x86	/*Message transmisson failed: Databyte not acknowledged*/
+
+CIMXCECAdapterCommunication::CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback) :
+    IAdapterCommunication(callback),
+    m_PAReporter(NULL)
+{
+  CLockObject lock(m_mutex);
+
+  m_iNextMessage = 0;
+  m_logicalAddress = CECDEVICE_UNKNOWN;
+  m_bLogicalAddressRegistered = false;
+  m_bInitialised = false;
+  m_dev = new CCDevSocket(CEC_IMX_PATH);
+  m_physicalAddress = -1;
+}
+
+CIMXCECAdapterCommunication::~CIMXCECAdapterCommunication(void)
+{
+  Close();
+  SAFE_DELETE(m_PAReporter);
+  delete m_dev;
+  m_dev = 0;
+}
+
+bool CIMXCECAdapterCommunication::IsOpen(void)
+{
+  return IsInitialised() && m_dev->IsOpen();
+}
+
+bool CIMXCECAdapterCommunication::Open(uint32_t iTimeoutMs, bool UNUSED(bSkipChecks), bool bStartListening)
+{
+  if (m_dev->Open(iTimeoutMs))
+  {
+    if (!bStartListening || CreateThread()) {
+      if (m_dev->Ioctl(HDMICEC_IOC_STARTDEVICE, NULL) == 0) {
+        m_bInitialised = true;
+        RegisterLogicalAddress(CECDEVICE_BROADCAST);
+        return true;
+      }
+      LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to start device\n", __func__);
+    }
+    m_dev->Close();
+  }
+
+  return false;
+}
+
+
+void CIMXCECAdapterCommunication::Close(void)
+{
+  m_bInitialised = false;
+  if (m_dev->Ioctl(HDMICEC_IOC_STOPDEVICE, NULL) != 0)
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to stop device\n", __func__);
+  }
+  StopThread(false);
+  m_dev->Close();
+}
+
+
+std::string CIMXCECAdapterCommunication::GetError(void) const
+{
+  std::string strError(m_strError);
+  return strError;
+}
+
+
+cec_adapter_message_state CIMXCECAdapterCommunication::Write(
+  const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool UNUSED(bIsReply))
+{
+  unsigned char message[MAX_MESSAGE_LEN];
+  CIMXCECAdapterMessageQueueEntry *entry;
+  int msg_len = 1;
+  cec_adapter_message_state rc = ADAPTER_MESSAGE_STATE_ERROR;
+
+  bRetry = true;
+  if ((size_t)data.parameters.size + data.opcode_set + 1 > sizeof(message))
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: data size too large !", __func__);
+    bRetry = false;
+    return rc;
+  }
+
+  message[0] = (data.initiator << 4) | (data.destination & 0x0f);
+  if (data.opcode_set)
+  {
+    message[1] = data.opcode;
+    msg_len++;
+    memcpy(&message[2], data.parameters.data, data.parameters.size);
+    msg_len+=data.parameters.size;
+  }
+
+  entry = new CIMXCECAdapterMessageQueueEntry(message[0], data.opcode);
+  m_messageMutex.Lock();
+  uint32_t msgKey = ++m_iNextMessage;
+  m_messages.insert(make_pair(msgKey, entry));
+  m_messageMutex.Unlock();
+
+  if (m_dev->Write(message, msg_len) > 0)
+  { 
+    if (entry->Wait(data.transmit_timeout ? data.transmit_timeout : iLineTimeout *1000))
+    {
+      int status = entry->Result();
+
+      if (status == MESSAGE_TYPE_NOACK)
+        rc = ADAPTER_MESSAGE_STATE_SENT_NOT_ACKED;
+      else if (status == MESSAGE_TYPE_SEND_SUCCESS)
+        rc = ADAPTER_MESSAGE_STATE_SENT_ACKED;
+
+      bRetry = false;
+    }
+    else
+    {
+      rc = ADAPTER_MESSAGE_STATE_WAITING_TO_BE_SENT;
+#ifdef CEC_DEBUGGING
+      LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: command timed out !", __func__);
+#endif
+    }
+  }
+  else
+  {
+    Sleep(CEC_DEFAULT_TRANSMIT_RETRY_WAIT);
+#ifdef CEC_DEBUGGING
+    LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: write failed !", __func__);
+#endif
+  }
+
+  m_messageMutex.Lock();
+  m_messages.erase(msgKey);
+  m_messageMutex.Unlock();
+
+  delete entry;
+
+  return rc;
+}
+
+
+uint16_t CIMXCECAdapterCommunication::GetFirmwareVersion(void)
+{
+  /* FIXME add ioctl ? */
+  return 0;
+}
+
+
+cec_vendor_id CIMXCECAdapterCommunication::GetVendorId(void)
+{
+  return CEC_VENDOR_UNKNOWN;
+}
+
+
+uint16_t CIMXCECAdapterCommunication::GetPhysicalAddress(void)
+{
+  uint8_t phy_addr[4];
+  uint16_t pa_tmp;
+
+  if (m_dev->Ioctl(HDMICEC_IOC_GETPHYADDRESS, &phy_addr) != 0)
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_GETPHYADDRESS failed !", __func__);
+    return CEC_INVALID_PHYSICAL_ADDRESS; 
+  }
+
+  if ((pa_tmp = ((phy_addr[0] << 4 | phy_addr[1]) << 8) | (phy_addr[2] << 4 | phy_addr[3])))
+    m_physicalAddress = pa_tmp;
+
+  return m_physicalAddress;
+}
+
+
+cec_logical_addresses CIMXCECAdapterCommunication::GetLogicalAddresses(void)
+{
+  cec_logical_addresses addresses;
+  addresses.Clear();
+
+  CLockObject lock(m_mutex);
+  if (m_bLogicalAddressRegistered)
+    addresses.Set(m_logicalAddress);
+
+  return addresses;
+}
+
+void CIMXCECAdapterCommunication::HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress))
+{
+  UnregisterLogicalAddress();
+}
+
+bool CIMXCECAdapterCommunication::UnregisterLogicalAddress(void)
+{
+  {
+    CLockObject lock(m_mutex);
+    if (!m_bLogicalAddressRegistered)
+      return true;
+  }
+
+#ifdef CEC_DEBUGGING
+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s - releasing previous logical address", __func__);
+#endif
+  return RegisterLogicalAddress(CECDEVICE_BROADCAST);
+}
+
+bool CIMXCECAdapterCommunication::RegisterLogicalAddress(const cec_logical_address address)
+{
+  {
+    CLockObject lock(m_mutex);
+    if ((m_logicalAddress == address && m_bLogicalAddressRegistered) ||
+        (m_logicalAddress == address && address == CECDEVICE_BROADCAST))
+    {
+      return true;
+    }
+  }
+
+#ifdef CEC_DEBUGGING
+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %x to %x", __func__, m_logicalAddress, address);
+#endif
+
+  if (m_dev->Ioctl(HDMICEC_IOC_SETLOGICALADDRESS, (void *)address) != 0)
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_SETLOGICALADDRESS failed !", __func__);
+    return false;
+  }
+
+  CLockObject lock(m_mutex);
+
+  m_logicalAddress = address;
+  m_bLogicalAddressRegistered = (address != CECDEVICE_BROADCAST) ? true : false;
+  return true;
+}
+
+bool CIMXCECAdapterCommunication::SetLogicalAddresses(const cec_logical_addresses &addresses)
+{
+  int log_addr = addresses.primary;
+
+  return RegisterLogicalAddress((cec_logical_address)log_addr);
+}
+
+
+void *CIMXCECAdapterCommunication::Process(void)
+{
+  bool bHandled;
+  hdmi_cec_event event;
+  int ret;
+
+  cec_logical_address initiator, destination;
+
+  while (!IsStopped())
+  {
+    if (IsInitialised() && (ret = m_dev->Read((char *)&event, sizeof(event), 1000)) > 0)
+    {
+
+      initiator = cec_logical_address(event.msg[0] >> 4);
+      destination = cec_logical_address(event.msg[0] & 0x0f);
+
+        if (event.event_type == MESSAGE_TYPE_RECEIVE_SUCCESS)
+        {
+            cec_command cmd;
+
+            cec_command::Format(
+                cmd, initiator, destination,
+                ( event.msg_len > 1 ) ? cec_opcode(event.msg[1]) : CEC_OPCODE_NONE);
+
+            for( uint8_t i = 2; i < event.msg_len; i++ )
+                cmd.parameters.PushBack(event.msg[i]);
+
+            if (!IsStopped()) {
+              m_callback->OnCommandReceived(cmd);
+            }
+        }
+        else if (event.event_type == MESSAGE_TYPE_SEND_SUCCESS 
+                || event.event_type == MESSAGE_TYPE_NOACK)
+        {
+            bHandled = false;
+
+            m_messageMutex.Lock();
+            for (map<uint32_t, CIMXCECAdapterMessageQueueEntry *>::iterator it = m_messages.begin();
+              !bHandled && it != m_messages.end(); it++)
+              {
+                bHandled = it->second->Received(event.event_type, event.msg[0], (cec_opcode)event.msg[1]);
+              }
+            m_messageMutex.Unlock();
+
+            if (!bHandled)
+              LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: response not matched !", __func__);
+        }
+        else if (event.event_type == MESSAGE_TYPE_DISCONNECTED)
+        {
+            /* HDMI Hotplug event - disconnect */
+        }
+        else if (event.event_type == MESSAGE_TYPE_CONNECTED && m_physicalAddress != 0xffff)
+        {
+            /* HDMI Hotplug event - connect */
+            uint16_t oldAddress = m_physicalAddress;
+
+            if (oldAddress != GetPhysicalAddress()) {
+              if (m_PAReporter)
+                while (m_PAReporter->IsRunning()) Sleep(5);
+              delete m_PAReporter;
+
+              m_PAReporter = new CCECPAChangedReporter(m_callback, m_physicalAddress);
+              m_PAReporter->CreateThread(false);
+            }
+#ifdef CEC_DEBUGGING
+            LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: plugin event received", __func__);
+#endif
+        }
+        else
+            LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: unhandled response received %d!", __func__, event.event_type);
+    }
+  }
+
+  return 0;
+}
+
+CCECPAChangedReporter::CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA) :
+    m_callback(callback),
+    m_newPA(newPA)
+{
+}
+
+void* CCECPAChangedReporter::Process(void)
+{
+  m_callback->HandlePhysicalAddressChanged(m_newPA);
+  return NULL;
+}
+
+#endif	// HAVE_IMX_API
diff --git a/src/libcec/adapter/IMX/IMXCECAdapterCommunication.h b/src/libcec/adapter/IMX/IMXCECAdapterCommunication.h
new file mode 100644
index 0000000..14ad562
--- /dev/null
+++ b/src/libcec/adapter/IMX/IMXCECAdapterCommunication.h
@@ -0,0 +1,139 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ *
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ *                     Copyright (C) 2014 by Matus Kral
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#if defined(HAVE_IMX_API)
+
+#include "platform/threads/mutex.h"
+#include "platform/threads/threads.h"
+#include "platform/sockets/socket.h"
+#include "adapter/IMX/mxc_hdmi-cec.h"
+#include "adapter/AdapterCommunication.h"
+#include <map>
+
+#define IMX_ADAPTER_VID 0x0471 /*FIXME TBD*/
+#define IMX_ADAPTER_PID 0x1001
+
+typedef struct hdmi_cec_event{
+  uint8_t event_type;
+  uint8_t msg_len;
+  uint8_t msg[MAX_MESSAGE_LEN];
+}hdmi_cec_event;
+
+
+namespace PLATFORM
+{
+  class CCDevSocket;
+};
+
+namespace CEC
+{
+  class CIMXCECAdapterMessageQueueEntry;
+
+  class CCECPAChangedReporter : public PLATFORM::CThread
+  {
+  public:
+    CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA);
+    void* Process(void);
+
+  private:
+    IAdapterCommunicationCallback *m_callback;
+    uint16_t                       m_newPA;
+  };
+
+  class CIMXCECAdapterCommunication : public IAdapterCommunication, public PLATFORM::CThread
+  {
+  public:
+    /*!
+     * @brief Create a new USB-CEC communication handler.
+     * @param callback The callback to use for incoming CEC commands.
+     */
+    CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback);
+    virtual ~CIMXCECAdapterCommunication(void);
+
+    /** @name IAdapterCommunication implementation */
+    ///{
+    bool Open(uint32_t iTimeoutMs = CEC_DEFAULT_CONNECT_TIMEOUT, bool bSkipChecks = false, bool bStartListening = true);
+    void Close(void);
+    bool IsOpen(void);
+    std::string GetError(void) const;
+    cec_adapter_message_state Write(const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool bIsReply);
+
+    bool SetLineTimeout(uint8_t UNUSED(iTimeout)) { return true; }
+    bool StartBootloader(void) { return false; }
+    bool SetLogicalAddresses(const cec_logical_addresses &addresses);
+    cec_logical_addresses GetLogicalAddresses(void);
+    bool PingAdapter(void) { return IsInitialised(); }
+    uint16_t GetFirmwareVersion(void);
+    uint32_t GetFirmwareBuildDate(void) { return 0; }
+    bool IsRunningLatestFirmware(void) { return true; }
+    bool PersistConfiguration(const libcec_configuration & UNUSED(configuration)) { return false; }
+    bool GetConfiguration(libcec_configuration & UNUSED(configuration)) { return false; }
+    std::string GetPortName(void) { return std::string("IMX"); }
+    uint16_t GetPhysicalAddress(void);
+    bool SetControlledMode(bool UNUSED(controlled)) { return true; }
+    cec_vendor_id GetVendorId(void);
+    void HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress));
+    bool SupportsSourceLogicalAddress(const cec_logical_address address) { return address > CECDEVICE_TV && address <= CECDEVICE_BROADCAST; }
+    cec_adapter_type GetAdapterType(void) { return ADAPTERTYPE_IMX; }
+    uint16_t GetAdapterVendorId(void) const { return IMX_ADAPTER_VID; }
+    uint16_t GetAdapterProductId(void) const { return IMX_ADAPTER_PID; }
+    void SetActiveSource(bool UNUSED(bSetTo), bool UNUSED(bClientUnregistered)) {}
+    ///}
+
+    /** @name PLATFORM::CThread implementation */
+    ///{
+    void *Process(void);
+    ///}
+
+  private:
+    bool IsInitialised(void) { return m_bInitialised; };
+    bool RegisterLogicalAddress(const cec_logical_address address);
+    bool UnregisterLogicalAddress(void);
+
+    std::string                 m_strError; /**< current error message */
+
+    cec_logical_address         m_logicalAddress;
+    uint16_t                    m_physicalAddress;
+
+    PLATFORM::CMutex            m_mutex;
+    PLATFORM::CCDevSocket       *m_dev;	/**< the device connection */
+    
+    PLATFORM::CMutex            m_messageMutex;
+    uint32_t                    m_iNextMessage;
+    std::map<uint32_t, CIMXCECAdapterMessageQueueEntry *> m_messages;
+
+    bool                        m_bLogicalAddressRegistered;
+    bool                        m_bInitialised;
+
+    CCECPAChangedReporter       *m_PAReporter;
+  };
+  
+};
+
+#endif
diff --git a/src/libcec/adapter/IMX/IMXCECAdapterDetection.cpp b/src/libcec/adapter/IMX/IMXCECAdapterDetection.cpp
new file mode 100644
index 0000000..6c93c45
--- /dev/null
+++ b/src/libcec/adapter/IMX/IMXCECAdapterDetection.cpp
@@ -0,0 +1,42 @@
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#include "env.h"
+#include <stdio.h>
+
+#if defined(HAVE_IMX_API)
+#include "IMXCECAdapterDetection.h"
+
+
+using namespace CEC;
+
+bool CIMXCECAdapterDetection::FindAdapter(void)
+{
+  return access(CEC_IMX_PATH, 0) == 0;
+}
+
+#endif
diff --git a/src/libcec/adapter/IMX/IMXCECAdapterDetection.h b/src/libcec/adapter/IMX/IMXCECAdapterDetection.h
new file mode 100644
index 0000000..d54891d
--- /dev/null
+++ b/src/libcec/adapter/IMX/IMXCECAdapterDetection.h
@@ -0,0 +1,36 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+namespace CEC
+{
+  class CIMXCECAdapterDetection
+  {
+  public:
+    static bool FindAdapter(void);
+  };
+}
diff --git a/src/libcec/adapter/IMX/IMXCECAdapterMessageQueue.h b/src/libcec/adapter/IMX/IMXCECAdapterMessageQueue.h
new file mode 100644
index 0000000..1c351ca
--- /dev/null
+++ b/src/libcec/adapter/IMX/IMXCECAdapterMessageQueue.h
@@ -0,0 +1,118 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ *
+ * This program is dual-licensed; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * Alternatively, you can license this library under a commercial license,
+ * please contact Pulse-Eight Licensing for more information.
+ *
+ * For more information contact:
+ * Pulse-Eight Licensing       <license@pulse-eight.com>
+ *     http://www.pulse-eight.com/
+ *     http://www.pulse-eight.net/
+ */
+
+#include "platform/threads/mutex.h"
+
+namespace CEC
+{
+  using namespace PLATFORM;
+  
+  class CIMXCECAdapterMessageQueueEntry
+  {
+  public:
+    CIMXCECAdapterMessageQueueEntry(uint8_t addrs, cec_opcode opcode)
+       : m_bWaiting(true), m_retval((uint32_t)-1), m_bSucceeded(false)
+    {
+      m_opcode = opcode;
+      m_addrs = addrs; 
+    }
+    
+    virtual ~CIMXCECAdapterMessageQueueEntry(void) {}
+
+    /*!
+     * @brief Query result from worker thread
+     */
+    uint32_t Result() const
+    {
+      return m_retval;
+    }
+    
+    /*!
+     * @brief Signal waiting threads
+     */
+    void Broadcast(void)
+    {
+      CLockObject lock(m_mutex);
+      m_condition.Broadcast();
+    }
+
+    /*!
+     * @brief Signal waiting thread(s) when message matches this entry
+     */
+    bool Received(int response, uint8_t addrs, cec_opcode opcode)
+    {
+      CLockObject lock(m_mutex);
+
+      if (!(m_addrs == addrs && m_opcode == opcode))
+        return false;
+
+      m_retval = response;
+      m_bSucceeded = true;
+      m_condition.Signal();
+      return true;
+    }
+
+    /*!
+     * @brief Wait for a response to this command.
+     * @param iTimeout The timeout to use while waiting.
+     * @return True when a response was received before the timeout passed, false otherwise.
+     */
+    bool Wait(uint32_t iTimeout)
+    {
+      CLockObject lock(m_mutex);
+      
+      bool bReturn = m_bSucceeded ? true : m_condition.Wait(m_mutex, m_bSucceeded, iTimeout);
+      m_bWaiting = false;
+      return bReturn;
+    }
+
+    /*!
+     * @return True while a thread is waiting for a signal or isn't waiting yet, false otherwise.
+     */
+    bool IsWaiting(void)
+    {
+      CLockObject lock(m_mutex);
+      return m_bWaiting;
+    }
+
+  private:    
+    bool                         m_bWaiting;     /**< true while a thread is waiting or when it hasn't started waiting yet */
+    PLATFORM::CCondition<bool>   m_condition;    /**< the condition to wait on */
+    PLATFORM::CMutex             m_mutex;        /**< mutex for changes to this class */
+    int                          m_retval;
+    bool                         m_bSucceeded;
+    uint8_t                      m_addrs;
+    cec_opcode                   m_opcode;
+  };
+ 
+};
diff --git a/src/libcec/adapter/IMX/mxc_hdmi-cec.h b/src/libcec/adapter/IMX/mxc_hdmi-cec.h
new file mode 100644
index 0000000..bc5bbce
--- /dev/null
+++ b/src/libcec/adapter/IMX/mxc_hdmi-cec.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef _HDMICEC_H_
+#define _HDMICEC_H_
+#include <linux/ioctl.h>
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'k' as magic number */
+#define HDMICEC_IOC_MAGIC  'H'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define HDMICEC_IOC_SETLOGICALADDRESS  \
+				_IOW(HDMICEC_IOC_MAGIC, 1, unsigned char)
+#define HDMICEC_IOC_STARTDEVICE	_IO(HDMICEC_IOC_MAGIC,  2)
+#define HDMICEC_IOC_STOPDEVICE	_IO(HDMICEC_IOC_MAGIC,  3)
+#define HDMICEC_IOC_GETPHYADDRESS	\
+				_IOR(HDMICEC_IOC_MAGIC, 4, unsigned char[4])
+
+#define MAX_MESSAGE_LEN				16
+
+#define MESSAGE_TYPE_RECEIVE_SUCCESS		1
+#define MESSAGE_TYPE_NOACK			2
+#define MESSAGE_TYPE_DISCONNECTED		3
+#define MESSAGE_TYPE_CONNECTED			4
+#define MESSAGE_TYPE_SEND_SUCCESS		5
+
+#endif				/* !_HDMICEC_H_ */
+
diff --git a/src/libcec/cmake/CheckPlatformSupport.cmake b/src/libcec/cmake/CheckPlatformSupport.cmake
index 4bd8043..57d8143 100644
--- a/src/libcec/cmake/CheckPlatformSupport.cmake
+++ b/src/libcec/cmake/CheckPlatformSupport.cmake
@@ -86,15 +86,31 @@ else()
     set(HAVE_RANDR 0)
   endif()
 
+  # iMX6
+  if (${HAVE_IMX_API})
+    set(LIB_INFO "${LIB_INFO}, iMX6")
+    set(HAVE_IMX_API 1)
+    set(CEC_SOURCES_ADAPTER_IMX adapter/IMX/IMXCECAdapterDetection.cpp
+                                adapter/IMX/IMXCECAdapterCommunication.cpp)
+    source_group("Source Files\\adapter\\iMX6" FILES ${CEC_SOURCES_ADAPTER_IMX})
+    list(APPEND CEC_SOURCES ${CEC_SOURCES_ADAPTER_IMX})
+    set(HAVE_RPI_API 0)
+  else()
+    set(HAVE_IMX_API 0)
+    set(HAVE_RPI_API 1)
+  endif()  
+
   # raspberry pi
-  find_library(RPI_BCM_HOST bcm_host "${RPI_LIB_DIR}")
-  check_library_exists(bcm_host bcm_host_init "${RPI_LIB_DIR}" HAVE_RPI_API)
   if (HAVE_RPI_API)
-    find_library(RPI_VCOS vcos "${RPI_LIB_DIR}")
-    find_library(RPI_VCHIQ_ARM vchiq_arm "${RPI_LIB_DIR}")
-    include_directories(${RPI_INCLUDE_DIR} ${RPI_INCLUDE_DIR}/interface/vcos/pthreads ${RPI_INCLUDE_DIR}/interface/vmcs_host/linux)
-
+    find_library(BCM_HOST bcm_host)
+    check_library_exists(${BCM_HOST} bcm_host_init "" HAVE_RPI_API)
+  endif()
+  if (HAVE_RPI_API)
     set(LIB_INFO "${LIB_INFO}, 'RPi'")
+    # find includes files on Raspberry Pi
+    include_directories(/opt/vc/include /opt/vc/include/interface/vcos/pthreads /opt/vc/include/interface/vmcs_host/linux)
+    list(APPEND CMAKE_REQUIRED_LIBRARIES "vcos")
+    list(APPEND CMAKE_REQUIRED_LIBRARIES "vchiq_arm")
     set(CEC_SOURCES_ADAPTER_RPI adapter/RPi/RPiCECAdapterDetection.cpp
                                 adapter/RPi/RPiCECAdapterCommunication.cpp
                                 adapter/RPi/RPiCECAdapterMessageQueue.cpp)
@@ -124,17 +140,7 @@ else()
     set(HAVE_EXYNOS_API 0)
   endif()
 
-  # iMX6
-  if (${HAVE_IMX_API})
-    set(LIB_INFO "${LIB_INFO}, iMX6")
-    set(HAVE_IMX_API 1)
-    set(CEC_SOURCES_ADAPTER_IMX adapter/IMX/IMXCECAdapterDetection.cpp
-                                adapter/IMX/IMXCECAdapterCommunication.cpp)
-    source_group("Source Files\\adapter\\iMX6" FILES ${CEC_SOURCES_ADAPTER_IMX})
-    list(APPEND CEC_SOURCES ${CEC_SOURCES_ADAPTER_IMX})
-  else()
-    set(HAVE_IMX_API 0)
-  endif()
+
 endif()
 
 # rt
diff --git a/src/libcec/env.h.in b/src/libcec/env.h.in
index ff20e49..a6e79bb 100644
--- a/src/libcec/env.h.in
+++ b/src/libcec/env.h.in
@@ -60,6 +60,9 @@
 /* Define to 1 for Raspberry Pi support */
 #cmakedefine HAVE_RPI_API @HAVE_RPI_API@
 
+/* Define to 1 for iMX6 support */
+#cmakedefine HAVE_IMX_API @HAVE_IMX_API@
+
 /* Define to 1 for TDA995x support */
 #cmakedefine HAVE_TDA995X_API @HAVE_TDA995X_API@
 
