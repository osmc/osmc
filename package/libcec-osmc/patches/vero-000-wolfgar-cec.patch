From 72cca3e01c2bed5ef2add7d2af008803896ad6cc Mon Sep 17 00:00:00 2001
From: wolfgar <stephan.rafin@laposte.net>
Date: Sat, 28 Sep 2013 13:31:13 +0200
Subject: [PATCH] Early support for i.MX6 Fix compiler warning (or even error
 depending on fpermissive flag) Fix adapter thanks to geexbox and rudi
 (0003-fix-adapter-factory.patch)

---
 configure.ac                                       | 411 +++++++++++++++++++++
 include/cectypes.h                                 |  20 +-
 src/lib/Makefile.am                                |  68 ++++
 src/lib/adapter/IMX/AdapterMessageQueue.h          | 134 +++++++
 src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp | 279 ++++++++++++++
 src/lib/adapter/IMX/IMXCECAdapterCommunication.h   | 114 ++++++
 src/lib/adapter/IMX/IMXCECAdapterDetection.cpp     |  42 +++
 src/lib/adapter/IMX/IMXCECAdapterDetection.h       |  36 ++
 src/libcec/CECTypeUtils.h                          |   2 +
 src/libcec/adapter/AdapterFactory.cpp              |  27 +-
 10 files changed, 1129 insertions(+), 4 deletions(-)
 create mode 100644 configure.ac
 create mode 100644 src/lib/Makefile.am
 create mode 100644 src/lib/adapter/IMX/AdapterMessageQueue.h
 create mode 100644 src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
 create mode 100644 src/lib/adapter/IMX/IMXCECAdapterCommunication.h
 create mode 100644 src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
 create mode 100644 src/lib/adapter/IMX/IMXCECAdapterDetection.h

diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..923d7e5
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,411 @@
+AC_PREREQ(2.59)
+AC_INIT([libcec], [2:1:0], [http://libcec.pulse-eight.com/])
+AC_CONFIG_HEADERS([config.h])
+AH_TOP([#pragma once])
+
+AM_INIT_AUTOMAKE([foreign])
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+
+AM_INIT_AUTOMAKE(AC_PACKAGE_NAME, AC_PACKAGE_VERSION)
+
+AC_CANONICAL_HOST
+
+cflags_reset="$CFLAGS"
+AC_LANG(C++)
+AC_PROG_CXX
+AC_PROG_LIBTOOL
+AC_PROG_INSTALL
+AC_LIBTOOL_DLOPEN
+CFLAGS="$cflags_reset"
+
+msg_pkg_config_missing="'pkg-config' is missing - adapter detection will not be available"
+msg_pthread_missing="required library 'pthread' is missing"
+msg_dl_missing="required library 'dl' is missing"
+msg_udev_missing="library 'udev' is missing - adapter detection will not be available"
+msg_dirent_missing="dirent.h header is missing - adapter detection will not be available"
+msg_lockdev_missing="library 'liblockdev' is missing"
+msg_rpi_api_missing="Raspberry Pi API not found or incompatible with libCEC"
+msg_rpi_will_check="will check for RPi support"
+msg_rpi_unsupported_target="will not check for RPi support (unsupported cpu: ${host_cpu})"
+msg_required_header_missing="required header is missing"
+
+## debugging symbols
+AC_ARG_ENABLE([debug],
+  [AS_HELP_STRING([--enable-debug],
+  [include debug symbols (default is no)])],
+  [use_debug=$enableval],
+  [use_debug=no])
+
+## optimisation
+AC_ARG_ENABLE([optimisation],
+  [AS_HELP_STRING([--enable-optimisation],
+  [optimisation flag (default is yes)])],
+  [use_optimisation=$enableval],
+  [use_optimisation=yes])
+
+## TDA995x support
+AC_ARG_ENABLE([cubox],
+  [AS_HELP_STRING([--enable-tda995x],
+  [enable support for the TDA995x (default is no)])],
+  [use_tda995x=$enableval],
+  [use_tda995x=no])
+
+## Optional path to the tda995x dev toolkit
+AC_ARG_WITH([tda995x-toolkit-path],
+  [AS_HELP_STRING([--with-tda995x-toolkit-path],
+    [location of the TDA995x driver toolkit (default is ./nxp_hdmi)])],
+  [TDA995X_CFLAGS="-I$withval/inc"],
+  [TDA995X_CFLAGS="-I\$(abs_top_srcdir)/nxp_hdmi/inc"])
+
+## Raspberry Pi support
+AC_ARG_ENABLE([rpi],
+  [AS_HELP_STRING([--enable-rpi],
+  [enable support for the Raspberry Pi (default is auto)])],
+  [use_rpi=$enableval],
+  [use_rpi=auto])
+
+## Optional path to the RPi's dev headers
+AC_ARG_WITH([rpi-include-path],
+  [AS_HELP_STRING([--with-rpi-include-path],
+    [location of the Raspberry Pi headers (location of /opt/vc/include, default is auto)])],
+  [RPI_CFLAGS="-I$withval -I$withval/interface/vcos/pthreads -I$withval/interface/vmcs_host/linux"])
+
+## Optional path to libbcm_host.so
+AC_ARG_WITH([rpi-lib-path],
+  [AS_HELP_STRING([--with-rpi-lib-path],
+    [location of the Raspberry Pi libraries (location of libbcm_host.so, default is auto)])],
+  [RPI_LIBS="-L$withval"])
+
+## only check for the RPi API on ARM targets
+if test "x$use_rpi" != "xno"; then
+  case "${host_cpu}" in
+    arm*)
+      AC_MSG_NOTICE($msg_rpi_will_check)
+      ;;
+    *)
+      if test "x$use_rpi" = "xyes"; then
+        AC_MSG_ERROR($msg_rpi_unsupported_target)
+      else
+        AC_MSG_NOTICE($msg_rpi_unsupported_target)
+      fi
+      use_rpi="no"
+      ;;
+  esac
+fi
+
+## i.MX6 support
+AC_ARG_ENABLE([imx6],
+  [AS_HELP_STRING([--enable-imx6],
+  [enable support for freescale i.MX6 (default is no)])],
+  [use_imx6=$enableval],
+  [use_imx6=no])
+
+
+## add the top dir and include to the include path, so we can include config.h and cec.h
+CPPFLAGS="$CPPFLAGS -I\$(abs_top_srcdir)/src -I\$(abs_top_srcdir)/include"
+
+## search for pkg-config
+AC_CHECK_PROG(HAVE_PKG_CONFIG, pkg-config, yes)
+if test "x$HAVE_PKG_CONFIG" != "xyes" ; then
+  AC_MSG_WARN($msg_pkg_config_missing)
+fi
+
+## search for pthread, required by all targets
+AC_SEARCH_LIBS([pthread_create],[pthread],,AC_MSG_ERROR($msg_pthread_missing))
+AC_CHECK_FUNCS([pthread_mutexattr_init pthread_cond_init pthread_cond_destroy pthread_cond_signal pthread_cond_broadcast pthread_cond_wait pthread_cond_timedwait])
+
+## search for dlopen, required by all targets
+AC_SEARCH_LIBS([dlopen], [dl],
+  [test "$ac_cv_search_dlopen" = "none required" || LIBS_DL=$ac_cv_search_dlopen],
+  AC_MSG_ERROR($msg_dl_missing))
+AC_CHECK_FUNCS([dlopen dlclose dlsym])
+
+## platform specific libs, required by all targets
+case "${host}" in
+  *-*-linux*)
+    # for timeutils
+    AC_SEARCH_LIBS([clock_gettime], [rt])
+    ;;
+  *-apple-darwin*)
+    LIBS="$LIBS -framework CoreVideo -framework IOKit"
+    ;;
+esac
+
+## we found all the libs and headers that we need for the client applications
+libs_client="$LIBS"
+
+## search for udev, lockdev and the RPi API, only required by libCEC
+use_udev="no"
+use_adapter_detection="yes"
+use_lockdev="no"
+SUPPRESS_MANGLING_WARNINGS=" -Wno-psabi"
+case "${host}" in
+  *-*-linux*)
+    ## search for udev if pkg-config was found
+    if test "x$HAVE_PKG_CONFIG" = "xyes" ; then
+      PKG_CHECK_MODULES([UDEV],[libudev],use_udev="yes",AC_MSG_WARN($msg_udev_missing))
+    fi
+
+    ## we need dirent.h on linux too
+    if test "$use_udev" = "yes"; then
+      AC_CHECK_HEADER(dirent.h,,[use_udev="no";AC_MSG_WARN($msg_dirent_missing)])
+    fi
+
+    if test "$use_udev" != "yes"; then
+      use_adapter_detection="no"
+    fi
+
+    ## search for lockdev
+    use_lockdev="yes"
+    AC_CHECK_HEADER(lockdev.h,,[use_lockdev="no";AC_MSG_WARN($msg_lockdev_missing)])
+    AC_CHECK_LIB(lockdev,dev_unlock,,[use_lockdev="no";AC_MSG_WARN($msg_lockdev_missing)])
+
+    AC_CHECK_HEADER(time.h,,AC_MSG_ERROR($msg_required_header_missing))
+    AC_CHECK_HEADER(sys/prctl.h,,AC_MSG_ERROR($msg_required_header_missing))
+
+    ## search for the RPi API. we need to check a couple of things to see if
+    ## it's recent enough and contains the calls needed for libCEC to operate
+    ## correctly.
+    if test "x$use_rpi" != "xno"; then
+      CPPFLAGS="$CPPFLAGS $RPI_CFLAGS"
+      libs_pre_rpi="$LIBS"
+      LIBS="$LIBS $RPI_LIBS -lvcos -lvchiq_arm"
+
+      check_rpi_cec_service="yes"
+
+      ## check for headers we need
+      AC_CHECK_HEADER(interface/vmcs_host/vc_cec.h,,check_rpi_cec_service="no")
+      AC_CHECK_HEADER(interface/vmcs_host/vc_cecservice.h,,check_rpi_cec_service="no")
+      AC_CHECK_HEADER(interface/vchiq_arm/vchiq_if.h,,check_rpi_cec_service="no")
+      AC_CHECK_HEADER(bcm_host.h,,check_rpi_cec_service="no")
+
+      ## check if the headers contain support for libCEC.
+      ## VC_CECSERVICE_VER needs to be defined
+      AC_MSG_CHECKING([interface/vmcs_host/vc_cec.h compatibility])
+
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <interface/vmcs_host/vc_cecservice.h>
+#include <interface/vchiq_arm/vchiq_if.h>
+#if !defined(VC_CECSERVICE_VER)
+#error RPi headers does not contain libCEC support
+#endif]], [[]])],[AC_MSG_RESULT([yes])],[check_rpi_cec_service="no"; AC_MSG_RESULT([no])])
+
+      ## check if the methods we're using can be found in libbcm_host.so, so we don't use an incompatible version
+      AC_CHECK_LIB(bcm_host,vchi_initialise,,check_rpi_cec_service="no")
+      libs_tmp="$LIBS"
+      AC_CHECK_LIB(bcm_host,vc_vchi_cec_init,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_get_logical_address,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_get_physical_address,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_param2message,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_poll_address,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_register_callback,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_release_logical_address,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vc_cec_set_passive,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vcos_init,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vchiq_initialise,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vchi_initialise,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,vchi_create_connection,,check_rpi_cec_service="no")
+      AC_CHECK_LIB(bcm_host,bcm_host_init,,check_rpi_cec_service="no")
+      LIBS="$libs_tmp"
+
+      if test "x$check_rpi_cec_service" != "xyes" && test "x$use_rpi" = "xyes"; then
+        AC_MSG_ERROR($msg_rpi_api_missing)
+      elif test "x$check_rpi_cec_service" != "xyes"; then
+        use_rpi="no"
+        LIBS="$libs_pre_rpi"
+      fi
+    fi
+    ;;
+  *-apple-darwin*)
+    AC_CHECK_HEADER(mach/mach_time.h,,AC_MSG_ERROR($msg_required_header_missing))
+    AC_CHECK_HEADER(CoreVideo/CVHostTime.h,,AC_MSG_ERROR($msg_required_header_missing))
+    AC_DEFINE([TARGET_DARWIN], [1], [Darwin target])
+    SUPPRESS_MANGLING_WARNINGS=""
+    ;;
+esac
+
+## define the build info
+LIB_INFO="host: ${host}, features:"
+
+features="Configured features:\n  Pulse-Eight CEC Adapter :\t\tyes"
+LIB_INFO="$LIB_INFO 'P8 USB'"
+AC_DEFINE([HAVE_P8_USB],[1],[Define to 1 to include support for the Pulse-Eight USB-CEC Adapter])
+AM_CONDITIONAL(USE_P8_USB, true)
+
+if test "x$use_lockdev" = "xyes"; then
+  AC_DEFINE([HAVE_LOCKDEV],[1],[Define to 1 if liblockdev is installed])
+fi
+
+## mark adapter detection as available if the required deps were found
+if test "x$use_adapter_detection" = "xyes"; then
+  ## mark udev as available if it was found
+  if test "x$use_udev" = "xyes"; then
+    INCLUDES="$INCLUDES $UDEV_CFLAGS"
+    LIBS="$LIBS $UDEV_LIBS"
+    AC_DEFINE([HAVE_LIBUDEV],[1],[Define to 1 if libudev is installed])
+    REQUIRES="$REQUIRES udev"
+  fi
+
+  AC_DEFINE([HAVE_P8_USB_DETECT],[1],[Define to 1 to include autodetection support for the Pulse-Eight USB-CEC Adapter])
+  AM_CONDITIONAL(USE_P8_USB_DETECT, true)
+
+  features="$features\n  Pulse-Eight CEC Adapter detection :\tyes"
+  LIB_INFO="$LIB_INFO 'P8 USB detect'"
+else
+  AM_CONDITIONAL(USE_P8_USB_DETECT, false)
+  features="$features\n  Pulse-Eight CEC Adapter detection :\tno"
+fi
+
+## mark RPi support as available if the required headers and libs were found
+if test "x$use_rpi" != "xno"; then
+  AC_DEFINE([HAVE_RPI_API],[1],[Define to 1 to include RPi support])
+  AM_CONDITIONAL(USE_RPI_API, true)
+  features="$features\n  Raspberry Pi support :\t\tyes"
+  LIB_INFO="$LIB_INFO 'RPi'"
+else
+  AM_CONDITIONAL(USE_RPI_API, false)
+  features="$features\n  Raspberry Pi support :\t\tno"
+fi
+
+## mark TDA995x support as available
+if test "x$use_tda995x" != "xno"; then
+  AC_DEFINE([HAVE_TDA995X_API],[1],[Define to 1 to include CuBox support])
+  AM_CONDITIONAL(USE_TDA995X_API, true)
+  features="$features\n  TDA995x support :\t\t\tyes"
+  LIB_INFO="$LIB_INFO 'TDA995x'"
+  CPPFLAGS="$CPPFLAGS $TDA995X_CFLAGS"
+else
+  AM_CONDITIONAL(USE_TDA995X_API, false)
+  features="$features\n  TDA995x support :\t\t\tno"
+fi
+
+## mark i.MX6 support as available
+if test "x$use_imx6" != "xno"; then
+  AC_DEFINE([HAVE_IMX_API],[1],[Define to 1 to include i.MX6 support])
+  AM_CONDITIONAL(USE_IMX_API, true)
+  features="$features\n  i.MX6 support :\t\t\tyes"
+  LIB_INFO="$LIB_INFO 'i.MX6'"
+else
+  AM_CONDITIONAL(USE_IMX_API, false)
+  features="$features\n  i.MX6 support :\t\t\tno"
+fi
+
+## check if our build system is complete
+AC_CHECK_HEADER(algorithm,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(ctype.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(dlfcn.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(errno.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(fcntl.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(functional,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(locale,,AC_DEFINE([SS_NO_LOCALE],[1],[Define to 1 to exclude locale support]))
+AC_CHECK_HEADER(map,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(netdb.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(poll.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(pthread.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(queue,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(semaphore.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(set,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(stdarg.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(stdint.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(stdio.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(stdlib.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(string,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(string.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(termios.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(unistd.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(vector,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(wchar.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(wctype.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(arpa/inet.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(netinet/in.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(netinet/tcp.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(sys/socket.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(sys/time.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_HEADER(sys/types.h,,AC_MSG_ERROR($msg_required_header_missing))
+AC_CHECK_FUNCS([close fcntl select write read shutdown send recv memset sprintf getaddrinfo getsockopt setsockopt connect poll sched_yield open strerror tcsetattr tcgetattr cfsetispeed cfsetospeed bind freeaddrinfo listen accept socket])
+
+## add the build date to LIB_INFO
+AC_CHECK_PROG(HAVE_GIT, git, yes)
+if test "x$HAVE_GIT" = "xyes"; then
+  revision=$(git --no-pager log --abbrev=7 -n 1 --pretty=format:"%h" HEAD)
+fi
+if test "x$revision" != "x"; then
+  LIB_INFO="$LIB_INFO, git revision: ${revision}"
+fi
+
+AC_CHECK_PROG(HAVE_DATE, date, yes)
+if test "x$HAVE_DATE" = "xyes"; then
+  LIB_INFO="$LIB_INFO, compiled on: `date -u`"
+else
+  LIB_INFO="$LIB_INFO, compiled on: (unknown date)"
+fi
+
+## add the name of the user who built libCEC to LIB_INFO
+AC_CHECK_PROG(HAVE_WHOAMI, whoami, yes)
+if test "x$HAVE_WHOAMI" = "xyes" ; then
+  LIB_INFO="$LIB_INFO by `whoami`"
+else
+  LIB_INFO="$LIB_INFO by (unknown user)"
+fi
+
+## add the hostname of the build host of libCEC to LIB_INFO
+AC_CHECK_PROG(HAVE_HOSTNAME, hostname, yes)
+if test "x$HAVE_HOSTNAME" = "xyes"; then
+  LIB_INFO="$LIB_INFO@`hostname -f`"
+fi
+
+## add the system info of the build host of libCEC to LIB_INFO
+AC_CHECK_PROG(HAVE_UNAME, uname, yes)
+if test "x$HAVE_UNAME" = "xyes"; then
+  LIB_INFO="$LIB_INFO on `uname -s` `uname -r` (`uname -m`)"
+fi
+
+## redefine the LIBS, so cec-client isn't linked against things they don't need
+LIBS_LIBCEC="$LIBS"
+LIBS="$libs_client"
+
+CXXFLAGS="$CXXFLAGS -fPIC -Wall -Wextra -Wno-missing-field-initializers $SUPPRESS_MANGLING_WARNINGS"
+
+if test "x$use_debug" = "xyes"; then
+  CXXFLAGS="$CXXFLAGS -g"
+  AC_DEFINE(CEC_DEBUGGING,"1", "generate libCEC debug output")
+fi
+
+if test "x$optimisation" = "xyes"; then
+  CXXFLAGS="$CXXFLAGS -O2"
+fi
+
+AC_DEFINE_UNQUOTED(LIB_INFO,"$LIB_INFO", "information about how libCEC was compiled")
+
+AC_SUBST([REQUIRES])
+AC_SUBST([LIBS])
+AC_SUBST([LIBS_LIBCEC])
+AC_SUBST([LIB_INFO])
+AC_SUBST([USE_P8_USB])
+AC_SUBST([USE_P8_USB_DETECT])
+AC_SUBST([USE_RPI_API])
+AC_CONFIG_FILES([src/lib/libcec.pc])
+AC_OUTPUT([Makefile src/lib/Makefile src/testclient/Makefile])
+
+cat <<EOB
+
+##############################################################################
+
+libCEC version $VERSION configured
+
+Compilation flags:
+  CXXFLAGS :       $CXXFLAGS
+  libCEC LDFLAGS : $LIBS_LIBCEC
+  client LDFLAGS : $LIBS
+
+EOB
+
+echo -e "$features"
+
+cat <<EOB
+
+You can now build libCEC by running:
+  make
+
+##############################################################################
+
+EOB
diff --git a/include/cectypes.h b/include/cectypes.h
index acff259..c43a921 100644
--- a/include/cectypes.h
+++ b/include/cectypes.h
@@ -299,9 +299,19 @@ namespace CEC {
 #define CEC_TDA995x_VIRTUAL_COM		"CuBox"
 
 /*!
+ * the path to use for the i.MX CEC wire
+ */
+#define CEC_IMX_PATH			"/dev/mxc_hdmi_cec"
+
+/*!
+ * the name of the virtual COM port to use for the i.MX CEC wire
+ */
+#define CEC_IMX_VIRTUAL_COM		"i.MX"
+
+/*!
  * the path to use for the Exynos HDMI CEC device
  */
-#define CEC_EXYNOS_PATH		"/dev/CEC"
+#define CEC_EXYNOS_PATH			"/dev/CEC"
 
 /*!
  * the name of the virtual COM port to use for the EXYNOS' CEC wire
@@ -311,6 +321,11 @@ namespace CEC {
 /*!
  * Mimimum client version
  */
+#define CEC_MIN_LIB_VERSION          2
+
+/*!
+ * libCEC's major version number
+ */
 #define CEC_MIN_LIB_VERSION          3
 
 #define MSGSTART                     0xFF
@@ -876,7 +891,8 @@ typedef enum cec_adapter_type
   ADAPTERTYPE_P8_DAUGHTERBOARD = 0x2,
   ADAPTERTYPE_RPI              = 0x100,
   ADAPTERTYPE_TDA995x          = 0x200,
-  ADAPTERTYPE_EXYNOS           = 0x300
+  ADAPTERTYPE_EXYNOS           = 0x300,
+  ADAPTERTYPE_IMX              = 0x400
 } cec_adapter_type;
 
 /** force exporting through swig */
diff --git a/src/lib/Makefile.am b/src/lib/Makefile.am
new file mode 100644
index 0000000..6788303
--- /dev/null
+++ b/src/lib/Makefile.am
@@ -0,0 +1,68 @@
+lib_LTLIBRARIES = libcec.la
+library_includedir=$(includedir)/libcec
+library_include_HEADERS = ../../include/cec.h \
+                          ../../include/cecc.h \
+                          ../../include/cectypes.h \
+                          ../../include/cecloader.h
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = libcec.pc
+
+## libCEC core
+libcec_la_SOURCES = CECProcessor.cpp \
+                    LibCEC.cpp \
+                    LibCECC.cpp \
+                    CECClient.cpp \
+                    adapter/AdapterFactory.cpp \
+                    devices/CECAudioSystem.cpp \
+                    devices/CECBusDevice.cpp \
+                    devices/CECDeviceMap.cpp \
+                    devices/CECPlaybackDevice.cpp \
+                    devices/CECRecordingDevice.cpp \
+                    devices/CECTuner.cpp \
+                    devices/CECTV.cpp \
+                    implementations/ANCommandHandler.cpp \
+                    implementations/CECCommandHandler.cpp \
+                    implementations/SLCommandHandler.cpp \
+                    implementations/VLCommandHandler.cpp \
+                    implementations/RLCommandHandler.cpp \
+                    implementations/PHCommandHandler.cpp \
+                    implementations/RHCommandHandler.cpp \
+                    implementations/AQCommandHandler.cpp
+
+## server sockets, currently unused
+##libcec_la_SOURCES += platform/posix/serversocket.cpp
+
+## Pulse-Eight USB-CEC support
+if USE_P8_USB
+libcec_la_SOURCES += adapter/Pulse-Eight/USBCECAdapterMessage.cpp \
+                     adapter/Pulse-Eight/USBCECAdapterCommands.cpp \
+                     adapter/Pulse-Eight/USBCECAdapterCommunication.cpp \
+                     adapter/Pulse-Eight/USBCECAdapterMessageQueue.cpp \
+                     adapter/Pulse-Eight/USBCECAdapterDetection.cpp \
+                     platform/posix/serialport.cpp \
+                     platform/posix/os-edid.cpp \
+                     platform/adl/adl-edid.cpp \
+                     platform/nvidia/nv-edid.cpp
+endif
+
+## Raspberry Pi support
+if USE_RPI_API
+libcec_la_SOURCES += adapter/RPi/RPiCECAdapterDetection.cpp \
+                     adapter/RPi/RPiCECAdapterCommunication.cpp \
+                     adapter/RPi/RPiCECAdapterMessageQueue.cpp
+endif
+
+## CuBox (NXP) support
+if USE_TDA995X_API
+libcec_la_SOURCES += adapter/TDA995x/TDA995xCECAdapterDetection.cpp \
+                     adapter/TDA995x/TDA995xCECAdapterCommunication.cpp
+endif
+
+## i.MX6 support
+if USE_IMX_API
+libcec_la_SOURCES += adapter/IMX/IMXCECAdapterDetection.cpp \
+                     adapter/IMX/IMXCECAdapterCommunication.cpp
+endif
+
+libcec_la_LDFLAGS = @LIBS_LIBCEC@ -version-info @VERSION@
diff --git a/src/lib/adapter/IMX/AdapterMessageQueue.h b/src/lib/adapter/IMX/AdapterMessageQueue.h
new file mode 100644
index 0000000..c8bcf71
--- /dev/null
+++ b/src/lib/adapter/IMX/AdapterMessageQueue.h
@@ -0,0 +1,134 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ *
+ * This program is dual-licensed; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * Alternatively, you can license this library under a commercial license,
+ * please contact Pulse-Eight Licensing for more information.
+ *
+ * For more information contact:
+ * Pulse-Eight Licensing       <license@pulse-eight.com>
+ *     http://www.pulse-eight.com/
+ *     http://www.pulse-eight.net/
+ */
+
+#include "lib/platform/threads/mutex.h"
+
+namespace CEC
+{
+  using namespace PLATFORM;
+  
+  class CAdapterMessageQueueEntry
+  {
+  public:
+    CAdapterMessageQueueEntry(const cec_command &command)
+       : m_bWaiting(true), m_retval((uint32_t)-1), m_bSucceeded(false)
+    {
+      m_hash = hashValue(
+    	uint32_t(command.opcode_set ? command.opcode : CEC_OPCODE_NONE),
+        command.initiator, command.destination);
+    }
+    
+    virtual ~CAdapterMessageQueueEntry(void) {}
+
+    /*!
+     * @brief Query result from worker thread
+     */
+    uint32_t Result() const
+    {
+      return m_retval;
+    }
+    
+    /*!
+     * @brief Signal waiting threads
+     */
+    void Broadcast(void)
+    {
+      CLockObject lock(m_mutex);
+      m_condition.Broadcast();
+    }
+
+    /*!
+     * @brief Signal waiting thread(s) when message matches this entry
+     */
+    bool CheckMatch(uint32_t opcode, cec_logical_address initiator, 
+                    cec_logical_address destination, uint32_t response)
+    {
+      uint32_t hash = hashValue(opcode, initiator, destination);
+      
+      if (hash == m_hash)
+      {
+        CLockObject lock(m_mutex);
+
+        m_retval = response;
+        m_bSucceeded = true;
+        m_condition.Signal();
+        return true;
+      }
+      
+      return false;
+    }
+
+    /*!
+     * @brief Wait for a response to this command.
+     * @param iTimeout The timeout to use while waiting.
+     * @return True when a response was received before the timeout passed, false otherwise.
+     */
+    bool Wait(uint32_t iTimeout)
+    {
+      CLockObject lock(m_mutex);
+      
+      bool bReturn = m_bSucceeded ? true : m_condition.Wait(m_mutex, m_bSucceeded, iTimeout);
+      m_bWaiting = false;
+      return bReturn;
+    }
+
+    /*!
+     * @return True while a thread is waiting for a signal or isn't waiting yet, false otherwise.
+     */
+    bool IsWaiting(void)
+    {
+      CLockObject lock(m_mutex);
+      return m_bWaiting;
+    }
+
+    /*!
+     * @return Hash value for given cec_command
+     */
+    static uint32_t hashValue(uint32_t opcode, 
+                              cec_logical_address initiator,  
+                              cec_logical_address destination)
+    {
+      return 1 | ((uint32_t)initiator << 8) | 
+             ((uint32_t)destination << 16) | ((uint32_t)opcode << 16);
+    }
+    
+  private:    
+    bool                         m_bWaiting;     /**< true while a thread is waiting or when it hasn't started waiting yet */
+    PLATFORM::CCondition<bool>   m_condition;    /**< the condition to wait on */
+    PLATFORM::CMutex             m_mutex;        /**< mutex for changes to this class */
+    uint32_t                  	 m_hash;
+    uint32_t                     m_retval;
+    bool                         m_bSucceeded;
+  };
+ 
+};
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp b/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
new file mode 100644
index 0000000..54e5662
--- /dev/null
+++ b/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
@@ -0,0 +1,279 @@
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#include "env.h"
+
+#if defined(HAVE_IMX_API)
+#include "IMXCECAdapterCommunication.h"
+
+#include "lib/CECTypeUtils.h"
+#include "lib/LibCEC.h"
+#include "lib/platform/sockets/cdevsocket.h"
+#include "lib/platform/util/StdString.h"
+#include "lib/platform/util/buffer.h"
+
+/*
+ * Ioctl definitions from kernel header
+ */
+#define HDMICEC_IOC_MAGIC  'H'
+#define HDMICEC_IOC_SETLOGICALADDRESS _IOW(HDMICEC_IOC_MAGIC,  1, unsigned char)
+#define HDMICEC_IOC_STARTDEVICE _IO(HDMICEC_IOC_MAGIC,  2)
+#define HDMICEC_IOC_STOPDEVICE  _IO(HDMICEC_IOC_MAGIC,  3)
+#define HDMICEC_IOC_GETPHYADDRESS _IOR(HDMICEC_IOC_MAGIC,  4, unsigned char[4])
+
+#define MAX_CEC_MESSAGE_LEN 17
+
+#define MESSAGE_TYPE_RECEIVE_SUCCESS 1
+#define MESSAGE_TYPE_NOACK 2
+#define MESSAGE_TYPE_DISCONNECTED 3
+#define MESSAGE_TYPE_CONNECTED 4
+#define MESSAGE_TYPE_SEND_SUCCESS 5
+
+typedef struct hdmi_cec_event{
+  int event_type;
+  int msg_len;
+  unsigned char msg[MAX_CEC_MESSAGE_LEN];
+}hdmi_cec_event;
+
+
+using namespace std;
+using namespace CEC;
+using namespace PLATFORM;
+
+#include "AdapterMessageQueue.h"
+
+#define LIB_CEC m_callback->GetLib()
+
+// these are defined in nxp private header file
+#define CEC_MSG_SUCCESS                 0x00	/*Message transmisson Succeed*/
+#define CEC_CSP_OFF_STATE               0x80	/*CSP in Off State*/
+#define CEC_BAD_REQ_SERVICE             0x81	/*Bad .req service*/
+#define CEC_MSG_FAIL_UNABLE_TO_ACCESS	0x82	/*Message transmisson failed: Unable to access CEC line*/
+#define CEC_MSG_FAIL_ARBITRATION_ERROR	0x83	/*Message transmisson failed: Arbitration error*/
+#define CEC_MSG_FAIL_BIT_TIMMING_ERROR	0x84	/*Message transmisson failed: Bit timming error*/
+#define CEC_MSG_FAIL_DEST_NOT_ACK       0x85	/*Message transmisson failed: Destination Address not aknowledged*/
+#define CEC_MSG_FAIL_DATA_NOT_ACK       0x86	/*Message transmisson failed: Databyte not acknowledged*/
+
+
+CIMXCECAdapterCommunication::CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback) :
+    IAdapterCommunication(callback)/*,
+    m_bLogicalAddressChanged(false)*/
+{ 
+  CLockObject lock(m_mutex);
+
+  m_iNextMessage = 0;
+  //m_logicalAddresses.Clear();
+  m_logicalAddress = CECDEVICE_UNKNOWN;
+  m_dev = new CCDevSocket(CEC_IMX_PATH);
+}
+
+CIMXCECAdapterCommunication::~CIMXCECAdapterCommunication(void)
+{
+  Close();
+
+  CLockObject lock(m_mutex);
+  delete m_dev;
+  m_dev = 0;
+}
+
+bool CIMXCECAdapterCommunication::IsOpen(void)
+{
+  return IsInitialised() && m_dev->IsOpen();
+}
+
+bool CIMXCECAdapterCommunication::Open(uint32_t iTimeoutMs, bool UNUSED(bSkipChecks), bool bStartListening)
+{
+  if (m_dev->Open(iTimeoutMs))
+  {
+    if (!bStartListening || CreateThread()) {
+      if (m_dev->Ioctl(HDMICEC_IOC_STARTDEVICE, NULL) != 0) {
+        LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to start device\n", __func__);
+      }
+      return true;
+    }
+    m_dev->Close();
+  }
+
+  return false;
+}
+
+
+void CIMXCECAdapterCommunication::Close(void)
+{
+  StopThread(0);
+  if (m_dev->Ioctl(HDMICEC_IOC_STOPDEVICE, NULL) != 0) {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to stop device\n", __func__);
+  }
+  m_dev->Close();
+}
+
+
+std::string CIMXCECAdapterCommunication::GetError(void) const
+{
+  std::string strError(m_strError);
+  return strError;
+}
+
+
+cec_adapter_message_state CIMXCECAdapterCommunication::Write(
+  const cec_command &data, bool &UNUSED(bRetry), uint8_t UNUSED(iLineTimeout), bool UNUSED(bIsReply))
+{
+  //cec_frame frame;
+  unsigned char message[MAX_CEC_MESSAGE_LEN];
+  int msg_len = 1;
+  cec_adapter_message_state rc = ADAPTER_MESSAGE_STATE_ERROR;
+
+  if ((size_t)data.parameters.size + data.opcode_set + 1 > sizeof(message))
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: data size too large !", __func__);
+    return ADAPTER_MESSAGE_STATE_ERROR;
+  }
+
+  message[0] = (data.initiator << 4) | (data.destination & 0x0f);
+  if (data.opcode_set)
+  {
+    message[1] = data.opcode;
+    msg_len++;
+    memcpy(&message[2], data.parameters.data, data.parameters.size);
+    msg_len+=data.parameters.size;
+  }
+
+  if (m_dev->Write(message, msg_len) == msg_len)
+  {
+    rc = ADAPTER_MESSAGE_STATE_SENT_ACKED;
+  }
+    else
+      LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: sent command error !", __func__);
+
+  return rc;
+}
+
+
+uint16_t CIMXCECAdapterCommunication::GetFirmwareVersion(void)
+{
+  /* FIXME add ioctl ? */
+  return 0;
+}
+
+
+cec_vendor_id CIMXCECAdapterCommunication::GetVendorId(void)
+{
+  return CEC_VENDOR_UNKNOWN;
+}
+
+
+uint16_t CIMXCECAdapterCommunication::GetPhysicalAddress(void)
+{
+  uint32_t info;
+
+  if (m_dev->Ioctl(HDMICEC_IOC_GETPHYADDRESS, &info) != 0)
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_GETPHYADDRESS failed !", __func__);
+    return CEC_INVALID_PHYSICAL_ADDRESS; 
+  }
+
+  return info;
+}
+
+
+cec_logical_addresses CIMXCECAdapterCommunication::GetLogicalAddresses(void)
+{
+  cec_logical_addresses addresses;
+  addresses.Clear();
+
+  CLockObject lock(m_mutex);
+  if ( m_logicalAddress != CECDEVICE_UNKNOWN)
+    addresses.Set(m_logicalAddress);
+
+  return addresses;
+}
+
+
+bool CIMXCECAdapterCommunication::SetLogicalAddresses(const cec_logical_addresses &addresses)
+{
+  int log_addr = addresses.primary;
+
+  CLockObject lock(m_mutex);
+  if (m_logicalAddress == log_addr)
+      return true;
+
+  if (m_dev->Ioctl(HDMICEC_IOC_SETLOGICALADDRESS, (void *)log_addr) != 0)
+  {
+    LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_SETLOGICALADDRESS failed !", __func__);
+    return false;
+  }
+
+  m_logicalAddress = (cec_logical_address)log_addr;
+  return true;
+}
+
+
+void *CIMXCECAdapterCommunication::Process(void)
+{
+  bool bHandled;
+  hdmi_cec_event event;
+  int ret;
+
+  uint32_t opcode, status;
+  cec_logical_address initiator, destination;
+
+  while (!IsStopped())
+  {
+    ret = m_dev->Read((char *)&event, sizeof(event), 5000);
+    if (ret > 0)
+    {
+
+      initiator = cec_logical_address(event.msg[0] >> 4);
+      destination = cec_logical_address(event.msg[0] & 0x0f);
+
+      //LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: Read data : type : %d initiator %d dest %d", __func__, event.event_type, initiator, destination);
+      if (event.event_type == MESSAGE_TYPE_RECEIVE_SUCCESS)
+      /* Message received */
+      {
+        cec_command cmd;
+
+        cec_command::Format(
+          cmd, initiator, destination,
+          ( event.msg_len > 1 ) ? cec_opcode(event.msg[1]) : CEC_OPCODE_NONE);
+
+        for( uint8_t i = 2; i < event.msg_len; i++ )
+          cmd.parameters.PushBack(event.msg[i]);
+
+        if (!IsStopped())
+          m_callback->OnCommandReceived(cmd);
+      }
+      /* We are not interested in other events */
+    } /*else {
+      LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: Read returned %d", __func__, ret);
+    }*/
+
+  }
+
+  return 0;
+}
+
+#endif	// HAVE_IMX_API
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.h b/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
new file mode 100644
index 0000000..910dd39
--- /dev/null
+++ b/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
@@ -0,0 +1,114 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ *
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#if defined(HAVE_IMX_API)
+
+#include "lib/platform/threads/mutex.h"
+#include "lib/platform/threads/threads.h"
+#include "lib/platform/sockets/socket.h"
+#include "lib/adapter/AdapterCommunication.h"
+#include <map>
+
+#define IMX_ADAPTER_VID 0x0471 /*FIXME TBD*/
+#define IMX_ADAPTER_PID 0x1001
+
+
+
+namespace PLATFORM
+{
+  class CCDevSocket;
+};
+
+
+namespace CEC
+{
+  class CAdapterMessageQueueEntry;
+
+  class CIMXCECAdapterCommunication : public IAdapterCommunication, public PLATFORM::CThread
+  {
+  public:
+    /*!
+     * @brief Create a new USB-CEC communication handler.
+     * @param callback The callback to use for incoming CEC commands.
+     */
+    CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback);
+    virtual ~CIMXCECAdapterCommunication(void);
+
+    /** @name IAdapterCommunication implementation */
+    ///{
+    bool Open(uint32_t iTimeoutMs = CEC_DEFAULT_CONNECT_TIMEOUT, bool bSkipChecks = false, bool bStartListening = true);
+    void Close(void);
+    bool IsOpen(void);
+    std::string GetError(void) const;
+    cec_adapter_message_state Write(const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool bIsReply);
+
+    bool SetLineTimeout(uint8_t UNUSED(iTimeout)) { return true; }
+    bool StartBootloader(void) { return false; }
+    bool SetLogicalAddresses(const cec_logical_addresses &addresses);
+    cec_logical_addresses GetLogicalAddresses(void);
+    bool PingAdapter(void) { return IsInitialised(); }
+    uint16_t GetFirmwareVersion(void);
+    uint32_t GetFirmwareBuildDate(void) { return 0; }
+    bool IsRunningLatestFirmware(void) { return true; }
+    bool PersistConfiguration(const libcec_configuration & UNUSED(configuration)) { return false; }
+    bool GetConfiguration(libcec_configuration & UNUSED(configuration)) { return false; }
+    std::string GetPortName(void) { return std::string("IMX"); }
+    uint16_t GetPhysicalAddress(void);
+    bool SetControlledMode(bool UNUSED(controlled)) { return true; }
+    cec_vendor_id GetVendorId(void);
+    bool SupportsSourceLogicalAddress(const cec_logical_address address) { return address > CECDEVICE_TV && address <= CECDEVICE_BROADCAST; }
+    cec_adapter_type GetAdapterType(void) { return ADAPTERTYPE_IMX; }
+    uint16_t GetAdapterVendorId(void) const { return IMX_ADAPTER_VID; }
+    uint16_t GetAdapterProductId(void) const { return IMX_ADAPTER_PID; }
+    void SetActiveSource(bool UNUSED(bSetTo), bool UNUSED(bClientUnregistered)) {}
+    ///}
+
+    /** @name PLATFORM::CThread implementation */
+    ///{
+    void *Process(void);
+    ///}
+
+  private:
+    bool IsInitialised(void) const { return m_dev != 0; };
+
+    std::string                 m_strError; /**< current error message */
+
+    //cec_logical_addresses       m_logicalAddresses;
+    cec_logical_address         m_logicalAddress;
+
+    PLATFORM::CMutex            m_mutex;
+    PLATFORM::CCDevSocket       *m_dev;	/**< the device connection */
+    
+    PLATFORM::CMutex            m_messageMutex;
+    uint32_t                    m_iNextMessage;
+    std::map<uint32_t, CAdapterMessageQueueEntry *> m_messages;
+  };
+  
+};
+
+#endif
diff --git a/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp b/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
new file mode 100644
index 0000000..6c93c45
--- /dev/null
+++ b/src/lib/adapter/IMX/IMXCECAdapterDetection.cpp
@@ -0,0 +1,42 @@
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+#include "env.h"
+#include <stdio.h>
+
+#if defined(HAVE_IMX_API)
+#include "IMXCECAdapterDetection.h"
+
+
+using namespace CEC;
+
+bool CIMXCECAdapterDetection::FindAdapter(void)
+{
+  return access(CEC_IMX_PATH, 0) == 0;
+}
+
+#endif
diff --git a/src/lib/adapter/IMX/IMXCECAdapterDetection.h b/src/lib/adapter/IMX/IMXCECAdapterDetection.h
new file mode 100644
index 0000000..d54891d
--- /dev/null
+++ b/src/lib/adapter/IMX/IMXCECAdapterDetection.h
@@ -0,0 +1,36 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ * 
+ * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ * 
+ * You can redistribute this file and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ */
+
+namespace CEC
+{
+  class CIMXCECAdapterDetection
+  {
+  public:
+    static bool FindAdapter(void);
+  };
+}
diff --git a/src/libcec/CECTypeUtils.h b/src/libcec/CECTypeUtils.h
index fd8046a..48cb215 100644
--- a/src/libcec/CECTypeUtils.h
+++ b/src/libcec/CECTypeUtils.h
@@ -765,6 +765,8 @@ namespace CEC
         return "Raspberry Pi";
       case ADAPTERTYPE_TDA995x:
         return "TDA995x";
+      case ADAPTERTYPE_IMX:
+        return "i.MX";
       default:
         return "unknown";
       }
diff --git a/src/libcec/adapter/AdapterFactory.cpp b/src/libcec/adapter/AdapterFactory.cpp
index da05725..3fe49f1 100644
--- a/src/libcec/adapter/AdapterFactory.cpp
+++ b/src/libcec/adapter/AdapterFactory.cpp
@@ -58,6 +58,11 @@
 #include "Exynos/ExynosCECAdapterCommunication.h"
 #endif
 
+#if defined(HAVE_IMX_API)
+#include "IMX/IMXCECAdapterDetection.h"
+#include "IMX/IMXCECAdapterCommunication.h"
+#endif
+
 using namespace CEC;
 
 int8_t CAdapterFactory::FindAdapters(cec_adapter *deviceList, uint8_t iBufSize, const char *strDevicePath /* = NULL */)
@@ -126,8 +131,21 @@ int8_t CAdapterFactory::DetectAdapters(cec_adapter_descriptor *deviceList, uint8
   }
 #endif
 
+#if defined(HAVE_IMX_API)
+  if (iAdaptersFound < iBufSize && CIMXCECAdapterDetection::FindAdapter() &&
+      (!strDevicePath || !strcmp(strDevicePath, CEC_IMX_VIRTUAL_COM)))
+  {
+    snprintf(deviceList[iAdaptersFound].strComPath, sizeof(deviceList[iAdaptersFound].strComPath), CEC_IMX_PATH);
+    snprintf(deviceList[iAdaptersFound].strComName, sizeof(deviceList[iAdaptersFound].strComName), CEC_IMX_VIRTUAL_COM);
+    deviceList[iAdaptersFound].iVendorId = IMX_ADAPTER_VID;
+    deviceList[iAdaptersFound].iProductId = IMX_ADAPTER_PID;
+    deviceList[iAdaptersFound].adapterType = ADAPTERTYPE_IMX;
+    iAdaptersFound++;
+  }
+#endif
+
 
-#if !defined(HAVE_RPI_API) && !defined(HAVE_P8_USB) && !defined(HAVE_TDA995X_API)
+#if !defined(HAVE_RPI_API) && !defined(HAVE_P8_USB) && !defined(HAVE_TDA995X_API) && !defined(HAVE_IMX_API)
 #error "libCEC doesn't have support for any type of adapter. please check your build system or configuration"
 #endif
 
@@ -151,11 +169,16 @@ IAdapterCommunication *CAdapterFactory::GetInstance(const char *strPort, uint16_
     return new CRPiCECAdapterCommunication(m_lib->m_cec);
 #endif
 
+#if defined(HAVE_IMX_API)
+  if (!strcmp(strPort, CEC_IMX_VIRTUAL_COM))
+    return new CIMXCECAdapterCommunication(m_lib->m_cec);
+#endif
+
 #if defined(HAVE_P8_USB)
   return new CUSBCECAdapterCommunication(m_lib->m_cec, strPort, iBaudRate);
 #endif
 
-#if !defined(HAVE_RPI_API) && !defined(HAVE_P8_USB) && !defined(HAVE_TDA995X_API) && !defined(HAVE_EXYNOS_API)
+#if !defined(HAVE_RPI_API) && !defined(HAVE_P8_USB) && !defined(HAVE_TDA995X_API) && !defined(HAVE_EXYNOS_API) && !defined(HAVE_IMX_API)
   return NULL;
 #endif
 }
