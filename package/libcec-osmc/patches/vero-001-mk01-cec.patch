From 0ee4cb8788c1a72680c4581570c6d19697dd291b Mon Sep 17 00:00:00 2001
From: Matus Kral <matuskral@me.com>
Date: Wed, 10 Sep 2014 22:23:37 +0200
Subject: [PATCH] - update to IMX6 support - handle releasing adapter better on
 close and unregister LA (change to 15) - don't change to bad PA (0000) -
 align cec_message data structure - IMX6: threaded PA change reporter to avoid
 blocking main process() - when transmitting PA, CECHandler transmits PA with
 bSuppressWait set to NO. Waiting here will block main Process() which should
 receive NACK/ACK (but it can't because it is it who called callback which is
 triggering PA resending) - IMX6: allowing infinite timeout on read from dev
 file. - SocketRead() was changed to polling (instead of select()). In order
 for this to work, kernel driver must be returning POLLHUP to interrupt
 waiting SocketRead(). Otherwise infinite timeout will block CEC adapter
 termination. - Building adaptations for imx6 - Don't Wait for PA update
 thread's start. Return immediately. - Fix stopping the thread / closing the
 port

---
 configure.ac                                       | 411 ---------------------
 src/lib/adapter/IMX/AdapterMessageQueue.h          | 134 -------
 src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp | 260 +++++++++----
 src/lib/adapter/IMX/IMXCECAdapterCommunication.h   |  35 +-
 src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h    | 118 ++++++
 src/lib/adapter/IMX/mxc_hdmi-cec.h                 |  47 +++
 src/libcec/CMakeLists.txt                          |  14 +-
 src/libcec/cmake/CheckPlatformSupport.cmake        |  28 +-
 src/libcec/cmake/DisplayPlatformSupport.cmake      |   6 +
 9 files changed, 412 insertions(+), 641 deletions(-)
 delete mode 100644 configure.ac
 delete mode 100644 src/lib/adapter/IMX/AdapterMessageQueue.h
 create mode 100644 src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
 create mode 100644 src/lib/adapter/IMX/mxc_hdmi-cec.h

diff --git a/configure.ac b/configure.ac
deleted file mode 100644
index 923d7e5..0000000
--- a/configure.ac
+++ /dev/null
@@ -1,411 +0,0 @@
-AC_PREREQ(2.59)
-AC_INIT([libcec], [2:1:0], [http://libcec.pulse-eight.com/])
-AC_CONFIG_HEADERS([config.h])
-AH_TOP([#pragma once])
-
-AM_INIT_AUTOMAKE([foreign])
-m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
-
-AM_INIT_AUTOMAKE(AC_PACKAGE_NAME, AC_PACKAGE_VERSION)
-
-AC_CANONICAL_HOST
-
-cflags_reset="$CFLAGS"
-AC_LANG(C++)
-AC_PROG_CXX
-AC_PROG_LIBTOOL
-AC_PROG_INSTALL
-AC_LIBTOOL_DLOPEN
-CFLAGS="$cflags_reset"
-
-msg_pkg_config_missing="'pkg-config' is missing - adapter detection will not be available"
-msg_pthread_missing="required library 'pthread' is missing"
-msg_dl_missing="required library 'dl' is missing"
-msg_udev_missing="library 'udev' is missing - adapter detection will not be available"
-msg_dirent_missing="dirent.h header is missing - adapter detection will not be available"
-msg_lockdev_missing="library 'liblockdev' is missing"
-msg_rpi_api_missing="Raspberry Pi API not found or incompatible with libCEC"
-msg_rpi_will_check="will check for RPi support"
-msg_rpi_unsupported_target="will not check for RPi support (unsupported cpu: ${host_cpu})"
-msg_required_header_missing="required header is missing"
-
-## debugging symbols
-AC_ARG_ENABLE([debug],
-  [AS_HELP_STRING([--enable-debug],
-  [include debug symbols (default is no)])],
-  [use_debug=$enableval],
-  [use_debug=no])
-
-## optimisation
-AC_ARG_ENABLE([optimisation],
-  [AS_HELP_STRING([--enable-optimisation],
-  [optimisation flag (default is yes)])],
-  [use_optimisation=$enableval],
-  [use_optimisation=yes])
-
-## TDA995x support
-AC_ARG_ENABLE([cubox],
-  [AS_HELP_STRING([--enable-tda995x],
-  [enable support for the TDA995x (default is no)])],
-  [use_tda995x=$enableval],
-  [use_tda995x=no])
-
-## Optional path to the tda995x dev toolkit
-AC_ARG_WITH([tda995x-toolkit-path],
-  [AS_HELP_STRING([--with-tda995x-toolkit-path],
-    [location of the TDA995x driver toolkit (default is ./nxp_hdmi)])],
-  [TDA995X_CFLAGS="-I$withval/inc"],
-  [TDA995X_CFLAGS="-I\$(abs_top_srcdir)/nxp_hdmi/inc"])
-
-## Raspberry Pi support
-AC_ARG_ENABLE([rpi],
-  [AS_HELP_STRING([--enable-rpi],
-  [enable support for the Raspberry Pi (default is auto)])],
-  [use_rpi=$enableval],
-  [use_rpi=auto])
-
-## Optional path to the RPi's dev headers
-AC_ARG_WITH([rpi-include-path],
-  [AS_HELP_STRING([--with-rpi-include-path],
-    [location of the Raspberry Pi headers (location of /opt/vc/include, default is auto)])],
-  [RPI_CFLAGS="-I$withval -I$withval/interface/vcos/pthreads -I$withval/interface/vmcs_host/linux"])
-
-## Optional path to libbcm_host.so
-AC_ARG_WITH([rpi-lib-path],
-  [AS_HELP_STRING([--with-rpi-lib-path],
-    [location of the Raspberry Pi libraries (location of libbcm_host.so, default is auto)])],
-  [RPI_LIBS="-L$withval"])
-
-## only check for the RPi API on ARM targets
-if test "x$use_rpi" != "xno"; then
-  case "${host_cpu}" in
-    arm*)
-      AC_MSG_NOTICE($msg_rpi_will_check)
-      ;;
-    *)
-      if test "x$use_rpi" = "xyes"; then
-        AC_MSG_ERROR($msg_rpi_unsupported_target)
-      else
-        AC_MSG_NOTICE($msg_rpi_unsupported_target)
-      fi
-      use_rpi="no"
-      ;;
-  esac
-fi
-
-## i.MX6 support
-AC_ARG_ENABLE([imx6],
-  [AS_HELP_STRING([--enable-imx6],
-  [enable support for freescale i.MX6 (default is no)])],
-  [use_imx6=$enableval],
-  [use_imx6=no])
-
-
-## add the top dir and include to the include path, so we can include config.h and cec.h
-CPPFLAGS="$CPPFLAGS -I\$(abs_top_srcdir)/src -I\$(abs_top_srcdir)/include"
-
-## search for pkg-config
-AC_CHECK_PROG(HAVE_PKG_CONFIG, pkg-config, yes)
-if test "x$HAVE_PKG_CONFIG" != "xyes" ; then
-  AC_MSG_WARN($msg_pkg_config_missing)
-fi
-
-## search for pthread, required by all targets
-AC_SEARCH_LIBS([pthread_create],[pthread],,AC_MSG_ERROR($msg_pthread_missing))
-AC_CHECK_FUNCS([pthread_mutexattr_init pthread_cond_init pthread_cond_destroy pthread_cond_signal pthread_cond_broadcast pthread_cond_wait pthread_cond_timedwait])
-
-## search for dlopen, required by all targets
-AC_SEARCH_LIBS([dlopen], [dl],
-  [test "$ac_cv_search_dlopen" = "none required" || LIBS_DL=$ac_cv_search_dlopen],
-  AC_MSG_ERROR($msg_dl_missing))
-AC_CHECK_FUNCS([dlopen dlclose dlsym])
-
-## platform specific libs, required by all targets
-case "${host}" in
-  *-*-linux*)
-    # for timeutils
-    AC_SEARCH_LIBS([clock_gettime], [rt])
-    ;;
-  *-apple-darwin*)
-    LIBS="$LIBS -framework CoreVideo -framework IOKit"
-    ;;
-esac
-
-## we found all the libs and headers that we need for the client applications
-libs_client="$LIBS"
-
-## search for udev, lockdev and the RPi API, only required by libCEC
-use_udev="no"
-use_adapter_detection="yes"
-use_lockdev="no"
-SUPPRESS_MANGLING_WARNINGS=" -Wno-psabi"
-case "${host}" in
-  *-*-linux*)
-    ## search for udev if pkg-config was found
-    if test "x$HAVE_PKG_CONFIG" = "xyes" ; then
-      PKG_CHECK_MODULES([UDEV],[libudev],use_udev="yes",AC_MSG_WARN($msg_udev_missing))
-    fi
-
-    ## we need dirent.h on linux too
-    if test "$use_udev" = "yes"; then
-      AC_CHECK_HEADER(dirent.h,,[use_udev="no";AC_MSG_WARN($msg_dirent_missing)])
-    fi
-
-    if test "$use_udev" != "yes"; then
-      use_adapter_detection="no"
-    fi
-
-    ## search for lockdev
-    use_lockdev="yes"
-    AC_CHECK_HEADER(lockdev.h,,[use_lockdev="no";AC_MSG_WARN($msg_lockdev_missing)])
-    AC_CHECK_LIB(lockdev,dev_unlock,,[use_lockdev="no";AC_MSG_WARN($msg_lockdev_missing)])
-
-    AC_CHECK_HEADER(time.h,,AC_MSG_ERROR($msg_required_header_missing))
-    AC_CHECK_HEADER(sys/prctl.h,,AC_MSG_ERROR($msg_required_header_missing))
-
-    ## search for the RPi API. we need to check a couple of things to see if
-    ## it's recent enough and contains the calls needed for libCEC to operate
-    ## correctly.
-    if test "x$use_rpi" != "xno"; then
-      CPPFLAGS="$CPPFLAGS $RPI_CFLAGS"
-      libs_pre_rpi="$LIBS"
-      LIBS="$LIBS $RPI_LIBS -lvcos -lvchiq_arm"
-
-      check_rpi_cec_service="yes"
-
-      ## check for headers we need
-      AC_CHECK_HEADER(interface/vmcs_host/vc_cec.h,,check_rpi_cec_service="no")
-      AC_CHECK_HEADER(interface/vmcs_host/vc_cecservice.h,,check_rpi_cec_service="no")
-      AC_CHECK_HEADER(interface/vchiq_arm/vchiq_if.h,,check_rpi_cec_service="no")
-      AC_CHECK_HEADER(bcm_host.h,,check_rpi_cec_service="no")
-
-      ## check if the headers contain support for libCEC.
-      ## VC_CECSERVICE_VER needs to be defined
-      AC_MSG_CHECKING([interface/vmcs_host/vc_cec.h compatibility])
-
-      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <interface/vmcs_host/vc_cecservice.h>
-#include <interface/vchiq_arm/vchiq_if.h>
-#if !defined(VC_CECSERVICE_VER)
-#error RPi headers does not contain libCEC support
-#endif]], [[]])],[AC_MSG_RESULT([yes])],[check_rpi_cec_service="no"; AC_MSG_RESULT([no])])
-
-      ## check if the methods we're using can be found in libbcm_host.so, so we don't use an incompatible version
-      AC_CHECK_LIB(bcm_host,vchi_initialise,,check_rpi_cec_service="no")
-      libs_tmp="$LIBS"
-      AC_CHECK_LIB(bcm_host,vc_vchi_cec_init,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_get_logical_address,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_get_physical_address,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_param2message,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_poll_address,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_register_callback,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_release_logical_address,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vc_cec_set_passive,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vcos_init,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vchiq_initialise,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vchi_initialise,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,vchi_create_connection,,check_rpi_cec_service="no")
-      AC_CHECK_LIB(bcm_host,bcm_host_init,,check_rpi_cec_service="no")
-      LIBS="$libs_tmp"
-
-      if test "x$check_rpi_cec_service" != "xyes" && test "x$use_rpi" = "xyes"; then
-        AC_MSG_ERROR($msg_rpi_api_missing)
-      elif test "x$check_rpi_cec_service" != "xyes"; then
-        use_rpi="no"
-        LIBS="$libs_pre_rpi"
-      fi
-    fi
-    ;;
-  *-apple-darwin*)
-    AC_CHECK_HEADER(mach/mach_time.h,,AC_MSG_ERROR($msg_required_header_missing))
-    AC_CHECK_HEADER(CoreVideo/CVHostTime.h,,AC_MSG_ERROR($msg_required_header_missing))
-    AC_DEFINE([TARGET_DARWIN], [1], [Darwin target])
-    SUPPRESS_MANGLING_WARNINGS=""
-    ;;
-esac
-
-## define the build info
-LIB_INFO="host: ${host}, features:"
-
-features="Configured features:\n  Pulse-Eight CEC Adapter :\t\tyes"
-LIB_INFO="$LIB_INFO 'P8 USB'"
-AC_DEFINE([HAVE_P8_USB],[1],[Define to 1 to include support for the Pulse-Eight USB-CEC Adapter])
-AM_CONDITIONAL(USE_P8_USB, true)
-
-if test "x$use_lockdev" = "xyes"; then
-  AC_DEFINE([HAVE_LOCKDEV],[1],[Define to 1 if liblockdev is installed])
-fi
-
-## mark adapter detection as available if the required deps were found
-if test "x$use_adapter_detection" = "xyes"; then
-  ## mark udev as available if it was found
-  if test "x$use_udev" = "xyes"; then
-    INCLUDES="$INCLUDES $UDEV_CFLAGS"
-    LIBS="$LIBS $UDEV_LIBS"
-    AC_DEFINE([HAVE_LIBUDEV],[1],[Define to 1 if libudev is installed])
-    REQUIRES="$REQUIRES udev"
-  fi
-
-  AC_DEFINE([HAVE_P8_USB_DETECT],[1],[Define to 1 to include autodetection support for the Pulse-Eight USB-CEC Adapter])
-  AM_CONDITIONAL(USE_P8_USB_DETECT, true)
-
-  features="$features\n  Pulse-Eight CEC Adapter detection :\tyes"
-  LIB_INFO="$LIB_INFO 'P8 USB detect'"
-else
-  AM_CONDITIONAL(USE_P8_USB_DETECT, false)
-  features="$features\n  Pulse-Eight CEC Adapter detection :\tno"
-fi
-
-## mark RPi support as available if the required headers and libs were found
-if test "x$use_rpi" != "xno"; then
-  AC_DEFINE([HAVE_RPI_API],[1],[Define to 1 to include RPi support])
-  AM_CONDITIONAL(USE_RPI_API, true)
-  features="$features\n  Raspberry Pi support :\t\tyes"
-  LIB_INFO="$LIB_INFO 'RPi'"
-else
-  AM_CONDITIONAL(USE_RPI_API, false)
-  features="$features\n  Raspberry Pi support :\t\tno"
-fi
-
-## mark TDA995x support as available
-if test "x$use_tda995x" != "xno"; then
-  AC_DEFINE([HAVE_TDA995X_API],[1],[Define to 1 to include CuBox support])
-  AM_CONDITIONAL(USE_TDA995X_API, true)
-  features="$features\n  TDA995x support :\t\t\tyes"
-  LIB_INFO="$LIB_INFO 'TDA995x'"
-  CPPFLAGS="$CPPFLAGS $TDA995X_CFLAGS"
-else
-  AM_CONDITIONAL(USE_TDA995X_API, false)
-  features="$features\n  TDA995x support :\t\t\tno"
-fi
-
-## mark i.MX6 support as available
-if test "x$use_imx6" != "xno"; then
-  AC_DEFINE([HAVE_IMX_API],[1],[Define to 1 to include i.MX6 support])
-  AM_CONDITIONAL(USE_IMX_API, true)
-  features="$features\n  i.MX6 support :\t\t\tyes"
-  LIB_INFO="$LIB_INFO 'i.MX6'"
-else
-  AM_CONDITIONAL(USE_IMX_API, false)
-  features="$features\n  i.MX6 support :\t\t\tno"
-fi
-
-## check if our build system is complete
-AC_CHECK_HEADER(algorithm,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(ctype.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(dlfcn.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(errno.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(fcntl.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(functional,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(locale,,AC_DEFINE([SS_NO_LOCALE],[1],[Define to 1 to exclude locale support]))
-AC_CHECK_HEADER(map,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(netdb.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(poll.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(pthread.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(queue,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(semaphore.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(set,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(stdarg.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(stdint.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(stdio.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(stdlib.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(string,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(string.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(termios.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(unistd.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(vector,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(wchar.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(wctype.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(arpa/inet.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(netinet/in.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(netinet/tcp.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(sys/socket.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(sys/time.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_HEADER(sys/types.h,,AC_MSG_ERROR($msg_required_header_missing))
-AC_CHECK_FUNCS([close fcntl select write read shutdown send recv memset sprintf getaddrinfo getsockopt setsockopt connect poll sched_yield open strerror tcsetattr tcgetattr cfsetispeed cfsetospeed bind freeaddrinfo listen accept socket])
-
-## add the build date to LIB_INFO
-AC_CHECK_PROG(HAVE_GIT, git, yes)
-if test "x$HAVE_GIT" = "xyes"; then
-  revision=$(git --no-pager log --abbrev=7 -n 1 --pretty=format:"%h" HEAD)
-fi
-if test "x$revision" != "x"; then
-  LIB_INFO="$LIB_INFO, git revision: ${revision}"
-fi
-
-AC_CHECK_PROG(HAVE_DATE, date, yes)
-if test "x$HAVE_DATE" = "xyes"; then
-  LIB_INFO="$LIB_INFO, compiled on: `date -u`"
-else
-  LIB_INFO="$LIB_INFO, compiled on: (unknown date)"
-fi
-
-## add the name of the user who built libCEC to LIB_INFO
-AC_CHECK_PROG(HAVE_WHOAMI, whoami, yes)
-if test "x$HAVE_WHOAMI" = "xyes" ; then
-  LIB_INFO="$LIB_INFO by `whoami`"
-else
-  LIB_INFO="$LIB_INFO by (unknown user)"
-fi
-
-## add the hostname of the build host of libCEC to LIB_INFO
-AC_CHECK_PROG(HAVE_HOSTNAME, hostname, yes)
-if test "x$HAVE_HOSTNAME" = "xyes"; then
-  LIB_INFO="$LIB_INFO@`hostname -f`"
-fi
-
-## add the system info of the build host of libCEC to LIB_INFO
-AC_CHECK_PROG(HAVE_UNAME, uname, yes)
-if test "x$HAVE_UNAME" = "xyes"; then
-  LIB_INFO="$LIB_INFO on `uname -s` `uname -r` (`uname -m`)"
-fi
-
-## redefine the LIBS, so cec-client isn't linked against things they don't need
-LIBS_LIBCEC="$LIBS"
-LIBS="$libs_client"
-
-CXXFLAGS="$CXXFLAGS -fPIC -Wall -Wextra -Wno-missing-field-initializers $SUPPRESS_MANGLING_WARNINGS"
-
-if test "x$use_debug" = "xyes"; then
-  CXXFLAGS="$CXXFLAGS -g"
-  AC_DEFINE(CEC_DEBUGGING,"1", "generate libCEC debug output")
-fi
-
-if test "x$optimisation" = "xyes"; then
-  CXXFLAGS="$CXXFLAGS -O2"
-fi
-
-AC_DEFINE_UNQUOTED(LIB_INFO,"$LIB_INFO", "information about how libCEC was compiled")
-
-AC_SUBST([REQUIRES])
-AC_SUBST([LIBS])
-AC_SUBST([LIBS_LIBCEC])
-AC_SUBST([LIB_INFO])
-AC_SUBST([USE_P8_USB])
-AC_SUBST([USE_P8_USB_DETECT])
-AC_SUBST([USE_RPI_API])
-AC_CONFIG_FILES([src/lib/libcec.pc])
-AC_OUTPUT([Makefile src/lib/Makefile src/testclient/Makefile])
-
-cat <<EOB
-
-##############################################################################
-
-libCEC version $VERSION configured
-
-Compilation flags:
-  CXXFLAGS :       $CXXFLAGS
-  libCEC LDFLAGS : $LIBS_LIBCEC
-  client LDFLAGS : $LIBS
-
-EOB
-
-echo -e "$features"
-
-cat <<EOB
-
-You can now build libCEC by running:
-  make
-
-##############################################################################
-
-EOB
diff --git a/src/lib/adapter/IMX/AdapterMessageQueue.h b/src/lib/adapter/IMX/AdapterMessageQueue.h
deleted file mode 100644
index c8bcf71..0000000
--- a/src/lib/adapter/IMX/AdapterMessageQueue.h
+++ /dev/null
@@ -1,134 +0,0 @@
-#pragma once
-/*
- * This file is part of the libCEC(R) library.
- *
- * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
- * libCEC(R) is an original work, containing original code.
- *
- * libCEC(R) is a trademark of Pulse-Eight Limited.
- *
- * This program is dual-licensed; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
- *
- * Alternatively, you can license this library under a commercial license,
- * please contact Pulse-Eight Licensing for more information.
- *
- * For more information contact:
- * Pulse-Eight Licensing       <license@pulse-eight.com>
- *     http://www.pulse-eight.com/
- *     http://www.pulse-eight.net/
- */
-
-#include "lib/platform/threads/mutex.h"
-
-namespace CEC
-{
-  using namespace PLATFORM;
-  
-  class CAdapterMessageQueueEntry
-  {
-  public:
-    CAdapterMessageQueueEntry(const cec_command &command)
-       : m_bWaiting(true), m_retval((uint32_t)-1), m_bSucceeded(false)
-    {
-      m_hash = hashValue(
-    	uint32_t(command.opcode_set ? command.opcode : CEC_OPCODE_NONE),
-        command.initiator, command.destination);
-    }
-    
-    virtual ~CAdapterMessageQueueEntry(void) {}
-
-    /*!
-     * @brief Query result from worker thread
-     */
-    uint32_t Result() const
-    {
-      return m_retval;
-    }
-    
-    /*!
-     * @brief Signal waiting threads
-     */
-    void Broadcast(void)
-    {
-      CLockObject lock(m_mutex);
-      m_condition.Broadcast();
-    }
-
-    /*!
-     * @brief Signal waiting thread(s) when message matches this entry
-     */
-    bool CheckMatch(uint32_t opcode, cec_logical_address initiator, 
-                    cec_logical_address destination, uint32_t response)
-    {
-      uint32_t hash = hashValue(opcode, initiator, destination);
-      
-      if (hash == m_hash)
-      {
-        CLockObject lock(m_mutex);
-
-        m_retval = response;
-        m_bSucceeded = true;
-        m_condition.Signal();
-        return true;
-      }
-      
-      return false;
-    }
-
-    /*!
-     * @brief Wait for a response to this command.
-     * @param iTimeout The timeout to use while waiting.
-     * @return True when a response was received before the timeout passed, false otherwise.
-     */
-    bool Wait(uint32_t iTimeout)
-    {
-      CLockObject lock(m_mutex);
-      
-      bool bReturn = m_bSucceeded ? true : m_condition.Wait(m_mutex, m_bSucceeded, iTimeout);
-      m_bWaiting = false;
-      return bReturn;
-    }
-
-    /*!
-     * @return True while a thread is waiting for a signal or isn't waiting yet, false otherwise.
-     */
-    bool IsWaiting(void)
-    {
-      CLockObject lock(m_mutex);
-      return m_bWaiting;
-    }
-
-    /*!
-     * @return Hash value for given cec_command
-     */
-    static uint32_t hashValue(uint32_t opcode, 
-                              cec_logical_address initiator,  
-                              cec_logical_address destination)
-    {
-      return 1 | ((uint32_t)initiator << 8) | 
-             ((uint32_t)destination << 16) | ((uint32_t)opcode << 16);
-    }
-    
-  private:    
-    bool                         m_bWaiting;     /**< true while a thread is waiting or when it hasn't started waiting yet */
-    PLATFORM::CCondition<bool>   m_condition;    /**< the condition to wait on */
-    PLATFORM::CMutex             m_mutex;        /**< mutex for changes to this class */
-    uint32_t                  	 m_hash;
-    uint32_t                     m_retval;
-    bool                         m_bSucceeded;
-  };
- 
-};
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp b/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
index 54e5662..de5f282 100644
--- a/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
+++ b/src/lib/adapter/IMX/IMXCECAdapterCommunication.cpp
@@ -7,6 +7,7 @@
  * libCEC(R) is a trademark of Pulse-Eight Limited.
  * 
  * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ *                     Copyright (C) 2014 by Matus Kral
  * 
  * You can redistribute this file and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -34,37 +35,13 @@
 #include "lib/LibCEC.h"
 #include "lib/platform/sockets/cdevsocket.h"
 #include "lib/platform/util/StdString.h"
-#include "lib/platform/util/buffer.h"
-
-/*
- * Ioctl definitions from kernel header
- */
-#define HDMICEC_IOC_MAGIC  'H'
-#define HDMICEC_IOC_SETLOGICALADDRESS _IOW(HDMICEC_IOC_MAGIC,  1, unsigned char)
-#define HDMICEC_IOC_STARTDEVICE _IO(HDMICEC_IOC_MAGIC,  2)
-#define HDMICEC_IOC_STOPDEVICE  _IO(HDMICEC_IOC_MAGIC,  3)
-#define HDMICEC_IOC_GETPHYADDRESS _IOR(HDMICEC_IOC_MAGIC,  4, unsigned char[4])
-
-#define MAX_CEC_MESSAGE_LEN 17
-
-#define MESSAGE_TYPE_RECEIVE_SUCCESS 1
-#define MESSAGE_TYPE_NOACK 2
-#define MESSAGE_TYPE_DISCONNECTED 3
-#define MESSAGE_TYPE_CONNECTED 4
-#define MESSAGE_TYPE_SEND_SUCCESS 5
-
-typedef struct hdmi_cec_event{
-  int event_type;
-  int msg_len;
-  unsigned char msg[MAX_CEC_MESSAGE_LEN];
-}hdmi_cec_event;
-
+#include "platform/util/util.h"
 
 using namespace std;
 using namespace CEC;
 using namespace PLATFORM;
 
-#include "AdapterMessageQueue.h"
+#include "IMXCECAdapterMessageQueue.h"
 
 #define LIB_CEC m_callback->GetLib()
 
@@ -78,24 +55,24 @@ using namespace PLATFORM;
 #define CEC_MSG_FAIL_DEST_NOT_ACK       0x85	/*Message transmisson failed: Destination Address not aknowledged*/
 #define CEC_MSG_FAIL_DATA_NOT_ACK       0x86	/*Message transmisson failed: Databyte not acknowledged*/
 
-
 CIMXCECAdapterCommunication::CIMXCECAdapterCommunication(IAdapterCommunicationCallback *callback) :
-    IAdapterCommunication(callback)/*,
-    m_bLogicalAddressChanged(false)*/
-{ 
+    IAdapterCommunication(callback),
+    m_PAReporter(NULL)
+{
   CLockObject lock(m_mutex);
 
   m_iNextMessage = 0;
-  //m_logicalAddresses.Clear();
   m_logicalAddress = CECDEVICE_UNKNOWN;
+  m_bLogicalAddressRegistered = false;
+  m_bInitialised = false;
   m_dev = new CCDevSocket(CEC_IMX_PATH);
+  m_physicalAddress = -1;
 }
 
 CIMXCECAdapterCommunication::~CIMXCECAdapterCommunication(void)
 {
   Close();
-
-  CLockObject lock(m_mutex);
+  DELETE_AND_NULL(m_PAReporter);
   delete m_dev;
   m_dev = 0;
 }
@@ -110,10 +87,12 @@ bool CIMXCECAdapterCommunication::Open(uint32_t iTimeoutMs, bool UNUSED(bSkipChe
   if (m_dev->Open(iTimeoutMs))
   {
     if (!bStartListening || CreateThread()) {
-      if (m_dev->Ioctl(HDMICEC_IOC_STARTDEVICE, NULL) != 0) {
-        LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to start device\n", __func__);
+      if (m_dev->Ioctl(HDMICEC_IOC_STARTDEVICE, NULL) == 0) {
+        m_bInitialised = true;
+        RegisterLogicalAddress(CECDEVICE_BROADCAST);
+        return true;
       }
-      return true;
+      LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to start device\n", __func__);
     }
     m_dev->Close();
   }
@@ -124,10 +103,12 @@ bool CIMXCECAdapterCommunication::Open(uint32_t iTimeoutMs, bool UNUSED(bSkipChe
 
 void CIMXCECAdapterCommunication::Close(void)
 {
-  StopThread(0);
-  if (m_dev->Ioctl(HDMICEC_IOC_STOPDEVICE, NULL) != 0) {
+  m_bInitialised = false;
+  if (m_dev->Ioctl(HDMICEC_IOC_STOPDEVICE, NULL) != 0)
+  {
     LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: Unable to stop device\n", __func__);
   }
+  StopThread(false);
   m_dev->Close();
 }
 
@@ -140,17 +121,19 @@ std::string CIMXCECAdapterCommunication::GetError(void) const
 
 
 cec_adapter_message_state CIMXCECAdapterCommunication::Write(
-  const cec_command &data, bool &UNUSED(bRetry), uint8_t UNUSED(iLineTimeout), bool UNUSED(bIsReply))
+  const cec_command &data, bool &bRetry, uint8_t iLineTimeout, bool UNUSED(bIsReply))
 {
-  //cec_frame frame;
-  unsigned char message[MAX_CEC_MESSAGE_LEN];
+  unsigned char message[MAX_MESSAGE_LEN];
+  CIMXCECAdapterMessageQueueEntry *entry;
   int msg_len = 1;
   cec_adapter_message_state rc = ADAPTER_MESSAGE_STATE_ERROR;
 
+  bRetry = true;
   if ((size_t)data.parameters.size + data.opcode_set + 1 > sizeof(message))
   {
     LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: data size too large !", __func__);
-    return ADAPTER_MESSAGE_STATE_ERROR;
+    bRetry = false;
+    return rc;
   }
 
   message[0] = (data.initiator << 4) | (data.destination & 0x0f);
@@ -162,12 +145,46 @@ cec_adapter_message_state CIMXCECAdapterCommunication::Write(
     msg_len+=data.parameters.size;
   }
 
-  if (m_dev->Write(message, msg_len) == msg_len)
+  entry = new CIMXCECAdapterMessageQueueEntry(message[0], data.opcode);
+  m_messageMutex.Lock();
+  uint32_t msgKey = ++m_iNextMessage;
+  m_messages.insert(make_pair(msgKey, entry));
+  m_messageMutex.Unlock();
+
+  if (m_dev->Write(message, msg_len) > 0)
+  { 
+    if (entry->Wait(data.transmit_timeout ? data.transmit_timeout : iLineTimeout *1000))
+    {
+      int status = entry->Result();
+
+      if (status == MESSAGE_TYPE_NOACK)
+        rc = ADAPTER_MESSAGE_STATE_SENT_NOT_ACKED;
+      else if (status == MESSAGE_TYPE_SEND_SUCCESS)
+        rc = ADAPTER_MESSAGE_STATE_SENT_ACKED;
+
+      bRetry = false;
+    }
+    else
+    {
+      rc = ADAPTER_MESSAGE_STATE_WAITING_TO_BE_SENT;
+#ifdef CEC_DEBUGGING
+      LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: command timed out !", __func__);
+#endif
+    }
+  }
+  else
   {
-    rc = ADAPTER_MESSAGE_STATE_SENT_ACKED;
+    Sleep(CEC_DEFAULT_TRANSMIT_RETRY_WAIT);
+#ifdef CEC_DEBUGGING
+    LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: write failed !", __func__);
+#endif
   }
-    else
-      LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: sent command error !", __func__);
+
+  m_messageMutex.Lock();
+  m_messages.erase(msgKey);
+  m_messageMutex.Unlock();
+
+  delete entry;
 
   return rc;
 }
@@ -188,15 +205,19 @@ cec_vendor_id CIMXCECAdapterCommunication::GetVendorId(void)
 
 uint16_t CIMXCECAdapterCommunication::GetPhysicalAddress(void)
 {
-  uint32_t info;
+  uint8_t phy_addr[4];
+  uint16_t pa_tmp;
 
-  if (m_dev->Ioctl(HDMICEC_IOC_GETPHYADDRESS, &info) != 0)
+  if (m_dev->Ioctl(HDMICEC_IOC_GETPHYADDRESS, &phy_addr) != 0)
   {
     LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_GETPHYADDRESS failed !", __func__);
     return CEC_INVALID_PHYSICAL_ADDRESS; 
   }
 
-  return info;
+  if ((pa_tmp = ((phy_addr[0] << 4 | phy_addr[1]) << 8) | (phy_addr[2] << 4 | phy_addr[3])))
+    m_physicalAddress = pa_tmp;
+
+  return m_physicalAddress;
 }
 
 
@@ -206,31 +227,66 @@ cec_logical_addresses CIMXCECAdapterCommunication::GetLogicalAddresses(void)
   addresses.Clear();
 
   CLockObject lock(m_mutex);
-  if ( m_logicalAddress != CECDEVICE_UNKNOWN)
+  if (m_bLogicalAddressRegistered)
     addresses.Set(m_logicalAddress);
 
   return addresses;
 }
 
+void CIMXCECAdapterCommunication::HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress))
+{
+  UnregisterLogicalAddress();
+}
 
-bool CIMXCECAdapterCommunication::SetLogicalAddresses(const cec_logical_addresses &addresses)
+bool CIMXCECAdapterCommunication::UnregisterLogicalAddress(void)
 {
-  int log_addr = addresses.primary;
+  {
+    CLockObject lock(m_mutex);
+    if (!m_bLogicalAddressRegistered)
+      return true;
+  }
 
-  CLockObject lock(m_mutex);
-  if (m_logicalAddress == log_addr)
+#ifdef CEC_DEBUGGING
+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s - releasing previous logical address", __func__);
+#endif
+  return RegisterLogicalAddress(CECDEVICE_BROADCAST);
+}
+
+bool CIMXCECAdapterCommunication::RegisterLogicalAddress(const cec_logical_address address)
+{
+  {
+    CLockObject lock(m_mutex);
+    if ((m_logicalAddress == address && m_bLogicalAddressRegistered) ||
+        (m_logicalAddress == address && address == CECDEVICE_BROADCAST))
+    {
       return true;
+    }
+  }
 
-  if (m_dev->Ioctl(HDMICEC_IOC_SETLOGICALADDRESS, (void *)log_addr) != 0)
+#ifdef CEC_DEBUGGING
+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %x to %x", __func__, m_logicalAddress, address);
+#endif
+
+  if (m_dev->Ioctl(HDMICEC_IOC_SETLOGICALADDRESS, (void *)address) != 0)
   {
     LIB_CEC->AddLog(CEC_LOG_ERROR, "%s: HDMICEC_IOC_SETLOGICALADDRESS failed !", __func__);
     return false;
   }
 
-  m_logicalAddress = (cec_logical_address)log_addr;
+  CLockObject lock(m_mutex);
+
+  m_logicalAddress = address;
+  m_bLogicalAddressRegistered = (address != CECDEVICE_BROADCAST) ? true : false;
   return true;
 }
 
+bool CIMXCECAdapterCommunication::SetLogicalAddresses(const cec_logical_addresses &addresses)
+{
+  int log_addr = addresses.primary;
+
+  return RegisterLogicalAddress((cec_logical_address)log_addr);
+}
+
 
 void *CIMXCECAdapterCommunication::Process(void)
 {
@@ -238,42 +294,86 @@ void *CIMXCECAdapterCommunication::Process(void)
   hdmi_cec_event event;
   int ret;
 
-  uint32_t opcode, status;
   cec_logical_address initiator, destination;
 
   while (!IsStopped())
   {
-    ret = m_dev->Read((char *)&event, sizeof(event), 5000);
-    if (ret > 0)
+    if (IsInitialised() && (ret = m_dev->Read((char *)&event, sizeof(event), 1000)) > 0)
     {
 
       initiator = cec_logical_address(event.msg[0] >> 4);
       destination = cec_logical_address(event.msg[0] & 0x0f);
 
-      //LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: Read data : type : %d initiator %d dest %d", __func__, event.event_type, initiator, destination);
-      if (event.event_type == MESSAGE_TYPE_RECEIVE_SUCCESS)
-      /* Message received */
-      {
-        cec_command cmd;
-
-        cec_command::Format(
-          cmd, initiator, destination,
-          ( event.msg_len > 1 ) ? cec_opcode(event.msg[1]) : CEC_OPCODE_NONE);
-
-        for( uint8_t i = 2; i < event.msg_len; i++ )
-          cmd.parameters.PushBack(event.msg[i]);
-
-        if (!IsStopped())
-          m_callback->OnCommandReceived(cmd);
-      }
-      /* We are not interested in other events */
-    } /*else {
-      LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: Read returned %d", __func__, ret);
-    }*/
-
+        if (event.event_type == MESSAGE_TYPE_RECEIVE_SUCCESS)
+        {
+            cec_command cmd;
+
+            cec_command::Format(
+                cmd, initiator, destination,
+                ( event.msg_len > 1 ) ? cec_opcode(event.msg[1]) : CEC_OPCODE_NONE);
+
+            for( uint8_t i = 2; i < event.msg_len; i++ )
+                cmd.parameters.PushBack(event.msg[i]);
+
+            if (!IsStopped()) {
+              m_callback->OnCommandReceived(cmd);
+            }
+        }
+        else if (event.event_type == MESSAGE_TYPE_SEND_SUCCESS 
+                || event.event_type == MESSAGE_TYPE_NOACK)
+        {
+            bHandled = false;
+
+            m_messageMutex.Lock();
+            for (map<uint32_t, CIMXCECAdapterMessageQueueEntry *>::iterator it = m_messages.begin();
+              !bHandled && it != m_messages.end(); it++)
+              {
+                bHandled = it->second->Received(event.event_type, event.msg[0], (cec_opcode)event.msg[1]);
+              }
+            m_messageMutex.Unlock();
+
+            if (!bHandled)
+              LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: response not matched !", __func__);
+        }
+        else if (event.event_type == MESSAGE_TYPE_DISCONNECTED)
+        {
+            /* HDMI Hotplug event - disconnect */
+        }
+        else if (event.event_type == MESSAGE_TYPE_CONNECTED && m_physicalAddress != 0xffff)
+        {
+            /* HDMI Hotplug event - connect */
+            uint16_t oldAddress = m_physicalAddress;
+
+            if (oldAddress != GetPhysicalAddress()) {
+              if (m_PAReporter)
+                while (m_PAReporter->IsRunning()) Sleep(5);
+              delete m_PAReporter;
+
+              m_PAReporter = new CCECPAChangedReporter(m_callback, m_physicalAddress);
+              m_PAReporter->CreateThread(false);
+            }
+#ifdef CEC_DEBUGGING
+            LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: plugin event received", __func__);
+#endif
+        }
+        else
+            LIB_CEC->AddLog(CEC_LOG_WARNING, "%s: unhandled response received %d!", __func__, event.event_type);
+    }
   }
 
   return 0;
 }
 
+CCECPAChangedReporter::CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA) :
+    m_callback(callback),
+    m_newPA(newPA)
+{
+}
+
+void* CCECPAChangedReporter::Process(void)
+{
+  m_callback->HandlePhysicalAddressChanged(m_newPA);
+  return NULL;
+}
+
 #endif	// HAVE_IMX_API
diff --git a/src/lib/adapter/IMX/IMXCECAdapterCommunication.h b/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
index 910dd39..7fe4acb 100644
--- a/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
+++ b/src/lib/adapter/IMX/IMXCECAdapterCommunication.h
@@ -8,6 +8,7 @@
  * libCEC(R) is a trademark of Pulse-Eight Limited.
  *
  * IMX adpater port is Copyright (C) 2013 by Stephan Rafin
+ *                     Copyright (C) 2014 by Matus Kral
  * 
  * You can redistribute this file and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -31,12 +32,18 @@
 #include "lib/platform/threads/mutex.h"
 #include "lib/platform/threads/threads.h"
 #include "lib/platform/sockets/socket.h"
+#include "lib/adapter/IMX/mxc_hdmi-cec.h"
 #include "lib/adapter/AdapterCommunication.h"
 #include <map>
 
 #define IMX_ADAPTER_VID 0x0471 /*FIXME TBD*/
 #define IMX_ADAPTER_PID 0x1001
 
+typedef struct hdmi_cec_event{
+  uint8_t event_type;
+  uint8_t msg_len;
+  uint8_t msg[MAX_MESSAGE_LEN];
+}hdmi_cec_event;
 
 
 namespace PLATFORM
@@ -44,10 +51,20 @@ namespace PLATFORM
   class CCDevSocket;
 };
 
-
 namespace CEC
 {
-  class CAdapterMessageQueueEntry;
+  class CIMXCECAdapterMessageQueueEntry;
+
+  class CCECPAChangedReporter : public PLATFORM::CThread
+  {
+  public:
+    CCECPAChangedReporter(IAdapterCommunicationCallback *callback, uint16_t newPA);
+    void* Process(void);
+
+  private:
+    IAdapterCommunicationCallback *m_callback;
+    uint16_t                       m_newPA;
+  };
 
   class CIMXCECAdapterCommunication : public IAdapterCommunication, public PLATFORM::CThread
   {
@@ -81,6 +98,7 @@ namespace CEC
     uint16_t GetPhysicalAddress(void);
     bool SetControlledMode(bool UNUSED(controlled)) { return true; }
     cec_vendor_id GetVendorId(void);
+    void HandleLogicalAddressLost(cec_logical_address UNUSED(oldAddress));
     bool SupportsSourceLogicalAddress(const cec_logical_address address) { return address > CECDEVICE_TV && address <= CECDEVICE_BROADCAST; }
     cec_adapter_type GetAdapterType(void) { return ADAPTERTYPE_IMX; }
     uint16_t GetAdapterVendorId(void) const { return IMX_ADAPTER_VID; }
@@ -94,19 +112,26 @@ namespace CEC
     ///}
 
   private:
-    bool IsInitialised(void) const { return m_dev != 0; };
+    bool IsInitialised(void) { return m_bInitialised; };
+    bool RegisterLogicalAddress(const cec_logical_address address);
+    bool UnregisterLogicalAddress(void);
 
     std::string                 m_strError; /**< current error message */
 
-    //cec_logical_addresses       m_logicalAddresses;
     cec_logical_address         m_logicalAddress;
+    uint16_t                    m_physicalAddress;
 
     PLATFORM::CMutex            m_mutex;
     PLATFORM::CCDevSocket       *m_dev;	/**< the device connection */
     
     PLATFORM::CMutex            m_messageMutex;
     uint32_t                    m_iNextMessage;
-    std::map<uint32_t, CAdapterMessageQueueEntry *> m_messages;
+    std::map<uint32_t, CIMXCECAdapterMessageQueueEntry *> m_messages;
+
+    bool                        m_bLogicalAddressRegistered;
+    bool                        m_bInitialised;
+
+    CCECPAChangedReporter       *m_PAReporter;
   };
   
 };
diff --git a/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h b/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
new file mode 100644
index 0000000..340b702
--- /dev/null
+++ b/src/lib/adapter/IMX/IMXCECAdapterMessageQueue.h
@@ -0,0 +1,118 @@
+#pragma once
+/*
+ * This file is part of the libCEC(R) library.
+ *
+ * libCEC(R) is Copyright (C) 2011-2013 Pulse-Eight Limited.  All rights reserved.
+ * libCEC(R) is an original work, containing original code.
+ *
+ * libCEC(R) is a trademark of Pulse-Eight Limited.
+ *
+ * This program is dual-licensed; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ *
+ * Alternatively, you can license this library under a commercial license,
+ * please contact Pulse-Eight Licensing for more information.
+ *
+ * For more information contact:
+ * Pulse-Eight Licensing       <license@pulse-eight.com>
+ *     http://www.pulse-eight.com/
+ *     http://www.pulse-eight.net/
+ */
+
+#include "lib/platform/threads/mutex.h"
+
+namespace CEC
+{
+  using namespace PLATFORM;
+  
+  class CIMXCECAdapterMessageQueueEntry
+  {
+  public:
+    CIMXCECAdapterMessageQueueEntry(uint8_t addrs, cec_opcode opcode)
+       : m_bWaiting(true), m_retval((uint32_t)-1), m_bSucceeded(false)
+    {
+      m_opcode = opcode;
+      m_addrs = addrs; 
+    }
+    
+    virtual ~CIMXCECAdapterMessageQueueEntry(void) {}
+
+    /*!
+     * @brief Query result from worker thread
+     */
+    uint32_t Result() const
+    {
+      return m_retval;
+    }
+    
+    /*!
+     * @brief Signal waiting threads
+     */
+    void Broadcast(void)
+    {
+      CLockObject lock(m_mutex);
+      m_condition.Broadcast();
+    }
+
+    /*!
+     * @brief Signal waiting thread(s) when message matches this entry
+     */
+    bool Received(int response, uint8_t addrs, cec_opcode opcode)
+    {
+      CLockObject lock(m_mutex);
+
+      if (!(m_addrs == addrs && m_opcode == opcode))
+        return false;
+
+      m_retval = response;
+      m_bSucceeded = true;
+      m_condition.Signal();
+      return true;
+    }
+
+    /*!
+     * @brief Wait for a response to this command.
+     * @param iTimeout The timeout to use while waiting.
+     * @return True when a response was received before the timeout passed, false otherwise.
+     */
+    bool Wait(uint32_t iTimeout)
+    {
+      CLockObject lock(m_mutex);
+      
+      bool bReturn = m_bSucceeded ? true : m_condition.Wait(m_mutex, m_bSucceeded, iTimeout);
+      m_bWaiting = false;
+      return bReturn;
+    }
+
+    /*!
+     * @return True while a thread is waiting for a signal or isn't waiting yet, false otherwise.
+     */
+    bool IsWaiting(void)
+    {
+      CLockObject lock(m_mutex);
+      return m_bWaiting;
+    }
+
+  private:    
+    bool                         m_bWaiting;     /**< true while a thread is waiting or when it hasn't started waiting yet */
+    PLATFORM::CCondition<bool>   m_condition;    /**< the condition to wait on */
+    PLATFORM::CMutex             m_mutex;        /**< mutex for changes to this class */
+    int                          m_retval;
+    bool                         m_bSucceeded;
+    uint8_t                      m_addrs;
+    cec_opcode                   m_opcode;
+  };
+ 
+};
diff --git a/src/lib/adapter/IMX/mxc_hdmi-cec.h b/src/lib/adapter/IMX/mxc_hdmi-cec.h
new file mode 100644
index 0000000..bc5bbce
--- /dev/null
+++ b/src/lib/adapter/IMX/mxc_hdmi-cec.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2005-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef _HDMICEC_H_
+#define _HDMICEC_H_
+#include <linux/ioctl.h>
+
+/*
+ * Ioctl definitions
+ */
+
+/* Use 'k' as magic number */
+#define HDMICEC_IOC_MAGIC  'H'
+/*
+ * S means "Set" through a ptr,
+ * T means "Tell" directly with the argument value
+ * G means "Get": reply by setting through a pointer
+ * Q means "Query": response is on the return value
+ * X means "eXchange": G and S atomically
+ * H means "sHift": T and Q atomically
+ */
+#define HDMICEC_IOC_SETLOGICALADDRESS  \
+				_IOW(HDMICEC_IOC_MAGIC, 1, unsigned char)
+#define HDMICEC_IOC_STARTDEVICE	_IO(HDMICEC_IOC_MAGIC,  2)
+#define HDMICEC_IOC_STOPDEVICE	_IO(HDMICEC_IOC_MAGIC,  3)
+#define HDMICEC_IOC_GETPHYADDRESS	\
+				_IOR(HDMICEC_IOC_MAGIC, 4, unsigned char[4])
+
+#define MAX_MESSAGE_LEN				16
+
+#define MESSAGE_TYPE_RECEIVE_SUCCESS		1
+#define MESSAGE_TYPE_NOACK			2
+#define MESSAGE_TYPE_DISCONNECTED		3
+#define MESSAGE_TYPE_CONNECTED			4
+#define MESSAGE_TYPE_SEND_SUCCESS		5
+
+#endif				/* !_HDMICEC_H_ */
+
diff --git a/src/libcec/CMakeLists.txt b/src/libcec/CMakeLists.txt
index a7cc6c4..bd13277 100644
--- a/src/libcec/CMakeLists.txt
+++ b/src/libcec/CMakeLists.txt
@@ -170,13 +170,17 @@ install(FILES ${PROJECT_SOURCE_DIR}/../../include/cec.h
         DESTINATION include/libcec)
 
 # libCEC target
-add_library(cec SHARED ${CEC_SOURCES})
-install(TARGETS cec
+add_library(cecobj OBJECT ${CEC_SOURCES})
+set_property(TARGET ${cecobj} PROPERTY POSITION_INDEPENDENT_CODE 1)
+add_library(cec SHARED $<TARGET_OBJECTS:cecobj>)
+add_library(cecstatic STATIC $<TARGET_OBJECTS:cecobj>)
+set_target_properties(cecstatic PROPERTIES OUTPUT_NAME cec)
+install(TARGETS cec cecstatic
         DESTINATION ${LIB_DESTINATION})
-set_target_properties(cec PROPERTIES VERSION   ${LIBCEC_VERSION_MAJOR}.${LIBCEC_VERSION_MINOR}.${LIBCEC_VERSION_PATCH}
+set_target_properties(cec cecstatic PROPERTIES VERSION   ${LIBCEC_VERSION_MAJOR}.${LIBCEC_VERSION_MINOR}.${LIBCEC_VERSION_PATCH}
                                      SOVERSION ${LIBCEC_VERSION_MAJOR}.0)
-target_link_libraries(cec ${platform_LIBRARIES})
-target_link_libraries(cec ${CMAKE_THREAD_LIBS_INIT})
+target_link_libraries(cec cecstatic ${platform_LIBRARIES})
+target_link_libraries(cec cecstatic ${CMAKE_THREAD_LIBS_INIT})
 
 include(cmake/LinkPlatformSupport.cmake)
 include(cmake/DisplayPlatformSupport.cmake)
diff --git a/src/libcec/cmake/CheckPlatformSupport.cmake b/src/libcec/cmake/CheckPlatformSupport.cmake
index 74f3690..4bd8043 100644
--- a/src/libcec/cmake/CheckPlatformSupport.cmake
+++ b/src/libcec/cmake/CheckPlatformSupport.cmake
@@ -72,12 +72,16 @@ else()
   endif()
 
   # xrandr
-  check_include_files("X11/Xlib.h;X11/Xatom.h;X11/extensions/Xrandr.h" HAVE_RANDR_HEADERS)
-  check_library_exists(Xrandr XRRGetScreenResources "" HAVE_RANDR_LIB)
-  if (HAVE_RANDR_HEADERS AND HAVE_RANDR_LIB)
-    set(LIB_INFO "${LIB_INFO}, randr")
-    list(APPEND CEC_SOURCES_PLATFORM platform/X11/randr-edid.cpp)
-    set(HAVE_RANDR 1)
+  if (${HAVE_RANDR_API})
+    check_include_files("X11/Xlib.h;X11/Xatom.h;X11/extensions/Xrandr.h" HAVE_RANDR_HEADERS)
+    check_library_exists(Xrandr XRRGetScreenResources "" HAVE_RANDR_LIB)
+    if (HAVE_RANDR_HEADERS AND HAVE_RANDR_LIB)
+      set(LIB_INFO "${LIB_INFO}, randr")
+      list(APPEND CEC_SOURCES_PLATFORM platform/X11/randr-edid.cpp)
+      set(HAVE_RANDR 1)
+    else()
+      set(HAVE_RANDR 0)
+    endif()
   else()
     set(HAVE_RANDR 0)
   endif()
@@ -119,6 +123,18 @@ else()
   else()
     set(HAVE_EXYNOS_API 0)
   endif()
+
+  # iMX6
+  if (${HAVE_IMX_API})
+    set(LIB_INFO "${LIB_INFO}, iMX6")
+    set(HAVE_IMX_API 1)
+    set(CEC_SOURCES_ADAPTER_IMX adapter/IMX/IMXCECAdapterDetection.cpp
+                                adapter/IMX/IMXCECAdapterCommunication.cpp)
+    source_group("Source Files\\adapter\\iMX6" FILES ${CEC_SOURCES_ADAPTER_IMX})
+    list(APPEND CEC_SOURCES ${CEC_SOURCES_ADAPTER_IMX})
+  else()
+    set(HAVE_IMX_API 0)
+  endif()
 endif()
 
 # rt
diff --git a/src/libcec/cmake/DisplayPlatformSupport.cmake b/src/libcec/cmake/DisplayPlatformSupport.cmake
index feee111..57f75dd 100644
--- a/src/libcec/cmake/DisplayPlatformSupport.cmake
+++ b/src/libcec/cmake/DisplayPlatformSupport.cmake
@@ -44,6 +44,12 @@ else()
   message(STATUS "Exynos support:                         no")
 endif()
 
+if (HAVE_IMX_API)
+  message(STATUS "i.MX6 support:                          yes")
+else()
+  message(STATUS "i.MX6 support:                          no")
+endif()
+
 if (HAVE_PYTHON)
   message(STATUS "Python support:                         version ${PYTHONLIBS_VERSION_STRING} (${PYTHON_VERSION})")
 else()
